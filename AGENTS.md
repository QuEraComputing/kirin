# AGENTS.md

## Principles

- less standalone function is better
- every module only expects a few names to be imported, do not create giant sets of new names
- if we have a lot of implementations (over 200 lines), it is better to split them into multiple files.
- use `mod.rs` over `<name>.rs` for modules that contain multiple files.
- when creating tests, always put common tools created for testing in the `kirin-test-utils` crate, unless they are specific to a single crate.

## Build and Test

```bash
cargo build --workspace          # Build all crates
cargo test --workspace           # Run all tests
cargo test -p kirin-chumsky      # Test a single crate
cargo test -p kirin-chumsky-derive test_parse_add  # Run a single test
cargo fmt --all                  # Format code
cargo insta review               # Review snapshot test changes
cargo xtask quick-validate .agents/skills/<skill-name>  # Validate a skill's SKILL.md frontmatter/rules
cargo xtask new-rfc "<title>" [--status <status> --author <name> --dependency <rfc-id> ...]  # Render rfc/<id>-<title>.md from the Tera template rfc/0000-template.md (`--update` refreshes timestamp and can append metadata on existing RFC)
```

Rust edition 2024. No `rust-toolchain.toml`; uses the default toolchain.

## Commit Messages

Use [Conventional Commits](https://www.conventionalcommits.org/): `<type>(<scope>): <description>`

Examples: `feat(chumsky): add region parser`, `fix(derive): handle empty enum variants`

Avoid large paragraphs in commit messages, keep them concise and focused on the changes made.

## RFC Status Policy

- If an RFC is generated by skills during implementation work, set RFC metadata `status` to `Implemented`.

## Project structure

- `design` contains design documents and diagrams.
- `example` contains example code of the top-level crate `kirin`
- `tests` contains integration tests for the top-level crate `kirin`
- `crates` contains the crates that make up the project, most implementation can be found here.
- `.agents` contains agent specific implementations that is not included in this file, e.g skills.

### Crates

**Core:**
- `kirin-ir` — IR types, `Dialect` trait
- `kirin-lexer` — Logos tokenizer

**Parser/Printer:**
- `kirin-chumsky` — Parser traits (`HasParser`, `HasDialectParser`, `EmitIR`), text APIs (`ParseStatementText`, `ParsePipelineText`)
- `kirin-prettyless` — Pretty printer (`PrettyPrint`)
- `kirin-chumsky-derive` — `#[derive(HasParser, PrettyPrint)]`
- `kirin-chumsky-format` — Code generation (internal)

**Interpreter:**
- `kirin-interpreter` — Interpreter traits, `StackInterpreter`, `AbstractInterpreter`
- `kirin-derive-interpreter` — `#[derive(Interpretable, CallSemantics)]`

**Dialects:**
- `kirin-cf`, `kirin-scf`, `kirin-constant`, `kirin-arith`, `kirin-function`

**Derive Infrastructure:**
- `kirin-derive-core` — Shared derive utilities
- `kirin-derive`, `kirin-derive-dialect` — `#[derive(Dialect)]`

**Testing:**
- `kirin-test-utils` — Shared test utilities (test dialects, `rustfmt` helper, interval domain)

## Derive Infrastructure Conventions

- **Darling re-export rule**: Derive crates that depend on `kirin-derive-core` must use `kirin_derive_core::prelude::darling` — never import `darling` directly. The workspace has multiple darling versions (0.20 via `bon`, 0.23 via `kirin-derive-core`); a direct import may resolve to the wrong version.

- **Bare attribute pattern**: Darling's `#[darling(attributes(...))]` only works for `#[attr(key = val)]` form. For bare flag attributes like `#[wraps]` or `#[callable]`, implement `FromDeriveInput`/`FromVariant` manually using `attrs.iter().any(|a| a.path().is_ident("name"))`.

- **Custom Layout for derive-specific attributes**: When a derive macro needs attributes beyond `StandardLayout` (which has `()` for all extras), define a custom `Layout` impl in that derive module. This keeps derive-specific attributes out of the core IR. See `CallSemanticsLayout` in `kirin-derive-interpreter` as an example.

- **`#[kirin(...)]` attribute convention**: Use path syntax for `crate`: `#[kirin(crate = kirin_ir)]` not `#[kirin(crate = "kirin_ir")]`. Darling parses `syn::Path` and supports bare idents directly.

## Chumsky Parser Conventions

- **`for<'src> HasParser` lifetime pattern**: `HasParser<'src, 'src>` ties the AST output lifetime to the input string. When writing trait impls that call `parse_ast::<L>(input)` and then `emit()`, the return type (`Statement`) does not borrow the input — but the compiler cannot prove this through the associated type chain. Do **not** use an associated `Output` type derived from `<<L as HasParser<'static, 'static>>::Output as EmitIR<L>>::Output` — it creates an unsatisfiable `'static` requirement on the input. Instead, hardcode `Statement` as the return type or use a helper function generic over `'src`.

- **`Ctx` default parameter for unified traits**: When the same trait method needs extra context for some implementors (e.g., `CompileStage` for `Pipeline`) but not others (e.g., `StageInfo`), use a default type parameter `Ctx = ()` on the trait. Pair with a blanket `Ext` trait that erases the `()` arg for ergonomic call sites. See `ParseStatementText<L, Ctx>` / `ParseStatementTextExt<L>`.
