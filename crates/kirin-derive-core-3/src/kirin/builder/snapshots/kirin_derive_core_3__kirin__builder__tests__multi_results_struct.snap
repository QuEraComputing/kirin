---
source: crates/kirin-derive-core-3/src/kirin/builder/mod.rs
expression: "Builder::default().print(&input)"
---
impl<T: CompileTimeValue + Typeof<L>, L: TypeLattice> MultiResult<T, L> {
    pub fn new<Lang>(
        context: &mut ::kirin::ir::Context<Lang>,
        value: impl Into<T>,
    ) -> multi_result_build_result::MultiResult
    where
        Lang: ::kirin::ir::Dialect + From<MultiResult<T, L>>,
        Lang::TypeLattice: From<L>,
    {
        let multiresult_statement_id = context.statement_arena().next_id();
        let value: T = value.into();
        let marker: std::marker::PhantomData<L> = std::marker::PhantomData;
        let result_0: ResultValue = context
            .ssa()
            .kind(SSAKind::Result(multiresult_statement_id, 0usize))
            .ty(Lang::TypeLattice::from(value.type_of()))
            .new()
            .into();
        let result_1: ResultValue = context
            .ssa()
            .kind(SSAKind::Result(multiresult_statement_id, 1usize))
            .ty(Lang::TypeLattice::from(value.type_of()))
            .new()
            .into();
        context
            .statement()
            .definition(Self {
                value,
                result1,
                result2,
                marker,
            })
            .new();
        multi_result_build_result::MultiResult {
            id: multiresult_statement_id,
            result_0,
            result_1,
        }
    }
}
pub mod multi_result_build_result {
    use kirin::ir::{ResultValue, Statement};
    pub struct MultiResult {
        pub id: Statement,
        pub result_0: ResultValue,
        pub result_1: ResultValue,
    }
    impl From<MultiResult> for Statement {
        fn from(value: MultiResult) -> Self {
            value.id
        }
    }
}
