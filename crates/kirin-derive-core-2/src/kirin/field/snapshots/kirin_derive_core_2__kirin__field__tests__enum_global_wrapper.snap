---
source: crates/kirin-derive-core-2/src/kirin/field/tests.rs
expression: "case!\n{\n    #[wraps] #[kirin(type_lattice = AnotherLattice)] enum TestEnum<T>\n    { VariantA { wrapped: InnerStructA<T> }, VariantB(InnerStructB), }\n}"
---
#[automatically_derived]
impl<'a, T> HasArguments<'a> for TestEnum<T> {
    type Iter = TestEnumArgumentsIter<'a, T>;
    fn arguments(&'a self) -> Self::Iter {
        match self {
            Self::VariantA { wrapped } => {
                ArgumentsIter::VariantA(
                    <InnerStructA<T> as HasArguments>::arguments(wrapped),
                )
            }
            Self::VariantB(field_0) => {
                ArgumentsIter::VariantB(
                    <InnerStructB as HasArguments>::arguments(field_0),
                )
            }
        }
    }
}
#[automatically_derived]
pub enum TestEnumArgumentsIter<'a, T> {
    VariantA(<InnerStructA<T> as HasArguments>::Iter),
    VariantB(<InnerStructB as HasArguments>::Iter),
}
#[automatically_derived]
impl<'a, T> Iterator for TestEnumArgumentsIter<'a, T> {
    type Item = &'a SSAValue;
    fn next(&mut self) -> Option<Self::Item> {
        match self {
            Self::VariantA(inner) => inner.next(),
            Self::VariantB(inner) => inner.next(),
        }
    }
}
#[automatically_derived]
impl<'a, T> HasArgumentsMut<'a> for TestEnum<T> {
    type IterMut = TestEnumArgumentsMutIter<'a, T>;
    fn arguments_mut(&'a mut self) -> Self::IterMut {
        match self {
            Self::VariantA { wrapped } => {
                ArgumentsMutIter::VariantA(
                    <InnerStructA<T> as HasArgumentsMut>::arguments_mut(wrapped),
                )
            }
            Self::VariantB(field_0) => {
                ArgumentsMutIter::VariantB(
                    <InnerStructB as HasArgumentsMut>::arguments_mut(field_0),
                )
            }
        }
    }
}
#[automatically_derived]
pub enum TestEnumArgumentsMutIter<'a, T> {
    VariantA(<InnerStructA<T> as HasArgumentsMut>::IterMut),
    VariantB(<InnerStructB as HasArgumentsMut>::IterMut),
}
#[automatically_derived]
impl<'a, T> Iterator for TestEnumArgumentsMutIter<'a, T> {
    type Item = &'a mut SSAValue;
    fn next(&mut self) -> Option<Self::Item> {
        match self {
            Self::VariantA(inner) => inner.next(),
            Self::VariantB(inner) => inner.next(),
        }
    }
}
