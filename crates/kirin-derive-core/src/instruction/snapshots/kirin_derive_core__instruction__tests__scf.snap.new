---
source: crates/kirin-derive-core/src/instruction/tests.rs
assertion_line: 162
expression: check(input)
---
#[automatically_derived]
impl ::kirin_ir::Instruction for SCFInstruction {
    fn is_terminator(&self) -> bool {
        match self {
            Self::If { .. } => false,
            Self::For { .. } => false,
        }
    }
    fn is_constant(&self) -> bool {
        match self {
            Self::If { .. } => false,
            Self::For { .. } => false,
        }
    }
    fn is_pure(&self) -> bool {
        match self {
            Self::If { .. } => false,
            Self::For { .. } => false,
        }
    }
    fn arguments(&self) -> impl Iterator<Item = &::kirin_ir::SSAValue> {
        __KirinArgumentsIter {
            parent: self,
            index: 0,
        }
    }
    fn results(&self) -> impl Iterator<Item = &::kirin_ir::ResultValue> {
        match self {
            Self::If { results, .. } => results.iter(),
            Self::For { results, .. } => results.iter(),
            _ => __KirinResultsIter {
                parent: self,
                index: 0,
            },
        }
    }
    fn successors(&self) -> impl Iterator<Item = &::kirin_ir::Block> {
        __KirinSuccessorsIter {
            parent: self,
            index: 0,
        }
    }
    fn regions(&self) -> impl Iterator<Item = &::kirin_ir::Region> {
        __KirinRegionsIter {
            parent: self,
            index: 0,
        }
    }
}
#[automatically_derived]
pub struct __KirinArgumentsIter<'__kirin_ir_iter_a> {
    parent: &'__kirin_ir_iter_a SCFInstruction,
    index: usize,
}
#[automatically_derived]
impl<'__kirin_ir_iter_a> Iterator for __KirinArgumentsIter<'__kirin_ir_iter_a> {
    type Item = &'__kirin_ir_iter_a ::kirin_ir::SSAValue;
    fn next(&mut self) -> Option<Self::Item> {
        match self.parent {
            SCFInstruction::If { condition, .. } => match self.index {
                0 => {
                    self.index += 1;
                    Some(condition)
                }
                _ => None,
            },
            SCFInstruction::For {
                lower_bound,
                upper_bound,
                step,
                ..
            } => match self.index {
                0 => {
                    self.index += 1;
                    Some(lower_bound)
                }
                1 => {
                    self.index += 1;
                    Some(upper_bound)
                }
                2 => {
                    self.index += 1;
                    Some(step)
                }
                _ => None,
            },
            _ => None,
        }
    }
}
#[automatically_derived]
pub struct __KirinResultsIter<'__kirin_ir_iter_a> {
    parent: &'__kirin_ir_iter_a SCFInstruction,
    index: usize,
}
#[automatically_derived]
impl<'__kirin_ir_iter_a> Iterator for __KirinResultsIter<'__kirin_ir_iter_a> {
    type Item = &'__kirin_ir_iter_a ::kirin_ir::ResultValue;
    fn next(&mut self) -> Option<Self::Item> {
        match self.parent {
            SCFInstruction::If => {
                unreachable!("variant with container should not generate iterator");
            }
            SCFInstruction::For => {
                unreachable!("variant with container should not generate iterator");
            }
            _ => None,
        }
    }
}
#[automatically_derived]
pub struct __KirinSuccessorsIter<'__kirin_ir_iter_a> {
    parent: &'__kirin_ir_iter_a SCFInstruction,
    index: usize,
}
#[automatically_derived]
impl<'__kirin_ir_iter_a> Iterator for __KirinSuccessorsIter<'__kirin_ir_iter_a> {
    type Item = &'__kirin_ir_iter_a ::kirin_ir::Block;
    fn next(&mut self) -> Option<Self::Item> {
        match self.parent {
            SCFInstruction::If {
                then_block,
                else_block,
                ..
            } => match self.index {
                0 => {
                    self.index += 1;
                    Some(then_block)
                }
                1 => {
                    self.index += 1;
                    Some(else_block)
                }
                _ => None,
            },
            SCFInstruction::For { body_block, .. } => match self.index {
                0 => {
                    self.index += 1;
                    Some(body_block)
                }
                _ => None,
            },
            _ => None,
        }
    }
}
#[automatically_derived]
pub struct __KirinRegionsIter<'__kirin_ir_iter_a> {
    parent: &'__kirin_ir_iter_a SCFInstruction,
    index: usize,
}
#[automatically_derived]
impl<'__kirin_ir_iter_a> Iterator for __KirinRegionsIter<'__kirin_ir_iter_a> {
    type Item = &'__kirin_ir_iter_a ::kirin_ir::Region;
    fn next(&mut self) -> Option<Self::Item> {
        match self.parent {
            _ => None,
        }
    }
}
