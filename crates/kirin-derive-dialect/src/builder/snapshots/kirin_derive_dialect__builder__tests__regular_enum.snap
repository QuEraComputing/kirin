---
source: crates/kirin-derive-dialect/src/builder/tests.rs
expression: "case!\n{\n    #[kirin(fn, type = SomeType)] enum TestEnum\n    {\n        A\n        {\n            #[kirin(into)] value: u32, #[kirin(type = u32_type)] result:\n            ResultValue,\n        }, B(#[kirin(into)] u64, #[kirin(type = u64_type)] ResultValue,),\n    }\n}"
---
impl TestEnum {
    pub fn op_a<Lang>(
        stage: &mut ::kirin::ir::StageInfo<Lang>,
        value: impl Into<u32>,
    ) -> test_enum_build_result::A
    where
        Lang: ::kirin::ir::Dialect + From<TestEnum>,
        Lang::Type: From<SomeType>,
    {
        let a_statement_id = stage.statement_arena().next_id();
        let value: u32 = value.into();
        let result: ResultValue = stage
            .ssa()
            .kind(SSAKind::Result(a_statement_id, 0usize))
            .ty(Lang::Type::from(u32_type))
            .new()
            .into();
        stage
            .statement()
            .definition(Self::A {
                value: value,
                result: result,
            })
            .new();
        test_enum_build_result::A {
            id: a_statement_id,
            result,
        }
    }
    pub fn op_b<Lang>(
        stage: &mut ::kirin::ir::StageInfo<Lang>,
        field_0: impl Into<u64>,
    ) -> test_enum_build_result::B
    where
        Lang: ::kirin::ir::Dialect + From<TestEnum>,
        Lang::Type: From<SomeType>,
    {
        let b_statement_id = stage.statement_arena().next_id();
        let field_0: u64 = field_0.into();
        let result: ResultValue = stage
            .ssa()
            .kind(SSAKind::Result(b_statement_id, 0usize))
            .ty(Lang::Type::from(u64_type))
            .new()
            .into();
        stage.statement().definition(Self::B(field_0, result)).new();
        test_enum_build_result::B {
            id: b_statement_id,
            result,
        }
    }
}
#[automatically_derived]
pub mod test_enum_build_result {
    use kirin::ir::{ResultValue, Statement};
    #[automatically_derived]
    pub struct A {
        pub id: Statement,
        pub result: ResultValue,
    }
    #[automatically_derived]
    impl From<A> for Statement {
        fn from(value: A) -> Self {
            value.id
        }
    }
    #[automatically_derived]
    pub struct B {
        pub id: Statement,
        pub result: ResultValue,
    }
    #[automatically_derived]
    impl From<B> for Statement {
        fn from(value: B) -> Self {
            value.id
        }
    }
}
