---
source: crates/kirin-derive-dialect/src/builder/tests.rs
expression: "case!\n{\n    #[kirin(terminator, fn, type = T)] pub enum ControlFlow<T: TypeLattice>\n    {\n        #[kirin(format = \"br {target}\")] Branch { target: Successor },\n        #[kirin(format =\n        \"cond_br {condition} then={true_target} else={false_target}\")]\n        ConditionalBranch\n        {\n            condition: SSAValue, true_target: Successor, false_target:\n            Successor, #[kirin(default = std::marker::PhantomData)] marker:\n            std::marker::PhantomData<T>,\n        }, #[kirin(format = \"ret {0}\")] Return(SSAValue),\n    }\n}"
---
#[automatically_derived]
impl<T: TypeLattice> ControlFlow<T> {
    pub fn op_branch<Lang>(
        stage: &mut ::kirin::ir::StageInfo<Lang>,
        target: impl Into<Successor>,
    ) -> control_flow_build_result::Branch
    where
        Lang: ::kirin::ir::Dialect + From<ControlFlow<T>>,
        Lang::Type: From<T>,
    {
        let branch_statement_id = stage.statement_arena().next_id();
        let target: Successor = target.into();
        stage
            .statement()
            .definition(Self::Branch { target: target })
            .new();
        control_flow_build_result::Branch {
            id: branch_statement_id,
        }
    }
    pub fn op_conditional_branch<Lang>(
        stage: &mut ::kirin::ir::StageInfo<Lang>,
        condition: impl Into<SSAValue>,
        true_target: impl Into<Successor>,
        false_target: impl Into<Successor>,
    ) -> control_flow_build_result::ConditionalBranch
    where
        Lang: ::kirin::ir::Dialect + From<ControlFlow<T>>,
        Lang::Type: From<T>,
    {
        let conditionalbranch_statement_id = stage.statement_arena().next_id();
        let condition: SSAValue = condition.into();
        let true_target: Successor = true_target.into();
        let false_target: Successor = false_target.into();
        let marker: std::marker::PhantomData<T> = std::marker::PhantomData;
        stage
            .statement()
            .definition(Self::ConditionalBranch {
                condition: condition,
                true_target: true_target,
                false_target: false_target,
                marker: marker,
            })
            .new();
        control_flow_build_result::ConditionalBranch {
            id: conditionalbranch_statement_id,
        }
    }
    pub fn op_return<Lang>(
        stage: &mut ::kirin::ir::StageInfo<Lang>,
        field_0: impl Into<SSAValue>,
    ) -> control_flow_build_result::Return
    where
        Lang: ::kirin::ir::Dialect + From<ControlFlow<T>>,
        Lang::Type: From<T>,
    {
        let return_statement_id = stage.statement_arena().next_id();
        let field_0: SSAValue = field_0.into();
        stage.statement().definition(Self::Return(field_0)).new();
        control_flow_build_result::Return {
            id: return_statement_id,
        }
    }
}
#[automatically_derived]
#[doc(hidden)]
pub mod control_flow_build_result {
    use kirin::ir::{ResultValue, Statement};
    #[automatically_derived]
    #[doc(hidden)]
    pub struct Branch {
        pub id: Statement,
    }
    #[automatically_derived]
    impl From<Branch> for Statement {
        fn from(value: Branch) -> Self {
            value.id
        }
    }
    #[automatically_derived]
    #[doc(hidden)]
    pub struct ConditionalBranch {
        pub id: Statement,
    }
    #[automatically_derived]
    impl From<ConditionalBranch> for Statement {
        fn from(value: ConditionalBranch) -> Self {
            value.id
        }
    }
    #[automatically_derived]
    #[doc(hidden)]
    pub struct Return {
        pub id: Statement,
    }
    #[automatically_derived]
    impl From<Return> for Statement {
        fn from(value: Return) -> Self {
            value.id
        }
    }
}
