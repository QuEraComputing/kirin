---
source: crates/kirin-derive-dialect/src/builder/tests.rs
expression: "case!\n{\n    #[kirin(fn, type = SimpleIRType, crate = kirin_ir)] pub enum\n    SimpleLanguage\n    {\n        Add(SSAValue, SSAValue, #[kirin(type = SimpleIRType::Float)]\n        ResultValue,),\n        Constant(#[kirin(into)] Value, #[kirin(type = SimpleIRType::Float)]\n        ResultValue,), #[kirin(terminator)] Return(SSAValue),\n        Function(Region, #[kirin(type = SimpleIRType::Float)] ResultValue,),\n    }\n}"
---
impl SimpleLanguage {
    pub fn op_add<Lang>(
        stage: &mut kirin_ir::StageInfo<Lang>,
        field_0: impl Into<SSAValue>,
        field_1: impl Into<SSAValue>,
    ) -> simple_language_build_result::Add
    where
        Lang: kirin_ir::Dialect + From<SimpleLanguage>,
        Lang::Type: From<SimpleIRType>,
    {
        let add_statement_id = stage.statement_arena().next_id();
        let field_0: SSAValue = field_0.into();
        let field_1: SSAValue = field_1.into();
        let result: ResultValue = stage
            .ssa()
            .kind(SSAKind::Result(add_statement_id, 0usize))
            .ty(Lang::Type::from(SimpleIRType::Float))
            .new()
            .into();
        stage
            .statement()
            .definition(Self::Add(field_0, field_1, result))
            .new();
        simple_language_build_result::Add {
            id: add_statement_id,
            result,
        }
    }
    pub fn op_constant<Lang>(
        stage: &mut kirin_ir::StageInfo<Lang>,
        field_0: impl Into<Value>,
    ) -> simple_language_build_result::Constant
    where
        Lang: kirin_ir::Dialect + From<SimpleLanguage>,
        Lang::Type: From<SimpleIRType>,
    {
        let constant_statement_id = stage.statement_arena().next_id();
        let field_0: Value = field_0.into();
        let result: ResultValue = stage
            .ssa()
            .kind(SSAKind::Result(constant_statement_id, 0usize))
            .ty(Lang::Type::from(SimpleIRType::Float))
            .new()
            .into();
        stage
            .statement()
            .definition(Self::Constant(field_0, result))
            .new();
        simple_language_build_result::Constant {
            id: constant_statement_id,
            result,
        }
    }
    pub fn op_return<Lang>(
        stage: &mut kirin_ir::StageInfo<Lang>,
        field_0: impl Into<SSAValue>,
    ) -> simple_language_build_result::Return
    where
        Lang: kirin_ir::Dialect + From<SimpleLanguage>,
        Lang::Type: From<SimpleIRType>,
    {
        let return_statement_id = stage.statement_arena().next_id();
        let field_0: SSAValue = field_0.into();
        stage.statement().definition(Self::Return(field_0)).new();
        simple_language_build_result::Return {
            id: return_statement_id,
        }
    }
    pub fn op_function<Lang>(
        stage: &mut kirin_ir::StageInfo<Lang>,
        field_0: impl Into<Region>,
    ) -> simple_language_build_result::Function
    where
        Lang: kirin_ir::Dialect + From<SimpleLanguage>,
        Lang::Type: From<SimpleIRType>,
    {
        let function_statement_id = stage.statement_arena().next_id();
        let field_0: Region = field_0.into();
        let result: ResultValue = stage
            .ssa()
            .kind(SSAKind::Result(function_statement_id, 0usize))
            .ty(Lang::Type::from(SimpleIRType::Float))
            .new()
            .into();
        stage
            .statement()
            .definition(Self::Function(field_0, result))
            .new();
        simple_language_build_result::Function {
            id: function_statement_id,
            result,
        }
    }
}
#[automatically_derived]
pub mod simple_language_build_result {
    use kirin_ir::{ResultValue, Statement};
    #[automatically_derived]
    pub struct Add {
        pub id: Statement,
        pub result: ResultValue,
    }
    #[automatically_derived]
    impl From<Add> for Statement {
        fn from(value: Add) -> Self {
            value.id
        }
    }
    #[automatically_derived]
    pub struct Constant {
        pub id: Statement,
        pub result: ResultValue,
    }
    #[automatically_derived]
    impl From<Constant> for Statement {
        fn from(value: Constant) -> Self {
            value.id
        }
    }
    #[automatically_derived]
    pub struct Return {
        pub id: Statement,
    }
    #[automatically_derived]
    impl From<Return> for Statement {
        fn from(value: Return) -> Self {
            value.id
        }
    }
    #[automatically_derived]
    pub struct Function {
        pub id: Statement,
        pub result: ResultValue,
    }
    #[automatically_derived]
    impl From<Function> for Statement {
        fn from(value: Function) -> Self {
            value.id
        }
    }
}
