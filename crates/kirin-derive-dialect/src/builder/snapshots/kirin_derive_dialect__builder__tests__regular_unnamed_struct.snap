---
source: crates/kirin-derive-dialect/src/builder/tests.rs
expression: "case!\n{\n    #[kirin(constant, fn = op_constant, type = L)] struct Constant<T:\n    CompileTimeValue + Typeof<L>, L:\n    TypeLattice>(#[kirin(into)] T, #[kirin(type = value.type_of())]\n    ResultValue, #[kirin(default = std::marker::PhantomData)]\n    std::marker::PhantomData<L>,);\n}"
---
#[automatically_derived]
impl<T: CompileTimeValue + Typeof<L>, L: TypeLattice> Constant<T, L> {
    pub fn op_constant<Lang>(
        stage: &mut ::kirin::ir::StageInfo<Lang>,
        field_0: impl Into<T>,
    ) -> constant_build_result::Constant
    where
        Lang: ::kirin::ir::Dialect + From<Constant<T, L>>,
        Lang::Type: From<L>,
    {
        let constant_statement_id = stage.statement_arena().next_id();
        let field_0: T = field_0.into();
        let field_2: std::marker::PhantomData<L> = std::marker::PhantomData;
        let result: ResultValue = stage
            .ssa()
            .kind(SSAKind::Result(constant_statement_id, 0usize))
            .ty(Lang::Type::from(value.type_of()))
            .new()
            .into();
        stage
            .statement()
            .definition(Self(field_0, result, field_2))
            .new();
        constant_build_result::Constant {
            id: constant_statement_id,
            result,
        }
    }
}
#[automatically_derived]
pub mod constant_build_result {
    use kirin::ir::{ResultValue, Statement};
    #[automatically_derived]
    pub struct Constant {
        pub id: Statement,
        pub result: ResultValue,
    }
    #[automatically_derived]
    impl From<Constant> for Statement {
        fn from(value: Constant) -> Self {
            value.id
        }
    }
}
