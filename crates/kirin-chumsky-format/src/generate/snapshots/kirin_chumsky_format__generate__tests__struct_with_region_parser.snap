---
source: crates/kirin-chumsky-format/src/generate/tests.rs
expression: parser
---
impl<'tokens, 'src: 'tokens> ::kirin_chumsky::HasDialectParser<'tokens, 'src, Function>
    for Function
{
    type Output = FunctionAST<'tokens, 'src, Function>;
    type TypeAST = <SimpleType as ::kirin_chumsky::HasParser<'tokens, 'src>>::Output;
    #[inline]
    fn recursive_parser<I>(
        language: ::kirin_chumsky::RecursiveParser<'tokens, 'src, I, Self::Output>,
    ) -> ::kirin_chumsky::BoxedParser<'tokens, 'src, I, Self::Output>
    where
        I: ::kirin_chumsky::TokenInput<'tokens, 'src>,
        Function: ::kirin_chumsky::HasDialectParser<'tokens, 'src, Function>,
    {
        use kirin_chumsky::chumsky::prelude::*;
        let parser: ::kirin_chumsky::BoxedParser<
            'tokens,
            'src,
            I,
            FunctionAST<'tokens, 'src, Function>,
        > = {
            use kirin_chumsky::Token;
            ::kirin_chumsky::nameof_ssa()
                .then_ignore(
                    ::kirin_chumsky::chumsky::prelude::just(Token::Equal).then_ignore(
                        ::kirin_chumsky::chumsky::prelude::just(Token::Identifier("function")),
                    ),
                )
                .then(
                    ::kirin_chumsky::region::<_, Function, SimpleType>(language.clone()).map(
                        |r| unsafe {
                            ::core::mem::transmute::<
                                ::kirin_chumsky::Region<
                                    'src,
                                    SimpleType,
                                    <Function as ::kirin_chumsky::HasDialectParser<
                                        'tokens,
                                        'src,
                                        Function,
                                    >>::Output,
                                >,
                                ::kirin_chumsky::Region<
                                    'src,
                                    SimpleType,
                                    FunctionAST<'tokens, 'src, Function>,
                                >,
                            >(r)
                        },
                    ),
                )
                .then_ignore(::kirin_chumsky::chumsky::prelude::just(Token::Arrow))
                .then(::kirin_chumsky::typeof_ssa::<_, Function, SimpleType>())
                .map(
                    |((res_name, body), res_type)| -> FunctionAST<'tokens, 'src, Function> {
                        FunctionAST {
                            res: ::kirin_chumsky::ResultValue {
                                name: ::kirin_chumsky::Spanned {
                                    value: res_name.name,
                                    span: res_name.span,
                                },
                                ty: Some(res_type.ty.clone()),
                            },
                            body: body,
                            _marker: ::core::marker::PhantomData,
                        }
                    },
                )
        }
        .boxed();
        unsafe { ::core::mem::transmute(parser) }
    }
}
impl<'tokens, 'src: 'tokens> ::kirin_chumsky::HasParser<'tokens, 'src> for Function
where
    SimpleType: ::kirin_chumsky::HasParser<'tokens, 'src, Output = SimpleType>,
{
    type Output = FunctionAST<'tokens, 'src, Function>;
    fn parser<I>() -> ::kirin_chumsky::BoxedParser<'tokens, 'src, I, Self::Output>
    where
        I: ::kirin_chumsky::TokenInput<'tokens, 'src>,
    {
        use kirin_chumsky::chumsky::prelude::*;
        :: kirin_chumsky :: chumsky :: recursive :: recursive (| language | { < Function as :: kirin_chumsky :: HasDialectParser < 'tokens , 'src , Function , >> :: recursive_parser (language) }) . boxed ()
    }
}
