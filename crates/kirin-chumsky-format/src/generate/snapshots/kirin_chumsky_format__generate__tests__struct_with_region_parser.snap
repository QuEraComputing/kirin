---
source: crates/kirin-chumsky-format/src/generate/tests.rs
expression: parser
---
impl<'tokens, 'src: 'tokens> ::kirin::parsers::HasDialectParser<'tokens, 'src> for Function
where
    SimpleType: ::kirin::parsers::HasParser<'tokens, 'src> + 'tokens,
{
    type Output<__Language>
        = FunctionAST<'tokens, 'src, __Language>
    where
        __Language: ::kirin::ir::Dialect + 'tokens;
    type TypeAST = <SimpleType as ::kirin::parsers::HasParser<'tokens, 'src>>::Output;
    #[inline]
    fn recursive_parser<I, __Language, __LanguageOutput>(
        language: ::kirin::parsers::RecursiveParser<'tokens, 'src, I, __LanguageOutput>,
    ) -> ::kirin::parsers::BoxedParser<'tokens, 'src, I, Self::Output<__Language>>
    where
        I: ::kirin::parsers::TokenInput<'tokens, 'src>,
        __Language: ::kirin::ir::Dialect + 'tokens,
        __LanguageOutput: Clone + 'tokens,
    {
        use kirin::parsers::chumsky::prelude::*;
        {
            use kirin::parsers::Token;
            ::kirin::parsers::nameof_ssa()
                .then_ignore(
                    ::kirin::parsers::chumsky::prelude::just(Token::Equal).then_ignore(
                        ::kirin::parsers::chumsky::prelude::just(Token::Identifier("function")),
                    ),
                )
                .then(
                    ::kirin::parsers::region::<_, SimpleType, _>(language.clone()).map(|r| {
                        ::kirin::parsers::coerce_region_type::<
                            <SimpleType as ::kirin::parsers::HasParser<'tokens, 'src>>::Output,
                            __LanguageOutput,
                            Self::Output<__Language>,
                            _,
                        >(r)
                    }),
                )
                .then_ignore(::kirin::parsers::chumsky::prelude::just(Token::Arrow))
                .then(::kirin::parsers::typeof_ssa::<_, SimpleType>())
                .map(
                    |((res_name, body), res_type)| -> FunctionAST<'tokens, 'src, __Language> {
                        FunctionAST {
                            body: body,
                            res: ::kirin::parsers::ResultValue {
                                name: ::kirin::parsers::Spanned {
                                    value: res_name.name,
                                    span: res_name.span,
                                },
                                ty: Some(res_type.ty.clone()),
                            },
                            _marker: ::core::marker::PhantomData::<
                                fn() -> (&'tokens (), &'src (), __Language),
                            >,
                        }
                    },
                )
        }
        .boxed()
    }
}
impl<'tokens, 'src: 'tokens> ::kirin::parsers::HasParser<'tokens, 'src> for Function
where
    SimpleType: ::kirin::parsers::HasParser<'tokens, 'src> + 'tokens,
{
    type Output = FunctionAST<'tokens, 'src, Function>;
    fn parser<I>() -> ::kirin::parsers::BoxedParser<'tokens, 'src, I, Self::Output>
    where
        I: ::kirin::parsers::TokenInput<'tokens, 'src>,
    {
        use kirin::parsers::chumsky::prelude::*;
        ::kirin::parsers::chumsky::recursive::recursive(|language| {
            <Function as ::kirin::parsers::HasDialectParser<'tokens, 'src>>::recursive_parser::<
                I,
                Function,
                Self::Output,
            >(language)
        })
        .boxed()
    }
}
