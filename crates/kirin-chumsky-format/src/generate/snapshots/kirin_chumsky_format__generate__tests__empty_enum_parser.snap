---
source: crates/kirin-chumsky-format/src/generate/tests.rs
expression: parser
---
impl<'tokens, 'src: 'tokens> ::kirin_chumsky::HasDialectParser<'tokens, 'src, EmptyLang>
    for EmptyLang
{
    type Output = EmptyLangAST<'tokens, 'src, EmptyLang>;
    type TypeAST = <SimpleType as ::kirin_chumsky::HasParser<'tokens, 'src>>::Output;
    #[inline]
    fn recursive_parser<I>(
        language: ::kirin_chumsky::RecursiveParser<'tokens, 'src, I, Self::Output>,
    ) -> ::kirin_chumsky::BoxedParser<'tokens, 'src, I, Self::Output>
    where
        I: ::kirin_chumsky::TokenInput<'tokens, 'src>,
        EmptyLang: ::kirin_chumsky::HasDialectParser<'tokens, 'src, EmptyLang>,
    {
        use chumsky::prelude::*;
        let parser: ::kirin_chumsky::BoxedParser<
            'tokens,
            'src,
            I,
            EmptyLangAST<'tokens, 'src, EmptyLang>,
        > = ::chumsky::prelude::empty()
            .map(|_: ()| unreachable!())
            .boxed();
        unsafe { ::core::mem::transmute(parser) }
    }
}
impl<'tokens, 'src: 'tokens> ::kirin_chumsky::HasParser<'tokens, 'src> for EmptyLang
where
    SimpleType: ::kirin_chumsky::HasParser<'tokens, 'src, Output = SimpleType>,
{
    type Output = EmptyLangAST<'tokens, 'src, EmptyLang>;
    fn parser<I>() -> ::kirin_chumsky::BoxedParser<'tokens, 'src, I, Self::Output>
    where
        I: ::kirin_chumsky::TokenInput<'tokens, 'src>,
    {
        use chumsky::prelude::*;
        :: chumsky :: recursive :: recursive (| language | { < EmptyLang as :: kirin_chumsky :: HasDialectParser < 'tokens , 'src , EmptyLang , >> :: recursive_parser (language) }) . boxed ()
    }
}
