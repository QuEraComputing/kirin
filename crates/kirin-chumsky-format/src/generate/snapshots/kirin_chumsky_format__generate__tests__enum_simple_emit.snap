---
source: crates/kirin-chumsky-format/src/generate/tests.rs
expression: emit
---
impl<'tokens, 'src: 'tokens, TypeOutput, LanguageOutput, Language>
    ::kirin::parsers::EmitIR<Language> for SimpleLangAST<'tokens, 'src, TypeOutput, LanguageOutput>
where
    Language: ::kirin::ir::Dialect + From<SimpleLang>,
    TypeOutput: Clone + PartialEq,
    LanguageOutput: Clone + PartialEq + 'tokens,
    LanguageOutput: ::kirin::parsers::EmitIR<Language, Output = ::kirin::ir::Statement>,
    SimpleType: ::kirin::parsers::HasParser<'tokens, 'src> + 'tokens,
    <SimpleType as ::kirin::parsers::HasParser<'tokens, 'src>>::Output: ::kirin::parsers::EmitIR<
        Language,
        Output = <Language as ::kirin::ir::Dialect>::TypeLattice,
    >,
{
    type Output = ::kirin::ir::Statement;
    fn emit(&self, ctx: &mut ::kirin::parsers::EmitContext<'_, Language>) -> Self::Output {
        match self {
            SimpleLangAST::Add {
                lhs: f_lhs,
                rhs: f_rhs,
                res: f_res,
            } => {
                let f_lhs_ir: ::kirin::ir::SSAValue = ::kirin::parsers::EmitIR::emit(f_lhs, ctx);
                let f_rhs_ir: ::kirin::ir::SSAValue = ::kirin::parsers::EmitIR::emit(f_rhs, ctx);
                let f_res_ir: ::kirin::ir::ResultValue = ::kirin::parsers::EmitIR::emit(f_res, ctx);
                let dialect_variant: SimpleLang = SimpleLang::Add {
                    lhs: f_lhs_ir.into(),
                    rhs: f_rhs_ir.into(),
                    res: f_res_ir.into(),
                };
                ctx.context.statement().definition(dialect_variant).new()
            }
            SimpleLangAST::Return { arg: f_arg } => {
                let f_arg_ir: ::kirin::ir::SSAValue = ::kirin::parsers::EmitIR::emit(f_arg, ctx);
                let dialect_variant: SimpleLang = SimpleLang::Return {
                    arg: f_arg_ir.into(),
                };
                ctx.context.statement().definition(dialect_variant).new()
            }
            SimpleLangAST::__Marker(_, unreachable) => match *unreachable {},
        }
    }
}
impl<'tokens, 'src, TypeOutput, Language> ::kirin::parsers::EmitIR<Language>
    for SimpleLangASTSelf<'tokens, 'src, TypeOutput>
where
    Language: ::kirin::ir::Dialect + From<SimpleLang>,
    TypeOutput: Clone + PartialEq,
    'src: 'tokens,
    SimpleType: ::kirin::parsers::HasParser<'tokens, 'src> + 'tokens,
    <SimpleType as ::kirin::parsers::HasParser<'tokens, 'src>>::Output: ::kirin::parsers::EmitIR<
        Language,
        Output = <Language as ::kirin::ir::Dialect>::TypeLattice,
    >,
{
    type Output = ::kirin::ir::Statement;
    fn emit(&self, ctx: &mut ::kirin::parsers::EmitContext<'_, Language>) -> Self::Output {
        ::kirin::parsers::EmitIR::emit(&self.0, ctx)
    }
}
