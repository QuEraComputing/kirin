---
source: crates/kirin-chumsky-format/src/generate/tests.rs
expression: parser
---
impl<'tokens, 'src: 'tokens> ::kirin_chumsky::HasDialectParser<'tokens, 'src, Load> for Load {
    type Output = LoadAST<'tokens, 'src, Load>;
    type TypeAST = <SimpleType as ::kirin_chumsky::HasParser<'tokens, 'src>>::Output;
    #[inline]
    fn recursive_parser<I>(
        language: ::kirin_chumsky::RecursiveParser<'tokens, 'src, I, Self::Output>,
    ) -> ::kirin_chumsky::BoxedParser<'tokens, 'src, I, Self::Output>
    where
        I: ::kirin_chumsky::TokenInput<'tokens, 'src>,
        Load: ::kirin_chumsky::HasDialectParser<'tokens, 'src, Load>,
    {
        use kirin_chumsky::chumsky::prelude::*;
        let parser: ::kirin_chumsky::BoxedParser<'tokens, 'src, I, LoadAST<'tokens, 'src, Load>> =
            {
                use kirin_chumsky::Token;
                ::kirin_chumsky::nameof_ssa()
                    .then_ignore(
                        ::kirin_chumsky::chumsky::prelude::just(Token::Equal)
                            .then_ignore(::kirin_chumsky::chumsky::prelude::just(
                                Token::Identifier("load"),
                            ))
                            .then_ignore(::kirin_chumsky::chumsky::prelude::just(Token::LBracket)),
                    )
                    .then(::kirin_chumsky::ssa_value::<_, Load, SimpleType>())
                    .then_ignore(
                        ::kirin_chumsky::chumsky::prelude::just(Token::RBracket)
                            .then_ignore(::kirin_chumsky::chumsky::prelude::just(Token::Arrow)),
                    )
                    .then(::kirin_chumsky::typeof_ssa::<_, Load, SimpleType>())
                    .map(
                        |((res_name, addr), res_type)| -> LoadAST<'tokens, 'src, Load> {
                            LoadAST {
                                addr: addr,
                                res: ::kirin_chumsky::ResultValue {
                                    name: ::kirin_chumsky::Spanned {
                                        value: res_name.name,
                                        span: res_name.span,
                                    },
                                    ty: Some(res_type.ty.clone()),
                                },
                                _marker: ::core::marker::PhantomData,
                            }
                        },
                    )
            }
            .boxed();
        unsafe { ::core::mem::transmute(parser) }
    }
}
impl<'tokens, 'src: 'tokens> ::kirin_chumsky::HasParser<'tokens, 'src> for Load
where
    SimpleType: ::kirin_chumsky::HasParser<'tokens, 'src, Output = SimpleType>,
{
    type Output = LoadAST<'tokens, 'src, Load>;
    fn parser<I>() -> ::kirin_chumsky::BoxedParser<'tokens, 'src, I, Self::Output>
    where
        I: ::kirin_chumsky::TokenInput<'tokens, 'src>,
    {
        use kirin_chumsky::chumsky::prelude::*;
        ::kirin_chumsky::chumsky::recursive::recursive(|language| {
            <Load as ::kirin_chumsky::HasDialectParser<'tokens, 'src, Load>>::recursive_parser(
                language,
            )
        })
        .boxed()
    }
}
