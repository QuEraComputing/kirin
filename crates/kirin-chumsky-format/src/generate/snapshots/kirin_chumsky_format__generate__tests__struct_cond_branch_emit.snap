---
source: crates/kirin-chumsky-format/src/generate/tests.rs
expression: emit
---
impl<'tokens, 'src: 'tokens, Language: ::kirin::ir::Dialect> ::kirin::parsers::EmitIR<Language>
    for CondBranchAST<'tokens, 'src, Language>
where
    Language: ::kirin::ir::Dialect + From<CondBranch>,
    SimpleType: ::kirin::parsers::HasParser<'tokens, 'src> + 'tokens,
    <SimpleType as ::kirin::parsers::HasParser<'tokens, 'src>>::Output: ::kirin::parsers::EmitIR<
        Language,
        Output = <Language as ::kirin::ir::Dialect>::TypeLattice,
    >,
{
    type Output = ::kirin::ir::Statement;
    fn emit(&self, ctx: &mut ::kirin::parsers::EmitContext<'_, Language>) -> Self::Output {
        let Self {
            cond: f_cond,
            then_target: f_then_target,
            else_target: f_else_target,
            ..
        } = self;
        let f_cond_ir: ::kirin::ir::SSAValue = ::kirin::parsers::EmitIR::emit(f_cond, ctx);
        let f_then_target_ir: ::kirin::ir::Successor =
            ::kirin::parsers::EmitIR::emit(f_then_target, ctx);
        let f_else_target_ir: ::kirin::ir::Successor =
            ::kirin::parsers::EmitIR::emit(f_else_target, ctx);
        let dialect_variant: CondBranch = CondBranch {
            cond: f_cond_ir.into(),
            then_target: f_then_target_ir.into(),
            else_target: f_else_target_ir.into(),
        };
        ctx.context.statement().definition(dialect_variant).new()
    }
}
