---
source: crates/kirin-chumsky-format/src/generate/tests.rs
expression: parser
---
impl<'tokens, 'src: 'tokens, Language> ::kirin::parsers::HasDialectParser<'tokens, 'src, Language>
    for MixedLang
where
    Language: ::kirin::ir::Dialect + 'tokens,
    SimpleType: ::kirin::parsers::HasParser<'tokens, 'src> + 'tokens,
    ArithDialect: ::kirin::parsers::HasDialectParser<'tokens, 'src, Language>,
    ControlDialect: ::kirin::parsers::HasDialectParser<'tokens, 'src, Language>,
{
    type Output = MixedLangAST<'tokens, 'src, Language>;
    type TypeAST = <SimpleType as ::kirin::parsers::HasParser<'tokens, 'src>>::Output;
    #[inline]
    fn recursive_parser<I>(
        language: ::kirin::parsers::RecursiveParser<
            'tokens,
            'src,
            I,
            <Language as ::kirin::parsers::HasDialectParser<'tokens, 'src, Language>>::Output,
        >,
    ) -> ::kirin::parsers::BoxedParser<'tokens, 'src, I, Self::Output>
    where
        I: ::kirin::parsers::TokenInput<'tokens, 'src>,
        Language: ::kirin::parsers::HasDialectParser<'tokens, 'src, Language>,
    {
        use kirin::parsers::chumsky::prelude::*;
        < ArithDialect as :: kirin :: parsers :: HasDialectParser < 'tokens , 'src , Language >> :: recursive_parser (language . clone ()) . map (| inner | -> MixedLangAST < 'tokens , 'src , Language > { MixedLangAST :: Arith (inner) }) . or ({ use :: kirin :: parsers :: Token ; :: kirin :: parsers :: nameof_ssa () . then_ignore (:: kirin :: parsers :: chumsky :: prelude :: just (Token :: Equal) . then_ignore (:: kirin :: parsers :: chumsky :: prelude :: just (Token :: Identifier ("custom")))) . then (:: kirin :: parsers :: ssa_value :: < _ , Language , SimpleType > ()) . then_ignore (:: kirin :: parsers :: chumsky :: prelude :: just (Token :: Arrow)) . then (:: kirin :: parsers :: typeof_ssa :: < _ , Language , SimpleType > ()) . map (| ((res_name , arg) , res_type) | -> MixedLangAST < 'tokens , 'src , Language > { MixedLangAST :: Custom { arg : arg , res : :: kirin :: parsers :: ResultValue { name : :: kirin :: parsers :: Spanned { value : res_name . name , span : res_name . span } , ty : Some (res_type . ty . clone ()) , } } }) }) . or (< ControlDialect as :: kirin :: parsers :: HasDialectParser < 'tokens , 'src , Language >> :: recursive_parser (language . clone ()) . map (| inner | -> MixedLangAST < 'tokens , 'src , Language > { MixedLangAST :: Control (inner) })) . boxed ()
    }
}
impl<'tokens, 'src: 'tokens> ::kirin::parsers::HasParser<'tokens, 'src> for MixedLang
where
    SimpleType: ::kirin::parsers::HasParser<'tokens, 'src> + 'tokens,
    ArithDialect: ::kirin::parsers::HasDialectParser<'tokens, 'src, MixedLang>,
    ControlDialect: ::kirin::parsers::HasDialectParser<'tokens, 'src, MixedLang>,
{
    type Output = MixedLangAST<'tokens, 'src, MixedLang>;
    fn parser<I>() -> ::kirin::parsers::BoxedParser<'tokens, 'src, I, Self::Output>
    where
        I: ::kirin::parsers::TokenInput<'tokens, 'src>,
    {
        use kirin::parsers::chumsky::prelude::*;
        :: kirin :: parsers :: chumsky :: recursive :: recursive (| language | { < MixedLang as :: kirin :: parsers :: HasDialectParser < 'tokens , 'src , MixedLang , >> :: recursive_parser (language) }) . boxed ()
    }
}
