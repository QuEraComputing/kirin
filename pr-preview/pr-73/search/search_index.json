{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"kirin-toolchain","text":""},{"location":"reference/kirin/","title":"Index","text":""},{"location":"reference/kirin/exceptions/","title":"Exceptions","text":""},{"location":"reference/kirin/graph/","title":"Graph","text":""},{"location":"reference/kirin/idtable/","title":"Idtable","text":""},{"location":"reference/kirin/lattice/","title":"Lattice","text":""},{"location":"reference/kirin/lattice/#kirin.lattice.SingletonMeta","title":"<code>SingletonMeta</code>","text":"<p>               Bases: <code>LatticeMeta</code></p> <p>See https://stackoverflow.com/questions/674304/why-is-init-always-called-after-new/8665179#8665179</p> Source code in <code>src/kirin/lattice.py</code> <pre><code>class SingletonMeta(LatticeMeta):\n    \"\"\"See https://stackoverflow.com/questions/674304/why-is-init-always-called-after-new/8665179#8665179\"\"\"\n\n    def __init__(cls, name, bases, attrs):\n        super().__init__(name, bases, attrs)\n        cls._instance = None\n\n    def __call__(cls, *args, **kwargs):\n        if cls._instance is None:\n            cls._instance = super().__call__(*args, **kwargs)\n        return cls._instance\n</code></pre>"},{"location":"reference/kirin/lattice/#kirin.lattice.UnionMeta","title":"<code>UnionMeta</code>","text":"<p>               Bases: <code>LatticeMeta</code></p> <p>Meta class for union types. It simplifies the union if possible.</p> Source code in <code>src/kirin/lattice.py</code> <pre><code>class UnionMeta(LatticeMeta):\n    \"\"\"Meta class for union types. It simplifies the union if possible.\"\"\"\n\n    def __call__(\n        self,\n        typ: Iterable[LatticeParent] | LatticeParent,\n        *others: LatticeParent,\n    ):\n        if isinstance(typ, Lattice):\n            typs: Iterable[LatticeParent] = (typ, *others)\n        elif not others:\n            typs = typ\n        else:\n            raise ValueError(\n                \"Expected an iterable of types or variadic arguments of types\"\n            )\n\n        # try if the union can be simplified\n        params: list[LatticeParent] = []\n        for typ in typs:\n            contains = False\n            for idx, other in enumerate(params):\n                if typ.is_subseteq(other):\n                    contains = True\n                    break\n                elif other.is_subseteq(typ):\n                    params[idx] = typ\n                    contains = True\n                    break\n\n            if not contains:\n                params.append(typ)\n\n        if len(params) == 1:\n            return params[0]\n\n        return super(UnionMeta, self).__call__(*params)\n</code></pre>"},{"location":"reference/kirin/prelude/","title":"Prelude","text":""},{"location":"reference/kirin/source/","title":"Source","text":""},{"location":"reference/kirin/worklist/","title":"Worklist","text":""},{"location":"reference/kirin/worklist/#kirin.worklist.WorkList","title":"<code>WorkList</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[ElemType]</code></p> <p>The worklist data structure.</p> <p>The worklist is a stack that allows for O(1) removal of elements from the stack.</p> Source code in <code>src/kirin/worklist.py</code> <pre><code>@dataclass\nclass WorkList(Generic[ElemType]):\n    \"\"\"The worklist data structure.\n\n    The worklist is a stack that allows for O(1) removal of elements from the stack.\n    \"\"\"\n\n    # this is from XDSL\n    _stack: list[ElemType | None] = field(default_factory=list, init=False)\n    _map: dict[ElemType, int] = field(default_factory=dict, init=False)\n    # allow O(1) removal from the stack via storage of the index\n\n    def __contains__(self, item: ElemType) -&gt; bool:\n        return item in self._map\n\n    def purge(self) -&gt; None:\n        \"\"\"remove all None values from the stack\"\"\"\n        while self._stack and self._stack[-1] is None:\n            self._stack.pop()\n\n    def is_empty(self) -&gt; bool:\n        self.purge()\n        return len(self._stack) == 0\n\n    def push(self, item: ElemType) -&gt; None:\n        if item not in self._map:\n            self._map[item] = len(self._stack)\n            self._stack.append(item)\n\n    def append(self, items: Iterable[ElemType]) -&gt; None:\n        for item in items:\n            self.push(item)\n\n    def pop(self) -&gt; ElemType | None:\n        while self._stack:\n            item = self._stack.pop()\n            if item is not None:\n                del self._map[item]\n                return item\n        return None\n\n    def remove(self, item: ElemType) -&gt; None:\n        if item in self._map:\n            idx = self._map[item]\n            self._stack[idx] = None\n            del self._map[item]\n</code></pre>"},{"location":"reference/kirin/worklist/#kirin.worklist.WorkList.purge","title":"<code>purge()</code>","text":"<p>remove all None values from the stack</p> Source code in <code>src/kirin/worklist.py</code> <pre><code>def purge(self) -&gt; None:\n    \"\"\"remove all None values from the stack\"\"\"\n    while self._stack and self._stack[-1] is None:\n        self._stack.pop()\n</code></pre>"},{"location":"reference/kirin/analysis/","title":"Index","text":""},{"location":"reference/kirin/analysis/cfg/","title":"Cfg","text":""},{"location":"reference/kirin/analysis/cfg/#kirin.analysis.cfg.CFG","title":"<code>CFG</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Printable</code></p> <p>Control Flow Graph of a given IR statement.</p> Source code in <code>src/kirin/analysis/cfg.py</code> <pre><code>@dataclass\nclass CFG(Printable):\n    \"\"\"Control Flow Graph of a given IR statement.\"\"\"\n\n    parent: ir.Region\n    \"\"\"Parent IR statement.\n    \"\"\"\n    entry: ir.Block | None = None\n    \"\"\"Entry block of the CFG.\n    \"\"\"\n\n    def __post_init__(self):\n        if self.parent.blocks.isempty():\n            self.entry = None\n        else:\n            self.entry = self.parent.blocks[0]\n\n    @cached_property\n    def predecessors(self):\n        \"\"\"CFG data, mapping a block to its predecessors.\"\"\"\n        graph: dict[ir.Block, set[ir.Block]] = {}\n        for block, neighbors in self.successors.items():\n            for neighbor in neighbors:\n                graph.setdefault(neighbor, set()).add(block)\n        return graph\n\n    @cached_property\n    def successors(self):\n        \"\"\"CFG data, mapping a block to its neighbors.\"\"\"\n        graph: dict[ir.Block, set[ir.Block]] = {}\n        worklist: WorkList[ir.Block] = WorkList()\n        if self.parent.blocks.isempty():\n            return graph\n\n        block = self.entry\n        while block is not None:\n            neighbors = graph.setdefault(block, set())\n            if block.last_stmt is not None:\n                neighbors.update(block.last_stmt.successors)\n                worklist.append(block.last_stmt.successors)\n\n            block = worklist.pop()\n        return graph\n\n    # graph interface\n    def get_neighbors(self, node: ir.Block) -&gt; Iterable[ir.Block]:\n        return self.successors[node]\n\n    def get_edges(self) -&gt; Iterable[tuple[ir.Block, ir.Block]]:\n        for block, neighbors in self.successors.items():\n            for neighbor in neighbors:\n                yield block, neighbor\n\n    def get_nodes(self) -&gt; Iterable[ir.Block]:\n        return self.successors.keys()\n\n    # printable interface\n    def print_impl(self, printer: Printer) -&gt; None:\n        # NOTE: this make sure we use the same name\n        # as the printing of CFG parent.\n        with printer.string_io():\n            self.parent.print(printer)\n\n        printer.plain_print(\"Successors:\")\n        printer.print_newline()\n        for block, neighbors in self.successors.items():\n            printer.plain_print(f\"{printer.state.block_id[block]} -&gt; \", end=\"\")\n            printer.print_seq(\n                neighbors,\n                delim=\", \",\n                prefix=\"[\",\n                suffix=\"]\",\n                emit=lambda block: printer.plain_print(printer.state.block_id[block]),\n            )\n            printer.print_newline()\n\n        if self.predecessors:\n            printer.print_newline()\n            printer.plain_print(\"Predecessors:\")\n            printer.print_newline()\n            for block, neighbors in self.predecessors.items():\n                printer.plain_print(f\"{printer.state.block_id[block]} &lt;- \", end=\"\")\n                printer.print_seq(\n                    neighbors,\n                    delim=\", \",\n                    prefix=\"[\",\n                    suffix=\"]\",\n                    emit=lambda block: printer.plain_print(\n                        printer.state.block_id[block]\n                    ),\n                )\n                printer.print_newline()\n</code></pre>"},{"location":"reference/kirin/analysis/cfg/#kirin.analysis.cfg.CFG.entry","title":"<code>entry: ir.Block | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Entry block of the CFG.</p>"},{"location":"reference/kirin/analysis/cfg/#kirin.analysis.cfg.CFG.parent","title":"<code>parent: ir.Region</code>  <code>instance-attribute</code>","text":"<p>Parent IR statement.</p>"},{"location":"reference/kirin/analysis/cfg/#kirin.analysis.cfg.CFG.predecessors","title":"<code>predecessors</code>  <code>cached</code> <code>property</code>","text":"<p>CFG data, mapping a block to its predecessors.</p>"},{"location":"reference/kirin/analysis/cfg/#kirin.analysis.cfg.CFG.successors","title":"<code>successors</code>  <code>cached</code> <code>property</code>","text":"<p>CFG data, mapping a block to its neighbors.</p>"},{"location":"reference/kirin/analysis/dataflow/","title":"Index","text":""},{"location":"reference/kirin/analysis/dataflow/constprop/","title":"Constprop","text":""},{"location":"reference/kirin/analysis/dataflow/forward/","title":"Forward","text":""},{"location":"reference/kirin/analysis/dataflow/forward/#kirin.analysis.dataflow.forward.ForwardExtra","title":"<code>ForwardExtra</code>","text":"<p>               Bases: <code>AbstractInterpreter[ForwardFrame[LatticeElemType, ExtraType], LatticeElemType]</code>, <code>Generic[LatticeElemType, ExtraType]</code></p> <p>Abstract interpreter but record results for each SSA value.</p> Source code in <code>src/kirin/analysis/dataflow/forward.py</code> <pre><code>class ForwardExtra(\n    AbstractInterpreter[ForwardFrame[LatticeElemType, ExtraType], LatticeElemType],\n    Generic[LatticeElemType, ExtraType],\n):\n    \"\"\"Abstract interpreter but record results for each SSA value.\"\"\"\n\n    results: dict[SSAValue, LatticeElemType] = field(init=False, default_factory=dict)\n\n    def __init__(\n        self,\n        dialects: DialectGroup | Iterable[Dialect],\n        *,\n        fuel: int | None = None,\n        max_depth: int = 128,\n        max_python_recursion_depth: int = 8192,\n    ):\n        super().__init__(\n            dialects,\n            fuel=fuel,\n            max_depth=max_depth,\n            max_python_recursion_depth=max_python_recursion_depth,\n        )\n        self.results = {}\n\n    def set_values(\n        self,\n        frame: AbstractFrame[LatticeElemType],\n        ssa: Iterable[SSAValue],\n        results: Iterable[LatticeElemType],\n    ):\n        for ssa_value, result in zip(ssa, results):\n            if ssa_value in frame.entries:\n                frame.entries[ssa_value] = frame.entries[ssa_value].join(result)\n            else:\n                frame.entries[ssa_value] = result\n\n    def postprocess_frame(\n        self, frame: ForwardFrame[LatticeElemType, ExtraType]\n    ) -&gt; None:\n        self.results = frame.entries\n\n    def new_method_frame(self, mt: Method) -&gt; ForwardFrame[LatticeElemType, ExtraType]:\n        return ForwardFrame.from_method(mt)\n</code></pre>"},{"location":"reference/kirin/analysis/dataflow/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/analysis/dataflow/typeinfer/#kirin.analysis.dataflow.typeinfer.TypeInference","title":"<code>TypeInference</code>","text":"<p>               Bases: <code>Forward[TypeAttribute]</code></p> Source code in <code>src/kirin/analysis/dataflow/typeinfer.py</code> <pre><code>class TypeInference(Forward[TypeAttribute]):\n    keys = [\"typeinfer\", \"typeinfer.default\"]\n\n    @classmethod\n    def bottom_value(cls) -&gt; TypeAttribute:\n        return BottomType()\n\n    def build_signature(self, stmt: Statement, args: tuple):\n        \"\"\"we use value here as signature as they will be types\"\"\"\n        _args = []\n        for x in args:\n            if isinstance(x, types.PyConst):\n                _args.append(x.typ)\n            elif isinstance(x, types.PyGeneric):\n                _args.append(x.body)\n            else:\n                _args.append(x)\n\n        return (\n            stmt.__class__,\n            tuple(_args),\n        )\n\n    def run_method_region(\n        self, mt: Method, body: Region, args: tuple[TypeAttribute, ...]\n    ) -&gt; InterpResult[TypeAttribute]:\n        # NOTE: widen method type here\n        return self.run_ssacfg_region(\n            body, (types.PyConst(mt, types.PyClass(ir.Method)),) + args\n        )\n</code></pre>"},{"location":"reference/kirin/analysis/dataflow/typeinfer/#kirin.analysis.dataflow.typeinfer.TypeInference.build_signature","title":"<code>build_signature(stmt, args)</code>","text":"<p>we use value here as signature as they will be types</p> Source code in <code>src/kirin/analysis/dataflow/typeinfer.py</code> <pre><code>def build_signature(self, stmt: Statement, args: tuple):\n    \"\"\"we use value here as signature as they will be types\"\"\"\n    _args = []\n    for x in args:\n        if isinstance(x, types.PyConst):\n            _args.append(x.typ)\n        elif isinstance(x, types.PyGeneric):\n            _args.append(x.body)\n        else:\n            _args.append(x)\n\n    return (\n        stmt.__class__,\n        tuple(_args),\n    )\n</code></pre>"},{"location":"reference/kirin/codegen/","title":"Index","text":""},{"location":"reference/kirin/codegen/base/","title":"Base","text":""},{"location":"reference/kirin/codegen/base/#kirin.codegen.base.CodeGen","title":"<code>CodeGen</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code>, <code>Generic[Target]</code></p> Source code in <code>src/kirin/codegen/base.py</code> <pre><code>@dataclass(init=False)\nclass CodeGen(ABC, Generic[Target]):\n    keys: ClassVar[list[str]]\n    dialects: ir.DialectGroup\n    registry: dict[\"Signature\", \"StatementImpl\"] = field(init=False, repr=False)\n\n    def __init__(self, dialects: ir.DialectGroup | Iterable[ir.Dialect]):\n        if not isinstance(dialects, ir.DialectGroup):\n            dialects = ir.DialectGroup(dialects)\n        self.dialects = dialects\n        self.registry = dialects.registry.codegen(self.keys)\n\n    def emit(self, mt: ir.Method) -&gt; Target:\n        \"\"\"top-level entry point for code generation.\"\"\"\n        return self.emit_Method(mt)\n\n    def emit_Statement(self, stmt: ir.Statement) -&gt; Target:\n        sig = self.build_signature(stmt)\n        if sig in self.registry:\n            return self.registry[sig](self, stmt)\n        elif stmt.__class__ in self.registry:\n            return self.registry[stmt.__class__](self, stmt)\n        return self.emit_Statement_fallback(stmt)\n\n    def emit_Attribute(self, attr: ir.Attribute) -&gt; Target:\n        if attr.__class__ in self.registry:\n            return self.registry[attr.__class__](self, attr)\n        return self.emit_Attribute_fallback(attr)\n\n    def emit_Attribute_fallback(self, attr: ir.Attribute) -&gt; Target:\n        raise NotImplementedError(f\"Emit for {attr.__class__.__name__} not implemented\")\n\n    def emit_Statement_fallback(self, stmt: ir.Statement) -&gt; Target:\n        raise NotImplementedError(f\"Emit for {stmt.__class__.__name__} not implemented\")\n\n    def build_signature(self, stmt: ir.Statement) -&gt; \"Signature\":\n        \"\"\"build signature for querying the statement implementation.\"\"\"\n        return (stmt.__class__, tuple(arg.type for arg in stmt.args))\n\n    @abstractmethod\n    def emit_Method(self, mt: ir.Method) -&gt; Target: ...\n\n    @abstractmethod\n    def emit_Region(self, region: ir.Region) -&gt; Target: ...\n\n    @abstractmethod\n    def emit_Block(self, block: ir.Block) -&gt; Target: ...\n</code></pre>"},{"location":"reference/kirin/codegen/base/#kirin.codegen.base.CodeGen.build_signature","title":"<code>build_signature(stmt)</code>","text":"<p>build signature for querying the statement implementation.</p> Source code in <code>src/kirin/codegen/base.py</code> <pre><code>def build_signature(self, stmt: ir.Statement) -&gt; \"Signature\":\n    \"\"\"build signature for querying the statement implementation.\"\"\"\n    return (stmt.__class__, tuple(arg.type for arg in stmt.args))\n</code></pre>"},{"location":"reference/kirin/codegen/base/#kirin.codegen.base.CodeGen.emit","title":"<code>emit(mt)</code>","text":"<p>top-level entry point for code generation.</p> Source code in <code>src/kirin/codegen/base.py</code> <pre><code>def emit(self, mt: ir.Method) -&gt; Target:\n    \"\"\"top-level entry point for code generation.\"\"\"\n    return self.emit_Method(mt)\n</code></pre>"},{"location":"reference/kirin/codegen/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/codegen/dict/","title":"Dict","text":""},{"location":"reference/kirin/codegen/impl/","title":"Impl","text":""},{"location":"reference/kirin/codegen/ssa/","title":"Ssa","text":""},{"location":"reference/kirin/decl/","title":"Index","text":""},{"location":"reference/kirin/decl/base/","title":"Base","text":""},{"location":"reference/kirin/decl/camel2snake/","title":"Camel2snake","text":""},{"location":"reference/kirin/decl/info/","title":"Info","text":""},{"location":"reference/kirin/decl/info/#kirin.decl.info.ArgumentField","title":"<code>ArgumentField</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Field</code></p> Source code in <code>src/kirin/decl/info.py</code> <pre><code>@dataclass\nclass ArgumentField(Field):\n    type: TypeAttribute\n    \"\"\"type of the argument, will be used in validation.\n    \"\"\"\n    print: bool = True\n    \"\"\"if `True`, this argument name is printed in the signature.\n    \"\"\"\n    group: bool = False  # NOTE: this cannot be set by user\n    \"\"\"if `True`, this argument is annotated with Tuple[SSAValue, ...]\n    \"\"\"\n\n    def has_no_default(self):\n        return True\n</code></pre>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.ArgumentField.group","title":"<code>group: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>if <code>True</code>, this argument is annotated with Tuple[SSAValue, ...]</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.ArgumentField.print","title":"<code>print: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>if <code>True</code>, this argument name is printed in the signature.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.ArgumentField.type","title":"<code>type: TypeAttribute</code>  <code>instance-attribute</code>","text":"<p>type of the argument, will be used in validation.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.AttributeField","title":"<code>AttributeField</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Field</code></p> Source code in <code>src/kirin/decl/info.py</code> <pre><code>@dataclass\nclass AttributeField(Field):\n    default: Any\n    init: bool\n    repr: bool\n    default_factory: Optional[Callable[[], Attribute]]\n    type: TypeAttribute\n    property: bool\n    pytype: bool = False\n    \"if `True`, annotation is a python type hint instead of `TypeAttribute`\"\n\n    def has_no_default(self):\n        return self.default is MISSING and self.default_factory is None\n</code></pre>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.AttributeField.pytype","title":"<code>pytype: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>if <code>True</code>, annotation is a python type hint instead of <code>TypeAttribute</code></p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields","title":"<code>StatementFields</code>  <code>dataclass</code>","text":"Source code in <code>src/kirin/decl/info.py</code> <pre><code>@dataclass\nclass StatementFields:\n    std_args: dict[str, ArgumentField] = field(default_factory=dict)\n    \"\"\"standard arguments of the statement.\"\"\"\n    kw_args: dict[str, ArgumentField] = field(default_factory=dict)\n    \"\"\"keyword-only arguments of the statement.\"\"\"\n    results: dict[str, ResultField] = field(default_factory=dict)\n    \"\"\"results of the statement.\"\"\"\n    regions: dict[str, RegionField] = field(default_factory=dict)\n    \"\"\"regions of the statement.\"\"\"\n    blocks: dict[str, BlockField] = field(default_factory=dict)\n    \"\"\"blocks of the statement.\"\"\"\n    attributes: dict[str, AttributeField] = field(default_factory=dict)\n    \"\"\"attributes of the statement.\"\"\"\n    properties: dict[str, AttributeField] = field(default_factory=dict)\n    \"\"\"properties of the statement.\"\"\"\n\n    class Args:\n        def __init__(self, fields: \"StatementFields\"):\n            self.fields = fields\n\n        def __len__(self):\n            return len(self.fields.std_args) + len(self.fields.kw_args)\n\n        def __getitem__(self, name):\n            if (value := self.fields.std_args.get(name)) is not None:\n                return value\n            elif (value := self.fields.kw_args.get(name)) is not None:\n                return value\n            raise KeyError(name)\n\n        def __setitem__(self, name: str, value: ArgumentField):\n            if value.kw_only:\n                self.fields.kw_args[name] = value\n            else:\n                self.fields.std_args[name] = value\n\n        def __contains__(self, name):\n            return name in self.fields.std_args or name in self.fields.kw_args\n\n        def values(self):\n            yield from self.fields.std_args.values()\n            yield from self.fields.kw_args.values()\n\n        def items(self):\n            yield from self.fields.std_args.items()\n            yield from self.fields.kw_args.items()\n\n        def keys(self):\n            yield from self.fields.std_args.keys()\n            yield from self.fields.kw_args.keys()\n\n    @property\n    def args(self):\n        \"\"\"iterable of all argument fields.\"\"\"\n        return self.Args(self)\n\n    @classmethod\n    def from_fields(cls, fields: dict[str, Field]):\n        ret = cls()\n        for name, f in fields.items():\n            ret[name] = f\n        return ret\n\n    def __contains__(self, name):\n        return (\n            name in self.args\n            or name in self.results\n            or name in self.regions\n            or name in self.blocks\n            or name in self.attributes\n            or name in self.properties\n        )\n\n    def __setitem__(self, name, value):\n        if isinstance(value, ArgumentField):\n            self.args[name] = value\n        elif isinstance(value, ResultField):\n            self.results[name] = value\n        elif isinstance(value, RegionField):\n            self.regions[name] = value\n        elif isinstance(value, BlockField):\n            self.blocks[name] = value\n        elif isinstance(value, AttributeField):\n            if value.property:\n                self.properties[name] = value\n            else:\n                self.attributes[name] = value\n        else:\n            raise TypeError(f\"unknown field type {value}\")\n\n    def __iter__(self):\n        yield from self.args.values()\n        yield from self.kw_args.values()\n        yield from self.results.values()\n        yield from self.regions.values()\n        yield from self.blocks.values()\n        yield from self.attributes.values()\n        yield from self.properties.values()\n\n    def __len__(self):\n        return (\n            len(self.args)\n            + len(self.results)\n            + len(self.regions)\n            + len(self.blocks)\n            + len(self.attributes)\n            + len(self.properties)\n        )\n\n    @cached_property\n    def attr_or_props(self):\n        return set(list(self.attributes.keys()) + list(self.properties.keys()))\n\n    @cached_property\n    def required_names(self):\n        \"\"\"set of all fields that do not have a default value.\"\"\"\n        return set(\n            list(self.args.keys())\n            + [name for name, f in self.attributes.items() if f.has_no_default()]\n            + [name for name, f in self.properties.items() if f.has_no_default()]\n            + [name for name, f in self.blocks.items() if f.has_no_default()]\n            + [name for name, f in self.regions.items() if f.has_no_default()]\n        )\n\n    @cached_property\n    def group_arg_names(self):\n        return set([name for name, f in self.args.items() if f.group])\n</code></pre>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.args","title":"<code>args</code>  <code>property</code>","text":"<p>iterable of all argument fields.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.attributes","title":"<code>attributes: dict[str, AttributeField] = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>attributes of the statement.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.blocks","title":"<code>blocks: dict[str, BlockField] = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>blocks of the statement.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.kw_args","title":"<code>kw_args: dict[str, ArgumentField] = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>keyword-only arguments of the statement.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.properties","title":"<code>properties: dict[str, AttributeField] = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>properties of the statement.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.regions","title":"<code>regions: dict[str, RegionField] = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>regions of the statement.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.required_names","title":"<code>required_names</code>  <code>cached</code> <code>property</code>","text":"<p>set of all fields that do not have a default value.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.results","title":"<code>results: dict[str, ResultField] = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>results of the statement.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.std_args","title":"<code>std_args: dict[str, ArgumentField] = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>standard arguments of the statement.</p>"},{"location":"reference/kirin/decl/scan_fields/","title":"Scan fields","text":""},{"location":"reference/kirin/decl/scan_fields/#kirin.decl.scan_fields.ScanFields","title":"<code>ScanFields</code>","text":"<p>               Bases: <code>BaseModifier</code></p> Source code in <code>src/kirin/decl/scan_fields.py</code> <pre><code>class ScanFields(BaseModifier):\n    _FIELDS = \"__kirin_stmt_fields\"\n    # String regex that string annotations for ClassVar or InitVar must match.\n    # Allows \"identifier.identifier[\" or \"identifier[\".\n    # https://bugs.python.org/issue33453 for details.\n    _MODULE_IDENTIFIER_RE = re.compile(r\"^(?:\\s*(\\w+)\\s*\\.)?\\s*(\\w+)\")\n\n    def scan_fields(self):\n        self._scan_base_fields()\n        self._scan_annotations()\n        setattr(self.cls, self._FIELDS, self.fields)\n        return\n\n    def _scan_base_fields(self):\n        # let's just assume dict preserve insertion order in python 3.7+\n        for b in self.cls.__mro__[-1:0:-1]:  # taken from dataclass impl\n            base_fields: StatementFields | None = getattr(b, self._FIELDS, None)\n            if base_fields is not None:\n                self.has_statement_bases = True\n                for f in base_fields:\n                    assert f.name is not None, \"field name must be set\"\n                    self.fields[f.name] = f\n\n    def _scan_annotations(self):\n        cls_fields: list[Field] = []\n        cls_annotations = inspect.get_annotations(self.cls, eval_str=True)\n        for name, typ in cls_annotations.items():\n            # See if this is a marker to change the value of kw_only.\n            if self._is_kw_only(typ) or (\n                isinstance(typ, str)\n                and self._is_type(typ, dataclasses, KW_ONLY, self._is_kw_only)\n            ):\n                if self.KW_ONLY_seen:\n                    raise TypeError(\n                        f\"{name!r} is KW_ONLY, but KW_ONLY \"\n                        \"has already been specified\"\n                    )\n                self.KW_ONLY_seen = True\n                self.kw_only = True\n            else:\n                cls_fields.append(self._get_field(name, typ))\n\n        for f in cls_fields:\n            name: str = f.name  # type: ignore # name has been set\n            self.fields[name] = f\n            if hasattr(self.cls, name):\n                # remove the field from the class\n                # unlike dataclass, we don't actually\n                # store any values in the class, they\n                # are stored inside the IR node.\n                delattr(self.cls, name)\n\n    def _get_field(self, name: str, typ):\n        \"\"\"Return a Field object for this field name and type.\"\"\"\n        guess = self._guess_type(typ)\n        default = getattr(self.cls, name, dataclasses.MISSING)\n        if isinstance(default, Field):\n            f = default\n        # no default descriptor, create a new one\n        elif is_subhint(typ, ir.SSAValue) or is_subhint(typ, tuple[ir.SSAValue, ...]):\n            f: Field = (\n                argument()\n            )  # only argument can have default, others must use field specifiers\n        elif typ is ir.ResultValue:\n            raise ValueError(\n                f\"expect field specifiers for `ir.ResultValue` fields: {name}\"\n            )\n        elif typ is ir.Region:\n            raise ValueError(f\"expect field specifiers for `ir.Region` fields: {name}\")\n        elif typ is ir.Block:\n            raise ValueError(f\"expect field specifiers for `ir.Block` fields: {name}\")\n        else:\n            # could be a wrong SSAValue field, e.g list[SSAValue], try check args\n            if typ_args := get_args(typ):\n                if any(is_subhint(arg, ir.SSAValue) for arg in typ_args):\n                    raise ValueError(\n                        f\"unsupported SSAValue field: {name},\"\n                        f\" expect `SSAValue` or `tuple[SSAValue, ...]`, got {typ}\"\n                    )\n            raise ValueError(f\"expect field specifiers for attribute fields: {name}\")\n\n        f.name = name\n        f.annotation = typ\n        self._post_init_field(f, guess)\n        return f\n\n    def _post_init_field(self, f: Field, guess: type | None):\n        if isinstance(f, ArgumentField) and is_subhint(guess, tuple[ir.SSAValue, ...]):\n            f.group = True\n        # try to narrow the type based on the guess\n        elif isinstance(f, AttributeField):\n            if guess and not is_subhint(\n                guess, ir.Attribute\n            ):  # not specified, and using python type\n                if f.type is types.Any:  # not set or too generic\n                    f.type = types.hint2type(guess)\n                f.pytype = True\n\n    @staticmethod\n    def _is_kw_only(a_type):\n        return a_type is KW_ONLY\n\n    def _is_type(\n        self,\n        annotation: type | str,\n        obj_module: ModuleType,\n        obj_type: type,\n        is_type_predicate: Callable[[type], bool],\n    ):\n        \"\"\"Given a type annotation string, does it refer to `obj_type` in\n        `obj_module`?  For example, when checking that annotation denotes a\n        `ClassVar`, then `obj_module` is typing, and a_type is\n        `typing.ClassVar`.\n\n        Taken from dataclasses.py/is_type.\n        \"\"\"\n        guess = self._guess_type(annotation)\n        if guess is not None:\n            return guess.__module__ is obj_module and is_type_predicate(guess)\n        return False\n\n    def _guess_type(self, annotation: type | str) -&gt; type | None:\n        \"\"\"Guess the type/hint object from a string annotation.\"\"\"\n        if not isinstance(annotation, str):\n            return annotation\n\n        match = self._MODULE_IDENTIFIER_RE.match(annotation)\n        ns = None\n        if match:\n            module_name = match.group(1)\n            if not module_name:\n                # No module name, assume the class's module did\n                # \"from dataclasses import InitVar\".\n                ns = sys.modules.get(self.cls.__module__).__dict__\n            else:\n                # Look up module_name in the class's module.\n                if self.cls_module:\n                    ns = self.cls_module.__dict__.get(module_name).__dict__\n            if ns:\n                return ns.get(match.group(2))\n        return None\n</code></pre>"},{"location":"reference/kirin/decl/verify/","title":"Verify","text":""},{"location":"reference/kirin/decl/emit/","title":"Index","text":""},{"location":"reference/kirin/decl/emit/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/decl/emit/from_python_call/","title":"From python call","text":""},{"location":"reference/kirin/decl/emit/init/","title":"Init","text":""},{"location":"reference/kirin/decl/emit/name/","title":"Name","text":""},{"location":"reference/kirin/decl/emit/property/","title":"Property","text":""},{"location":"reference/kirin/decl/emit/repr/","title":"Repr","text":""},{"location":"reference/kirin/decl/emit/traits/","title":"Traits","text":""},{"location":"reference/kirin/decl/emit/typecheck/","title":"Typecheck","text":""},{"location":"reference/kirin/decl/emit/verify/","title":"Verify","text":""},{"location":"reference/kirin/dialects/","title":"Index","text":""},{"location":"reference/kirin/dialects/cf/","title":"Index","text":""},{"location":"reference/kirin/dialects/cf/constprop/","title":"Constprop","text":""},{"location":"reference/kirin/dialects/cf/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/dialects/cf/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/cf/lower/","title":"Lower","text":""},{"location":"reference/kirin/dialects/cf/stmts/","title":"Stmts","text":""},{"location":"reference/kirin/dialects/cf/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/dialects/fcf/","title":"Index","text":""},{"location":"reference/kirin/dialects/fcf/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/dialects/fcf/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/fcf/stmts/","title":"Stmts","text":""},{"location":"reference/kirin/dialects/fcf/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/dialects/func/","title":"Index","text":"<p>A function dialect that is compatible with python semantics.</p>"},{"location":"reference/kirin/dialects/func/attrs/","title":"Attrs","text":""},{"location":"reference/kirin/dialects/func/attrs/#kirin.dialects.func.attrs.Signature","title":"<code>Signature</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[TypeLatticeElem]</code>, <code>Attribute</code></p> <p>function body signature.</p> <p>This is not a type attribute because it just stores the signature of a function at its definition site. We don't perform type inference on this directly.</p> <p>The type of a function is the type of <code>inputs[0]</code>, which typically is a <code>MethodType</code>.</p> Source code in <code>src/kirin/dialects/func/attrs.py</code> <pre><code>@dialect.register\n@dataclass\nclass Signature(Generic[TypeLatticeElem], Attribute):\n    \"\"\"function body signature.\n\n    This is not a type attribute because it just stores\n    the signature of a function at its definition site.\n    We don't perform type inference on this directly.\n\n    The type of a function is the type of `inputs[0]`, which\n    typically is a `MethodType`.\n    \"\"\"\n\n    name = \"Signature\"\n    inputs: tuple[TypeLatticeElem, ...]\n    output: TypeLatticeElem  # multi-output must be tuple\n\n    def __hash__(self) -&gt; int:\n        return hash((self.inputs, self.output))\n\n    def print_impl(self, printer: Printer) -&gt; None:\n        printer.print_seq(self.inputs, delim=\", \", prefix=\"(\", suffix=\")\")\n        printer.plain_print(\" -&gt; \")\n        printer.print(self.output)\n</code></pre>"},{"location":"reference/kirin/dialects/func/constprop/","title":"Constprop","text":""},{"location":"reference/kirin/dialects/func/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/dialects/func/emit/","title":"Emit","text":""},{"location":"reference/kirin/dialects/func/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/func/lower/","title":"Lower","text":""},{"location":"reference/kirin/dialects/func/stmts/","title":"Stmts","text":""},{"location":"reference/kirin/dialects/func/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/dialects/math/","title":"Index","text":"<p>math dialect, modeling functions in python's <code>math</code> stdlib</p>"},{"location":"reference/kirin/dialects/math/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/dialects/math/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/math/stmts/","title":"Stmts","text":""},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.acos","title":"<code>acos</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Statement</code></p> <p>acos statement, wrapping the math.acos function</p> Source code in <code>src/kirin/dialects/math/stmts.py</code> <pre><code>@statement(dialect=dialect)\nclass acos(ir.Statement):\n    \"\"\"acos statement, wrapping the math.acos function\"\"\"\n\n    name = \"acos\"\n    traits = frozenset({ir.Pure()})\n    x: ir.SSAValue = info.argument(Float)\n    result: ir.ResultValue = info.result(Float)\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.asin","title":"<code>asin</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Statement</code></p> <p>asin statement, wrapping the math.asin function</p> Source code in <code>src/kirin/dialects/math/stmts.py</code> <pre><code>@statement(dialect=dialect)\nclass asin(ir.Statement):\n    \"\"\"asin statement, wrapping the math.asin function\"\"\"\n\n    name = \"asin\"\n    traits = frozenset({ir.Pure()})\n    x: ir.SSAValue = info.argument(Float)\n    result: ir.ResultValue = info.result(Float)\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.asinh","title":"<code>asinh</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Statement</code></p> <p>asinh statement, wrapping the math.asinh function</p> Source code in <code>src/kirin/dialects/math/stmts.py</code> <pre><code>@statement(dialect=dialect)\nclass asinh(ir.Statement):\n    \"\"\"asinh statement, wrapping the math.asinh function\"\"\"\n\n    name = \"asinh\"\n    traits = frozenset({ir.Pure()})\n    x: ir.SSAValue = info.argument(Float)\n    result: ir.ResultValue = info.result(Float)\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.atan","title":"<code>atan</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Statement</code></p> <p>atan statement, wrapping the math.atan function</p> Source code in <code>src/kirin/dialects/math/stmts.py</code> <pre><code>@statement(dialect=dialect)\nclass atan(ir.Statement):\n    \"\"\"atan statement, wrapping the math.atan function\"\"\"\n\n    name = \"atan\"\n    traits = frozenset({ir.Pure()})\n    x: ir.SSAValue = info.argument(Float)\n    result: ir.ResultValue = info.result(Float)\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.atan2","title":"<code>atan2</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Statement</code></p> <p>atan2 statement, wrapping the math.atan2 function</p> Source code in <code>src/kirin/dialects/math/stmts.py</code> <pre><code>@statement(dialect=dialect)\nclass atan2(ir.Statement):\n    \"\"\"atan2 statement, wrapping the math.atan2 function\"\"\"\n\n    name = \"atan2\"\n    traits = frozenset({ir.Pure()})\n    y: ir.SSAValue = info.argument(Float)\n    x: ir.SSAValue = info.argument(Float)\n    result: ir.ResultValue = info.result(Float)\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.atanh","title":"<code>atanh</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Statement</code></p> <p>atanh statement, wrapping the math.atanh function</p> Source code in <code>src/kirin/dialects/math/stmts.py</code> <pre><code>@statement(dialect=dialect)\nclass atanh(ir.Statement):\n    \"\"\"atanh statement, wrapping the math.atanh function\"\"\"\n\n    name = \"atanh\"\n    traits = frozenset({ir.Pure()})\n    x: ir.SSAValue = info.argument(Float)\n    result: ir.ResultValue = info.result(Float)\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.ceil","title":"<code>ceil</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Statement</code></p> <p>ceil statement, wrapping the math.ceil function</p> Source code in <code>src/kirin/dialects/math/stmts.py</code> <pre><code>@statement(dialect=dialect)\nclass ceil(ir.Statement):\n    \"\"\"ceil statement, wrapping the math.ceil function\"\"\"\n\n    name = \"ceil\"\n    traits = frozenset({ir.Pure()})\n    x: ir.SSAValue = info.argument(Float)\n    result: ir.ResultValue = info.result(Float)\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.copysign","title":"<code>copysign</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Statement</code></p> <p>copysign statement, wrapping the math.copysign function</p> Source code in <code>src/kirin/dialects/math/stmts.py</code> <pre><code>@statement(dialect=dialect)\nclass copysign(ir.Statement):\n    \"\"\"copysign statement, wrapping the math.copysign function\"\"\"\n\n    name = \"copysign\"\n    traits = frozenset({ir.Pure()})\n    x: ir.SSAValue = info.argument(Float)\n    y: ir.SSAValue = info.argument(Float)\n    result: ir.ResultValue = info.result(Float)\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.cos","title":"<code>cos</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Statement</code></p> <p>cos statement, wrapping the math.cos function</p> Source code in <code>src/kirin/dialects/math/stmts.py</code> <pre><code>@statement(dialect=dialect)\nclass cos(ir.Statement):\n    \"\"\"cos statement, wrapping the math.cos function\"\"\"\n\n    name = \"cos\"\n    traits = frozenset({ir.Pure()})\n    x: ir.SSAValue = info.argument(Float)\n    result: ir.ResultValue = info.result(Float)\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.cosh","title":"<code>cosh</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Statement</code></p> <p>cosh statement, wrapping the math.cosh function</p> Source code in <code>src/kirin/dialects/math/stmts.py</code> <pre><code>@statement(dialect=dialect)\nclass cosh(ir.Statement):\n    \"\"\"cosh statement, wrapping the math.cosh function\"\"\"\n\n    name = \"cosh\"\n    traits = frozenset({ir.Pure()})\n    x: ir.SSAValue = info.argument(Float)\n    result: ir.ResultValue = info.result(Float)\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.degrees","title":"<code>degrees</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Statement</code></p> <p>degrees statement, wrapping the math.degrees function</p> Source code in <code>src/kirin/dialects/math/stmts.py</code> <pre><code>@statement(dialect=dialect)\nclass degrees(ir.Statement):\n    \"\"\"degrees statement, wrapping the math.degrees function\"\"\"\n\n    name = \"degrees\"\n    traits = frozenset({ir.Pure()})\n    x: ir.SSAValue = info.argument(Float)\n    result: ir.ResultValue = info.result(Float)\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.erf","title":"<code>erf</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Statement</code></p> <p>erf statement, wrapping the math.erf function</p> Source code in <code>src/kirin/dialects/math/stmts.py</code> <pre><code>@statement(dialect=dialect)\nclass erf(ir.Statement):\n    \"\"\"erf statement, wrapping the math.erf function\"\"\"\n\n    name = \"erf\"\n    traits = frozenset({ir.Pure()})\n    x: ir.SSAValue = info.argument(Float)\n    result: ir.ResultValue = info.result(Float)\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.erfc","title":"<code>erfc</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Statement</code></p> <p>erfc statement, wrapping the math.erfc function</p> Source code in <code>src/kirin/dialects/math/stmts.py</code> <pre><code>@statement(dialect=dialect)\nclass erfc(ir.Statement):\n    \"\"\"erfc statement, wrapping the math.erfc function\"\"\"\n\n    name = \"erfc\"\n    traits = frozenset({ir.Pure()})\n    x: ir.SSAValue = info.argument(Float)\n    result: ir.ResultValue = info.result(Float)\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.exp","title":"<code>exp</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Statement</code></p> <p>exp statement, wrapping the math.exp function</p> Source code in <code>src/kirin/dialects/math/stmts.py</code> <pre><code>@statement(dialect=dialect)\nclass exp(ir.Statement):\n    \"\"\"exp statement, wrapping the math.exp function\"\"\"\n\n    name = \"exp\"\n    traits = frozenset({ir.Pure()})\n    x: ir.SSAValue = info.argument(Float)\n    result: ir.ResultValue = info.result(Float)\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.expm1","title":"<code>expm1</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Statement</code></p> <p>expm1 statement, wrapping the math.expm1 function</p> Source code in <code>src/kirin/dialects/math/stmts.py</code> <pre><code>@statement(dialect=dialect)\nclass expm1(ir.Statement):\n    \"\"\"expm1 statement, wrapping the math.expm1 function\"\"\"\n\n    name = \"expm1\"\n    traits = frozenset({ir.Pure()})\n    x: ir.SSAValue = info.argument(Float)\n    result: ir.ResultValue = info.result(Float)\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.fabs","title":"<code>fabs</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Statement</code></p> <p>fabs statement, wrapping the math.fabs function</p> Source code in <code>src/kirin/dialects/math/stmts.py</code> <pre><code>@statement(dialect=dialect)\nclass fabs(ir.Statement):\n    \"\"\"fabs statement, wrapping the math.fabs function\"\"\"\n\n    name = \"fabs\"\n    traits = frozenset({ir.Pure()})\n    x: ir.SSAValue = info.argument(Float)\n    result: ir.ResultValue = info.result(Float)\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.floor","title":"<code>floor</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Statement</code></p> <p>floor statement, wrapping the math.floor function</p> Source code in <code>src/kirin/dialects/math/stmts.py</code> <pre><code>@statement(dialect=dialect)\nclass floor(ir.Statement):\n    \"\"\"floor statement, wrapping the math.floor function\"\"\"\n\n    name = \"floor\"\n    traits = frozenset({ir.Pure()})\n    x: ir.SSAValue = info.argument(Float)\n    result: ir.ResultValue = info.result(Float)\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.fmod","title":"<code>fmod</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Statement</code></p> <p>fmod statement, wrapping the math.fmod function</p> Source code in <code>src/kirin/dialects/math/stmts.py</code> <pre><code>@statement(dialect=dialect)\nclass fmod(ir.Statement):\n    \"\"\"fmod statement, wrapping the math.fmod function\"\"\"\n\n    name = \"fmod\"\n    traits = frozenset({ir.Pure()})\n    x: ir.SSAValue = info.argument(Float)\n    y: ir.SSAValue = info.argument(Float)\n    result: ir.ResultValue = info.result(Float)\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.gamma","title":"<code>gamma</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Statement</code></p> <p>gamma statement, wrapping the math.gamma function</p> Source code in <code>src/kirin/dialects/math/stmts.py</code> <pre><code>@statement(dialect=dialect)\nclass gamma(ir.Statement):\n    \"\"\"gamma statement, wrapping the math.gamma function\"\"\"\n\n    name = \"gamma\"\n    traits = frozenset({ir.Pure()})\n    x: ir.SSAValue = info.argument(Float)\n    result: ir.ResultValue = info.result(Float)\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.isfinite","title":"<code>isfinite</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Statement</code></p> <p>isfinite statement, wrapping the math.isfinite function</p> Source code in <code>src/kirin/dialects/math/stmts.py</code> <pre><code>@statement(dialect=dialect)\nclass isfinite(ir.Statement):\n    \"\"\"isfinite statement, wrapping the math.isfinite function\"\"\"\n\n    name = \"isfinite\"\n    traits = frozenset({ir.Pure()})\n    x: ir.SSAValue = info.argument(Float)\n    result: ir.ResultValue = info.result(Float)\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.isinf","title":"<code>isinf</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Statement</code></p> <p>isinf statement, wrapping the math.isinf function</p> Source code in <code>src/kirin/dialects/math/stmts.py</code> <pre><code>@statement(dialect=dialect)\nclass isinf(ir.Statement):\n    \"\"\"isinf statement, wrapping the math.isinf function\"\"\"\n\n    name = \"isinf\"\n    traits = frozenset({ir.Pure()})\n    x: ir.SSAValue = info.argument(Float)\n    result: ir.ResultValue = info.result(Float)\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.isnan","title":"<code>isnan</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Statement</code></p> <p>isnan statement, wrapping the math.isnan function</p> Source code in <code>src/kirin/dialects/math/stmts.py</code> <pre><code>@statement(dialect=dialect)\nclass isnan(ir.Statement):\n    \"\"\"isnan statement, wrapping the math.isnan function\"\"\"\n\n    name = \"isnan\"\n    traits = frozenset({ir.Pure()})\n    x: ir.SSAValue = info.argument(Float)\n    result: ir.ResultValue = info.result(Float)\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.lgamma","title":"<code>lgamma</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Statement</code></p> <p>lgamma statement, wrapping the math.lgamma function</p> Source code in <code>src/kirin/dialects/math/stmts.py</code> <pre><code>@statement(dialect=dialect)\nclass lgamma(ir.Statement):\n    \"\"\"lgamma statement, wrapping the math.lgamma function\"\"\"\n\n    name = \"lgamma\"\n    traits = frozenset({ir.Pure()})\n    x: ir.SSAValue = info.argument(Float)\n    result: ir.ResultValue = info.result(Float)\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.log10","title":"<code>log10</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Statement</code></p> <p>log10 statement, wrapping the math.log10 function</p> Source code in <code>src/kirin/dialects/math/stmts.py</code> <pre><code>@statement(dialect=dialect)\nclass log10(ir.Statement):\n    \"\"\"log10 statement, wrapping the math.log10 function\"\"\"\n\n    name = \"log10\"\n    traits = frozenset({ir.Pure()})\n    x: ir.SSAValue = info.argument(Float)\n    result: ir.ResultValue = info.result(Float)\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.log1p","title":"<code>log1p</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Statement</code></p> <p>log1p statement, wrapping the math.log1p function</p> Source code in <code>src/kirin/dialects/math/stmts.py</code> <pre><code>@statement(dialect=dialect)\nclass log1p(ir.Statement):\n    \"\"\"log1p statement, wrapping the math.log1p function\"\"\"\n\n    name = \"log1p\"\n    traits = frozenset({ir.Pure()})\n    x: ir.SSAValue = info.argument(Float)\n    result: ir.ResultValue = info.result(Float)\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.log2","title":"<code>log2</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Statement</code></p> <p>log2 statement, wrapping the math.log2 function</p> Source code in <code>src/kirin/dialects/math/stmts.py</code> <pre><code>@statement(dialect=dialect)\nclass log2(ir.Statement):\n    \"\"\"log2 statement, wrapping the math.log2 function\"\"\"\n\n    name = \"log2\"\n    traits = frozenset({ir.Pure()})\n    x: ir.SSAValue = info.argument(Float)\n    result: ir.ResultValue = info.result(Float)\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.pow","title":"<code>pow</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Statement</code></p> <p>pow statement, wrapping the math.pow function</p> Source code in <code>src/kirin/dialects/math/stmts.py</code> <pre><code>@statement(dialect=dialect)\nclass pow(ir.Statement):\n    \"\"\"pow statement, wrapping the math.pow function\"\"\"\n\n    name = \"pow\"\n    traits = frozenset({ir.Pure()})\n    x: ir.SSAValue = info.argument(Float)\n    y: ir.SSAValue = info.argument(Float)\n    result: ir.ResultValue = info.result(Float)\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.radians","title":"<code>radians</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Statement</code></p> <p>radians statement, wrapping the math.radians function</p> Source code in <code>src/kirin/dialects/math/stmts.py</code> <pre><code>@statement(dialect=dialect)\nclass radians(ir.Statement):\n    \"\"\"radians statement, wrapping the math.radians function\"\"\"\n\n    name = \"radians\"\n    traits = frozenset({ir.Pure()})\n    x: ir.SSAValue = info.argument(Float)\n    result: ir.ResultValue = info.result(Float)\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.remainder","title":"<code>remainder</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Statement</code></p> <p>remainder statement, wrapping the math.remainder function</p> Source code in <code>src/kirin/dialects/math/stmts.py</code> <pre><code>@statement(dialect=dialect)\nclass remainder(ir.Statement):\n    \"\"\"remainder statement, wrapping the math.remainder function\"\"\"\n\n    name = \"remainder\"\n    traits = frozenset({ir.Pure()})\n    x: ir.SSAValue = info.argument(Float)\n    y: ir.SSAValue = info.argument(Float)\n    result: ir.ResultValue = info.result(Float)\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.sin","title":"<code>sin</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Statement</code></p> <p>sin statement, wrapping the math.sin function</p> Source code in <code>src/kirin/dialects/math/stmts.py</code> <pre><code>@statement(dialect=dialect)\nclass sin(ir.Statement):\n    \"\"\"sin statement, wrapping the math.sin function\"\"\"\n\n    name = \"sin\"\n    traits = frozenset({ir.Pure()})\n    x: ir.SSAValue = info.argument(Float)\n    result: ir.ResultValue = info.result(Float)\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.sinh","title":"<code>sinh</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Statement</code></p> <p>sinh statement, wrapping the math.sinh function</p> Source code in <code>src/kirin/dialects/math/stmts.py</code> <pre><code>@statement(dialect=dialect)\nclass sinh(ir.Statement):\n    \"\"\"sinh statement, wrapping the math.sinh function\"\"\"\n\n    name = \"sinh\"\n    traits = frozenset({ir.Pure()})\n    x: ir.SSAValue = info.argument(Float)\n    result: ir.ResultValue = info.result(Float)\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.sqrt","title":"<code>sqrt</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Statement</code></p> <p>sqrt statement, wrapping the math.sqrt function</p> Source code in <code>src/kirin/dialects/math/stmts.py</code> <pre><code>@statement(dialect=dialect)\nclass sqrt(ir.Statement):\n    \"\"\"sqrt statement, wrapping the math.sqrt function\"\"\"\n\n    name = \"sqrt\"\n    traits = frozenset({ir.Pure()})\n    x: ir.SSAValue = info.argument(Float)\n    result: ir.ResultValue = info.result(Float)\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.tan","title":"<code>tan</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Statement</code></p> <p>tan statement, wrapping the math.tan function</p> Source code in <code>src/kirin/dialects/math/stmts.py</code> <pre><code>@statement(dialect=dialect)\nclass tan(ir.Statement):\n    \"\"\"tan statement, wrapping the math.tan function\"\"\"\n\n    name = \"tan\"\n    traits = frozenset({ir.Pure()})\n    x: ir.SSAValue = info.argument(Float)\n    result: ir.ResultValue = info.result(Float)\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.tanh","title":"<code>tanh</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Statement</code></p> <p>tanh statement, wrapping the math.tanh function</p> Source code in <code>src/kirin/dialects/math/stmts.py</code> <pre><code>@statement(dialect=dialect)\nclass tanh(ir.Statement):\n    \"\"\"tanh statement, wrapping the math.tanh function\"\"\"\n\n    name = \"tanh\"\n    traits = frozenset({ir.Pure()})\n    x: ir.SSAValue = info.argument(Float)\n    result: ir.ResultValue = info.result(Float)\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.trunc","title":"<code>trunc</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Statement</code></p> <p>trunc statement, wrapping the math.trunc function</p> Source code in <code>src/kirin/dialects/math/stmts.py</code> <pre><code>@statement(dialect=dialect)\nclass trunc(ir.Statement):\n    \"\"\"trunc statement, wrapping the math.trunc function\"\"\"\n\n    name = \"trunc\"\n    traits = frozenset({ir.Pure()})\n    x: ir.SSAValue = info.argument(Float)\n    result: ir.ResultValue = info.result(Float)\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.ulp","title":"<code>ulp</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Statement</code></p> <p>ulp statement, wrapping the math.ulp function</p> Source code in <code>src/kirin/dialects/math/stmts.py</code> <pre><code>@statement(dialect=dialect)\nclass ulp(ir.Statement):\n    \"\"\"ulp statement, wrapping the math.ulp function\"\"\"\n\n    name = \"ulp\"\n    traits = frozenset({ir.Pure()})\n    x: ir.SSAValue = info.argument(Float)\n    result: ir.ResultValue = info.result(Float)\n</code></pre>"},{"location":"reference/kirin/dialects/py/","title":"Index","text":""},{"location":"reference/kirin/dialects/py/data/","title":"Data","text":""},{"location":"reference/kirin/dialects/py/rules/","title":"Index","text":""},{"location":"reference/kirin/dialects/py/rules/getitem/","title":"Getitem","text":""},{"location":"reference/kirin/dialects/py/stmts/","title":"Index","text":""},{"location":"reference/kirin/dialects/py/stmts/constprop/","title":"Constprop","text":""},{"location":"reference/kirin/dialects/py/stmts/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/dialects/py/stmts/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/py/stmts/lowering/","title":"Lowering","text":""},{"location":"reference/kirin/dialects/py/stmts/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/","title":"Index","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/assign/","title":"Assign","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/binop/","title":"Binop","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/boolean/","title":"Boolean","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/builtin/","title":"Builtin","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/cmp/","title":"Cmp","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/constant/","title":"Constant","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/getattr/","title":"Getattr","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/getitem/","title":"Getitem","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/list/","title":"List","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/range/","title":"Range","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/slice/","title":"Slice","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/tuple/","title":"Tuple","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/unary/","title":"Unary","text":""},{"location":"reference/kirin/dialects/py/types/","title":"Index","text":""},{"location":"reference/kirin/dialects/py/types/base/","title":"Base","text":""},{"location":"reference/kirin/dialects/py/types/base/#kirin.dialects.py.types.base.PyConst","title":"<code>PyConst</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PyType</code>, <code>Generic[Type]</code></p> <p>This will not appear in user-space. It is used to pass around constant values interprocedurally.</p> Source code in <code>src/kirin/dialects/py/types/elem.py</code> <pre><code>@dialect.register\n@dataclass(init=False)\nclass PyConst(PyType, Generic[Type]):\n    \"\"\"This will not appear in user-space. It is used to\n    pass around constant values interprocedurally.\n    \"\"\"\n\n    name = \"Const\"\n    data: Type\n    typ: PyType\n\n    def __init__(self, data: Type, typ: PyType | None = None):\n        self.data = data\n        if isinstance(typ, PyConst):\n            typ = widen_const(typ)\n\n        if typ is not None:\n            self.typ = typ\n        else:\n            self.typ = PyClass(type(data))\n\n    def is_equal(self, other: TypeAttribute) -&gt; bool:\n        return isinstance(other, PyConst) and self.data == other.data\n\n    def is_subseteq_PyConst(self, other: PyConst) -&gt; bool:\n        return self.is_equal(other)\n\n    def is_subseteq_fallback(self, other: TypeAttribute) -&gt; bool:\n        return self.typ.is_subseteq(other)\n\n    def __hash__(self) -&gt; int:\n        return hash(self.typ)\n\n    def __repr__(self) -&gt; str:\n        return f\"Const({self.data})\"\n\n    def print_impl(self, printer: Printer) -&gt; None:\n        printer.print_name(self, prefix=\"!\")\n        printer.plain_print(\"(\", self.data, \", \")\n        printer.print(self.typ)\n        printer.plain_print(\")\")\n</code></pre>"},{"location":"reference/kirin/dialects/py/types/base/#kirin.dialects.py.types.base.PyGeneric","title":"<code>PyGeneric</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PyType</code>, <code>Generic[Type]</code></p> Source code in <code>src/kirin/dialects/py/types/elem.py</code> <pre><code>@dialect.register\n@dataclass(init=False)\nclass PyGeneric(PyType, Generic[Type]):\n    name = \"generic\"\n    body: PyClass[Type]\n    vars: tuple[PyType, ...]\n    vararg: PyVararg | None = None\n    \"\"\"unknown type variables\n    \"\"\"\n\n    def __init__(self, body: type[Type] | PyClass[Type], *vars: PyType | PyVararg):\n        if isinstance(body, PyClass):\n            self.body = body\n        else:\n            self.body = PyClass(body)\n\n        self.vars, self.vararg = split_type_args(vars)\n\n    def is_subseteq_PyLiteral(self, other: PyLiteral) -&gt; bool:\n        return False\n\n    def is_subseteq_PyClass(self, other: PyClass) -&gt; bool:\n        return self.body.is_subseteq(other)\n\n    def is_subseteq_PyUnion(self, other: PyUnion) -&gt; bool:\n        return any(self.is_subseteq(a) for a in other.args)\n\n    def is_subseteq_PyTypeVar(self, other: PyTypeVar) -&gt; bool:\n        return self.is_subseteq(other.bound)\n\n    def is_subseteq_PyGeneric(self, other: PyGeneric):\n        if other.vararg is None:\n            return (\n                self.body.is_subseteq(other.body)\n                and len(self.vars) == len(other.vars)\n                and all(v.is_subseteq(o) for v, o in zip(self.vars, other.vars))\n            )\n        else:\n            return (\n                self.body.is_subseteq(other.body)\n                and len(self.vars) &gt;= len(other.vars)\n                and all(v.is_subseteq(o) for v, o in zip(self.vars, other.vars))\n                and all(\n                    v.is_subseteq(other.vararg.typ)\n                    for v in self.vars[len(other.vars) :]\n                )\n                and (\n                    self.vararg is None or self.vararg.typ.is_subseteq(other.vararg.typ)\n                )\n            )\n\n    def __hash__(self) -&gt; int:\n        return hash((PyGeneric, self.body, self.vars, self.vararg))\n\n    def __repr__(self) -&gt; str:\n        from kirin.print import Printer\n\n        return self.print_str(Printer()).splitlines()[0]\n\n    def print_impl(self, printer: Printer) -&gt; None:\n        printer.print(self.body)\n        printer.plain_print(\"[\")\n        if self.vars:\n            printer.print_seq(self.vars)\n        if self.vararg is not None:\n            if self.vars:\n                printer.plain_print(\", \")\n            printer.print(self.vararg.typ)\n            printer.plain_print(\", ...\")\n        printer.plain_print(\"]\")\n\n    def __getitem__(\n        self, typ: PyTypeVarValue | tuple[PyTypeVarValue, ...]\n    ) -&gt; PyGeneric:\n        return self.where(typ)\n\n    def where(self, typ: PyTypeVarValue | tuple[PyTypeVarValue, ...]) -&gt; PyGeneric:\n        if isinstance(typ, tuple):\n            typs = typ\n        else:\n            typs = (typ,)\n\n        args, vararg = split_type_args(typs)\n        if self.vararg is None and vararg is None:\n            assert len(args) &lt;= len(\n                self.vars\n            ), \"Number of type arguments does not match\"\n            if all(v.is_subseteq(bound) for v, bound in zip(args, self.vars)):\n                return PyGeneric(self.body, *args, *self.vars[len(args) :])\n            else:\n                raise TypeError(\"Type arguments do not match\")\n        elif self.vararg is not None and vararg is None:\n            assert len(args) &gt;= len(\n                self.vars\n            ), \"Number of type arguments does not match\"\n            if all(v.is_subseteq(bound) for v, bound in zip(args, self.vars)) and all(\n                v.is_subseteq(self.vararg.typ) for v in args[len(self.vars) :]\n            ):\n                return PyGeneric(self.body, *args)\n        elif self.vararg is not None and vararg is not None:\n            if len(args) &lt; len(self.vars):\n                if (\n                    all(v.is_subseteq(bound) for v, bound in zip(args, self.vars))\n                    and all(\n                        vararg.typ.is_subseteq(bound)\n                        for bound in self.vars[len(args) :]\n                    )\n                    and vararg.typ.is_subseteq(self.vararg.typ)\n                ):\n                    return PyGeneric(self.body, *args, vararg)\n            else:\n                if (\n                    all(v.is_subseteq(bound) for v, bound in zip(args, self.vars))\n                    and all(v.is_subseteq(vararg.typ) for v in args[len(self.vars) :])\n                    and vararg.typ.is_subseteq(self.vararg.typ)\n                ):\n                    return PyGeneric(self.body, *args, vararg)\n        raise TypeError(\"Type arguments do not match\")\n</code></pre>"},{"location":"reference/kirin/dialects/py/types/base/#kirin.dialects.py.types.base.PyGeneric.vararg","title":"<code>vararg: PyVararg | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>unknown type variables</p>"},{"location":"reference/kirin/dialects/py/types/builtin/","title":"Builtin","text":"<p>some convenient singleton wrapper for python.</p> <p>They should be equivalent directly construct PyClass.</p>"},{"location":"reference/kirin/dialects/py/types/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/dialects/py/types/elem/","title":"Elem","text":""},{"location":"reference/kirin/dialects/py/types/elem/#kirin.dialects.py.types.elem.PyConst","title":"<code>PyConst</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PyType</code>, <code>Generic[Type]</code></p> <p>This will not appear in user-space. It is used to pass around constant values interprocedurally.</p> Source code in <code>src/kirin/dialects/py/types/elem.py</code> <pre><code>@dialect.register\n@dataclass(init=False)\nclass PyConst(PyType, Generic[Type]):\n    \"\"\"This will not appear in user-space. It is used to\n    pass around constant values interprocedurally.\n    \"\"\"\n\n    name = \"Const\"\n    data: Type\n    typ: PyType\n\n    def __init__(self, data: Type, typ: PyType | None = None):\n        self.data = data\n        if isinstance(typ, PyConst):\n            typ = widen_const(typ)\n\n        if typ is not None:\n            self.typ = typ\n        else:\n            self.typ = PyClass(type(data))\n\n    def is_equal(self, other: TypeAttribute) -&gt; bool:\n        return isinstance(other, PyConst) and self.data == other.data\n\n    def is_subseteq_PyConst(self, other: PyConst) -&gt; bool:\n        return self.is_equal(other)\n\n    def is_subseteq_fallback(self, other: TypeAttribute) -&gt; bool:\n        return self.typ.is_subseteq(other)\n\n    def __hash__(self) -&gt; int:\n        return hash(self.typ)\n\n    def __repr__(self) -&gt; str:\n        return f\"Const({self.data})\"\n\n    def print_impl(self, printer: Printer) -&gt; None:\n        printer.print_name(self, prefix=\"!\")\n        printer.plain_print(\"(\", self.data, \", \")\n        printer.print(self.typ)\n        printer.plain_print(\")\")\n</code></pre>"},{"location":"reference/kirin/dialects/py/types/elem/#kirin.dialects.py.types.elem.PyGeneric","title":"<code>PyGeneric</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PyType</code>, <code>Generic[Type]</code></p> Source code in <code>src/kirin/dialects/py/types/elem.py</code> <pre><code>@dialect.register\n@dataclass(init=False)\nclass PyGeneric(PyType, Generic[Type]):\n    name = \"generic\"\n    body: PyClass[Type]\n    vars: tuple[PyType, ...]\n    vararg: PyVararg | None = None\n    \"\"\"unknown type variables\n    \"\"\"\n\n    def __init__(self, body: type[Type] | PyClass[Type], *vars: PyType | PyVararg):\n        if isinstance(body, PyClass):\n            self.body = body\n        else:\n            self.body = PyClass(body)\n\n        self.vars, self.vararg = split_type_args(vars)\n\n    def is_subseteq_PyLiteral(self, other: PyLiteral) -&gt; bool:\n        return False\n\n    def is_subseteq_PyClass(self, other: PyClass) -&gt; bool:\n        return self.body.is_subseteq(other)\n\n    def is_subseteq_PyUnion(self, other: PyUnion) -&gt; bool:\n        return any(self.is_subseteq(a) for a in other.args)\n\n    def is_subseteq_PyTypeVar(self, other: PyTypeVar) -&gt; bool:\n        return self.is_subseteq(other.bound)\n\n    def is_subseteq_PyGeneric(self, other: PyGeneric):\n        if other.vararg is None:\n            return (\n                self.body.is_subseteq(other.body)\n                and len(self.vars) == len(other.vars)\n                and all(v.is_subseteq(o) for v, o in zip(self.vars, other.vars))\n            )\n        else:\n            return (\n                self.body.is_subseteq(other.body)\n                and len(self.vars) &gt;= len(other.vars)\n                and all(v.is_subseteq(o) for v, o in zip(self.vars, other.vars))\n                and all(\n                    v.is_subseteq(other.vararg.typ)\n                    for v in self.vars[len(other.vars) :]\n                )\n                and (\n                    self.vararg is None or self.vararg.typ.is_subseteq(other.vararg.typ)\n                )\n            )\n\n    def __hash__(self) -&gt; int:\n        return hash((PyGeneric, self.body, self.vars, self.vararg))\n\n    def __repr__(self) -&gt; str:\n        from kirin.print import Printer\n\n        return self.print_str(Printer()).splitlines()[0]\n\n    def print_impl(self, printer: Printer) -&gt; None:\n        printer.print(self.body)\n        printer.plain_print(\"[\")\n        if self.vars:\n            printer.print_seq(self.vars)\n        if self.vararg is not None:\n            if self.vars:\n                printer.plain_print(\", \")\n            printer.print(self.vararg.typ)\n            printer.plain_print(\", ...\")\n        printer.plain_print(\"]\")\n\n    def __getitem__(\n        self, typ: PyTypeVarValue | tuple[PyTypeVarValue, ...]\n    ) -&gt; PyGeneric:\n        return self.where(typ)\n\n    def where(self, typ: PyTypeVarValue | tuple[PyTypeVarValue, ...]) -&gt; PyGeneric:\n        if isinstance(typ, tuple):\n            typs = typ\n        else:\n            typs = (typ,)\n\n        args, vararg = split_type_args(typs)\n        if self.vararg is None and vararg is None:\n            assert len(args) &lt;= len(\n                self.vars\n            ), \"Number of type arguments does not match\"\n            if all(v.is_subseteq(bound) for v, bound in zip(args, self.vars)):\n                return PyGeneric(self.body, *args, *self.vars[len(args) :])\n            else:\n                raise TypeError(\"Type arguments do not match\")\n        elif self.vararg is not None and vararg is None:\n            assert len(args) &gt;= len(\n                self.vars\n            ), \"Number of type arguments does not match\"\n            if all(v.is_subseteq(bound) for v, bound in zip(args, self.vars)) and all(\n                v.is_subseteq(self.vararg.typ) for v in args[len(self.vars) :]\n            ):\n                return PyGeneric(self.body, *args)\n        elif self.vararg is not None and vararg is not None:\n            if len(args) &lt; len(self.vars):\n                if (\n                    all(v.is_subseteq(bound) for v, bound in zip(args, self.vars))\n                    and all(\n                        vararg.typ.is_subseteq(bound)\n                        for bound in self.vars[len(args) :]\n                    )\n                    and vararg.typ.is_subseteq(self.vararg.typ)\n                ):\n                    return PyGeneric(self.body, *args, vararg)\n            else:\n                if (\n                    all(v.is_subseteq(bound) for v, bound in zip(args, self.vars))\n                    and all(v.is_subseteq(vararg.typ) for v in args[len(self.vars) :])\n                    and vararg.typ.is_subseteq(self.vararg.typ)\n                ):\n                    return PyGeneric(self.body, *args, vararg)\n        raise TypeError(\"Type arguments do not match\")\n</code></pre>"},{"location":"reference/kirin/dialects/py/types/elem/#kirin.dialects.py.types.elem.PyGeneric.vararg","title":"<code>vararg: PyVararg | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>unknown type variables</p>"},{"location":"reference/kirin/dialects/py/types/emit/","title":"Emit","text":""},{"location":"reference/kirin/interp/","title":"Index","text":""},{"location":"reference/kirin/interp/abstract/","title":"Abstract","text":""},{"location":"reference/kirin/interp/base/","title":"Base","text":""},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter","title":"<code>BaseInterpreter</code>","text":"<p>               Bases: <code>ABC</code>, <code>Generic[FrameType, ValueType]</code></p> <p>A base class for interpreters.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>class BaseInterpreter(ABC, Generic[FrameType, ValueType], metaclass=InterpreterMeta):\n    \"\"\"A base class for interpreters.\"\"\"\n\n    keys: ClassVar[list[str]]\n    \"\"\"The name of the interpreter to select from dialects by order.\n    \"\"\"\n    dialects: DialectGroup\n    \"\"\"The dialects to interpret.\"\"\"\n\n    registry: dict[\"Signature\", \"StatementImpl\"] = field(init=False, repr=False)\n    \"\"\"A mapping of statement signature to their implementation.\n    \"\"\"\n    fallbacks: dict[Dialect, \"StatementImpl\"] = field(init=False, repr=False)\n    state: InterpreterState[FrameType] = field(init=False, repr=False)\n    \"\"\"The interpreter state.\n    \"\"\"\n    fuel: int | None = field(default=None, init=False, kw_only=True)\n    \"\"\"The fuel limit.\n    \"\"\"\n    max_depth: int = field(default=128, init=False, kw_only=True)\n    max_python_recursion_depth: int = field(default=8192, init=False, kw_only=True)\n\n    def __init__(\n        self,\n        dialects: DialectGroup | Iterable[Dialect],\n        *,\n        fuel: int | None = None,\n        max_depth: int = 128,\n        max_python_recursion_depth: int = 8192,\n    ):\n        if not isinstance(dialects, DialectGroup):\n            dialects = DialectGroup(dialects)\n        self.dialects = dialects\n\n        self.registry, self.fallbacks = self.dialects.registry.interpreter(\n            keys=self.keys\n        )\n        self.state = InterpreterState()\n        self.fuel = fuel\n        self.max_depth = max_depth\n        self.max_python_recursion_depth = max_python_recursion_depth\n\n    @abstractmethod\n    def new_method_frame(self, mt: Method) -&gt; FrameType:\n        \"\"\"Create a new frame for the given method.\"\"\"\n        ...\n\n    def eval(\n        self,\n        mt: Method,\n        args: tuple[ValueType, ...],\n        kwargs: dict[str, ValueType] | None = None,\n    ) -&gt; InterpResult[ValueType]:\n        \"\"\"Evaluate a method.\"\"\"\n        current_recursion_limit = sys.getrecursionlimit()\n        sys.setrecursionlimit(self.max_python_recursion_depth)\n        interface = mt.code.get_trait(traits.CallableStmtInterface)\n        if interface is None:\n            raise InterpreterError(f\"compiled method {mt} is not callable\")\n\n        if len(self.state.frames) &gt;= self.max_depth:\n            raise InterpreterError(\"maximum recursion depth exceeded\")\n\n        self.state.push_frame(self.new_method_frame(mt))\n        body = interface.get_callable_region(mt.code)\n        # NOTE: #self# is not user input so it is not\n        # in the args, +1 is for self\n        args = self.get_args(mt.arg_names[len(args) + 1 :], args, kwargs)\n        # NOTE: this should be checked via static validation, we just assume\n        # number of args is correct here\n        # NOTE: Method is used as if it is a singleton type, but it is not recognized by mypy\n        results = self.run_method_region(mt, body, args)\n        self.postprocess_frame(self.state.pop_frame())\n        sys.setrecursionlimit(current_recursion_limit)\n        return results\n\n    @abstractmethod\n    def run_method_region(\n        self, mt: Method, body: Region, args: tuple[ValueType, ...]\n    ) -&gt; InterpResult[ValueType]: ...\n\n    def postprocess_frame(self, frame: FrameType) -&gt; None:\n        \"\"\"Postprocess a frame after it is popped from the stack. This is\n        called after a method is evaluated and the frame is popped. Default\n        implementation does nothing.\n        \"\"\"\n        return\n\n    @staticmethod\n    def get_args(\n        left_arg_names, args: tuple[ValueType, ...], kwargs: dict[str, ValueType] | None\n    ) -&gt; tuple[ValueType, ...]:\n        if kwargs:\n            # NOTE: #self# is not user input so it is not\n            # in the args, +1 is for self\n            for name in left_arg_names:\n                args += (kwargs[name],)\n        return args\n\n    @staticmethod\n    def permute_values(\n        mt: Method, values: tuple[ValueType, ...], kwarg_names: tuple[str, ...]\n    ) -&gt; tuple[ValueType, ...]:\n        \"\"\"Permute the arguments according to the method signature and\n        the given keyword arguments, where the keyword argument names\n        refer to the last n arguments in the values tuple.\n\n        Args\n\n        mt: the method\n        values: the values tuple (should not contain method itself)\n        kwarg_names: the keyword argument names\n        \"\"\"\n        n_total = len(values)\n        if kwarg_names:\n            kwargs = dict(zip(kwarg_names, values[n_total - len(kwarg_names) :]))\n        else:\n            kwargs = None\n\n        positionals = values[: n_total - len(kwarg_names)]\n        args = BaseInterpreter.get_args(\n            mt.arg_names[len(positionals) + 1 :], positionals, kwargs\n        )\n        return args\n\n    def run_stmt(self, stmt: Statement, args: tuple) -&gt; Result[ValueType]:\n        \"run a statement within the current frame\"\n        if self.state.frames:\n            # NOTE: if run_stmt is called directly,\n            # there is no frame being pushed, we only\n            # push a frame when we call a method\n            self.state.current_frame().set_stmt(stmt)\n        return self.eval_stmt(stmt, args)\n\n    def eval_stmt(self, stmt: Statement, args: tuple) -&gt; Result[ValueType]:\n        \"simply evaluate a statement\"\n        sig = self.build_signature(stmt, args)\n        if sig in self.registry:\n            return self.registry[sig](self, stmt, args)\n        elif stmt.__class__ in self.registry:\n            return self.registry[stmt.__class__](self, stmt, args)\n        elif stmt.dialect:\n            return self.fallbacks[stmt.dialect](self, stmt, args)\n        raise ValueError(f\"no dialect for stmt {stmt}\")\n\n    def build_signature(self, stmt: Statement, args: tuple) -&gt; \"Signature\":\n        \"\"\"build signature for querying the statement implementation.\"\"\"\n        return (stmt.__class__, tuple(arg.type for arg in stmt.args))\n\n    @abstractmethod\n    def run_ssacfg_region(\n        self, region: Region, args: tuple[ValueType, ...]\n    ) -&gt; InterpResult[ValueType]: ...\n\n    class FuelResult(Enum):\n        Stop = 0\n        Continue = 1\n\n    def consume_fuel(self) -&gt; FuelResult:\n        if self.fuel is None:  # no fuel limit\n            return self.FuelResult.Continue\n\n        if self.fuel == 0:\n            return self.FuelResult.Stop\n        else:\n            self.fuel -= 1\n            return self.FuelResult.Continue\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.dialects","title":"<code>dialects: DialectGroup = dialects</code>  <code>instance-attribute</code>","text":"<p>The dialects to interpret.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.fuel","title":"<code>fuel: int | None = fuel</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The fuel limit.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.keys","title":"<code>keys: list[str]</code>  <code>class-attribute</code>","text":"<p>The name of the interpreter to select from dialects by order.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.registry","title":"<code>registry: dict[Signature, StatementImpl] = field(init=False, repr=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A mapping of statement signature to their implementation.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.state","title":"<code>state: InterpreterState[FrameType] = InterpreterState()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The interpreter state.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.build_signature","title":"<code>build_signature(stmt, args)</code>","text":"<p>build signature for querying the statement implementation.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def build_signature(self, stmt: Statement, args: tuple) -&gt; \"Signature\":\n    \"\"\"build signature for querying the statement implementation.\"\"\"\n    return (stmt.__class__, tuple(arg.type for arg in stmt.args))\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.eval","title":"<code>eval(mt, args, kwargs=None)</code>","text":"<p>Evaluate a method.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def eval(\n    self,\n    mt: Method,\n    args: tuple[ValueType, ...],\n    kwargs: dict[str, ValueType] | None = None,\n) -&gt; InterpResult[ValueType]:\n    \"\"\"Evaluate a method.\"\"\"\n    current_recursion_limit = sys.getrecursionlimit()\n    sys.setrecursionlimit(self.max_python_recursion_depth)\n    interface = mt.code.get_trait(traits.CallableStmtInterface)\n    if interface is None:\n        raise InterpreterError(f\"compiled method {mt} is not callable\")\n\n    if len(self.state.frames) &gt;= self.max_depth:\n        raise InterpreterError(\"maximum recursion depth exceeded\")\n\n    self.state.push_frame(self.new_method_frame(mt))\n    body = interface.get_callable_region(mt.code)\n    # NOTE: #self# is not user input so it is not\n    # in the args, +1 is for self\n    args = self.get_args(mt.arg_names[len(args) + 1 :], args, kwargs)\n    # NOTE: this should be checked via static validation, we just assume\n    # number of args is correct here\n    # NOTE: Method is used as if it is a singleton type, but it is not recognized by mypy\n    results = self.run_method_region(mt, body, args)\n    self.postprocess_frame(self.state.pop_frame())\n    sys.setrecursionlimit(current_recursion_limit)\n    return results\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.eval_stmt","title":"<code>eval_stmt(stmt, args)</code>","text":"<p>simply evaluate a statement</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def eval_stmt(self, stmt: Statement, args: tuple) -&gt; Result[ValueType]:\n    \"simply evaluate a statement\"\n    sig = self.build_signature(stmt, args)\n    if sig in self.registry:\n        return self.registry[sig](self, stmt, args)\n    elif stmt.__class__ in self.registry:\n        return self.registry[stmt.__class__](self, stmt, args)\n    elif stmt.dialect:\n        return self.fallbacks[stmt.dialect](self, stmt, args)\n    raise ValueError(f\"no dialect for stmt {stmt}\")\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.new_method_frame","title":"<code>new_method_frame(mt)</code>  <code>abstractmethod</code>","text":"<p>Create a new frame for the given method.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>@abstractmethod\ndef new_method_frame(self, mt: Method) -&gt; FrameType:\n    \"\"\"Create a new frame for the given method.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.permute_values","title":"<code>permute_values(mt, values, kwarg_names)</code>  <code>staticmethod</code>","text":"<p>Permute the arguments according to the method signature and the given keyword arguments, where the keyword argument names refer to the last n arguments in the values tuple.</p> <p>Args</p> <p>mt: the method values: the values tuple (should not contain method itself) kwarg_names: the keyword argument names</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>@staticmethod\ndef permute_values(\n    mt: Method, values: tuple[ValueType, ...], kwarg_names: tuple[str, ...]\n) -&gt; tuple[ValueType, ...]:\n    \"\"\"Permute the arguments according to the method signature and\n    the given keyword arguments, where the keyword argument names\n    refer to the last n arguments in the values tuple.\n\n    Args\n\n    mt: the method\n    values: the values tuple (should not contain method itself)\n    kwarg_names: the keyword argument names\n    \"\"\"\n    n_total = len(values)\n    if kwarg_names:\n        kwargs = dict(zip(kwarg_names, values[n_total - len(kwarg_names) :]))\n    else:\n        kwargs = None\n\n    positionals = values[: n_total - len(kwarg_names)]\n    args = BaseInterpreter.get_args(\n        mt.arg_names[len(positionals) + 1 :], positionals, kwargs\n    )\n    return args\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.postprocess_frame","title":"<code>postprocess_frame(frame)</code>","text":"<p>Postprocess a frame after it is popped from the stack. This is called after a method is evaluated and the frame is popped. Default implementation does nothing.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def postprocess_frame(self, frame: FrameType) -&gt; None:\n    \"\"\"Postprocess a frame after it is popped from the stack. This is\n    called after a method is evaluated and the frame is popped. Default\n    implementation does nothing.\n    \"\"\"\n    return\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.run_stmt","title":"<code>run_stmt(stmt, args)</code>","text":"<p>run a statement within the current frame</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def run_stmt(self, stmt: Statement, args: tuple) -&gt; Result[ValueType]:\n    \"run a statement within the current frame\"\n    if self.state.frames:\n        # NOTE: if run_stmt is called directly,\n        # there is no frame being pushed, we only\n        # push a frame when we call a method\n        self.state.current_frame().set_stmt(stmt)\n    return self.eval_stmt(stmt, args)\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.InterpResult","title":"<code>InterpResult</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[ValueType]</code></p> <p>This is used by the interpreter eval only.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>@dataclass(init=False)\nclass InterpResult(Generic[ValueType]):\n    \"\"\"This is used by the interpreter eval only.\"\"\"\n\n    value: ValueType | NoReturn\n    err: Err[ValueType] | None = None\n\n    def __init__(self, result: ValueType | NoReturn | Err):\n        if isinstance(result, Err):\n            self.err = result\n            self.value = NoReturn()\n        else:\n            self.value = result\n\n    def expect(self) -&gt; ValueType:\n        if self.err is not None:\n            self.err.print_stack()\n            return self.err.panic()\n        elif isinstance(self.value, NoReturn):\n            raise InterpreterError(\"no return value\")\n        else:\n            return self.value\n\n    def to_result(self) -&gt; Result[ValueType]:\n        if self.err is not None:\n            return self.err\n        elif isinstance(self.value, NoReturn):\n            return NoReturn()\n        else:\n            return ResultValue(self.value)\n</code></pre>"},{"location":"reference/kirin/interp/concrete/","title":"Concrete","text":""},{"location":"reference/kirin/interp/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/interp/frame/","title":"Frame","text":""},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame","title":"<code>Frame</code>  <code>dataclass</code>","text":"<p>               Bases: <code>FrameABC[ValueType]</code></p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>@dataclass\nclass Frame(FrameABC[ValueType]):\n    method: Method\n    \"\"\"method being interpreted.\n    \"\"\"\n    lino: int = 0\n    stmt: Statement | None = None\n    \"\"\"statement being interpreted.\n    \"\"\"\n\n    globals: dict[str, Any] = field(default_factory=dict)\n    \"\"\"Global variables this frame has access to.\n    \"\"\"\n\n    # NOTE: we are sharing the same frame within blocks\n    # this is because we are validating e.g SSA value pointing\n    # to other blocks separately. This avoids the need\n    # to have a separate frame for each block.\n    entries: dict[SSAValue, ValueType] = field(default_factory=dict)\n    \"\"\"SSA values and their corresponding values.\n    \"\"\"\n\n    @classmethod\n    def from_method(cls, method: Method) -&gt; Self:\n        return cls(method=method)\n\n    def get_values(self, keys: Iterable[SSAValue]) -&gt; tuple:\n        return tuple(self.entries[key] for key in keys)\n\n    def set_values(self, keys: Iterable[SSAValue], values: Iterable[ValueType]) -&gt; None:\n        for key, value in zip(keys, values):\n            self.entries[key] = value\n\n    def set_stmt(self, stmt: Statement) -&gt; Self:\n        self.stmt = stmt\n        return self\n</code></pre>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame.entries","title":"<code>entries: dict[SSAValue, ValueType] = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>SSA values and their corresponding values.</p>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame.globals","title":"<code>globals: dict[str, Any] = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Global variables this frame has access to.</p>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame.method","title":"<code>method: Method</code>  <code>instance-attribute</code>","text":"<p>method being interpreted.</p>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame.stmt","title":"<code>stmt: Statement | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>statement being interpreted.</p>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.FrameABC","title":"<code>FrameABC</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code>, <code>Generic[ValueType]</code></p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>@dataclass\nclass FrameABC(ABC, Generic[ValueType]):\n\n    @classmethod\n    @abstractmethod\n    def from_method(cls, method: Method) -&gt; Self:\n        \"\"\"Create a new frame for the given method.\"\"\"\n        ...\n\n    @abstractmethod\n    def get_values(self, keys: Iterable[SSAValue]) -&gt; tuple:\n        \"\"\"Get the values of the given `SSAValue` keys.\"\"\"\n        ...\n\n    @abstractmethod\n    def set_values(self, keys: Iterable[SSAValue], values: Iterable[ValueType]) -&gt; None:\n        \"\"\"Set the values of the given `SSAValue` keys.\"\"\"\n        ...\n\n    @abstractmethod\n    def set_stmt(self, stmt: Statement) -&gt; Self:\n        \"\"\"Set the current statement.\"\"\"\n        ...\n</code></pre>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.FrameABC.from_method","title":"<code>from_method(method)</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Create a new frame for the given method.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>@classmethod\n@abstractmethod\ndef from_method(cls, method: Method) -&gt; Self:\n    \"\"\"Create a new frame for the given method.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.FrameABC.get_values","title":"<code>get_values(keys)</code>  <code>abstractmethod</code>","text":"<p>Get the values of the given <code>SSAValue</code> keys.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>@abstractmethod\ndef get_values(self, keys: Iterable[SSAValue]) -&gt; tuple:\n    \"\"\"Get the values of the given `SSAValue` keys.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.FrameABC.set_stmt","title":"<code>set_stmt(stmt)</code>  <code>abstractmethod</code>","text":"<p>Set the current statement.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>@abstractmethod\ndef set_stmt(self, stmt: Statement) -&gt; Self:\n    \"\"\"Set the current statement.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.FrameABC.set_values","title":"<code>set_values(keys, values)</code>  <code>abstractmethod</code>","text":"<p>Set the values of the given <code>SSAValue</code> keys.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>@abstractmethod\ndef set_values(self, keys: Iterable[SSAValue], values: Iterable[ValueType]) -&gt; None:\n    \"\"\"Set the values of the given `SSAValue` keys.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/interp/impl/","title":"Impl","text":""},{"location":"reference/kirin/interp/state/","title":"State","text":""},{"location":"reference/kirin/interp/value/","title":"Value","text":""},{"location":"reference/kirin/ir/","title":"Index","text":""},{"location":"reference/kirin/ir/attrs/","title":"Attrs","text":""},{"location":"reference/kirin/ir/attrs/#kirin.ir.attrs.AnyType","title":"<code>AnyType</code>  <code>dataclass</code>","text":"<p>               Bases: <code>TypeAttribute</code></p> <p>Top of any type lattice.</p> Source code in <code>src/kirin/ir/attrs.py</code> <pre><code>class AnyType(TypeAttribute, metaclass=SingletonTypeMeta):\n    \"\"\"Top of any type lattice.\"\"\"\n\n    name = \"Any\"\n\n    def join(self: TypeAttribute, other: TypeAttribute) -&gt; TypeAttribute:\n        return self\n\n    def meet(self: TypeAttribute, other: TypeAttribute) -&gt; TypeAttribute:\n        return other\n\n    def is_subseteq(self, other: TypeAttribute) -&gt; bool:\n        return isinstance(other, AnyType)  # allow subclassing\n\n    def is_equal(self, other: TypeAttribute) -&gt; bool:\n        return other.is_top()\n\n    def __hash__(self):\n        return id(self)\n</code></pre>"},{"location":"reference/kirin/ir/attrs/#kirin.ir.attrs.BottomType","title":"<code>BottomType</code>  <code>dataclass</code>","text":"<p>               Bases: <code>TypeAttribute</code></p> <p>Bottom of any type lattice.</p> Source code in <code>src/kirin/ir/attrs.py</code> <pre><code>class BottomType(TypeAttribute, metaclass=SingletonTypeMeta):\n    \"\"\"Bottom of any type lattice.\"\"\"\n\n    name = \"Bottom\"\n\n    def join(self: TypeAttribute, other: TypeAttribute) -&gt; TypeAttribute:\n        return other\n\n    def meet(self: TypeAttribute, other: TypeAttribute) -&gt; TypeAttribute:\n        return self\n\n    def is_equal(self, other: TypeAttribute) -&gt; bool:\n        return other.is_bottom()\n\n    def is_subseteq(self, other: TypeAttribute) -&gt; bool:\n        return True\n\n    def __hash__(self):\n        return id(self)\n</code></pre>"},{"location":"reference/kirin/ir/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/ir/group/","title":"Group","text":""},{"location":"reference/kirin/ir/group/#kirin.ir.group.Registry","title":"<code>Registry</code>  <code>dataclass</code>","text":"Source code in <code>src/kirin/ir/group.py</code> <pre><code>@dataclass\nclass Registry:\n    parent: \"DialectGroup\"\n\n    def lowering(self, keys: Iterable[str]):\n        ret: dict[str, \"FromPythonAST\"] = {}\n        from_ast = None\n        for dialect in self.parent.data:\n            for key in keys:\n                if key in dialect.lowering:\n                    from_ast = dialect.lowering[key]\n                    break\n\n            if from_ast is None:\n                msg = \",\".join(keys)\n                raise KeyError(f\"Lowering not found for {msg}\")\n\n            for name in from_ast.names:\n                if name in ret:\n                    raise KeyError(f\"Lowering {name} already exists\")\n\n                ret[name] = from_ast\n        return ret\n\n    def interpreter(self, keys: Iterable[str]):\n        \"\"\"select the dialect interpreter for the given key.\n\n        ### Args\n        - `keys: Iterable[str]` the keys to search for in the dialects\n\n        ### Returns\n        - `dict[\"Signature\", \"ImplFunction\"]` a map of dialects to their interpreters\n        \"\"\"\n        from kirin.interp.impl import MethodImpl\n\n        ret: dict[\"Signature\", \"InterpImpl\"] = {}\n        fallback: dict[\"Dialect\", \"InterpImpl\"] = {}\n        for dialect in self.parent.data:\n            dialect_interp = None\n            for key in keys:\n                if key in dialect.interps:\n                    dialect_interp = dialect.interps[key]\n                    if dialect not in fallback:  # use the first fallback\n                        fallback[dialect] = dialect_interp.fallback\n\n                    for sig, func in dialect_interp.table.items():\n                        if sig not in ret:\n                            ret[sig] = MethodImpl(dialect_interp, func)\n\n            if dialect not in fallback:\n                msg = \",\".join(keys)\n                raise KeyError(f\"Interpreter of {dialect.name} not found for {msg}\")\n        return ret, fallback\n\n    def codegen(self, keys: Iterable[str]):\n        from kirin.codegen.impl import MethodImpl\n\n        ret: dict[\"CodegenSignature\", \"CodegenImpl\"] = {}\n        for dialect in self.parent.data:\n            dialect_codegen = None\n            for key in keys:\n                if key in dialect.codegen:\n                    dialect_codegen = dialect.codegen[key]\n                    break\n\n            # not found, just skip\n            if dialect_codegen is None:\n                continue\n\n            for key, func in dialect_codegen.table.items():\n                ret[key] = MethodImpl(dialect_codegen, func)\n        return ret\n</code></pre>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.Registry.interpreter","title":"<code>interpreter(keys)</code>","text":"<p>select the dialect interpreter for the given key.</p>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.Registry.interpreter--args","title":"Args","text":"<ul> <li><code>keys: Iterable[str]</code> the keys to search for in the dialects</li> </ul>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.Registry.interpreter--returns","title":"Returns","text":"<ul> <li><code>dict[\"Signature\", \"ImplFunction\"]</code> a map of dialects to their interpreters</li> </ul> Source code in <code>src/kirin/ir/group.py</code> <pre><code>def interpreter(self, keys: Iterable[str]):\n    \"\"\"select the dialect interpreter for the given key.\n\n    ### Args\n    - `keys: Iterable[str]` the keys to search for in the dialects\n\n    ### Returns\n    - `dict[\"Signature\", \"ImplFunction\"]` a map of dialects to their interpreters\n    \"\"\"\n    from kirin.interp.impl import MethodImpl\n\n    ret: dict[\"Signature\", \"InterpImpl\"] = {}\n    fallback: dict[\"Dialect\", \"InterpImpl\"] = {}\n    for dialect in self.parent.data:\n        dialect_interp = None\n        for key in keys:\n            if key in dialect.interps:\n                dialect_interp = dialect.interps[key]\n                if dialect not in fallback:  # use the first fallback\n                    fallback[dialect] = dialect_interp.fallback\n\n                for sig, func in dialect_interp.table.items():\n                    if sig not in ret:\n                        ret[sig] = MethodImpl(dialect_interp, func)\n\n        if dialect not in fallback:\n            msg = \",\".join(keys)\n            raise KeyError(f\"Interpreter of {dialect.name} not found for {msg}\")\n    return ret, fallback\n</code></pre>"},{"location":"reference/kirin/ir/method/","title":"Method","text":""},{"location":"reference/kirin/ir/method/#kirin.ir.method.Method","title":"<code>Method</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Printable</code>, <code>Generic[Param, RetType]</code></p> Source code in <code>src/kirin/ir/method.py</code> <pre><code>@dataclass\nclass Method(Printable, Generic[Param, RetType]):\n    mod: ModuleType | None  # ref\n    py_func: Callable[Param, RetType] | None  # ref\n    sym_name: str | None\n    arg_names: list[str]\n    dialects: \"DialectGroup\"  # own\n    code: Statement  # own, the corresponding IR, a func.func usually\n    # values contained if closure\n    fields: tuple = field(default_factory=tuple)  # own\n    file: str = \"\"\n    lineno: list[tuple[int, int]] = field(default_factory=list)\n    \"\"\"(&lt;line&gt;, &lt;col&gt;) at the start of the statement call.\n    \"\"\"\n    backedges: list[\"Method\"] = field(default_factory=list)  # own\n    return_type: TypeAttribute | None = None\n    inferred: bool = False\n    \"\"\"if typeinfer has been run on this method\n    \"\"\"\n    verified: bool = False\n    \"\"\"if `code.verify` has been run on this method\n    \"\"\"\n\n    def __call__(self, *args: Param.args, **kwargs: Param.kwargs) -&gt; RetType:\n        from kirin.interp.concrete import Interpreter\n\n        if len(args) + len(kwargs) != len(self.arg_names) - 1:\n            raise InterpreterError(\"Incorrect number of arguments\")\n        # NOTE: multi-return values will be wrapped in a tuple for Python\n        return Interpreter(self.dialects).eval(self, args=args, kwargs=kwargs).expect()\n\n    @property\n    def args(self):\n        return tuple(arg for arg in self.callable_region.blocks[0].args[1:])\n\n    @property\n    def arg_types(self):\n        return tuple(arg.type for arg in self.args)\n\n    @property\n    def callable_region(self):\n        trait = self.code.get_trait(CallableStmtInterface)\n        if trait is None:\n            raise ValueError(\"Method body must implement CallableStmtInterface\")\n        return trait.get_callable_region(self.code)\n\n    def __repr__(self) -&gt; str:\n        return f'Method(\"{self.sym_name}\")'\n\n    def print_impl(self, printer: Printer) -&gt; None:\n        return printer.print(self.code)\n\n    def verify(self) -&gt; None:\n        \"\"\"verify the method body.\"\"\"\n        try:\n            self.code.verify()\n        except VerificationError as e:\n            msg = f'File \"{self.file}\"'\n            if isinstance(e.node, Statement):\n                if e.node.source:\n                    msg += f\", line {e.node.source.lineno}\"\n                msg += f\", in {e.node.name}\"\n\n            msg += f\":\\n    Verification failed for {self.sym_name}: {e.args[0]}\"\n            raise Exception(msg) from e\n        self.verified = True\n        return\n</code></pre>"},{"location":"reference/kirin/ir/method/#kirin.ir.method.Method.inferred","title":"<code>inferred: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>if typeinfer has been run on this method</p>"},{"location":"reference/kirin/ir/method/#kirin.ir.method.Method.lineno","title":"<code>lineno: list[tuple[int, int]] = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>(, ) at the start of the statement call."},{"location":"reference/kirin/ir/method/#kirin.ir.method.Method.verified","title":"<code>verified: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>if <code>code.verify</code> has been run on this method</p>"},{"location":"reference/kirin/ir/method/#kirin.ir.method.Method.verify","title":"<code>verify()</code>","text":"<p>verify the method body.</p> Source code in <code>src/kirin/ir/method.py</code> <pre><code>def verify(self) -&gt; None:\n    \"\"\"verify the method body.\"\"\"\n    try:\n        self.code.verify()\n    except VerificationError as e:\n        msg = f'File \"{self.file}\"'\n        if isinstance(e.node, Statement):\n            if e.node.source:\n                msg += f\", line {e.node.source.lineno}\"\n            msg += f\", in {e.node.name}\"\n\n        msg += f\":\\n    Verification failed for {self.sym_name}: {e.args[0]}\"\n        raise Exception(msg) from e\n    self.verified = True\n    return\n</code></pre>"},{"location":"reference/kirin/ir/ssa/","title":"Ssa","text":""},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.TestValue","title":"<code>TestValue</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SSAValue</code></p> <p>Test SSAValue for testing IR construction.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>@dataclass\nclass TestValue(SSAValue):\n    \"\"\"Test SSAValue for testing IR construction.\"\"\"\n\n    def __init__(self, type: TypeAttribute = AnyType()) -&gt; None:\n        super().__init__()\n        self.type = type\n\n    def __hash__(self) -&gt; int:\n        return id(self)\n\n    @property\n    def owner(self) -&gt; Statement | Block:\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/kirin/ir/test/","title":"Test","text":""},{"location":"reference/kirin/ir/traits/","title":"Traits","text":""},{"location":"reference/kirin/ir/traits/#kirin.ir.traits.CallableStmtInterface","title":"<code>CallableStmtInterface</code>  <code>dataclass</code>","text":"<p>               Bases: <code>StmtTrait</code>, <code>Generic[StmtType]</code></p> Source code in <code>src/kirin/ir/traits.py</code> <pre><code>@dataclass(frozen=True)\nclass CallableStmtInterface(StmtTrait, Generic[StmtType]):\n\n    @classmethod\n    @abstractmethod\n    def get_callable_region(cls, stmt: \"StmtType\") -&gt; Region:\n        \"\"\"Returns the body of the callable region\"\"\"\n        ...\n</code></pre>"},{"location":"reference/kirin/ir/traits/#kirin.ir.traits.CallableStmtInterface.get_callable_region","title":"<code>get_callable_region(stmt)</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Returns the body of the callable region</p> Source code in <code>src/kirin/ir/traits.py</code> <pre><code>@classmethod\n@abstractmethod\ndef get_callable_region(cls, stmt: \"StmtType\") -&gt; Region:\n    \"\"\"Returns the body of the callable region\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/ir/traits/#kirin.ir.traits.SymbolTable","title":"<code>SymbolTable</code>  <code>dataclass</code>","text":"<p>               Bases: <code>StmtTrait</code></p> <p>Statement with SymbolTable trait can only have one region with one block.</p> Source code in <code>src/kirin/ir/traits.py</code> <pre><code>@dataclass(frozen=True)\nclass SymbolTable(StmtTrait):\n    \"\"\"\n    Statement with SymbolTable trait can only have one region with one block.\n    \"\"\"\n\n    @staticmethod\n    def walk(stmt: Statement):\n        return stmt.regions[0].blocks[0].stmts\n\n    def verify(self, stmt: Statement):\n        if len(stmt.regions) != 1:\n            raise VerificationError(\n                stmt,\n                f\"Statement {stmt.name} with SymbolTable trait must have exactly one region\",\n            )\n\n        if len(stmt.regions[0].blocks) != 1:\n            raise VerificationError(\n                stmt,\n                f\"Statement {stmt.name} with SymbolTable trait must have exactly one block\",\n            )\n</code></pre>"},{"location":"reference/kirin/ir/use/","title":"Use","text":""},{"location":"reference/kirin/ir/nodes/","title":"Index","text":""},{"location":"reference/kirin/ir/nodes/base/","title":"Base","text":""},{"location":"reference/kirin/ir/nodes/block/","title":"Block","text":""},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockStmts","title":"<code>BlockStmts</code>  <code>dataclass</code>","text":"<p>               Bases: <code>View['Block', 'Statement']</code></p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>@dataclass\nclass BlockStmts(View[\"Block\", \"Statement\"]):\n    def __iter__(self) -&gt; Iterator[Statement]:\n        return BlockStmtIterator(self.node.first_stmt)\n\n    def __len__(self) -&gt; int:\n        return self.node._stmt_len\n\n    def __reversed__(self) -&gt; Iterator[Statement]:\n        return BlockStmtsReverseIterator(self.node.last_stmt)\n\n    def __repr__(self) -&gt; str:\n        return f\"BlockStmts(len={len(self)})\"\n\n    def __getitem__(self, index: int) -&gt; Statement:\n        raise NotImplementedError(\"Use at() instead\")\n\n    def at(self, index: int) -&gt; Statement:\n        \"\"\"This is similar to __getitem__ but due to the nature of the linked list,\n        it is less efficient than __getitem__.\n        \"\"\"\n        if index &gt;= len(self):\n            raise IndexError(\"Index out of range\")\n\n        if index &lt; 0:\n            return self._at_reverse(-index - 1)\n\n        return self._at_forward(index)\n\n    def _at_forward(self, index: int) -&gt; Statement:\n        if self.node.first_stmt is None:\n            raise IndexError(\"Index out of range\")\n\n        stmt = self.node.first_stmt\n        for _ in range(index):\n            if stmt is None:\n                raise IndexError(\"Index out of range\")\n            stmt = stmt.next_stmt\n\n        if stmt is None:\n            raise IndexError(\"Index out of range\")\n        return stmt\n\n    def _at_reverse(self, index: int) -&gt; Statement:\n        if self.node.last_stmt is None:\n            raise IndexError(\"Index out of range\")\n\n        stmt = self.node.last_stmt\n        for _ in range(index):\n            if stmt is None:\n                raise IndexError(\"Index out of range\")\n            stmt = stmt.prev_stmt\n\n        if stmt is None:\n            raise IndexError(\"Index out of range\")\n        return stmt\n\n    def append(self, value: Statement) -&gt; None:\n        from kirin.ir.nodes.stmt import Statement\n\n        if not isinstance(value, Statement):\n            raise ValueError(f\"Expected Statement, got {type(value).__name__}\")\n\n        if self.node._stmt_len == 0:  # empty block\n            value.attach(self.node)\n            self.node._first_stmt = value\n            self.node._last_stmt = value\n            self.node._stmt_len += 1\n        elif self.node._last_stmt:\n            value.insert_after(self.node._last_stmt)\n        else:\n            raise ValueError(\"Invalid block, last_stmt is None\")\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockStmts.at","title":"<code>at(index)</code>","text":"<p>This is similar to getitem but due to the nature of the linked list, it is less efficient than getitem.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def at(self, index: int) -&gt; Statement:\n    \"\"\"This is similar to __getitem__ but due to the nature of the linked list,\n    it is less efficient than __getitem__.\n    \"\"\"\n    if index &gt;= len(self):\n        raise IndexError(\"Index out of range\")\n\n    if index &lt; 0:\n        return self._at_reverse(-index - 1)\n\n    return self._at_forward(index)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/","title":"Region","text":""},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region","title":"<code>Region</code>  <code>dataclass</code>","text":"<p>               Bases: <code>IRNode['Statement']</code></p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>@dataclass\nclass Region(IRNode[\"Statement\"]):\n    _blocks: list[Block] = field(default_factory=list, repr=False)\n    _block_idx: dict[Block, int] = field(default_factory=dict, repr=False)\n    _parent: Statement | None = field(default=None, repr=False)\n\n    def __init__(\n        self,\n        blocks: Block | Iterable[Block] = (),\n        parent: Statement | None = None,\n    ):\n        self._blocks = []\n        self._block_idx = {}\n        self.parent_node = parent\n        if isinstance(blocks, Block):\n            blocks = (blocks,)\n        for block in blocks:\n            self.blocks.append(block)\n\n    def __getitem__(self, block: Block) -&gt; int:\n        if block.parent is not self:\n            raise ValueError(\"Block does not belong to the region\")\n        return self._block_idx[block]\n\n    def __hash__(self) -&gt; int:\n        return id(self)\n\n    def clone(self, ssamap: dict[SSAValue, SSAValue] | None = None) -&gt; Region:\n        \"\"\"Clone a region. This will clone all blocks and statements in the region.\n        `SSAValue` defined outside the region will not be cloned unless provided in `ssamap`.\n        \"\"\"\n        ret = Region()\n        successor_map: dict[Block, Block] = {}\n        _ssamap = ssamap or {}\n        for block in self.blocks:\n            new_block = Block()\n            ret.blocks.append(new_block)\n            successor_map[block] = new_block\n            for arg in block.args:\n                new_arg = new_block.args.append_from(arg.type, arg.name)\n                _ssamap[arg] = new_arg\n\n        # update statements\n        for block in self.blocks:\n            for stmt in block.stmts:\n                new_stmt = stmt.from_stmt(\n                    stmt,\n                    args=[_ssamap[arg] for arg in stmt.args],\n                    regions=[region.clone(_ssamap) for region in stmt.regions],\n                    successors=[\n                        successor_map[successor] for successor in stmt.successors\n                    ],\n                )\n                successor_map[block].stmts.append(new_stmt)\n                for result, new_result in zip(stmt.results, new_stmt.results):\n                    _ssamap[result] = new_result\n\n        return ret\n\n    @property\n    def parent_node(self) -&gt; Statement | None:\n        return self._parent\n\n    @parent_node.setter\n    def parent_node(self, parent: Statement | None) -&gt; None:\n        from kirin.ir.nodes.stmt import Statement\n\n        self.assert_parent(Statement, parent)\n        self._parent = parent\n\n    @property\n    def blocks(self) -&gt; RegionBlocks:\n        return RegionBlocks(self, self._blocks)\n\n    @property\n    def region_index(self) -&gt; int:\n        if self.parent_node is None:\n            raise ValueError(\"Region has no parent\")\n        for idx, region in enumerate(self.parent_node.regions):\n            if region is self:\n                return idx\n        raise ValueError(\"Region not found in parent\")\n\n    def detach(self, index: int | None = None) -&gt; None:\n        # already detached\n        if self.parent_node is None:\n            return\n\n        if index is not None:\n            region_idx = index\n        else:\n            region_idx = self.region_index\n\n        del self.parent_node._regions[region_idx]\n        self.parent_node = None\n\n    def drop_all_references(self) -&gt; None:\n        self.parent_node = None\n        for block in self._blocks:\n            block.drop_all_references()\n\n    def delete(self, safe: bool = True) -&gt; None:\n        self.detach()\n        self.drop_all_references()\n\n    def is_structurally_equal(\n        self,\n        other: Self,\n        context: dict[IRNode | SSAValue, IRNode | SSAValue] | None = None,\n    ) -&gt; bool:\n        if context is None:\n            context = {}\n\n        if len(self.blocks) != len(other.blocks):\n            return False\n\n        for block, other_block in zip(self.blocks, other.blocks):\n            context[block] = other_block\n\n        if not all(\n            block.is_structurally_equal(other_block, context)\n            for block, other_block in zip(self.blocks, other.blocks)\n        ):\n            return False\n\n        return True\n\n    def walk(\n        self, *, reverse: bool = False, region_first: bool = False\n    ) -&gt; Iterator[Statement]:\n        for block in reversed(self.blocks) if reverse else self.blocks:\n            yield from block.walk(reverse=reverse, region_first=region_first)\n\n    def print_impl(self, printer: Printer) -&gt; None:\n        # populate block ids\n        for block in self.blocks:\n            printer.state.block_id[block]\n\n        printer.plain_print(\"{\")\n        if len(self.blocks) == 0:\n            printer.print_newline()\n            printer.plain_print(\"}\")\n            return\n\n        result_width = 0\n        for bb in self.blocks:\n            for stmt in bb.stmts:\n                result_width = max(result_width, len(printer.result_str(stmt._results)))\n\n        with printer.align(result_width):\n            with printer.indent(increase=2, mark=True):\n                printer.print_newline()\n                for idx, bb in enumerate(self.blocks):\n                    printer.print(bb)\n\n                    if idx != len(self.blocks) - 1:\n                        printer.print_newline()\n\n        printer.print_newline()\n        printer.plain_print(\"}\")\n\n    def typecheck(self) -&gt; None:\n        for block in self.blocks:\n            block.typecheck()\n\n    def verify(self) -&gt; None:\n        from kirin.ir.nodes.stmt import Statement\n\n        if not isinstance(self.parent_node, Statement):\n            raise VerificationError(\n                self, \"expect Region to have a parent of type Statement\"\n            )\n\n        for block in self.blocks:\n            block.verify()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.clone","title":"<code>clone(ssamap=None)</code>","text":"<p>Clone a region. This will clone all blocks and statements in the region. <code>SSAValue</code> defined outside the region will not be cloned unless provided in <code>ssamap</code>.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def clone(self, ssamap: dict[SSAValue, SSAValue] | None = None) -&gt; Region:\n    \"\"\"Clone a region. This will clone all blocks and statements in the region.\n    `SSAValue` defined outside the region will not be cloned unless provided in `ssamap`.\n    \"\"\"\n    ret = Region()\n    successor_map: dict[Block, Block] = {}\n    _ssamap = ssamap or {}\n    for block in self.blocks:\n        new_block = Block()\n        ret.blocks.append(new_block)\n        successor_map[block] = new_block\n        for arg in block.args:\n            new_arg = new_block.args.append_from(arg.type, arg.name)\n            _ssamap[arg] = new_arg\n\n    # update statements\n    for block in self.blocks:\n        for stmt in block.stmts:\n            new_stmt = stmt.from_stmt(\n                stmt,\n                args=[_ssamap[arg] for arg in stmt.args],\n                regions=[region.clone(_ssamap) for region in stmt.regions],\n                successors=[\n                    successor_map[successor] for successor in stmt.successors\n                ],\n            )\n            successor_map[block].stmts.append(new_stmt)\n            for result, new_result in zip(stmt.results, new_stmt.results):\n                _ssamap[result] = new_result\n\n    return ret\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/","title":"Stmt","text":""},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement","title":"<code>Statement</code>  <code>dataclass</code>","text":"<p>               Bases: <code>IRNode['Block']</code></p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>@dataclass(repr=False)\nclass Statement(IRNode[\"Block\"]):\n    name: ClassVar[str]\n    dialect: ClassVar[Dialect | None] = field(default=None, init=False, repr=False)\n    traits: ClassVar[frozenset[StmtTrait]]\n    _arg_groups: ClassVar[frozenset[str]] = frozenset()\n\n    _args: tuple[SSAValue, ...] = field(init=False)\n    _results: list[ResultValue] = field(init=False, default_factory=list)\n    successors: list[Block] = field(init=False)\n    _regions: list[Region] = field(init=False)\n    attributes: dict[str, Attribute] = field(init=False)\n    properties: dict[str, Attribute] = field(init=False)\n\n    parent: Block | None = field(default=None, init=False, repr=False)\n    _next_stmt: Statement | None = field(default=None, init=False, repr=False)\n    _prev_stmt: Statement | None = field(default=None, init=False, repr=False)\n\n    # NOTE: This is only for syntax sugar to provide\n    # access to args via the properties\n    _name_args_slice: dict[str, int | slice] = field(\n        init=False, repr=False, default_factory=dict\n    )\n    source: SourceInfo | None = field(default=None, init=False, repr=False)\n\n    @property\n    def parent_stmt(self) -&gt; Statement | None:\n        if not self.parent_node:\n            return None\n        return self.parent_node.parent_stmt\n\n    @property\n    def parent_node(self) -&gt; Block | None:\n        return self.parent\n\n    @parent_node.setter\n    def parent_node(self, parent: Block | None) -&gt; None:\n        from kirin.ir.nodes.block import Block\n\n        self.assert_parent(Block, parent)\n        self.parent = parent\n\n    @property\n    def parent_region(self) -&gt; Region | None:\n        if (p := self.parent_node) is not None:\n            return p.parent_node\n        return None\n\n    @property\n    def parent_block(self) -&gt; Block | None:\n        return self.parent_node\n\n    @property\n    def next_stmt(self) -&gt; Statement | None:\n        return self._next_stmt\n\n    @next_stmt.setter\n    def next_stmt(self, stmt: Statement) -&gt; None:\n        raise ValueError(\n            \"Cannot set next_stmt directly, use stmt.insert_after(self) or stmt.insert_before(self)\"\n        )\n\n    @property\n    def prev_stmt(self) -&gt; Statement | None:\n        return self._prev_stmt\n\n    @prev_stmt.setter\n    def prev_stmt(self, stmt: Statement) -&gt; None:\n        raise ValueError(\n            \"Cannot set prev_stmt directly, use stmt.insert_after(self) or stmt.insert_before(self)\"\n        )\n\n    def insert_after(self, stmt: Statement) -&gt; None:\n        if self._next_stmt is not None and self._prev_stmt is not None:\n            raise ValueError(\n                f\"Cannot insert before a statement that is already in a block: {self.name}\"\n            )\n\n        if stmt._next_stmt is not None:\n            stmt._next_stmt._prev_stmt = self\n\n        self._prev_stmt = stmt\n        self._next_stmt = stmt._next_stmt\n\n        self.parent = stmt.parent\n        stmt._next_stmt = self\n\n        if self.parent:\n            self.parent._stmt_len += 1\n\n            if self._next_stmt is None:\n                self.parent._last_stmt = self\n\n    def insert_before(self, stmt: Statement) -&gt; None:\n        if self._next_stmt is not None and self._prev_stmt is not None:\n            raise ValueError(\n                f\"Cannot insert before a statement that is already in a block: {self.name}\"\n            )\n\n        if stmt._prev_stmt is not None:\n            stmt._prev_stmt._next_stmt = self\n\n        self._next_stmt = stmt\n        self._prev_stmt = stmt._prev_stmt\n\n        self.parent = stmt.parent\n        stmt._prev_stmt = self\n\n        if self.parent:\n            self.parent._stmt_len += 1\n\n            if self._prev_stmt is None:\n                self.parent._first_stmt = self\n\n    def replace_by(self, stmt: Statement) -&gt; None:\n        stmt.insert_before(self)\n        for result, old_result in zip(stmt._results, self._results):\n            old_result.replace_by(result)\n            if old_result.name:\n                result.name = old_result.name\n        self.delete()\n\n    @property\n    def args(self) -&gt; ArgumentList:\n        return ArgumentList(self, self._args)\n\n    @args.setter\n    def args(self, args: Sequence[SSAValue]) -&gt; None:\n        new = tuple(args)\n        for idx, arg in enumerate(self._args):\n            arg.remove_use(Use(self, idx))\n        for idx, arg in enumerate(new):\n            arg.add_use(Use(self, idx))\n        self._args = new\n\n    @property\n    def results(self) -&gt; ResultList:\n        return ResultList(self, self._results)\n\n    @property\n    def regions(self) -&gt; list[Region]:\n        return self._regions\n\n    @regions.setter\n    def regions(self, regions: list[Region]) -&gt; None:\n        for region in self._regions:\n            region._parent = None\n        for region in regions:\n            region._parent = self\n        self._regions = regions\n\n    def drop_all_references(self) -&gt; None:\n        self.parent = None\n        for idx, arg in enumerate(self._args):\n            arg.remove_use(Use(self, idx))\n        for region in self._regions:\n            region.drop_all_references()\n\n    def delete(self, safe: bool = True) -&gt; None:\n        self.detach()\n        self.drop_all_references()\n        for result in self._results:\n            result.delete(safe=safe)\n\n    def detach(self) -&gt; None:\n        \"\"\"detach the statement from its parent block.\"\"\"\n        if self.parent is None:\n            return\n\n        parent: Block = self.parent\n        prev_stmt = self.prev_stmt\n        next_stmt = self.next_stmt\n\n        if prev_stmt is not None:\n            prev_stmt._next_stmt = next_stmt\n            self._prev_stmt = None\n        else:\n            assert (\n                parent._first_stmt is self\n            ), \"Invalid statement, has no prev_stmt but not first_stmt\"\n            parent._first_stmt = next_stmt\n\n        if next_stmt is not None:\n            next_stmt._prev_stmt = prev_stmt\n            self._next_stmt = None\n        else:\n            assert (\n                parent._last_stmt is self\n            ), \"Invalid statement, has no next_stmt but not last_stmt\"\n            parent._last_stmt = prev_stmt\n\n        self.parent = None\n        parent._stmt_len -= 1\n        return\n\n    def __post_init__(self):\n        assert self.name != \"\"\n        assert isinstance(self.name, str)\n\n        for key in self.attributes:\n            if key in self.properties:\n                raise ValueError(f\"name clash: Attribute {key} is already a property\")\n\n    def __init__(\n        self,\n        *,\n        args: Sequence[SSAValue] = (),\n        regions: Sequence[Region] = (),\n        successors: Sequence[Block] = (),\n        attributes: Mapping[str, Attribute] = {},\n        properties: Mapping[str, Attribute] = {},\n        results: Sequence[ResultValue] = (),\n        result_types: Sequence[TypeAttribute] = (),\n        args_slice: Mapping[str, int | slice] = {},\n        source: SourceInfo | None = None,\n    ) -&gt; None:\n        super().__init__()\n\n        self._args = ()\n        self._regions = []\n        self._name_args_slice = dict(args_slice)\n        self.source = source\n        self.args = args\n\n        if results:\n            self._results = list(results)\n            assert (\n                len(result_types) == 0\n            ), \"expect either results or result_types specified, got both\"\n\n        if result_types:\n            self._results = [\n                ResultValue(self, idx, type=type)\n                for idx, type in enumerate(result_types)\n            ]\n\n        if not results and not result_types:\n            self._results = list(results)\n\n        self.successors = list(successors)\n        self.properties = dict(properties)\n        self.attributes = dict(attributes)\n        self.regions = list(regions)\n\n        self.parent = None\n        self._next_stmt = None\n        self._prev_stmt = None\n        self.__post_init__()\n\n    @classmethod\n    def from_stmt(\n        cls,\n        other: Statement,\n        args: Sequence[SSAValue] | None = None,\n        regions: list[Region] | None = None,\n        successors: list[Block] | None = None,\n        attributes: dict[str, Attribute] | None = None,\n    ) -&gt; Self:\n        \"\"\"Create a similar Statement with new `ResultValue` and without\n        attaching to any parent block. This still references to the old successor\n        and regions.\n        \"\"\"\n        obj = cls.__new__(cls)\n        Statement.__init__(\n            obj,\n            args=args or other._args,\n            regions=regions or other._regions,\n            successors=successors or other.successors,\n            attributes=attributes or other.attributes,\n            properties=other.properties,  # properties are immutable, thus no need to copy\n            result_types=[result.type for result in other._results],\n            args_slice=other._name_args_slice,\n        )\n        return obj\n\n    def walk(\n        self,\n        *,\n        reverse: bool = False,\n        region_first: bool = False,\n        include_self: bool = True,\n    ) -&gt; Iterator[Statement]:\n        if include_self and not region_first:\n            yield self\n\n        for region in reversed(self.regions) if reverse else self.regions:\n            yield from region.walk(reverse=reverse, region_first=region_first)\n\n        if include_self and region_first:\n            yield self\n\n    def is_structurally_equal(\n        self,\n        other: Self,\n        context: dict[IRNode | SSAValue, IRNode | SSAValue] | None = None,\n    ) -&gt; bool:\n        if context is None:\n            context = {}\n\n        if self.name != other.name:\n            return False\n\n        if (\n            len(self.args) != len(other.args)\n            or len(self.regions) != len(other.regions)\n            or len(self.successors) != len(other.successors)\n            or self.attributes != other.attributes\n            or self.properties != other.properties\n        ):\n            return False\n\n        if (\n            self.parent is not None\n            and other.parent is not None\n            and context.get(self.parent) != other.parent\n        ):\n            return False\n\n        if not all(\n            context.get(arg, arg) == other_arg\n            for arg, other_arg in zip(self.args, other.args)\n        ):\n            return False\n\n        if not all(\n            context.get(successor, successor) == other_successor\n            for successor, other_successor in zip(self.successors, other.successors)\n        ):\n            return False\n\n        if not all(\n            region.is_structurally_equal(other_region, context)\n            for region, other_region in zip(self.regions, other.regions)\n        ):\n            return False\n\n        for result, other_result in zip(self._results, other._results):\n            context[result] = other_result\n\n        return True\n\n    def __hash__(self) -&gt; int:\n        return id(self)\n\n    def print_impl(self, printer: Printer) -&gt; None:\n        from kirin.decl import fields as stmt_fields\n\n        printer.print_name(self)\n        printer.plain_print(\"(\")\n        for idx, (name, s) in enumerate(self._name_args_slice.items()):\n            values = self.args[s]\n            if (fields := stmt_fields(self)) and not fields.args[name].print:\n                pass\n            else:\n                with printer.rich(style=\"orange4\"):\n                    printer.plain_print(name, \"=\")\n\n            if isinstance(values, SSAValue):\n                printer.print(values)\n            else:\n                printer.print_seq(values, delim=\", \")\n\n            if idx &lt; len(self._name_args_slice) - 1:\n                printer.plain_print(\", \")\n\n        # NOTE: args are specified manually without names\n        if not self._name_args_slice and self._args:\n            printer.print_seq(self._args, delim=\", \")\n\n        printer.plain_print(\")\")\n\n        if self.successors:\n            printer.print_seq(\n                (printer.state.block_id[successor] for successor in self.successors),\n                emit=printer.plain_print,\n                delim=\", \",\n                prefix=\"[\",\n                suffix=\"]\",\n            )\n\n        if self.properties:\n            printer.plain_print(\"&lt;{\")\n            with printer.rich(highlight=True):\n                printer.print_mapping(self.properties, delim=\", \")\n            printer.plain_print(\"}&gt;\")\n\n        if self.regions:\n            printer.print_seq(\n                self.regions,\n                delim=\" \",\n                prefix=\" (\",\n                suffix=\")\",\n            )\n\n        if self.attributes:\n            printer.plain_print(\"{\")\n            with printer.rich(highlight=True):\n                printer.print_mapping(self.attributes, delim=\", \")\n            printer.plain_print(\"}\")\n\n        if self._results:\n            with printer.rich(style=\"black\"):\n                printer.plain_print(\" : \")\n                printer.print_seq(\n                    [result.type for result in self._results],\n                    delim=\", \",\n                )\n\n    def get_attr_or_prop(self, key: str) -&gt; Attribute | None:\n        return self.attributes.get(key, self.properties.get(key))\n\n    @classmethod\n    def has_trait(cls, trait_type: type[StmtTrait]) -&gt; bool:\n        for trait in cls.traits:\n            if isinstance(trait, trait_type):\n                return True\n        return False\n\n    TraitType = TypeVar(\"TraitType\", bound=StmtTrait)\n\n    @classmethod\n    def get_trait(cls, trait: type[TraitType]) -&gt; TraitType | None:\n        for t in cls.traits:\n            if isinstance(t, trait):\n                return t\n        return None\n\n    @classmethod\n    def from_python_call(cls, state: LoweringState, node: ast.Call) -&gt; Result:\n        raise NotImplementedError\n\n    def expect_one_result(self) -&gt; ResultValue:\n        if len(self._results) != 1:\n            raise ValueError(f\"expected one result, got {len(self._results)}\")\n        return self._results[0]\n\n    # NOTE: statement should implement typecheck\n    # this is done automatically via @statement, but\n    # in the case manualy implementation is needed,\n    # it should be implemented here.\n    # NOTE: not an @abstractmethod to make linter happy\n    def typecheck(self) -&gt; None:\n        raise NotImplementedError\n\n    def verify(self) -&gt; None:\n        return\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.detach","title":"<code>detach()</code>","text":"<p>detach the statement from its parent block.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def detach(self) -&gt; None:\n    \"\"\"detach the statement from its parent block.\"\"\"\n    if self.parent is None:\n        return\n\n    parent: Block = self.parent\n    prev_stmt = self.prev_stmt\n    next_stmt = self.next_stmt\n\n    if prev_stmt is not None:\n        prev_stmt._next_stmt = next_stmt\n        self._prev_stmt = None\n    else:\n        assert (\n            parent._first_stmt is self\n        ), \"Invalid statement, has no prev_stmt but not first_stmt\"\n        parent._first_stmt = next_stmt\n\n    if next_stmt is not None:\n        next_stmt._prev_stmt = prev_stmt\n        self._next_stmt = None\n    else:\n        assert (\n            parent._last_stmt is self\n        ), \"Invalid statement, has no next_stmt but not last_stmt\"\n        parent._last_stmt = prev_stmt\n\n    self.parent = None\n    parent._stmt_len -= 1\n    return\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.from_stmt","title":"<code>from_stmt(other, args=None, regions=None, successors=None, attributes=None)</code>  <code>classmethod</code>","text":"<p>Create a similar Statement with new <code>ResultValue</code> and without attaching to any parent block. This still references to the old successor and regions.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>@classmethod\ndef from_stmt(\n    cls,\n    other: Statement,\n    args: Sequence[SSAValue] | None = None,\n    regions: list[Region] | None = None,\n    successors: list[Block] | None = None,\n    attributes: dict[str, Attribute] | None = None,\n) -&gt; Self:\n    \"\"\"Create a similar Statement with new `ResultValue` and without\n    attaching to any parent block. This still references to the old successor\n    and regions.\n    \"\"\"\n    obj = cls.__new__(cls)\n    Statement.__init__(\n        obj,\n        args=args or other._args,\n        regions=regions or other._regions,\n        successors=successors or other.successors,\n        attributes=attributes or other.attributes,\n        properties=other.properties,  # properties are immutable, thus no need to copy\n        result_types=[result.type for result in other._results],\n        args_slice=other._name_args_slice,\n    )\n    return obj\n</code></pre>"},{"location":"reference/kirin/ir/nodes/view/","title":"View","text":""},{"location":"reference/kirin/lowering/","title":"Index","text":""},{"location":"reference/kirin/lowering/core/","title":"Core","text":""},{"location":"reference/kirin/lowering/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.FromPythonAST","title":"<code>FromPythonAST</code>","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>src/kirin/lowering/dialect.py</code> <pre><code>class FromPythonAST(ABC):\n\n    @property\n    def names(self) -&gt; list[str]:  # show the name without lower_\n        return [name[6:] for name in dir(self) if name.startswith(\"lower_\")]\n\n    def lower(self, state: LoweringState, node: ast.AST) -&gt; Result:\n        \"\"\"Entry point of dialect specific lowering.\"\"\"\n        return getattr(self, f\"lower_{node.__class__.__name__}\", self.unreachable)(\n            state, node\n        )\n\n    def unreachable(self, state: LoweringState, node: ast.AST) -&gt; Result:\n        raise DialectLoweringError(f\"unreachable reached for {node.__class__.__name__}\")\n</code></pre>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.FromPythonAST.lower","title":"<code>lower(state, node)</code>","text":"<p>Entry point of dialect specific lowering.</p> Source code in <code>src/kirin/lowering/dialect.py</code> <pre><code>def lower(self, state: LoweringState, node: ast.AST) -&gt; Result:\n    \"\"\"Entry point of dialect specific lowering.\"\"\"\n    return getattr(self, f\"lower_{node.__class__.__name__}\", self.unreachable)(\n        state, node\n    )\n</code></pre>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.Method","title":"<code>Method</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Printable</code>, <code>Generic[Param, RetType]</code></p> Source code in <code>src/kirin/ir/method.py</code> <pre><code>@dataclass\nclass Method(Printable, Generic[Param, RetType]):\n    mod: ModuleType | None  # ref\n    py_func: Callable[Param, RetType] | None  # ref\n    sym_name: str | None\n    arg_names: list[str]\n    dialects: \"DialectGroup\"  # own\n    code: Statement  # own, the corresponding IR, a func.func usually\n    # values contained if closure\n    fields: tuple = field(default_factory=tuple)  # own\n    file: str = \"\"\n    lineno: list[tuple[int, int]] = field(default_factory=list)\n    \"\"\"(&lt;line&gt;, &lt;col&gt;) at the start of the statement call.\n    \"\"\"\n    backedges: list[\"Method\"] = field(default_factory=list)  # own\n    return_type: TypeAttribute | None = None\n    inferred: bool = False\n    \"\"\"if typeinfer has been run on this method\n    \"\"\"\n    verified: bool = False\n    \"\"\"if `code.verify` has been run on this method\n    \"\"\"\n\n    def __call__(self, *args: Param.args, **kwargs: Param.kwargs) -&gt; RetType:\n        from kirin.interp.concrete import Interpreter\n\n        if len(args) + len(kwargs) != len(self.arg_names) - 1:\n            raise InterpreterError(\"Incorrect number of arguments\")\n        # NOTE: multi-return values will be wrapped in a tuple for Python\n        return Interpreter(self.dialects).eval(self, args=args, kwargs=kwargs).expect()\n\n    @property\n    def args(self):\n        return tuple(arg for arg in self.callable_region.blocks[0].args[1:])\n\n    @property\n    def arg_types(self):\n        return tuple(arg.type for arg in self.args)\n\n    @property\n    def callable_region(self):\n        trait = self.code.get_trait(CallableStmtInterface)\n        if trait is None:\n            raise ValueError(\"Method body must implement CallableStmtInterface\")\n        return trait.get_callable_region(self.code)\n\n    def __repr__(self) -&gt; str:\n        return f'Method(\"{self.sym_name}\")'\n\n    def print_impl(self, printer: Printer) -&gt; None:\n        return printer.print(self.code)\n\n    def verify(self) -&gt; None:\n        \"\"\"verify the method body.\"\"\"\n        try:\n            self.code.verify()\n        except VerificationError as e:\n            msg = f'File \"{self.file}\"'\n            if isinstance(e.node, Statement):\n                if e.node.source:\n                    msg += f\", line {e.node.source.lineno}\"\n                msg += f\", in {e.node.name}\"\n\n            msg += f\":\\n    Verification failed for {self.sym_name}: {e.args[0]}\"\n            raise Exception(msg) from e\n        self.verified = True\n        return\n</code></pre>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.Method.inferred","title":"<code>inferred: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>if typeinfer has been run on this method</p>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.Method.lineno","title":"<code>lineno: list[tuple[int, int]] = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>(, ) at the start of the statement call."},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.Method.verified","title":"<code>verified: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>if <code>code.verify</code> has been run on this method</p>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.Method.verify","title":"<code>verify()</code>","text":"<p>verify the method body.</p> Source code in <code>src/kirin/ir/method.py</code> <pre><code>def verify(self) -&gt; None:\n    \"\"\"verify the method body.\"\"\"\n    try:\n        self.code.verify()\n    except VerificationError as e:\n        msg = f'File \"{self.file}\"'\n        if isinstance(e.node, Statement):\n            if e.node.source:\n                msg += f\", line {e.node.source.lineno}\"\n            msg += f\", in {e.node.name}\"\n\n        msg += f\":\\n    Verification failed for {self.sym_name}: {e.args[0]}\"\n        raise Exception(msg) from e\n    self.verified = True\n    return\n</code></pre>"},{"location":"reference/kirin/lowering/frame/","title":"Frame","text":""},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame","title":"<code>Frame</code>  <code>dataclass</code>","text":"Source code in <code>src/kirin/lowering/frame.py</code> <pre><code>@dataclass\nclass Frame:\n    state: \"LoweringState\"\n    parent: Optional[\"Frame\"]\n    stream: StmtStream[ast.stmt]\n\n    current_region: Region\n    \"\"\"current region being lowered\n    \"\"\"\n    entry_block: Block\n    \"\"\"entry block of the frame\n    \"\"\"\n    current_block: Block\n    \"\"\"current block being lowered\n    \"\"\"\n    next_block: Block | None = None\n    \"\"\"next block, if any\n    \"\"\"\n\n    # known variables, local SSA values or global values\n    defs: dict[str, SSAValue | set[SSAValue]] = field(default_factory=dict)\n    \"\"\"values defined in the current frame\n    \"\"\"\n    globals: dict[str, Any] = field(default_factory=dict)\n    \"\"\"global values known to the current frame\n    \"\"\"\n    captures: dict[str, SSAValue] = field(default_factory=dict)\n    \"\"\"values accessed from the parent frame\n    \"\"\"\n    capture_callback: Optional[CallbackFn] = None\n    \"\"\"callback function that creates a local SSAValue value when an captured value was used.\n    \"\"\"\n\n    @classmethod\n    def from_stmts(\n        cls,\n        stmts: Sequence[ast.stmt] | StmtStream[ast.stmt],\n        state: \"LoweringState\",\n        parent: Optional[\"Frame\"] = None,\n        region: Optional[Region] = None,\n        block: Optional[Block] = None,\n        globals: dict[str, Any] | None = None,\n        capture_callback: Optional[CallbackFn] = None,\n    ):\n        \"\"\"Create a new frame from a list of statements or a new `StmtStream`.\n\n        - `stmts`: list of statements or a `StmtStream` to be lowered.\n        - `region`: `Region` to append the new block to, `None` to create a new one, default `None`.\n        - `block`: `Block` to append the new statements to, `None` to create a new one, default `None`.\n        - `globals`: global variables, default `None`.\n        \"\"\"\n        if not isinstance(stmts, StmtStream):\n            stmts = StmtStream(stmts)\n\n        block = block or Block()\n        if region:\n            region.blocks.append(block)\n\n        return cls(\n            state=state,\n            parent=parent,\n            stream=stmts,\n            current_region=region or Region(block),\n            entry_block=block,\n            current_block=block,\n            globals=globals or {},\n            capture_callback=capture_callback,\n        )\n\n    def get(self, name: str) -&gt; SSAValue | None:\n        value = self.get_local(name)\n        if value is not None:\n            return value\n\n        # NOTE: look up local first, then globals\n        if name in self.globals:\n            return self.state.visit(ast.Constant(self.globals[name])).expect_one()\n        return None\n\n    def get_local(self, name: str) -&gt; SSAValue | None:\n        if name in self.defs:\n            value = self.defs[name]\n            # phi node used first time\n            # replace with an argument\n            if isinstance(value, set):\n                it = iter(value)\n                typ = next(it).type\n                for v in it:\n                    typ: TypeAttribute = v.type.join(typ)\n                ret = self.current_block.args.append_from(typ, name)\n                self.defs[name] = ret\n                return ret\n            else:\n                return value\n\n        if self.parent is None:\n            return None  # no parent frame, return None\n\n        value = self.parent.get_local(name)\n        if value is not None:\n            self.captures[name] = value\n            if self.capture_callback:\n                # whatever generates a local value gets defined\n                ret = self.capture_callback(self, value)\n                self.defs[name] = ret\n                return ret\n            return value\n        return None\n\n    StmtType = TypeVar(\"StmtType\", bound=Statement)\n\n    def append_stmt(self, stmt: StmtType) -&gt; StmtType:\n        self.current_block.stmts.append(stmt)\n        stmt.source = self.state.source\n        return stmt\n\n    def append_block(self, block: Block | None = None):\n        block = block or Block()\n        self.current_region.blocks.append(block)\n        self.current_block = block\n        return block\n\n    def __repr__(self):\n        return f\"Frame({len(self.defs)} defs, {len(self.globals)} globals)\"\n</code></pre>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.capture_callback","title":"<code>capture_callback: Optional[CallbackFn] = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>callback function that creates a local SSAValue value when an captured value was used.</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.captures","title":"<code>captures: dict[str, SSAValue] = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>values accessed from the parent frame</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.current_block","title":"<code>current_block: Block</code>  <code>instance-attribute</code>","text":"<p>current block being lowered</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.current_region","title":"<code>current_region: Region</code>  <code>instance-attribute</code>","text":"<p>current region being lowered</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.defs","title":"<code>defs: dict[str, SSAValue | set[SSAValue]] = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>values defined in the current frame</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.entry_block","title":"<code>entry_block: Block</code>  <code>instance-attribute</code>","text":"<p>entry block of the frame</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.globals","title":"<code>globals: dict[str, Any] = field(default_factory=dict)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>global values known to the current frame</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.next_block","title":"<code>next_block: Block | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>next block, if any</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.from_stmts","title":"<code>from_stmts(stmts, state, parent=None, region=None, block=None, globals=None, capture_callback=None)</code>  <code>classmethod</code>","text":"<p>Create a new frame from a list of statements or a new <code>StmtStream</code>.</p> <ul> <li><code>stmts</code>: list of statements or a <code>StmtStream</code> to be lowered.</li> <li><code>region</code>: <code>Region</code> to append the new block to, <code>None</code> to create a new one, default <code>None</code>.</li> <li><code>block</code>: <code>Block</code> to append the new statements to, <code>None</code> to create a new one, default <code>None</code>.</li> <li><code>globals</code>: global variables, default <code>None</code>.</li> </ul> Source code in <code>src/kirin/lowering/frame.py</code> <pre><code>@classmethod\ndef from_stmts(\n    cls,\n    stmts: Sequence[ast.stmt] | StmtStream[ast.stmt],\n    state: \"LoweringState\",\n    parent: Optional[\"Frame\"] = None,\n    region: Optional[Region] = None,\n    block: Optional[Block] = None,\n    globals: dict[str, Any] | None = None,\n    capture_callback: Optional[CallbackFn] = None,\n):\n    \"\"\"Create a new frame from a list of statements or a new `StmtStream`.\n\n    - `stmts`: list of statements or a `StmtStream` to be lowered.\n    - `region`: `Region` to append the new block to, `None` to create a new one, default `None`.\n    - `block`: `Block` to append the new statements to, `None` to create a new one, default `None`.\n    - `globals`: global variables, default `None`.\n    \"\"\"\n    if not isinstance(stmts, StmtStream):\n        stmts = StmtStream(stmts)\n\n    block = block or Block()\n    if region:\n        region.blocks.append(block)\n\n    return cls(\n        state=state,\n        parent=parent,\n        stream=stmts,\n        current_region=region or Region(block),\n        entry_block=block,\n        current_block=block,\n        globals=globals or {},\n        capture_callback=capture_callback,\n    )\n</code></pre>"},{"location":"reference/kirin/lowering/result/","title":"Result","text":""},{"location":"reference/kirin/lowering/state/","title":"State","text":""},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.LoweringState","title":"<code>LoweringState</code>  <code>dataclass</code>","text":"<p>               Bases: <code>NodeVisitor</code></p> Source code in <code>src/kirin/lowering/state.py</code> <pre><code>@dataclass\nclass LoweringState(ast.NodeVisitor):\n    # from parent\n    dialects: DialectGroup\n    registry: dict[str, FromPythonAST]\n\n    # debug info\n    lines: list[str]\n    lineno_offset: int\n    \"lineno offset at the beginning of the source\"\n    col_offset: int\n    \"column offset at the beginning of the source\"\n    source: SourceInfo\n    \"source info of the current node\"\n    # line_range: tuple[int, int]  # current (&lt;start&gt;, &lt;end&gt;)\n    # col_range: tuple[int, int]  # current (&lt;start&gt;, &lt;end&gt;)\n    max_lines: int = 3\n    _current_frame: Frame | None = None\n\n    @classmethod\n    def from_stmt(\n        cls,\n        lowering: \"Lowering\",\n        stmt: ast.stmt,\n        source: str | None = None,\n        globals: dict[str, Any] | None = None,\n        max_lines: int = 3,\n        lineno_offset: int = 0,\n        col_offset: int = 0,\n    ):\n        if not isinstance(stmt, ast.stmt):\n            raise ValueError(f\"Expected ast.stmt, got {type(stmt)}\")\n\n        if not source:\n            source = ast.unparse(stmt)\n\n        state = cls(\n            dialects=lowering.dialects,\n            registry=lowering.registry,\n            lines=source.splitlines(),\n            lineno_offset=lineno_offset,\n            col_offset=col_offset,\n            source=SourceInfo.from_ast(stmt, lineno_offset, col_offset),\n            max_lines=max_lines,\n        )\n\n        frame = Frame.from_stmts([stmt], state, globals=globals)\n        state.push_frame(frame)\n        return state\n\n    @property\n    def current_frame(self):\n        if self._current_frame is None:\n            raise ValueError(\"No frame\")\n        return self._current_frame\n\n    @property\n    def code(self):\n        stmt = self.current_frame.current_region.blocks[0].first_stmt\n        if stmt:\n            return stmt\n        raise ValueError(\"No code generated\")\n\n    StmtType = TypeVar(\"StmtType\", bound=Statement)\n\n    def append_stmt(self, stmt: StmtType) -&gt; StmtType:\n        \"\"\"Shorthand for appending a statement to the current block of current frame.\"\"\"\n        return self.current_frame.append_stmt(stmt)\n\n    def push_frame(self, frame: Frame):\n        frame.parent = self._current_frame\n        self._current_frame = frame\n        return frame\n\n    def pop_frame(self):\n        if self._current_frame is None:\n            raise ValueError(\"No frame to pop\")\n        frame = self._current_frame\n        self._current_frame = frame.parent\n        return frame\n\n    def update_lineno(self, node):\n        self.source = SourceInfo.from_ast(node, self.lineno_offset, self.col_offset)\n\n    def __repr__(self) -&gt; str:\n        return f\"LoweringState({self.current_frame})\"\n\n    def visit(self, node: ast.AST) -&gt; Result:\n        self.update_lineno(node)\n        name = node.__class__.__name__\n        if name in self.registry:\n            return self.registry[name].lower(self, node)\n        elif isinstance(node, ast.Call):\n            # NOTE: if lower_Call is implemented,\n            # it will be called first before __dispatch_Call\n            # because \"Call\" exists in self.registry\n            return self.__dispatch_Call(node)\n        return super().visit(node)\n\n    def generic_visit(self, node: ast.AST):\n        raise DialectLoweringError(f\"unsupported ast node {type(node)}:\")\n\n    def __dispatch_Call(self, node: ast.Call):\n        # 1. try to lookup global statement object\n        # 2. lookup local values\n        global_callee_result = self.get_global_nothrow(node.func)\n        if global_callee_result is None:  # not found in globals, has to be local\n            return self.__lower_Call_local(node)\n\n        global_callee = global_callee_result.unwrap()\n        if isinstance(global_callee, Method):\n            if \"Call_global_method\" in self.registry:\n                return self.registry[\"Call_global_method\"].lower_Call_global_method(\n                    self, global_callee, node\n                )\n            raise DialectLoweringError(\"`lower_Call_global_method` not implemented\")\n        elif inspect.isclass(global_callee):\n            if issubclass(global_callee, Statement):\n                if global_callee.dialect is not None:\n                    if global_callee.dialect not in self.dialects.data:\n                        raise DialectLoweringError(\n                            f\"unsupported dialect `{global_callee.dialect.name}`\"\n                        )\n                    return global_callee.from_python_call(self, node)\n                else:\n                    raise DialectLoweringError(\n                        f\"unsupported dialect `None` for {global_callee.name}\"\n                    )\n            elif issubclass(global_callee, slice):\n                if \"Call_slice\" in self.registry:\n                    return self.registry[\"Call_slice\"].lower_Call_slice(self, node)\n                raise DialectLoweringError(\"`lower_Call_slice` not implemented\")\n            elif issubclass(global_callee, range):\n                if \"Call_range\" in self.registry:\n                    return self.registry[\"Call_range\"].lower_Call_range(self, node)\n                raise DialectLoweringError(\"`lower_Call_range` not implemented\")\n        elif inspect.isbuiltin(global_callee):\n            name = f\"Call_{global_callee.__name__}\"\n            if \"Call_builtins\" in self.registry:\n                dialect_lowering = self.registry[\"Call_builtins\"]\n                return dialect_lowering.lower_Call_builtins(self, node)\n            elif name in self.registry:\n                dialect_lowering = self.registry[name]\n                return getattr(dialect_lowering, f\"lower_{name}\")(self, node)\n            else:\n                raise DialectLoweringError(\n                    f\"`lower_{name}` is not implemented for builtin function `{global_callee.__name__}`.\"\n                )\n\n        # symbol exist in global, but not ir.Statement, it may refer to a\n        # local value that shadows the global value\n        try:\n            return self.__lower_Call_local(node)\n        except DialectLoweringError:\n            # symbol exist in global, but not ir.Statement, not found in locals either\n            # this means the symbol is referring to an external uncallable object\n            if inspect.isfunction(global_callee):\n                raise DialectLoweringError(\n                    f\"unsupported callee: {type(global_callee)}.\"\n                    \"Are you trying to call a python function? This is not supported.\"\n                )\n            else:  # well not much we can do, can't hint\n                raise DialectLoweringError(\n                    f\"unsupported callee type: {type(global_callee)}\"\n                )\n\n    def __lower_Call_local(self, node: ast.Call) -&gt; Result:\n        callee = self.visit(node.func).expect_one()\n        if \"Call_local\" in self.registry:\n            return self.registry[\"Call_local\"].lower_Call_local(self, callee, node)\n        raise DialectLoweringError(\"`lower_Call_local` not implemented\")\n\n    ValueT = TypeVar(\"ValueT\", bound=SSAValue)\n\n    def exhaust(self, frame: Frame | None = None) -&gt; Frame:\n        \"\"\"Exhaust given frame's stream. If not given, exhaust current frame's stream.\"\"\"\n        if not frame:\n            current_frame = self.current_frame\n        else:\n            current_frame = frame\n\n        stream = current_frame.stream\n        while stream.has_next():\n            stmt = stream.pop()\n            self.visit(stmt)\n        return current_frame\n\n    def error_hint(self) -&gt; str:\n        begin = max(0, self.source.lineno - self.max_lines)\n        end = max(self.source.lineno + self.max_lines, self.source.end_lineno or 0)\n        end = min(len(self.lines), end)  # make sure end is within bounds\n        lines = self.lines[begin:end]\n        code_indent = min(map(self.__get_indent, lines), default=0)\n        lines.append(\"\")  # in case the last line errors\n\n        snippet_lines = []\n        for lineno, line in enumerate(lines, begin):\n            if lineno == self.source.lineno:\n                snippet_lines.append((\"-\" * (self.source.col_offset)) + \"^\")\n\n            snippet_lines.append(line[code_indent:])\n\n        return \"\\n\".join(snippet_lines)\n\n    @staticmethod\n    def __get_indent(line: str) -&gt; int:\n        if len(line) == 0:\n            return int(1e9)  # very large number\n        return len(line) - len(line.lstrip())\n\n    @dataclass\n    class GlobalRefResult:\n        data: Any\n\n        def unwrap(self):\n            return self.data\n\n        ExpectT = TypeVar(\"ExpectT\")\n\n        def expect(self, typ: type[ExpectT]) -&gt; ExpectT:\n            if not isinstance(self.data, typ):\n                raise DialectLoweringError(f\"expected {typ}, got {type(self.data)}\")\n            return self.data\n\n    def get_global_nothrow(self, node) -&gt; GlobalRefResult | None:\n        try:\n            return self.get_global(node)\n        except DialectLoweringError:\n            return None\n\n    def get_global(self, node) -&gt; GlobalRefResult:\n        return getattr(\n            self, f\"get_global_{node.__class__.__name__}\", self.get_global_fallback\n        )(node)\n\n    def get_global_fallback(self, node: ast.AST) -&gt; GlobalRefResult:\n        raise DialectLoweringError(\n            f\"unsupported global access get_global_{node.__class__.__name__}: {ast.unparse(node)}\"\n        )\n\n    def get_global_Constant(self, node: ast.Constant) -&gt; GlobalRefResult:\n        return self.GlobalRefResult(node.value)\n\n    def get_global_str(self, node: str) -&gt; GlobalRefResult:\n        if node in (globals := self.current_frame.globals):\n            return self.GlobalRefResult(globals[node])\n\n        if hasattr(builtins, node):\n            return self.GlobalRefResult(getattr(builtins, node))\n\n        raise DialectLoweringError(f\"global {node} not found\")\n\n    def get_global_Name(self, node: ast.Name) -&gt; GlobalRefResult:\n        return self.get_global_str(node.id)\n\n    def get_global_Attribute(self, node: ast.Attribute) -&gt; GlobalRefResult:\n        if not isinstance(node.ctx, ast.Load):\n            raise DialectLoweringError(\"unsupported attribute access\")\n\n        match node.value:\n            case ast.Name(id):\n                value = self.get_global_str(id).unwrap()\n            case ast.Attribute():\n                value = self.get_global(node.value).unwrap()\n            case _:\n                raise DialectLoweringError(\"unsupported attribute access\")\n\n        if hasattr(value, node.attr):\n            return self.GlobalRefResult(getattr(value, node.attr))\n\n        raise DialectLoweringError(f\"attribute {node.attr} not found in {value}\")\n\n    def get_global_Subscript(self, node: ast.Subscript) -&gt; GlobalRefResult:\n        value = self.get_global(node.value).unwrap()\n        if isinstance(node.slice, ast.Tuple):\n            index = tuple(self.get_global(elt).unwrap() for elt in node.slice.elts)\n        else:\n            index = self.get_global(node.slice).unwrap()\n        return self.GlobalRefResult(value[index])\n\n    def get_global_Call(self, node: ast.Call) -&gt; GlobalRefResult:\n        func = self.get_global(node.func).unwrap()\n        args = [self.get_global(arg).unwrap() for arg in node.args]\n        kwargs = {kw.arg: self.get_global(kw.value).unwrap() for kw in node.keywords}\n        return self.GlobalRefResult(func(*args, **kwargs))\n</code></pre>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.LoweringState.col_offset","title":"<code>col_offset: int</code>  <code>instance-attribute</code>","text":"<p>column offset at the beginning of the source</p>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.LoweringState.lineno_offset","title":"<code>lineno_offset: int</code>  <code>instance-attribute</code>","text":"<p>lineno offset at the beginning of the source</p>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.LoweringState.source","title":"<code>source: SourceInfo</code>  <code>instance-attribute</code>","text":"<p>source info of the current node</p>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.LoweringState.append_stmt","title":"<code>append_stmt(stmt)</code>","text":"<p>Shorthand for appending a statement to the current block of current frame.</p> Source code in <code>src/kirin/lowering/state.py</code> <pre><code>def append_stmt(self, stmt: StmtType) -&gt; StmtType:\n    \"\"\"Shorthand for appending a statement to the current block of current frame.\"\"\"\n    return self.current_frame.append_stmt(stmt)\n</code></pre>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.LoweringState.exhaust","title":"<code>exhaust(frame=None)</code>","text":"<p>Exhaust given frame's stream. If not given, exhaust current frame's stream.</p> Source code in <code>src/kirin/lowering/state.py</code> <pre><code>def exhaust(self, frame: Frame | None = None) -&gt; Frame:\n    \"\"\"Exhaust given frame's stream. If not given, exhaust current frame's stream.\"\"\"\n    if not frame:\n        current_frame = self.current_frame\n    else:\n        current_frame = frame\n\n    stream = current_frame.stream\n    while stream.has_next():\n        stmt = stream.pop()\n        self.visit(stmt)\n    return current_frame\n</code></pre>"},{"location":"reference/kirin/lowering/stream/","title":"Stream","text":""},{"location":"reference/kirin/passes/","title":"Index","text":""},{"location":"reference/kirin/passes/abc/","title":"Abc","text":""},{"location":"reference/kirin/passes/fold/","title":"Fold","text":""},{"location":"reference/kirin/passes/inline/","title":"Inline","text":""},{"location":"reference/kirin/passes/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/print/","title":"Index","text":""},{"location":"reference/kirin/print/printable/","title":"Printable","text":""},{"location":"reference/kirin/print/printable/#kirin.print.printable.Printable","title":"<code>Printable</code>","text":"Source code in <code>src/kirin/print/printable.py</code> <pre><code>class Printable:\n\n    @staticmethod\n    def __get_printer(\n        printer: Printer | None = None, analysis: dict[ir.SSAValue, Any] | None = None\n    ) -&gt; Printer:\n        if printer is None:\n            from kirin.print import Printer\n\n            return Printer(analysis=analysis)\n        return printer\n\n    def pager(\n        self,\n        printer: Printer | None = None,\n        analysis: dict[ir.SSAValue, Any] | None = None,\n    ) -&gt; None:\n        printer = self.__get_printer(printer, analysis)\n        with printer.console.pager(styles=True, links=True):\n            self.print(printer)\n\n    def print(\n        self,\n        printer: Printer | None = None,\n        analysis: dict[ir.SSAValue, Any] | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Entry point of the printing process.\n\n        Args:\n            printer (Printer):\n                `Printer` object to use for printing.\n                If None, a new `Printer` object will be created.\n            analysis (dict[ir.SSAValue, Printable]):\n                Analysis results to use for printing. If `None`, no analysis results\n        \"\"\"\n        printer = self.__get_printer(printer, analysis)\n        self.print_impl(printer)\n        printer.plain_print(\"\\n\")  # add a new line in the end\n\n    def print_str(self, printer: Printer) -&gt; str:\n        with printer.string_io() as stream:\n            self.print(printer)\n            return stream.getvalue()\n\n    @abstractmethod\n    def print_impl(self, printer: Printer) -&gt; None:\n        raise NotImplementedError(f\"print is not implemented for {type(self)}\")\n</code></pre>"},{"location":"reference/kirin/print/printable/#kirin.print.printable.Printable.print","title":"<code>print(printer=None, analysis=None)</code>","text":"<p>Entry point of the printing process.</p> <p>Parameters:</p> Name Type Description Default <code>printer</code> <code>Printer</code> <p><code>Printer</code> object to use for printing. If None, a new <code>Printer</code> object will be created.</p> <code>None</code> <code>analysis</code> <code>dict[SSAValue, Printable]</code> <p>Analysis results to use for printing. If <code>None</code>, no analysis results</p> <code>None</code> Source code in <code>src/kirin/print/printable.py</code> <pre><code>def print(\n    self,\n    printer: Printer | None = None,\n    analysis: dict[ir.SSAValue, Any] | None = None,\n) -&gt; None:\n    \"\"\"\n    Entry point of the printing process.\n\n    Args:\n        printer (Printer):\n            `Printer` object to use for printing.\n            If None, a new `Printer` object will be created.\n        analysis (dict[ir.SSAValue, Printable]):\n            Analysis results to use for printing. If `None`, no analysis results\n    \"\"\"\n    printer = self.__get_printer(printer, analysis)\n    self.print_impl(printer)\n    printer.plain_print(\"\\n\")  # add a new line in the end\n</code></pre>"},{"location":"reference/kirin/print/printer/","title":"Printer","text":""},{"location":"reference/kirin/print/printer/#kirin.print.printer.PrintState","title":"<code>PrintState</code>  <code>dataclass</code>","text":"Source code in <code>src/kirin/print/printer.py</code> <pre><code>@dataclass\nclass PrintState:\n    ssa_id: IdTable[\"ir.SSAValue\"] = field(default_factory=IdTable[\"ir.SSAValue\"])\n    block_id: IdTable[\"ir.Block\"] = field(\n        default_factory=lambda: IdTable[\"ir.Block\"](prefix=\"^\")\n    )\n    indent: int = 0\n    result_width: int = 0\n    indent_marks: list[int] = field(default_factory=list)\n    result_width: int = 0\n    \"SSA-value column width in printing\"\n    rich_style: str | None = None\n    rich_highlight: bool | None = False\n    messages: list[str] = field(default_factory=list)\n</code></pre>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.PrintState.result_width","title":"<code>result_width: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>SSA-value column width in printing</p>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer","title":"<code>Printer</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Generic[IOType]</code></p> Source code in <code>src/kirin/print/printer.py</code> <pre><code>@dataclass(init=False)\nclass Printer(Generic[IOType]):\n    stream: IOType | None = None\n    analysis: dict[\"ir.SSAValue\", Any] | None = None\n    console: Console = field(default_factory=Console)\n    state: PrintState = field(default_factory=PrintState)\n    color: ColorScheme = field(default_factory=ColorScheme)\n    show_indent_mark: bool = True\n    \"Whether to show indent marks, e.g \u2502\"\n\n    def __init__(\n        self,\n        stream: IOType | None = None,\n        analysis: dict[\"ir.SSAValue\", Printable] | None = None,\n        show_indent_mark: bool = True,\n    ):\n        self.stream = stream\n        self.analysis = analysis\n        self.console = Console(file=self.stream, highlight=False)\n        self.state = PrintState()\n        self.color = ColorScheme()\n        self.show_indent_mark = show_indent_mark\n\n    def print(self, object):\n        \"\"\"entry point for printing an object\"\"\"\n        if isinstance(object, Printable):\n            object.print_impl(self)\n        else:\n            fn = getattr(self, f\"print_{object.__class__.__name__}\", None)\n            if fn is None:\n                raise NotImplementedError(\n                    f\"Printer for {object.__class__.__name__} not found\"\n                )\n            fn(object)\n\n    def print_name(\n        self, node: Union[\"ir.Attribute\", \"ir.Statement\"], prefix: str = \"\"\n    ) -&gt; None:\n        self.print_dialect_path(node, prefix=prefix)\n        if node.dialect:\n            self.plain_print(\".\")\n        self.plain_print(node.name)\n\n    def print_dialect_path(\n        self, node: Union[\"ir.Attribute\", \"ir.Statement\"], prefix: str = \"\"\n    ) -&gt; None:\n        if node.dialect:  # not None\n            self.plain_print(prefix)\n            self.plain_print(node.dialect.name, style=self.color.dialect)\n        else:\n            self.plain_print(prefix)\n\n    def print_newline(self):\n        self.plain_print(\"\\n\")\n\n        if self.state.messages:\n            for message in self.state.messages:\n                self.plain_print(message)\n                self.plain_print(\"\\n\")\n            self.state.messages.clear()\n        self.print_indent()\n\n    def print_indent(self):\n        indent_str = \"\"\n        if self.show_indent_mark and self.state.indent_marks:\n            indent_str = \"\".join(\n                \"\u2502\" if i in self.state.indent_marks else \" \"\n                for i in range(self.state.indent)\n            )\n            with self.rich(style=self.color.comment):\n                self.plain_print(indent_str)\n        else:\n            indent_str = \" \" * self.state.indent\n            self.plain_print(indent_str)\n\n    def plain_print(self, *objects, sep=\"\", end=\"\", style=None, highlight=None):\n        self.console.out(\n            *objects,\n            sep=sep,\n            end=end,\n            style=style or self.state.rich_style,\n            highlight=highlight or self.state.rich_highlight,\n        )\n\n    ElemType = TypeVar(\"ElemType\")\n\n    def print_seq(\n        self,\n        seq: Iterable[ElemType],\n        *,\n        emit: Callable[[ElemType], None] | None = None,\n        delim: str = \", \",\n        prefix: str = \"\",\n        suffix: str = \"\",\n        style=None,\n        highlight=None,\n    ) -&gt; None:\n        emit = emit or self.print\n        self.plain_print(prefix, style=style, highlight=highlight)\n        for idx, item in enumerate(seq):\n            if idx &gt; 0:\n                self.plain_print(delim)\n            emit(item)\n        self.plain_print(suffix, style=style, highlight=highlight)\n\n    KeyType = TypeVar(\"KeyType\")\n    ValueType = TypeVar(\"ValueType\", bound=Printable)\n\n    def print_mapping(\n        self,\n        elems: dict[KeyType, ValueType],\n        *,\n        emit: Callable[[ValueType], None] | None = None,\n        delim: str = \", \",\n    ):\n        emit = emit or self.print\n        for i, (key, value) in enumerate(elems.items()):\n            if i &gt; 0:\n                self.plain_print(delim)\n            self.plain_print(f\"{key}=\")\n            emit(value)\n\n    @contextmanager\n    def align(self, width: int):\n        old_width = self.state.result_width\n        self.state.result_width = width\n        try:\n            yield self.state\n        finally:\n            self.state.result_width = old_width\n\n    @contextmanager\n    def indent(self, increase: int = 2, mark: bool | None = None):\n        mark = mark if mark is not None else self.show_indent_mark\n        self.state.indent += increase\n        if mark:\n            self.state.indent_marks.append(self.state.indent)\n        try:\n            yield self.state\n        finally:\n            self.state.indent -= increase\n            if mark:\n                self.state.indent_marks.pop()\n\n    @contextmanager\n    def rich(self, style: str | None = None, highlight: bool = False):\n        old_style = self.state.rich_style\n        old_highlight = self.state.rich_highlight\n        self.state.rich_style = style\n        self.state.rich_highlight = highlight\n        try:\n            yield self.state\n        finally:\n            self.state.rich_style = old_style\n            self.state.rich_highlight = old_highlight\n\n    @contextmanager\n    def string_io(self):\n        stream = io.StringIO()\n        old_file = self.console.file\n        self.console.file = stream\n        try:\n            yield stream\n        finally:\n            self.console.file = old_file\n            stream.close()\n\n    def result_str(self, results: list[\"ir.ResultValue\"]) -&gt; str:\n        with self.string_io() as stream:\n            self.print_seq(results, delim=\", \")\n            result_str = stream.getvalue()\n        return result_str\n\n    def debug(self, message: str):\n        self.state.messages.append(f\"DEBUG: {message}\")\n</code></pre>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.show_indent_mark","title":"<code>show_indent_mark: bool = show_indent_mark</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to show indent marks, e.g \u2502</p>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.print","title":"<code>print(object)</code>","text":"<p>entry point for printing an object</p> Source code in <code>src/kirin/print/printer.py</code> <pre><code>def print(self, object):\n    \"\"\"entry point for printing an object\"\"\"\n    if isinstance(object, Printable):\n        object.print_impl(self)\n    else:\n        fn = getattr(self, f\"print_{object.__class__.__name__}\", None)\n        if fn is None:\n            raise NotImplementedError(\n                f\"Printer for {object.__class__.__name__} not found\"\n            )\n        fn(object)\n</code></pre>"},{"location":"reference/kirin/rewrite/","title":"Index","text":""},{"location":"reference/kirin/rewrite/abc/","title":"Abc","text":""},{"location":"reference/kirin/rewrite/abc/#kirin.rewrite.abc.RewriteRule","title":"<code>RewriteRule</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>A rewrite rule that matches and rewrites IR nodes.</p> <p>The rewrite rule is applied to an IR node by calling the instance with the node as an argument. The rewrite rule should mutate the node instead of returning a new node. A <code>RewriteResult</code> should be returned to indicate whether the rewrite rule has done something, whether the rewrite rule should terminate, and whether the rewrite rule has exceeded the maximum number of iterations.</p> Source code in <code>src/kirin/rewrite/abc.py</code> <pre><code>@dataclass(repr=False)\nclass RewriteRule(ABC):\n    \"\"\"A rewrite rule that matches and rewrites IR nodes.\n\n    The rewrite rule is applied to an IR node by calling the instance with the node as an argument.\n    The rewrite rule should mutate the node instead of returning a new node. A `RewriteResult` should\n    be returned to indicate whether the rewrite rule has done something, whether the rewrite rule\n    should terminate, and whether the rewrite rule has exceeded the maximum number of iterations.\n    \"\"\"\n\n    def rewrite(self, node: IRNode) -&gt; RewriteResult:\n        if isinstance(node, Region):\n            return self.rewrite_Region(node)\n        elif isinstance(node, Block):\n            return self.rewrite_Block(node)\n        elif isinstance(node, Statement):\n            return self.rewrite_Statement(node)\n        else:\n            return RewriteResult()\n\n    def rewrite_Region(self, node: Region) -&gt; RewriteResult:\n        return RewriteResult()\n\n    def rewrite_Block(self, node: Block) -&gt; RewriteResult:\n        return RewriteResult()\n\n    def rewrite_Statement(self, node: Statement) -&gt; RewriteResult:\n        return RewriteResult()\n</code></pre>"},{"location":"reference/kirin/rewrite/chain/","title":"Chain","text":""},{"location":"reference/kirin/rewrite/chain/#kirin.rewrite.chain.Chain","title":"<code>Chain</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Chain multiple rewrites together.</p> <p>The chain will apply each rewrite in order until one of the rewrites terminates.</p> Source code in <code>src/kirin/rewrite/chain.py</code> <pre><code>@dataclass\nclass Chain(RewriteRule):\n    \"\"\"Chain multiple rewrites together.\n\n    The chain will apply each rewrite in order until one of the rewrites terminates.\n    \"\"\"\n\n    rules: List[RewriteRule]\n\n    def rewrite(self, node: IRNode) -&gt; RewriteResult:\n        has_done_something = False\n        for rule in self.rules:\n            result = rule.rewrite(node)\n            if result.terminated:\n                return result\n\n            if result.has_done_something:\n                has_done_something = True\n        return RewriteResult(has_done_something=has_done_something)\n\n    def __repr__(self):\n        return \" -&gt; \".join(map(str, self.rules))\n</code></pre>"},{"location":"reference/kirin/rewrite/fixpoint/","title":"Fixpoint","text":""},{"location":"reference/kirin/rewrite/fixpoint/#kirin.rewrite.fixpoint.Fixpoint","title":"<code>Fixpoint</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Apply a rewrite rule until a fixpoint is reached.</p> <p>The rewrite rule is applied to the node until the rewrite rule does not do anything.</p>"},{"location":"reference/kirin/rewrite/fixpoint/#kirin.rewrite.fixpoint.Fixpoint--parameters","title":"Parameters","text":"<ul> <li><code>map</code>: The rewrite rule to apply.</li> <li><code>max_iter</code>: The maximum number of iterations to apply the rewrite rule. Default is 32.</li> </ul> Source code in <code>src/kirin/rewrite/fixpoint.py</code> <pre><code>@dataclass\nclass Fixpoint(RewriteRule):\n    \"\"\"Apply a rewrite rule until a fixpoint is reached.\n\n    The rewrite rule is applied to the node until the rewrite rule does not do anything.\n\n    ### Parameters\n    - `map`: The rewrite rule to apply.\n    - `max_iter`: The maximum number of iterations to apply the rewrite rule. Default is 32.\n    \"\"\"\n\n    rule: RewriteRule\n    max_iter: int = 32\n\n    def rewrite(self, node: IRNode) -&gt; RewriteResult:\n        has_done_something = False\n        for _ in range(self.max_iter):\n            result = self.rule.rewrite(node)\n            if result.terminated:\n                return result\n\n            if result.has_done_something:\n                has_done_something = True\n            else:\n                return RewriteResult(has_done_something=has_done_something)\n\n        return RewriteResult(exceeded_max_iter=True)\n</code></pre>"},{"location":"reference/kirin/rewrite/result/","title":"Result","text":""},{"location":"reference/kirin/rewrite/walk/","title":"Walk","text":""},{"location":"reference/kirin/rewrite/walk/#kirin.rewrite.walk.Walk","title":"<code>Walk</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Walk through the IR nodes and apply a rewrite rule.</p> <p>The walk will apply the rewrite rule to each node in the IR tree in a depth-first order.</p>"},{"location":"reference/kirin/rewrite/walk/#kirin.rewrite.walk.Walk--parameters","title":"Parameters","text":"<ul> <li><code>map</code>: The rewrite rule to apply.</li> <li><code>reverse</code>: Whether to traverse the IR tree in reverse order. Default is <code>False</code>.</li> <li><code>region_first</code>: Whether to traverse the regions before the blocks. Default is <code>False</code>.</li> </ul> Source code in <code>src/kirin/rewrite/walk.py</code> <pre><code>@dataclass\nclass Walk(RewriteRule):\n    \"\"\"Walk through the IR nodes and apply a rewrite rule.\n\n    The walk will apply the rewrite rule to each node in the IR tree in a depth-first order.\n\n    ### Parameters\n    - `map`: The rewrite rule to apply.\n    - `reverse`: Whether to traverse the IR tree in reverse order. Default is `False`.\n    - `region_first`: Whether to traverse the regions before the blocks. Default is `False`.\n    \"\"\"\n\n    rule: RewriteRule\n    worklist: WorkList[IRNode] = field(default_factory=WorkList)\n\n    # options\n    reverse: bool = field(default=False)\n    region_first: bool = field(default=False)\n\n    def rewrite(self, node: IRNode) -&gt; RewriteResult:\n        # NOTE: because the rewrite pass may mutate the node\n        # thus we need to save the list of nodes to be processed\n        # first before we start processing them\n        self.populate_worklist(node)\n        has_done_something = False\n        subnode = self.worklist.pop()\n        while subnode is not None:\n            result = self.rule.rewrite(subnode)\n            if result.terminated:\n                return result\n\n            if result.has_done_something:\n                has_done_something = True\n            subnode = self.worklist.pop()\n        return RewriteResult(has_done_something=has_done_something)\n\n    def populate_worklist(self, node: IRNode) -&gt; None:\n        if isinstance(node, Statement):\n            self.populate_worklist_Statement(node)\n        elif isinstance(node, Region):\n            self.populate_worklist_Region(node)\n        elif isinstance(node, Block):\n            self.populate_worklist_Block(node)\n        else:\n            raise NotImplementedError(f\"populate_worklist_{node.__class__.__name__}\")\n\n    def populate_worklist_Statement(self, node: Statement) -&gt; None:\n        if self.region_first:\n            self.worklist.push(node)\n\n        if node.regions:\n            for region in reversed(node.regions) if not self.reverse else node.regions:\n                self.populate_worklist(region)\n\n        if not self.region_first:\n            self.worklist.push(node)\n\n    def populate_worklist_Region(self, node: Region) -&gt; None:\n        self.worklist.push(node)\n        if node.blocks:\n            for block in reversed(node.blocks) if not self.reverse else node.blocks:\n                self.populate_worklist(block)\n\n    def populate_worklist_Block(self, node: Block) -&gt; None:\n        self.worklist.push(node)\n        stmt = node.last_stmt\n        while stmt is not None:\n            self.populate_worklist(stmt)\n            stmt = stmt.prev_stmt\n</code></pre>"},{"location":"reference/kirin/rules/","title":"Index","text":""},{"location":"reference/kirin/rules/alias/","title":"Alias","text":""},{"location":"reference/kirin/rules/apply_type/","title":"Apply type","text":""},{"location":"reference/kirin/rules/call2invoke/","title":"Call2invoke","text":""},{"location":"reference/kirin/rules/call2invoke/#kirin.rules.call2invoke.Call2Invoke","title":"<code>Call2Invoke</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RewriteRule</code></p> <p>Rewrite a <code>Call</code> statement to an <code>Invoke</code> statement.</p> Source code in <code>src/kirin/rules/call2invoke.py</code> <pre><code>@dataclass\nclass Call2Invoke(RewriteRule):\n    \"\"\"Rewrite a `Call` statement to an `Invoke` statement.\"\"\"\n\n    results: dict[ir.SSAValue, ConstPropLattice]\n\n    def rewrite_Statement(self, node: ir.Statement) -&gt; RewriteResult:\n        if not isinstance(node, Call):\n            return RewriteResult()\n\n        if (mt := self.results.get(node.callee)) is None:\n            return RewriteResult()\n\n        if not isinstance(mt, Const):\n            return RewriteResult()\n\n        stmt = Invoke(inputs=node.inputs, callee=mt.data, kwargs=node.kwargs)\n        for result, new_result in zip(node.results, stmt.results):\n            new_result.name = result.name\n            new_result.type = result.type\n            if result in self.results:\n                self.results[new_result] = self.results.pop(result)\n\n        node.replace_by(stmt)\n        return RewriteResult(has_done_something=True)\n</code></pre>"},{"location":"reference/kirin/rules/cfg_compatify/","title":"Cfg compatify","text":""},{"location":"reference/kirin/rules/cse/","title":"Cse","text":""},{"location":"reference/kirin/rules/dce/","title":"Dce","text":""},{"location":"reference/kirin/rules/fold/","title":"Fold","text":""},{"location":"reference/kirin/rules/getitem/","title":"Getitem","text":""},{"location":"reference/kirin/rules/inline/","title":"Inline","text":""},{"location":"reference/kirin/rules/inline/#kirin.rules.inline.Inline","title":"<code>Inline</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RewriteRule</code></p> Source code in <code>src/kirin/rules/inline.py</code> <pre><code>@dataclass\nclass Inline(RewriteRule):\n    heuristic: Callable[[ir.IRNode], bool]\n    \"\"\"inline heuristic that determines whether a function should be inlined\n    \"\"\"\n\n    def rewrite_Statement(self, node: ir.Statement) -&gt; RewriteResult:\n        if isinstance(node, func.Invoke):\n            return self.rewrite_func_Invoke(node)\n        else:\n            return RewriteResult()\n\n    def rewrite_func_Invoke(self, node: func.Invoke) -&gt; RewriteResult:\n        has_done_something = False\n        callee = node.callee\n\n        if (\n            isinstance(callee, ir.Method)\n            and self.heuristic(callee.code)\n            and (call_trait := callee.code.get_trait(ir.CallableStmtInterface))\n            is not None\n        ):\n            region = call_trait.get_callable_region(callee.code)\n            self.inline_callee(node, region)\n            has_done_something = True\n\n        return RewriteResult(has_done_something=has_done_something)\n\n    def inline_callee(self, call: func.Invoke, region: ir.Region):\n        # &lt;stmt&gt;\n        # &lt;stmt&gt;\n        # &lt;br (a, b, c)&gt;\n\n        # &lt;block (a, b,c)&gt;:\n        # &lt;block&gt;:\n        # &lt;block&gt;:\n        # &lt;br&gt;\n\n        # ^&lt;block&gt;:\n        # &lt;stmt&gt;\n        # &lt;stmt&gt;\n\n        # 1. we insert the entry block of the callee function\n        # 2. we insert the rest of the blocks into the parent region\n        # 3.1 if the return is in the entry block, means no control flow,\n        #     replace the call results with the return values\n        # 3.2 if the return is some of the blocks, means control flow,\n        #     split the current block into two, and replace the return with\n        #     the branch instruction\n        # 4. remove the call\n        if not call.parent_block:\n            return\n\n        if not call.parent_region:\n            return\n\n        # NOTE: we cannot change region because it may be used elsewhere\n        inline_region: ir.Region = region.clone()\n        parent_block: ir.Block = call.parent_block\n        parent_region: ir.Region = call.parent_region\n\n        # wrap what's after invoke into a block\n        after_block = ir.Block()\n        stmt = call.next_stmt\n        while stmt is not None:\n            stmt.detach()\n            after_block.stmts.append(stmt)\n            stmt = call.next_stmt\n\n        for result in call.results:\n            block_arg = after_block.args.append_from(result.type, result.name)\n            result.replace_by(block_arg)\n\n        parent_block_idx = parent_region._block_idx[parent_block]\n        idx, block = 0, inline_region.blocks.pop(0)\n        entry_block = block\n        while inline_region.blocks:\n            idx += 1\n\n            if block.last_stmt and isinstance(block.last_stmt, func.Return):\n                block.last_stmt.replace_by(\n                    cf.Branch(\n                        arguments=(block.last_stmt.value,),\n                        successor=after_block,\n                    )\n                )\n\n            parent_region.blocks.insert(parent_block_idx + idx, block)\n            block = inline_region.blocks.pop(0)\n\n        parent_region.blocks.append(after_block)\n\n        func_self = stmts.Constant(call.callee)\n        func_self.result.name = call.callee.sym_name\n        func_self.insert_before(call)\n        cf.Branch(\n            arguments=(func_self.result,) + tuple(arg for arg in call.args),\n            successor=entry_block,\n        ).insert_before(call)\n        call.delete()\n        return\n</code></pre>"},{"location":"reference/kirin/rules/inline/#kirin.rules.inline.Inline.heuristic","title":"<code>heuristic: Callable[[ir.IRNode], bool]</code>  <code>instance-attribute</code>","text":"<p>inline heuristic that determines whether a function should be inlined</p>"}]}