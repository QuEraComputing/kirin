{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\: )\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Kirin","text":"<p>Kirin is the Kernel Intermediate Representation Infrastructure. It is a compiler infrastructure for building compilers for embedded domain-specific languages (eDSLs) that target scientific computing kernels.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>MLIR-like dialects as composable python packages</li> <li>Generated Python frontend for your DSLs</li> <li>Pythonic API for building compiler passes</li> <li>Julia-like abstract interpretation framework</li> <li>Builtin support for interpretation</li> <li>Builtin support Python type system and type inference</li> <li>Type hinted via modern Python type hints</li> </ul>"},{"location":"#kirins-mission","title":"Kirin's mission","text":"<p>Compiler toolchain for scientists. Scientists are building domain-specific languages (DSLs) for scientific purposes. Most scientists do not have any compiler engineering background. On the other hand, these DSLs are often high-level, and their instructions are usually slower than the low-level instructions and thus result in smaller programs. No need to generate high quality LLVM IR/native binary most of the time! So there are some chances to simplify terminologies, interfaces for the none-pros, while allowing good interactivity and fast prototyping.</p> <p>For the interested, please read the Kirin's Mission blog post for more details.</p>"},{"location":"#acknowledgement","title":"Acknowledgement","text":"<p>While the mission and audience may be very different, Kirin has been deeply inspired by a few projects:</p> <ul> <li>MLIR, the concept of dialects and the way it is designed.</li> <li>xDSL, about how IR data structure &amp; interpreter should be designed in Python.</li> <li>Julia, abstract interpretation, and certain design choices for scientific community.</li> <li>JAX and numba, the frontend syntax and the way it is designed.</li> <li>Symbolics.jl and its predecessors, the design of rule-based rewriter.</li> </ul>"},{"location":"#quick-example-the-beer-language","title":"Quick Example: the <code>beer</code> language","text":"<p>In this example, we will mutate python's semantics to support a small eDSL (embedded domain-specific language) called <code>beer</code>. It describes the process of brewing beer and get drunk.</p> <p>Before we start, let's take a look at what would our <code>beer</code> language look like:</p> <pre><code>@beer\ndef main(x):\n    beer = NewBeer(\"budlight\") # (1)!\n    Pour(beer, 12) # (2)!\n    Drink(beer) # (3)!\n    Puke() # (4)!\n    if x &gt; 1: # (5)!\n        Drink(NewBeer(\"heineken\")) # (6)!\n    else:\n        Drink(NewBeer(\"tsingdao\")) # (7)!\n    return x + 1 # (8)!\n</code></pre> <ol> <li>The <code>NewBeer</code> statement creates a new beer object with a given brand.</li> <li>The <code>Pour</code> statement pours a beer object.</li> <li>The <code>Drink</code> statement drinks a beer object.</li> <li>The <code>Puke</code> statement pukes. Now we are drunk!</li> <li>Instead of a normal <code>if else</code> branching statement, we execute the branches randomly because we are drunk.</li> <li>The <code>Drink</code> statement drinks a <code>heineken</code> beer object for some possibility.</li> <li>The <code>Drink</code> statement drinks a <code>tsingdao</code> beer object for some possibility.</li> <li>Doing some math to get a result.</li> </ol> <p>The beer language is wrapped with a decorator <code>@beer</code> to indicate that the function is written in the <code>beer</code> language instead of normal Python. (think about how would you program GPU kernels in Python, or how would you use <code>jax.jit</code> and <code>numba.jit</code> decorators).</p> <p>You can run the <code>main</code> function as if it is a normal Python function.</p> <pre><code>main(1)\n</code></pre> <p>or you can inspect the compile result via</p> <pre><code>main.print()\n</code></pre> <p></p>"},{"location":"#defining-the-dialect","title":"Defining the dialect","text":"<p>First, let's define the dialect object, which is a registry for all the objects modeling the semantics.</p> <pre><code>from kirin import ir\n\ndialect = ir.Dialect(\"beer\")\n</code></pre>"},{"location":"#defining-the-statements","title":"Defining the statements","text":"<p>Next, we want to define a runtime value <code>Beer</code> for the <code>beer</code> language so that we may use later in our interpreter. This is just a standard Python <code>dataclass</code>.</p> <pre><code>from dataclasses import dataclass\n\n@dataclass\nclass Beer:\n    brand: str\n</code></pre> <p>Now, we can define the <code>beer</code> language's statements.</p> <pre><code>from kirin.decl import statement, info\nfrom kirin.dialects.py import types\n\n@statement(dialect=dialect)\nclass NewBeer(Statement):\n    name = \"new_beer\" # (1)!\n    traits = frozenset({ir.Pure()}) # (2)!\n    brand: ir.SSAValue = info.argument(types.String) # (3)!\n    result: ir.ResultValue = info.result(types.PyClass(Beer)) # (4)!\n</code></pre> <ol> <li>The <code>name</code> field specifies the name of the statement in the IR text format (e.g printing).</li> <li>The <code>traits</code> field specifies the statement's traits, in this case, it is a    pure function because each brand name uniquely identifies a    beer object.</li> <li>The <code>brand</code> field specifies the argument of the statement. It is a string value. The arguments    of a <code>Statement</code> must be <code>ir.SSAValue</code> objects with a    field specifier <code>info.argument</code> that optionally specifies the type of the argument. The type used    here is <code>types.String</code> which is not Python's type but a <code>TypeAttribute</code> object    from the <code>py.types</code> dialect.</li> <li>The <code>result</code> field specifies the result of the statement. Usually a statement only has one result    value. The type of the result must be <code>ir.ResultValue</code> with a field specifier     <code>info.result</code> that optionally specifies the type of the result.</li> </ol> <p>the <code>NewBeer</code> statement creates a new beer object with a given brand. Thus it takes a string as an argument and returns a <code>Beer</code> object. Click the plus sign above to see the corresponding explanation.</p> <pre><code>@statement(dialect=dialect)\nclass Drink(Statement):\n    name = \"drink\"\n    beverage: ir.SSAValue = info.argument(types.PyClass(Beer))\n</code></pre> <p>Similarly, we define <code>Drink</code> statement that takes a <code>Beer</code> object as an argument. The <code>types.PyClass</code> type from <code>py.type</code> dialect understands Python classes and can take a Python class as an argument to create a type attribute.</p> <pre><code>@statement(dialect=dialect)\nclass Pour(Statement):\n    name = \"pour\"\n    beverage: ir.SSAValue = info.argument(types.PyClass(Beer))\n    amount: ir.SSAValue = info.argument(types.Int)\n</code></pre> <p>The <code>Pour</code> statement takes a <code>Beer</code> object and an integer amount as arguments. The <code>types.Int</code> type is from the <code>py.types</code> dialect. Now we can define a more complicated statement that involves control flow.</p> <pre><code>@statement(dialect=dialect)\nclass RandomBranch(Statement):\n    name = \"random_br\"\n    traits = frozenset({IsTerminator()}) # (1)!\n    cond: SSAValue = info.argument(types.Bool) # (2)!\n    then_arguments: tuple[ir.SSAValue, ...] = info.argument() # (3)!\n    else_arguments: tuple[ir.SSAValue, ...] = info.argument() # (4)!\n    then_successor: ir.Block = info.block() # (5)!\n    else_successor: ir.Block = info.block() # (6)!\n</code></pre> <ol> <li>The <code>traits</code> field specifies that this statement is a terminator. A terminator is a statement that    ends a block. In this case, the <code>RandomBranch</code> statement is a terminator because it decides which    block to go next.</li> <li>The <code>cond</code> field specifies the condition of the branch. It is a boolean value.</li> <li>The <code>then_arguments</code> field specifies the arguments that are passed to the <code>then_successor</code> block. Unlike    previous examples, the <code>then_arguments</code> field is annotated with <code>tuple[ir.SSAValue, ...]</code>, which means    it takes a tuple of <code>ir.SSAValue</code> objects (like what it means in a <code>dataclass</code>).</li> <li>The <code>else_arguments</code> field specifies the arguments that are passed to the <code>else_successor</code> block.</li> <li>The <code>then_successor</code> field specifies the block that the control flow goes to if the condition is true.</li> <li>The <code>else_successor</code> field specifies the block that the control flow goes to if the condition is false.</li> </ol> <p>the <code>RandomBranch</code> statement is a terminator that takes a boolean condition and two tuples of arguments. However, unlike a normal <code>if else</code> branching statement, it does not execute the branches based on the condition. Instead, it randomly chooses one of the branches to execute.</p>"},{"location":"#defining-the-interpreter","title":"Defining the interpreter","text":"<p>Now with the statements defined, we can define how to interpret them</p> <pre><code>from kirin.interp import DialectInterpreter, Interpreter, ResultValue, Successor, impl\n\n@dialect.register\nclass BeerInterpreter(DialectInterpreter):\n    ...\n</code></pre> <p>the <code>BeerInterpreter</code> class is a subclass of <code>DialectInterpreter</code> that registers the implementation of each implementation. The implementation is a method decorated with <code>@impl</code> that executes the statement.</p> <pre><code>    @impl(NewBeer)\n    def new_beer(self, interp: Interpreter, stmt: NewBeer, values: tuple):\n        return ResultValue(Beer(values[0]))\n\n    @impl(Drink)\n    def drink(self, interp: Interpreter, stmt: Drink, values: tuple):\n        print(f\"Drinking {values[0].brand}\")\n        return ResultValue()\n\n    @impl(Pour)\n    def pour(self, interp: Interpreter, stmt: Pour, values: tuple):\n        print(f\"Pouring {values[0].brand} {values[1]}\")\n        return ResultValue()\n\n    @impl(Puke)\n    def puke(self, interp: Interpreter, stmt: Puke, values: tuple):\n        print(\"Puking!!!\")\n        return ResultValue()\n</code></pre> <p>Normally, most implementations are just straightforward like the above except that they will do more meaningful things than printing. The <code>ResultValue</code> object is a result type of the interpreter that saying the return value is just a normal tuple of values. This will be different when we implement interpretation for a terminator:</p> <pre><code>    @impl(RandomBranch)\n    def random_branch(self, interp: Interpreter, stmt: RandomBranch, values: tuple):\n        frame = interp.state.current_frame()\n        if randint(0, 1):\n            return Successor(\n                stmt.then_successor, *frame.get_values(stmt.then_arguments)\n            )\n        else:\n            return Successor(\n                stmt.else_successor, *frame.get_values(stmt.then_arguments)\n            )\n</code></pre> <p>The <code>random_branch</code> implementation randomly chooses one of the branches to execute. The return value is a <code>Successor</code> object that specifies the next block to execute and the arguments to pass to the block.</p>"},{"location":"#rewrite-python-if-else-statement-to-randombranch","title":"Rewrite Python <code>if else</code> statement to <code>RandomBranch</code>","text":"<p>Now we can define a rewrite pass that rewrites Python <code>if else</code> statement to <code>RandomBranch</code> statement. This is done by defining a subclass of <code>RewriteRule</code> and implementing the <code>rewrite_Statement</code> method. The <code>RewriteRule</code> class is a standard Python visitor on Kirin's IR.</p> <p>Here, we only need to implement the <code>rewrite_Statement</code> method to rewrite the <code>if else</code> statement to <code>RandomBranch</code>.</p> <pre><code>from kirin.dialects import cf # (1)!\nfrom kirin.rewrite import RewriteResult, RewriteRule # (2)!\n\n@dataclass\nclass RewriteToRandomBranch(RewriteRule):\n\n    def rewrite_Statement(self, node: ir.Statement) -&gt; RewriteResult: # (3)!\n        if not isinstance(node, cf.ConditionalBranch): # (4)!\n            return RewriteResult()\n        node.replace_by(\n            RandomBranch(\n                cond=node.cond,\n                then_arguments=node.then_arguments,\n                then_successor=node.then_successor,\n                else_arguments=node.else_arguments,\n                else_successor=node.else_successor,\n            )\n        )\n        return RewriteResult(has_done_something=True) # (5)!\n</code></pre> <ol> <li>Import the control flow dialect <code>cf</code> which is what Python <code>if else</code> statement compiles to by default in the <code>basic</code> dialect group.</li> <li>Import the <code>RewriteRule</code> class from the <code>rewrite</code> module.</li> <li>This is the signature of <code>rewrite_Statement</code> method. Your IDE should hint you the type signature so you can auto-complete it.</li> <li>Check if the statement is a <code>ConditionalBranch</code> statement. If it is not, return an empty <code>RewriteResult</code>.</li> <li>Replace the <code>ConditionalBranch</code> statement with a <code>RandomBranch</code> statement and return a <code>RewriteResult</code> that indicates the rewrite has been done. Every statement has a <code>replace_by</code> method that replaces the statement with another statement.</li> </ol>"},{"location":"#putting-everything-together","title":"Putting everything together","text":"<p>Now we can put everything together and finally create the <code>beer</code> decorator, and you do not need to figure out the complicated type hinting and decorator implementation because Kirin will do it for you!</p> <pre><code>from kirin.ir import dialect_group\nfrom kirin.prelude import basic_no_opt\nfrom kirin.rewrite import Fixpoint, Walk\n\n@dialect_group(basic_no_opt.add(dialect)) # (1)!\ndef beer(self): # (2)!\n    # some initialization if you need it\n    def run_pass(mt): # (3)!\n        Fixpoint(Walk(RandomWalkBranch())).rewrite(mt.code) # (4)!\n\n    return run_pass # (5)!\n</code></pre> <ol> <li>The <code>dialect_group</code> decorator specifies the dialect group that the <code>beer</code> dialect belongs to. In this case, instead of rebuilding the whole dialect group, we just add our <code>dialect</code> object to the <code>basic_no_opt</code> dialect group which provides all the basic Python semantics, such as math, function, closure, control flows, etc.</li> <li>The <code>beer</code> function is the decorator that will be used to decorate the <code>main</code> function.</li> <li>The <code>run_pass</code> function wraps all the passes that need to run on the input method. It optionally can take some arguments or keyword arguments that will be passed to the <code>beer</code> decorator.</li> <li>Inside the <code>run_pass</code> function, we will traverse the entire IR and rewrite all the <code>ConditionalBranch</code> statements to <code>RandomBranch</code> statements until no more rewrites can be done.</li> <li>Remember to return the <code>run_pass</code> function at the end of the <code>beer</code> function.</li> </ol> <p>This is it!</p>"},{"location":"#license","title":"License","text":"<p>Apache License 2.0 with LLVM Exceptions</p>"},{"location":"101/","title":"Compiler 101","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"101/#compiler-101-for-scientists","title":"Compiler 101 for scientists","text":"<p>In this section, we cover some common compiler concepts that are useful to know when working with Kirin.</p>"},{"location":"101/#static-single-assignment-ssa-form","title":"Static Single Assignment (SSA) Form","text":"<p>Kirin IR is in Static Single Assignment (SSA) form. This means that each variable is assigned exactly once. This makes it easier to reason about the program and allows for more aggressive optimizations.</p>"},{"location":"101/#what-is-purity","title":"What is purity?","text":"<p>A function is said to be pure if it has no side effects. In other word, a pure function is a function that only depends on its input arguments and produces a result. This means that the function does not modify any state outside of its scope. This is useful because it allows the compiler to optimize the function more aggressively.</p>"},{"location":"analysis/","title":"Analysis","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"analysis/#analysis","title":"Analysis","text":"<p>Kirin provides a framework for performing dataflow analysis on the IR. This is done via</p> <ul> <li>IR walking</li> <li>Abstract interpretation</li> </ul>"},{"location":"analysis/#lattice","title":"Lattice","text":"<p>A lattice is a set of values that are partially ordered. In Kirin IR, a lattice is a subclass of the <code>Lattice</code> ABC class. A lattice can be used to represent the result of a statement that has multiple possible results.</p>"},{"location":"codegen/","title":"Codegen","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"comparison/","title":"Comparison","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"contrib/","title":"Contributing","text":"<p>Please see Installation for instructions on how to set up your development environment.</p>"},{"location":"contrib/#pre-commit-hooks","title":"Pre-commit hooks","text":"<p>We use <code>pre-commit</code> to run the linter checks before you commit your changes. The pre-commit hooks are installed as part of the development dependencies. You can setup <code>pre-commit</code> using the following command:</p> <pre><code>pre-commit install\n</code></pre> <p>This will run the linter checks before you commit your changes. If the checks fail, the commit will be rejected. Most of the following sections can be checked by the pre-commit hooks.</p>"},{"location":"contrib/#running-the-tests","title":"Running the tests","text":"<p>We use <code>pytest</code> for testing. To run the tests, simply run:</p> <pre><code>pytest\n</code></pre> <p>or for a specific test file with the <code>-s</code> flag to show the output of the program:</p> <pre><code>pytest -s tests/test_program.py\n</code></pre> <p>lots of tests contains pretty printing of the IR themselves, so it's useful to see the output.</p>"},{"location":"contrib/#code-style","title":"Code style","text":"<p>We use <code>black</code> for code formatting. Besides the linter requirements, we also require the following good-to-have practices:</p>"},{"location":"contrib/#naming","title":"Naming","text":"<ul> <li>try not to use abbreviation as names, unless it's a common abbreviation like <code>idx</code> for <code>index</code></li> <li>try not create a lot of duplicated name prefix unless the extra information is necessary when accessing the class object.</li> <li>try to use <code>snake_case</code> for naming variables and functions, and <code>CamelCase</code> for classes.</li> </ul>"},{"location":"contrib/#comments","title":"Comments","text":"<ul> <li>try not to write comments, unless it's really necessary. The code should be self-explanatory.</li> <li>if you have to write comments, try to use <code>NOTE:</code>, <code>TODO:</code> <code>FIXME:</code> tags to make it easier to search for them.</li> </ul>"},{"location":"contrib/#documentation","title":"Documentation","text":"<p>We use <code>just</code> for mangaging command line tools and scripts. It should be installed when you run <code>uv sync</code>. To build the documentation, simply run:</p> <pre><code>just doc\n</code></pre> <p>This will launch a local server to preview the documentation. You can also run <code>just doc-build</code> to build the documentation without launching the server.</p>"},{"location":"contrib/#license","title":"License","text":"<p>By contributing to this project, you agree to license your contributions under the Apache License 2.0 with LLVM Exceptions.</p>"},{"location":"def/","title":"Declarations","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"def/#understanding-kirin-ir-declarations","title":"Understanding Kirin IR Declarations","text":"<p>In this section, we will learn about the terminology used in Kirin IR. This will help you understand the structure of the IR and how to write your own compiler using Kirin.</p> <p>Note</p> <p>The examples in this section will also contain the equivalent MLIR and xDSL code to help you understand the differences between them if you are already familiar with MLIR or xDSL.</p>"},{"location":"def/#dialect","title":"Dialect","text":"<p>The <code>Dialect</code> object is the main registry of all the statements and attributes that are available in the IR. You can create a dialect by just following:</p> <pre><code>from kirin import ir\ndialect = ir.Dialect(\"my_dialect\") # (1)!\n</code></pre> <ol> <li>The <code>Dialect</code> object is created with the name <code>my_dialect</code>.</li> </ol>"},{"location":"def/#dialect-groups","title":"Dialect Groups","text":"<p>A dialect group is a collection of dialects that can be used as a decorator for Python frontend. It is used to group multiple dialects together and define the passes, compiler options, and other configurations for the dialects.</p> <pre><code>from kirin.ir import Method, dialect_group\n\n@dialect_group(\n    [\n        base,\n        binop,\n        cmp,\n        unary,\n        assign,\n        attr,\n        boolop,\n        constant,\n        indexing,\n        func,\n    ]\n) # (1)!\ndef python_basic(self): # (2)!\n    def run_pass(mt: Method) -&gt; None: # (3)!\n        pass # (4)!\n    return run_pass\n</code></pre> <ol> <li>The <code>dialect_group</code> decorator is used to create a dialect group with the specified dialects. In this case, we construct a basic Python dialect that allows some basic operations.</li> <li>The <code>python_basic</code> function is the entry point of the dialect group. It takes a <code>self</code> argument, which is the <code>DialectGroup</code> object. This argument is used to access the definition of the dialect group and optionally update the dialect group.</li> <li>The <code>run_pass</code> function is the function that will be called when the dialect group is applied to a given Python function. This is where you can define the passes that will be applied to the method. See the next example.</li> </ol> <p>Note</p> <p>Unlike MLIR/LLVM, because Kirin focuses on kernel functions, the minimal unit of compilation is a function. Therefore, the compiler pass always passes a <code>ir.Method</code> object which contains a function-like statement (a statement has <code>ir.traits.CallableStmtInterface</code>).</p> <p>The above dialect group <code>python_basic</code> allows you to use it as following:</p> <pre><code>@python_basic\ndef my_function():\n    pass\n</code></pre> <p>However, if we want to run some compilation passes on the function, we need to define some passes in the <code>run_pass</code> function.</p> <pre><code>from kirin.passes.fold import Fold\n\n@dialect_group(python_basic) # (1)!\ndef python(self):\n    fold_pass = Fold(self) # (2)!\n\n    def run_pass(mt: Method, *, verify: bool = True, fold: bool = True) -&gt; None: # (3)!\n        if verify: # (4)!\n            mt.verify()\n\n        if fold: # (5)!\n            fold_pass(mt)\n    return run_pass\n</code></pre> <ol> <li>The <code>dialect_group</code> decorator can also take a dialect group as an argument. This will use the dialects defined in the given dialect group with different passes.</li> <li>The <code>Fold</code> pass is created when initializing the dialect group. This pass is used later when running the <code>run_pass</code> function.</li> <li>The <code>run_pass</code> function is the function that will be called when the dialect group is applied to a given Python function. This function takes a <code>mt</code> argument, which is the <code>ir.Method</code> object, and optional arguments <code>verify</code>, <code>fold</code>, and <code>aggressive</code>.</li> <li>If the <code>verify</code> argument is <code>True</code>, the method will be verified.</li> <li>If the <code>fold</code> argument is <code>True</code>, the <code>Fold</code> pass will be applied to the method.</li> </ol> <p>The above dialect group <code>python</code> allows you to use it as following:</p> <pre><code>@python(fold=True) # (1)!\ndef my_function():\n    pass\n</code></pre> <ol> <li>The <code>fold</code> argument here is passed to the <code>run_pass</code> function defined in the dialect group. Looks complicated? Don't worry, the <code>@dialect_group</code> decorator will handle everything including the type hints!</li> </ol>"},{"location":"def/#statement","title":"Statement","text":"<p>In Kirin IR, a statement describes an operation that can be executed. Statements are the building blocks that contain the semantics of the program.</p>"},{"location":"def/#defining-a-statement","title":"Defining a Statement","text":"<p>While a statement can be hand-written by inheriting <code>ir.Statement</code>, we provide a python-<code>dataclass</code>-like decorator <code>statement</code> and in combine with the <code>info.argument</code>,<code>info.result</code>,<code>info.region</code>, <code>info.block</code> field specifier to make it easier to define a statement.</p> KirinMLIRxDSL <pre><code>from kirin import ir\nfrom kirin.decl import statement, info\n\n@statement # (1)!\nclass MyStatement(ir.Statement): # (2)!\n    name = \"awesome\" # (3)!\n    traits = frozenset({ir.Pure()}) # (4)!\n    # blabla, we will talk about this later\n</code></pre> <ol> <li>the decorator <code>@statement</code> is used to generate implementations for the <code>MyStatement</code> class based on the fields defined in the class.</li> <li>The <code>MyStatement</code> class inherits from <code>ir.Statement</code>.</li> <li>The <code>name</code> field is the name of the statement, if your desired name is just <code>my_statement</code>, you can omit this field, <code>@statement</code> will automatically generate the name by converting the class name to snake case. The name is what will be used in text/pretty printing.</li> <li>The <code>traits</code> field is used to specify the traits of the statement. In this case, the statement is pure.</li> </ol> <pre><code>\n</code></pre> <pre><code>\n</code></pre> <p>Like a function, a statement can have multiple inputs and outputs.</p> KirinMLIRxDSL <pre><code>@statement # (1)!\nclass Add(ir.Statement):\n    traits = frozenset({ir.Pure()}) # (2)!\n    lhs: ir.SSAValue = info.argument(ir.types.Int) # (3)!\n    rhs: ir.SSAValue = info.argument(ir.types.Int) # (4)!\n    output: ir.ResultValue = info.result(ir.types.Int) # (5)!\n</code></pre> <ol> <li>the decorator <code>@statement</code> is used to generate implementations for the <code>MyStatement</code> class based on the fields defined in the class.</li> <li>The <code>traits</code> field is used to specify the traits of the statement. In this case, the statement is pure.</li> <li>The <code>lhs</code> field is the left-hand side input value of the statement. The field descriptor <code>info.argument</code> is used to specify the type of the input value.</li> <li>The <code>rhs</code> field is the right-hand side input value of the statement. The field descriptor <code>info.argument</code> is used to specify the type of the input value.</li> <li>The <code>output</code> field is the output value of the statement. The field descriptor <code>info.result</code> is used to specify the type of the output value.</li> </ol> <pre><code>\n</code></pre> <pre><code>\n</code></pre> <p>A statement can have blocks as successors, which describe the control flow of the program.</p> KirinMLIRxDSL <pre><code>@statement\nclass Branch(Statement):\n   name = \"br\"\n   traits = frozenset({IsTerminator()}) # (1)!\n\n   arguments: tuple[SSAValue, ...] # (2)!\n   successor: Block = info.block() # (3)!\n</code></pre> <ol> <li>The <code>traits</code> field is used to specify the traits of the statement. In this case, the statement is a terminator.</li> <li>The <code>arguments</code> field is the input values of the statement. Branch can take multiple arguments, <code>tuple[SSAValue, ...]</code> is used to specify that the field is a tuple of <code>SSAValue</code>. Note that only <code>...</code> is supported because if the number of arguments is known, we recommend specifying them explicitly.</li> <li>The <code>successor</code> field is the block that the statement will go to after execution. The field descriptor <code>info.block</code> is used to specify the type of the field.</li> </ol> <pre><code>\n</code></pre> <pre><code>\n</code></pre> <p>It can also have a region that contains other statements, for example, a function statement</p> KirinMLIRxDSL <pre><code>@statement\nclass Function(ir.Statement):\n   name = \"func\"\n   traits = frozenset({SSACFGRegion()}) # (1)!\n   sym_name: str = info.attribute(property=True) # (2)!\n   body: Region = info.region(multi=True) # (3)!\n</code></pre> <ol> <li>The <code>traits</code> field contains the <code>SSACFGRegion</code> trait, which indicates that the region in the statement is a standard control-flow graph.</li> <li>The <code>sym_name</code> field is the name of the function. In the <code>@statement</code> decorator, if a field annotated with normal Python types (not an IR node, e.g <code>ir.SSAValue</code>, <code>ir.Block</code>, <code>ir.Region</code>), it will be treated as a <code>PyAttr</code> attribute.</li> <li>The <code>body</code> field is the region that contains the statements of the function. The field descriptor <code>info.region</code> is used to specify this region can contain multiple blocks.</li> </ol> <pre><code>\n</code></pre> <pre><code>\n</code></pre>"},{"location":"def/#constructing-a-statement","title":"Constructing a Statement","text":"<p>Statements can be constructed in similar ways to constructing a normal Python <code>dataclass</code>. Taking the previous definitions as an example:</p> <pre><code>from kirin.dialects.py.constant import Constant\n\nlhs, rhs = Constant(1), Constant(2) # (1)!\nadd = Add(lhs.result, rhs=rhs.result) # (2)!\n</code></pre> <ol> <li>Two <code>Constant</code> statements are created with the value <code>1</code> and <code>2</code>.</li> <li>An <code>Add</code> statement is created with the <code>lhs</code> and <code>rhs</code> fields set to the results of the <code>lhs</code> and <code>rhs</code> statements. Like <code>@dataclass</code> unless specified by <code>kw_only=True</code>, the fields are positional.</li> </ol>"},{"location":"def/#block","title":"Block","text":"<p>A block is a sequence of statements that are executed in order. Optionally, a block can have arguments that are passed from the predecessor block and terminates with a terminator statement. Unlike <code>ir.Statement</code>, the <code>ir.Block</code> class is final and cannot be extended.</p>"},{"location":"def/#constructing-a-block","title":"Constructing a Block","text":"<p><code>Block</code> takes a <code>Sequence</code> of statements as an argument, e.g a list of statements.</p> <pre><code>from kirin import ir\nir.Block() # Block(_args=())\nir.Block([stmt_a, stmt_b])\n</code></pre> <p>continue the example from Constructing a Statement, we can construct a block like following:</p> <pre><code>block = ir.Block()\narg_x = block.args.append_from(ir.types.Any)\narg_y = block.args.append_from(ir.types.Any)\nblock.stmts.append(Add(arg_x, arg_y))\n</code></pre> <p>Note</p> <p>Every IR node in Kirin has a pretty printer that can be used to print the node in a human-readable format. Just call <code>.print</code> method. In the above example, we have</p> <p><pre><code>^0(%0, %1):\n    %2 = add(lhs=%0, rhs=%1) : !py.int\n</code></pre> which is the pretty-printed version of the block. You may notice this is similar to MLIR text format, which is intentional.</p>"},{"location":"def/#region","title":"Region","text":"<p>A region is a sequence of blocks that are connected by control flow. A region can contain multiple blocks and can be nested within another region via statements that contain a region field. Unlike <code>ir.Statement</code>, the <code>ir.Region</code> class is final and cannot be extended.</p>"},{"location":"def/#constructing-a-region","title":"Constructing a Region","text":"<p>Continuing the example from Constructing a Block, we can construct a region like following:</p> <pre><code>region = ir.Region([block])\n</code></pre> <p>pretty printing the region will give you</p> <pre><code>{\n  ^0(%1, %2):\n  \u2502 %0 = add(lhs=%1, rhs=%2) : !py.int\n}\n</code></pre>"},{"location":"def/#ssa-value","title":"SSA Value","text":"<p>An SSA value is a value that is assigned only once in the program. In Kirin IR, an SSA value is represented by the <code>ir.SSAValue</code> class. Most of the time, one does not need to construct the SSA value directly, as it is automatically created when constructing a statement.</p> <p>There are 3 types of SSA values:</p> <ul> <li><code>ir.SSAValue</code>: the base class of SSA values.</li> <li><code>ir.ResultValue</code>: SSA values that are the result of a statement, this object allows you to access the parent statement via <code>result.owner</code> property.</li> <li><code>ir.BlockArgument</code>: SSA values that are the arguments of a block.</li> </ul>"},{"location":"install/","title":"Installation","text":"<p>Kirin is available in PyPI and thus can be installed via <code>pip</code>. Install Kirin using the following command:</p> <pre><code>pip install kirin-toolchain\n</code></pre> <p>Kirin supports Python 3.9 or later. We recommend using Python 3.10+ for the best experience.</p> <p>We strongly recommend developing your compiler project using <code>uv</code>, which is the official development environment for Kirin. You can install <code>uv</code> using the following command:</p> Linux and macOSWindows <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <p>then</p> <pre><code>uv add kirin-toolchain\n</code></pre> <pre><code>powershell -ExecutionPolicy ByPass -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n</code></pre> <p>then</p> <pre><code>uv add kirin-toolchain\n</code></pre>"},{"location":"install/#kirin-and-its-friends","title":"Kirin and its friends","text":"<p>Kirin also comes with a few friends that you might find useful:</p> <ul> <li><code>bloqade-qasm</code>: (link missing) A quantum assembly language (QASM 2.0) dialect for Kirin with a builtin QASM 2.0 text format parser.</li> <li><code>bloqade</code>: (available soon) QuEra's SDK for next-gen error-corrected neutral-atom quantum computers.</li> </ul>"},{"location":"install/#development","title":"Development","text":"<p>If you want to contribute to Kirin, you can clone the repository from GitHub:</p> <pre><code>git clone https://github.com/QuEraComputing/kirin.git\n</code></pre> <p>We use <code>uv</code> to manage the development environment, after you install <code>uv</code>, you can install the development dependencies using the following command:</p> <pre><code>uv sync\n</code></pre> <p>Our code review requires that you pass the tests and the linting checks. We recommend you to install <code>pre-commit</code> to run the checks before you commit your changes, the command line tool <code>pre-commit</code> has been installed as part of the development dependencies. You can setup <code>pre-commit</code> using the following command:</p> <pre><code>pre-commit install\n</code></pre>"},{"location":"install/#requirements","title":"Requirements","text":"<p>Kirin requires the following dependencies:</p> <ul> <li><code>rich</code>: for pretty-printing</li> <li><code>type-extensions</code>: for type hints</li> <li><code>beartype</code>: for runtime type checking and analysis of type hints in the python dialect</li> </ul>"},{"location":"interp/","title":"Interpretation","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"interp/#interpretation","title":"Interpretation","text":"<p>Kirin provides a framework for interpreting the IR. There are multiple ways to interpret the IR:</p> <ol> <li>concrete interpretation, which evaluates the IR using concrete values like CPython.</li> <li>abstract interpretation, which evaluates the IR on lattice values. (See also Analysis)</li> <li>tree walking, which walks the IR tree and performs actions on each node. (See also Code Generation)</li> </ol> <p>this page will focus on concrete interpretation.</p>"},{"location":"interp/#concrete-interpretation","title":"Concrete Interpretation","text":""},{"location":"interp/#function-call-like-interpretation","title":"Function-call like interpretation","text":"<p>The concrete interpreter is essentially a dispatcher of implementations for each statement in the IR. For dialect developers, the main task is to implement a method table, taking the <code>py.binop</code> dialect as an example:</p> <pre><code>from kirin import interp # (1)!\n\nfrom . import stmts # (2)!\nfrom ._dialect import dialect # (3)!\n\n@dialect.register # (4)!\nclass PyMethodTable(interp.MethodTable): # (4)!\n\n    @interp.impl(stmts.Add) # (5)!\n    def add(self, interp, frame: interp.Frame, stmt: stmts.Add): # (6)!\n        return (frame.get(stmt.lhs) + frame.get(stmt.rhs),) # (7)!\n</code></pre> <ol> <li>Import the <code>interp</code> module.</li> <li>Import the statements module. This is defined similarly as Declaring Statements.</li> <li>Import the dialect object. This is defined in a similar way as Declaring Dialect.</li> <li>Register the method table with the dialect. This will push the method table to the dialect's registry. By default this will be registered under the key <code>\"main\"</code>, equivalent to <code>@dialect.register(key=\"main\")</code>.</li> <li>Mark the method as an implementation of the <code>Add</code> statement. This can be dispatched on the type of the statement, e.g to only mark the implementation for <code>Add(Int, Int)</code>, you can write <code>@interp.impl(stmts.Add, types.Int, types.Int)</code>, where <code>types</code> can be imported by <code>from kirin import types</code>.</li> <li>While this is enforced, it is recommended to type hint the frame and the statement so you can get the hinting from the IDE. The <code>@interp.impl</code> decorator will also type check if the method signature is correct.</li> <li>In the actual implementation, <code>frame.get</code> is used to get the value of the operands. This will return the value of the operand if it is defined in the frame, otherwise it will raise an <code>InterpreterError</code>. Most of the case, the return value should be a <code>tuple</code> of the results of the statement. In this case, there is only one result, so it is returned as a single-element tuple.</li> </ol> <p>What is a frame?</p> <p>A frame is a mapping of <code>SSAValue</code> to their actual values. It represents the state of a function-like statement that cuts the scope of the variables. The frame is passed to the method table so that the interpreter can get the values of the operands from current frame.</p>"},{"location":"interp/#control-flow-statements","title":"Control flow statements","text":"<p>Except these \"normal\" statements that act more like a function call, there are also control flow statements. For example, the <code>Branch</code> statement from <code>cf</code> dialect, defined as follows (see also Declaring Statements):</p> <pre><code>@statement(dialect=dialect)\nclass Branch(Statement):\n    name = \"br\"\n    traits = frozenset({IsTerminator()})\n\n    arguments: tuple[SSAValue, ...]\n    successor: Block = info.block()\n</code></pre> <p>When interpreting a <code>Branch</code> statement, instead of actually executing something, we would like to instruct the interpreter to jump to a successor block. This is done by returning a special value <code>interp.Successor</code>:</p> <pre><code>@dialect.register\nclass CfMethods(MethodTable):\n\n    @impl(Branch)\n    def branch(self, interp: Interpreter, frame: Frame, stmt: Branch):\n        return Successor(stmt.successor, *frame.get_values(stmt.arguments))\n</code></pre> <p>Similar to <code>frame.get</code>, <code>frame.get_values</code> is a convenience method to get the values of multiple operands at once.</p> <p>What is a successor?</p> <p>A successor is a tuple of a block and the values to be passed to the block. The interpreter will use this information to jump to the block and pass the values to the block.</p> <p>Another special control flow statement is <code>ReturnValue</code>, unlike <code>interp.Successor</code> that jumps to another block, <code>ReturnValue</code> will let interpreter pop the current frame and return the values to the caller or finish the execution:</p> <pre><code>@dialect.register\nclass FuncMethods(MethodTable):\n\n    @impl(Return)\n    def return_(self, interp: Interpreter, frame: Frame, stmt: Return):\n        return interp.ReturnValue(*frame.get_values(stmt.values))\n</code></pre>"},{"location":"interp/#error-handling","title":"Error handling","text":"<p>Some statements will throw a runtime error, such as <code>cf.Assert</code> from the <code>cf</code> dialect, defined as follows:</p> <pre><code>@statement(dialect=dialect)\nclass Assert(Statement):\n    name = \"assert\"\n    condition: SSAValue\n    message: SSAValue = info.argument(String)\n</code></pre> <p>When interpreting an <code>Assert</code> statement, we need to check the condition and raise an error if it is false, this can be either returning the <code>interp.Err</code> object:</p> <pre><code>@dialect.register\nclass CfMethods(MethodTable):\n\n    @impl(Assert)\n    def assert_stmt(self, interp: Interpreter, frame: Frame, stmt: Assert):\n        if frame.get(stmt.condition) is True:\n            return ()\n\n        if stmt.message:\n            return Err(AssertionError(frame.get(stmt.message)), interp.state.frames)\n        else:\n            return Err(AssertionError(), interp.state.frames)\n</code></pre> <p>or raising an <code>InterpreterError</code>:</p> <pre><code>@dialect.register\nclass CfMethods(MethodTable):\n\n    @impl(Assert)\n    def assert_stmt(self, interp: Interpreter, frame: Frame, stmt: Assert):\n        if frame.get(stmt.condition) is True:\n            return ()\n\n        if stmt.message:\n            raise InterpreterError(frame.get(stmt.message))\n        else:\n            raise InterpreterError(\"assertion failed\")\n</code></pre>"},{"location":"interp/#running-the-interpreter","title":"Running the interpreter","text":"<p>To run the interpreter, you just need to pass the method to <code>eval</code>:</p> <pre><code>from kirin.interp import Interpreter\nfrom kirin.prelude import basic\ninterp = Interpreter(basic)\n\n@basic\ndef main(a: int, b: int) -&gt; int:\n    return a + b\n\ninterp.eval(main, 1, 2)\n</code></pre>"},{"location":"interp/#overlaying","title":"Overlaying","text":"<p>One of the most powerful features of the interpreter is overlaying. This allows you to override the implementation of a statement in a dialect by picking different order of method table lookup or even customize the method lookup. This is done by inheriting <code>Interpreter</code> and define the class variable <code>keys</code>:</p> <pre><code>class MyInterpreter(Interpreter):\n    keys = [\"my_overlay\", \"main\"]\n</code></pre> <p>When using this new <code>MyInterpreter</code>, the method lookup will first look for the methods registered in the <code>my_overlay</code> key. If the method is not found, it will fall back to the <code>main</code> key. This allows you to override the implementation of a statement in a dialect without modifying the dialect itself.</p> <p>We will talk about overlaying in abstract interpretation and analysis section which has more use cases.</p>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/2024/11/11/kirins-mission/","title":"Kirin's Mission","text":"<p>The field of scientific software has seen great development in the past decade. Scientists have been building more and more sophisticated simulators (quantum circuit simulators, differential equation solvers,  differentiable solvers), and many different human controlable physical systems (neutral atoms, trapped ions, superconducting qubits, optical lattices, etc) that may be used for multiple purposes.</p> <p>These impressive progress urges the need for a more sophisticated way to interact with these simulators and physical systems. Yes, it's not just about new hardware, computation, afterall, is about how to compile a problem description to human-controlable physical systems. In software community, a domain-specific language (DSL) and a corresponding compiler is the way to go. However, building a DSL and a compiler is a non-trivial task, and it is not something that scientists are familiar with.</p> <p>This is why we are building Kirin - we want to provide a set of tools for scientists to build their own DSLs and making their DSLs composable with each other. This article is to explain the mission of Kirin, and why we are building it.</p>"},{"location":"blog/2024/11/11/kirins-mission/#the-fragmentation-of-scientific-software","title":"The fragmentation of scientific software","text":"<p>I cannot talk about all scientific software, but software for quantum many-body system are already quite fragmented. For example, there are many different ways to represent sets of quantum operators system mathematically, such as tensor networks, quantum circuits, ZX diagrams<sup>1</sup>, operator table<sup>2</sup>, symbolic expressions, Quon<sup>3</sup>, etc. Each of these representations may result in a few different DSLs due to different design tradeoffs. In the lab, experimentalists also have different languages, such as pulse sequences, movings, QASM, QIR, etc. Almost every university lab has their own representation of the device, depsite of the sanity (e.g see last section). People have often been thinking if we can create a unified representation for all these problems, but it is not easy. Instead, the dream is: if we can make representations composable, we can build a unified representation by composing different representations from the experts.</p> <p>We, at QuEra Computing Inc., naturally falls into this fragmentation problem, and thus have many duplicated representations in the past. Then the question is, how can we improve composability? There are already an answer in the software engineering community, which is the Multi-Level Intermediate Representation (MLIR). I like MLIR, but we are not using it. I will explain why.</p>"},{"location":"blog/2024/11/11/kirins-mission/#why-didnt-use-x","title":"Why didn't use X?","text":"<p>This is a common question that one may ask when they see a new project. Here are some reasons why we are not using previous work.</p>"},{"location":"blog/2024/11/11/kirins-mission/#why-not-use-mlir","title":"Why not use MLIR?","text":"<p>We have been trying to adopt MLIR since 2021, and we found that MLIR is a great project, but it is not easy to use for scientists. The scope of compilation problems that MLIR is trying to solve is too broad, and thus the complexity of the project is inevitably high. More specifically, we do not care about:</p> <ul> <li>low-level semantics</li> <li>traditional hardware targets</li> <li>high-quality native binary</li> <li>roundtrip-able IR text format</li> <li>speed of the compiler or the generated code <sup>4</sup></li> </ul> <p>We do care about:</p> <ul> <li>high-level semantics</li> <li>new optimization techniques for the scientific problems</li> <li>interpretation and JIT compilation</li> <li>a frontend that is easy to use for scientists</li> </ul> <p>In the quantum computing community, we have seen a lot of projects that are trying to build a quantum DSL and a compiler using MLIR. However, everyone will build</p> <ul> <li>their own set of dialects, including control-flow dialects</li> <li>Python frontend for the DSL</li> <li>another infrastructure to write IR passes in Python</li> </ul> <p>This is mainly because how to compile such program is still under research. Thus we expect normal scientists (e.g theoretical/experimental physicists) to write compiler passes. And it is impossible for them to learn MLIR within one week. As a result, MLIR was never adopted by broader quantum community.</p> <p>A few existing compilers focus on building an eDSL in Python then JIT compile the kernel to native binary. However, at least in our case, we have to decompile such native binary back to a JSON in order to run the program on a Python-based control system. It turns out what is really needed for a lot of scientists is:</p> <ul> <li>a way to write a high-level eDSL in Python (model of the problem)</li> <li>then run some rewrites (problem simplification/compilation)</li> <li>run it with an interpreter (model execution)</li> <li>optionally compile it to another IR then run it with another interpreter. (simulation)</li> </ul> <p>This seems to be the case not only for quantum physicists but other scientists such as the original machine-learning engineer's use case in supporting interpreter framework in MLIR. To support such use case, because MLIR needs to consider a lot more complicated senarios, it will take a lot of thinking to do it right.</p> <p>Big entities with sufficient bandwidth can afford doing this by hiring a lot of engineers with professional compiler engineering background, but for small companies and individual researchers, this is not feasible. We see the issue is due to the complexity of a generic problem, and the lack of involvement of scientists in the design of a compiler infrastructure. We believe that the solution is to build a more user-friendly compiler infrastructure by scientists for scientists. This is possible by limiting the program to</p> <ul> <li>only kernel functions (program size are small)</li> <li>only existing langauge (e.g Python) frontend (so that we can focus on designing composable lowering framework)</li> <li>focus on interpretation (or abstract interpretation), turn every compilation into different interpretation steps</li> <li>focus on Python-like type system</li> </ul>"},{"location":"blog/2024/11/11/kirins-mission/#why-not-use-xdsl","title":"Why not use xDSL?","text":"<p>Ok, after we have decided not to use MLIR, we were excited to see this project called xDSL around late 2023 and tried to play with it. However, we found that the project is still sophisticated for scientists to use. Mostly because the project is built by professional compiler engineers with a great familarity of MLIR. This is an advantage for the project to be able to support a wide range of problems and being able to interop with MLIR. The project is great, if you are interested in a friendlier version of MLIR in Python, you should definitely check it out. However, as a result, the priority of the project is not to build something scientists can get started with in a few days. What was missing from our wishlist is:</p> <ul> <li>composable Python lowering (e.g Python syntax claims from different dialects)</li> <li>different ways of interpretation (e.g abstract interpretation)</li> <li>Python type system instead of MLIR type attributes</li> <li>dialects that supports Python semantics instead of MLIR dialects</li> </ul> <p>while maybe eventually this would be in xDSL but more realistically, because the focus is quite different and xDSL was also new, the priorities are different.</p>"},{"location":"blog/2024/11/11/kirins-mission/#why-not-julia-compiler-plugin","title":"Why not Julia compiler plugin?","text":"<p>For those who are familiar with my past work, I have been working with Julia since 2015. This is a great language for scientific computing, and scientists with performance needs definitely love it. And in fact, the idea of building some infrastructure to help scientists to build their own DSLs and compilers was initially from the Julia community because of automatic differentiation and sparsity optimization (check the CompilerPlugin org and Symbolics+ModelingToolkit). To enable automatic differentiation, we also end up building a small DSL in Yao to represent quantum circuits. In fact, to support automatic differentiation well, a lot of packages end up building their own DSLs and compilers.</p> <p>However, when I start moving towards a compiler for quantum circuit (YaoCompiler), the instability of the Julia compiler internal API quickly becomes a problem. On the other hand, the Julia SSA IR was not designed for custom DSLs, e.g it does not have the region semantics to represent hierarchical IRs, and it does not have the abstraction of dialects to allow composing different DSLs. While we have seen some promising progress in MLIR.jl, the project is still in its early stage.</p> <p>On the other hand, I do get jelous of how Julia compiler solve the dynamic language compilation problem, thus I learnt a lot from the Julia compiler and the Julia compiler plugin. This results in the design of the Kirin type system, and the abstract interpretation framework. <sup>5</sup></p> <p>Python has been a hard requirement for us in building production software. But I reserve the right to use Julia to rewrite certain components of Kirin in the future.</p>"},{"location":"blog/2024/11/11/kirins-mission/#why-not-use-jaxpr","title":"Why not use JAXPR?","text":"<p>JAX is a great project for automatic differentiation and scientific computing. I have been using it extensively for a few projects. While it is true that JAXPR covers a wide range of scientific computing tasks, it is not designed for more complicated tasks like quantum compilation, especially when you work at levels lower than quantum circuits. The limitation of JAX is intentionally designed to allow only tracing-based compilation, thus it does not support native Python control flows, and may not have clear function barriers in the traced program unless you use <code>jit</code> to separate them. The runtime value is restricted to JAX arrays, etc. These tradeoffs may not always be suitable for building a quantum program. The JAX compiler is designed for differentiable/machine-learning linear algebra programs afterall.</p>"},{"location":"blog/2024/11/11/kirins-mission/#how-would-kirin-be-different","title":"How would Kirin be different?","text":"<p>While Kirin draws inspiration from MLIR, xDSL, Julia compiler plugin, and JAXPR, we aim to build a more user-friendly compiler infrastructure for scientists to solve their specific problems. There are nothing fundamentally new in theory, but the combination is new. Here are some key differences:</p> <p>Composable Python Lowering, in our beer-lang example, the kernel decorator <code>@beer</code> is just a <code>DialectGroup</code> object that contains the <code>Dialect</code> objects you specified to include for the frontend. The Python syntax just maginally works! This is because Kirin features a composable lowering system that allows you to claim Python syntax from each separate dialect. When combining the dialects together, Kirin will be able to compile each Python syntax to the corresponding IR nodes, e.g</p> <ul> <li><code>func</code> dialect claims function related syntax: the <code>ast.FunctionDef</code>, nested <code>ast.FunctionDef</code> (as closures), <code>ast.Call</code>, <code>ast.Return</code>, etc.</li> <li><code>cf</code> (unstructured control flow) dialect claims control flow related syntax: <code>ast.If</code>, <code>assert</code>.</li> <li><code>math</code> dialect claims python builtin math functions</li> <li><code>py.stmts</code> claims miscellaneous other Python statements, e.g assignment, comparison, slice, range, etc.</li> </ul> <p>You can define your own lowering rules for new dialects, and compose with other dialects to build your own frontend.</p> <p>Abstract Interpretation, inspired by Julia abstract interpreter, Kirin features a simple abstract interpretation framework that allows you to define how to interpret your own dialects on a given lattice. This allows Kirin to perform analysis such as constant propagation and type inference on your program. For example, like Julia, Kirin can perform constant propagation interprocedurally, and infer the types of your program, and this is composable with new dialects.</p> <p>Python Type System, based on the abstract interpretation framework, the <code>py.types</code> dialect defines a Python type system as Kirin type attributes. This allows dynamic and generic definitions of dialects. This becomes quite useful defining high-level Python-like semantics, such as a statement taking a list of integers, or a statement taking a callable object. Taking the example from tests, you can just write the following in your frontend and let Kirin figure out the types</p> <pre><code>@basic\ndef foo(x: int):\n    if x &gt; 1:\n        return x + 1\n    else:\n        return x - 1.0\n\n\n@basic(typeinfer=True)\ndef main(x: int):\n    return foo(x)\n\n\n@basic(typeinfer=True)\ndef moo(x):\n    return foo(x)\n</code></pre> <p>prints the following</p> <pre><code>moo.print()\n</code></pre> <p></p> <p>while <code>py.types</code> supports generics, the type inference is still work-in-progress on generics.</p> <p>IR Declaration Decorators, like <code>xDSL</code>, Kirin also provides the <code>statement</code> decorator to declare a new IR statement. However, the difference is Kirin focus on reducing extra terminologies and concepts that are not familiar to scientists with the cost of being more entangled with Python. The <code>statement</code> decorator is designed to be <code>@dataclass</code>-like, which is what scientists are familiar with. This is the only decorator one needs to know. Fields declared with native Python types are automatically converted to Kirin attributes via the Python type system.</p> <p>Taking an example from xDSL, you would define <code>Func</code> as</p> <pre><code>@irdl_op_definition\nclass FuncOp(IRDLOperation):\n    name = \"func.func\"\n\n    body = region_def()\n    sym_name = prop_def(StringAttr)\n    function_type = prop_def(FunctionType)\n    sym_visibility = opt_prop_def(StringAttr)\n    arg_attrs = opt_prop_def(ArrayAttr[DictionaryAttr])\n    res_attrs = opt_prop_def(ArrayAttr[DictionaryAttr])\n\n    traits = traits_def(\n        IsolatedFromAbove(), SymbolOpInterface(), FuncOpCallableInterface()\n    )\n</code></pre> <p>and you will need to define <code>__init__</code> etc. in the following. In Kirin, you would define <code>Func</code> as</p> <pre><code>@statement(dialect=dialect)\nclass Function(Statement):\n    name = \"func\"\n    traits = frozenset(\n        {\n            IsolatedFromAbove(),\n            SymbolOpInterface(),\n            HasSignature(),\n            FuncOpCallableInterface(),\n            SSACFGRegion(),\n        }\n    )\n    sym_name: str = info.attribute(property=True)\n    signature: Signature = info.attribute()\n    body: Region = info.region(multi=True)\n</code></pre> <p>which is a more <code>@dataclass</code>-like definition, where fields with types are instance fields, and fields without types are (class) properties. The <code>@statement</code> also generates the corresponding <code>__init__</code> etc. just like a <code>@dataclass</code> (and your linter understands it!).</p>"},{"location":"blog/2024/11/11/kirins-mission/#conclusion","title":"Conclusion","text":"<p>When we start thinking about these scientific problems seriously, there seems not many in the software engineering community that would worry about the scientists. The scientists are living with a lot of workaround solutions, including but not limited to \"define the language as a string, where each character represents an operation/statement, then let a human perform the control-flow\" (the man in-the-loop). The compiler community are often excited about programming language for everything. However, for scientific community, especially nature science, there seems to be a big gap between the compiler community and the natural-science community (e.g a physicist like me) to make this come true.</p> <p>Kirin in its current form, may not be perfect (likely). However, we hope we can share this same vision for the scientific software community. So that Kirin, as a vision, can bridge this gap and help scientists to push the boundary of science with scientific software.</p> <ol> <li> <p>ZX diagrams can be seen as tensor networks too, but the implementation is usually different data structure.\u00a0\u21a9</p> </li> <li> <p>Aaronson's stabilizer table, stochastic series expansion's operator table, etc.\u00a0\u21a9</p> </li> <li> <p>Quon is a 3D representation of quantum operators.\u00a0\u21a9</p> </li> <li> <p>this does not mean the program execution has to be very slow, e.g we can generate a different set of high-level IR that can be interpreted quickly (via optimized instruction implementation, etc.).\u00a0\u21a9</p> </li> <li> <p>Kirin does not support multiple dispatch at the moment, this may be added in the future. I'm hesitating to add multiple dispatch because this turns out less useful for kernels because they can be embeded in host language abstraction most of the time.\u00a0\u21a9</p> </li> </ol>"},{"location":"cookbook/","title":"Index","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"dialects/cf/","title":"Control Flow","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"dialects/func/","title":"Function","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"dialects/ilist/","title":"Immutable List","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"dialects/python/","title":"Python","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"reference/kirin/","title":"Index","text":""},{"location":"reference/kirin/#kirin.statement","title":"statement","text":"<pre><code>statement(\n    cls=None, **kwargs: Unpack[StatementOptions]\n) -&gt; Callable[[type[StmtType]], type[StmtType]]\n</code></pre> <p>Declare a new statement class.</p> <p>This decorator is used to declare a new statement class. It is used to generate the necessary boilerplate code for the class. The class should inherit from <code>kirin.ir.Statement</code>.</p> <p>Parameters:</p> Name Type Description Default <code>init(bool)</code> <p>Whether to generate an <code>__init__</code> method.</p> required <code>repr(bool)</code> <p>Whether to generate a <code>__repr__</code> method.</p> required <code>kw_only(bool)</code> <p>Whether to use keyword-only arguments in the <code>__init__</code> method.</p> required <code>dialect(Optional[Dialect])</code> <p>The dialect of the statement.</p> required <code>property(bool)</code> <p>Whether to generate property methods for attributes.</p> required Example <p>The following is an example of how to use the <code>statement</code> decorator.</p> <pre><code># optionally register the statement with\n# @statement(dialect=my_dialect_object)\n@statement\nclass MyStatement(ir.Statement):\n    name = \"some_name\"\n    traits = frozenset({TraitA(), TraitB()})\n    some_input: ir.SSAValue = info.argument()\n    some_output: ir.ResultValue = info.result()\n    body: ir.Region = info.region()\n    successor: ir.Block = info.block()\n</code></pre> Source code in <code>src/kirin/decl/__init__.py</code> <pre><code>@dataclass_transform(\n    field_specifiers=(\n        info.attribute,\n        info.argument,\n        info.region,\n        info.result,\n        info.block,\n    )\n)\ndef statement(\n    cls=None,\n    **kwargs: Unpack[StatementOptions],\n) -&gt; Callable[[type[StmtType]], type[StmtType]]:\n    \"\"\"Declare a new statement class.\n\n    This decorator is used to declare a new statement class. It is used to\n    generate the necessary boilerplate code for the class. The class should\n    inherit from `kirin.ir.Statement`.\n\n    Args:\n        init(bool): Whether to generate an `__init__` method.\n        repr(bool): Whether to generate a `__repr__` method.\n        kw_only(bool): Whether to use keyword-only arguments in the `__init__`\n            method.\n        dialect(Optional[Dialect]): The dialect of the statement.\n        property(bool): Whether to generate property methods for attributes.\n\n    Example:\n        The following is an example of how to use the `statement` decorator.\n\n        ```python\n        # optionally register the statement with\n        # @statement(dialect=my_dialect_object)\n        @statement\n        class MyStatement(ir.Statement):\n            name = \"some_name\"\n            traits = frozenset({TraitA(), TraitB()})\n            some_input: ir.SSAValue = info.argument()\n            some_output: ir.ResultValue = info.result()\n            body: ir.Region = info.region()\n            successor: ir.Block = info.block()\n        ```\n    \"\"\"\n\n    def wrap(cls):\n        decl = StatementDecl(cls, **kwargs)\n        decl.scan_fields()\n        decl.verify()\n        decl.emit()\n        decl.register()\n        return cls\n\n    if cls is None:\n        return wrap\n    return wrap(cls)\n</code></pre>"},{"location":"reference/kirin/exceptions/","title":"Exceptions","text":""},{"location":"reference/kirin/graph/","title":"Graph","text":""},{"location":"reference/kirin/graph/#kirin.graph.Graph","title":"Graph","text":"<p>               Bases: <code>Protocol</code>, <code>Generic[Node]</code></p> <p>The graph interface.</p> <p>This interface defines the methods that a graph object must implement. The graph interface is mainly for compatibility reasons so that one can use multiple graph implementations interchangeably.</p>"},{"location":"reference/kirin/graph/#kirin.graph.Graph.get_edges","title":"get_edges","text":"<pre><code>get_edges() -&gt; Iterable[tuple[Node, Node]]\n</code></pre> <p>Get all the edges in the graph.</p> Source code in <code>src/kirin/graph.py</code> <pre><code>def get_edges(self) -&gt; Iterable[tuple[Node, Node]]:\n    \"\"\"Get all the edges in the graph.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/graph/#kirin.graph.Graph.get_neighbors","title":"get_neighbors","text":"<pre><code>get_neighbors(node: Node) -&gt; Iterable[Node]\n</code></pre> <p>Get the neighbors of a node.</p> Source code in <code>src/kirin/graph.py</code> <pre><code>def get_neighbors(self, node: Node) -&gt; Iterable[Node]:\n    \"\"\"Get the neighbors of a node.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/graph/#kirin.graph.Graph.get_nodes","title":"get_nodes","text":"<pre><code>get_nodes() -&gt; Iterable[Node]\n</code></pre> <p>Get all the nodes in the graph.</p> Source code in <code>src/kirin/graph.py</code> <pre><code>def get_nodes(self) -&gt; Iterable[Node]:\n    \"\"\"Get all the nodes in the graph.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/idtable/","title":"IdTable","text":""},{"location":"reference/kirin/idtable/#kirin.idtable.IdTable","title":"IdTable  <code>dataclass</code>","text":"<pre><code>IdTable(\n    prefix: str = \"%\",\n    table: dict[T, str] = dict(),\n    name_count: dict[str, int] = dict(),\n    next_id: int = 0,\n    prefix_if_none: str = \"\",\n)\n</code></pre> <p>               Bases: <code>Generic[T]</code></p> <p>A table that maps values to \"human readable\" unique names. This is used for IR printing and code generation of SSA values and basic blocks, or anything else required to have a unique name.</p>"},{"location":"reference/kirin/idtable/#kirin.idtable.IdTable--example","title":"Example","text":"<pre><code>from kirin import ir\nfrom kirin.idtable import IdTable\ntable = IdTable()\nx = ir.TestValue()\ntable[x] # \"%0\"\ntable[x] # \"%0\"\ny = ir.TestValue()\ntable[y] # \"%1\"\n</code></pre>"},{"location":"reference/kirin/idtable/#kirin.idtable.IdTable.name_count","title":"name_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name_count: dict[str, int] = field(default_factory=dict)\n</code></pre> <p>The count of names that have been generated.</p>"},{"location":"reference/kirin/idtable/#kirin.idtable.IdTable.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id: int = 0\n</code></pre> <p>The next ID to use for generating names.</p>"},{"location":"reference/kirin/idtable/#kirin.idtable.IdTable.prefix","title":"prefix  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>prefix: str = '%'\n</code></pre> <p>The prefix to use for generated names.</p>"},{"location":"reference/kirin/idtable/#kirin.idtable.IdTable.prefix_if_none","title":"prefix_if_none  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>prefix_if_none: str = ''\n</code></pre> <p>An alternate prefix to use when the name is None.</p>"},{"location":"reference/kirin/idtable/#kirin.idtable.IdTable.table","title":"table  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>table: dict[T, str] = field(default_factory=dict)\n</code></pre> <p>The table that maps values to names.</p>"},{"location":"reference/kirin/idtable/#kirin.idtable.IdTable.add","title":"add","text":"<pre><code>add(value: T) -&gt; str\n</code></pre> <p>Add a value to the table and return the name.</p> Source code in <code>src/kirin/idtable.py</code> <pre><code>def add(self, value: T) -&gt; str:\n    \"\"\"Add a value to the table and return the name.\"\"\"\n    id = self.next_id\n    if (value_name := getattr(value, \"name\", None)) is not None:\n        curr_ind = self.name_count.get(value_name, 0)\n        suffix = f\"_{curr_ind}\" if curr_ind != 0 else \"\"\n        self.name_count[value_name] = curr_ind + 1\n        name = self.prefix + value_name + suffix\n        self.table[value] = name\n    else:\n        name = f\"{self.prefix}{self.prefix_if_none}{id}\"\n        self.next_id += 1\n        self.table[value] = name\n    return name\n</code></pre>"},{"location":"reference/kirin/prelude/","title":"Prelude","text":"<p>This module contains some common eDSLs that can be used to build more complex eDSLs. The eDSLs in this module are built on top of the basic dialects provided by the <code>kirin.dialects</code> module.</p>"},{"location":"reference/kirin/prelude/#kirin.prelude.basic","title":"basic","text":"<pre><code>basic(self)\n</code></pre> <p>The basic kernel.</p> <p>This eDSL includes the basic dialects and the basic optimization passes. Other eDSL can usually be built on top of this eDSL by utilizing the <code>basic.add</code> method to add more dialects and optimization passes.</p> <p>See also <code>basic_no_opt</code> for the basic kernel without optimization passes.</p>"},{"location":"reference/kirin/prelude/#kirin.prelude.basic--example","title":"Example","text":"<pre><code>from kirin.prelude import basic\n\n@basic(typeinfer=True)\ndef main(x: int) -&gt; int:\n    return x + 1 + 1\n\nmain.print() # main is a Method!\n</code></pre> Source code in <code>src/kirin/prelude.py</code> <pre><code>@dialect_group(basic_no_opt)\ndef basic(self):\n    \"\"\"The basic kernel.\n\n    This eDSL includes the basic dialects and the basic optimization passes.\n    Other eDSL can usually be built on top of this eDSL by utilizing the\n    `basic.add` method to add more dialects and optimization passes.\n\n    See also [`basic_no_opt`][kirin.prelude.basic_no_opt] for the basic kernel without optimization passes.\n\n    ## Example\n\n    ```python\n    from kirin.prelude import basic\n\n    @basic(typeinfer=True)\n    def main(x: int) -&gt; int:\n        return x + 1 + 1\n\n    main.print() # main is a Method!\n    ```\n    \"\"\"\n    fold_pass = Fold(self)\n    ilist_desugar = ilist.IListDesugar(self)\n    aggressive_fold_pass = aggressive.Fold(self)\n    typeinfer_pass = TypeInfer(self)\n\n    def run_pass(\n        mt: Annotated[Method, Doc(\"The method to run pass on.\")],\n        *,\n        verify: Annotated[\n            bool, Doc(\"run `verify` before running passes, default is `True`\")\n        ] = True,\n        typeinfer: Annotated[\n            bool,\n            Doc(\n                \"run type inference and apply the inferred type to IR, default `False`\"\n            ),\n        ] = False,\n        fold: Annotated[bool, Doc(\"run folding passes\")] = True,\n        aggressive: Annotated[\n            bool, Doc(\"run aggressive folding passes if `fold=True`\")\n        ] = False,\n    ) -&gt; None:\n        if verify:\n            mt.verify()\n\n        ilist_desugar.fixpoint(mt)\n\n        if fold:\n            if aggressive:\n                aggressive_fold_pass.fixpoint(mt)\n            else:\n                fold_pass(mt)\n\n        if typeinfer:\n            typeinfer_pass(mt)\n\n    return run_pass\n</code></pre>"},{"location":"reference/kirin/prelude/#kirin.prelude.basic_no_opt","title":"basic_no_opt","text":"<pre><code>basic_no_opt(self)\n</code></pre> <p>The basic kernel without optimization passes. This is a builtin eDSL that includes the basic dialects that are commonly used in Python-like eDSLs.</p> <p>This eDSL includes the basic dialects without any optimization passes. Other eDSL can usually be built on top of this eDSL by utilizing the <code>basic_no_opt.add</code> method to add more dialects and optimization passes.</p> <p>Note that unlike Python, list in this eDSL is immutable, and the <code>append</code> method is not available. Use <code>+</code> operator to concatenate lists instead. Immutable list is easier to optimize and reason about.</p> <p>See also <code>basic</code> for the basic kernel with optimization passes. See also <code>ilist</code> for the immutable list dialect.</p> Source code in <code>src/kirin/prelude.py</code> <pre><code>@dialect_group(python_basic.union([ilist, range, slice, cf, func, math]))\ndef basic_no_opt(self):\n    \"\"\"The basic kernel without optimization passes. This is a builtin\n    eDSL that includes the basic dialects that are commonly used in\n    Python-like eDSLs.\n\n    This eDSL includes the basic dialects without any optimization passes.\n    Other eDSL can usually be built on top of this eDSL by utilizing the\n    `basic_no_opt.add` method to add more dialects and optimization passes.\n\n    Note that unlike Python, list in this eDSL is immutable, and the\n    `append` method is not available. Use `+` operator to concatenate lists\n    instead. Immutable list is easier to optimize and reason about.\n\n    See also [`basic`][kirin.prelude.basic] for the basic kernel with optimization passes.\n    See also [`ilist`][kirin.dialects.ilist] for the immutable list dialect.\n    \"\"\"\n    ilist_desugar = ilist.IListDesugar(self)\n\n    def run_pass(mt: Method) -&gt; None:\n        ilist_desugar.fixpoint(mt)\n\n    return run_pass\n</code></pre>"},{"location":"reference/kirin/prelude/#kirin.prelude.python_basic","title":"python_basic","text":"<pre><code>python_basic(self)\n</code></pre> <p>The basic Python dialect without list, range, and slice.</p> Source code in <code>src/kirin/prelude.py</code> <pre><code>@dialect_group(\n    [\n        base,\n        binop,\n        cmp,\n        unary,\n        assign,\n        attr,\n        boolop,\n        builtin,\n        constant,\n        indexing,\n        len,\n        tuple,\n    ]\n)\ndef python_basic(self):\n    \"\"\"The basic Python dialect without list, range, and slice.\"\"\"\n\n    def run_pass(mt: Method) -&gt; None:\n        pass\n\n    return run_pass\n</code></pre>"},{"location":"reference/kirin/prelude/#kirin.prelude.python_no_opt","title":"python_no_opt","text":"<pre><code>python_no_opt(self)\n</code></pre> <p>The Python dialect without optimization passes.</p> Source code in <code>src/kirin/prelude.py</code> <pre><code>@dialect_group(python_basic.union([list, range, slice, cf, func, math]))\ndef python_no_opt(self):\n    \"\"\"The Python dialect without optimization passes.\"\"\"\n\n    def run_pass(mt: Method) -&gt; None:\n        pass\n\n    return run_pass\n</code></pre>"},{"location":"reference/kirin/registry/","title":"Registry","text":""},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter","title":"BaseInterpreter  <code>dataclass</code>","text":"<pre><code>BaseInterpreter(\n    dialects: DialectGroup,\n    *,\n    fuel: int | None = None,\n    debug: bool = False,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192\n)\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[FrameType, ValueType]</code></p> <p>A base class for interpreters.</p> <p>This class defines the basic structure of an interpreter. It is designed to be subclassed to provide the actual implementation of the interpreter.</p> <p>When subclassing, if the bases contains <code>ABC</code> no checks will be performed on the subclass. If the subclass does not contain <code>ABC</code>, the subclass must define the following attributes:</p> <ul> <li><code>keys</code>: a list of strings that defines the order of dialects to select from.</li> <li><code>void</code>: the value to return when the interpreter evaluates nothing.</li> </ul>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.debug","title":"debug  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug: bool = field(default=False, kw_only=True)\n</code></pre> <p>Whether to enable debug mode.</p>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.dialects","title":"dialects  <code>instance-attribute</code>","text":"<pre><code>dialects: DialectGroup\n</code></pre> <p>The dialects to interpret.</p>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.fuel","title":"fuel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fuel: int | None = field(default=None, kw_only=True)\n</code></pre> <p>The fuel limit for the interpreter.</p>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.keys","title":"keys  <code>class-attribute</code>","text":"<pre><code>keys: list[str]\n</code></pre> <p>The name of the interpreter to select from dialects by order.</p>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.max_depth","title":"max_depth  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_depth: int = field(default=128, kw_only=True)\n</code></pre> <p>The maximum depth of the interpreter stack.</p>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.max_python_recursion_depth","title":"max_python_recursion_depth  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_python_recursion_depth: int = field(\n    default=8192, kw_only=True\n)\n</code></pre> <p>The maximum recursion depth of the Python interpreter.</p>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.registry","title":"registry  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>registry: InterpreterRegistry = field(\n    init=False, compare=False\n)\n</code></pre> <p>The interpreter registry.</p>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.state","title":"state  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>state: InterpreterState[FrameType] = field(\n    init=False, compare=False\n)\n</code></pre> <p>The interpreter state.</p>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.symbol_table","title":"symbol_table  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol_table: dict[str, Statement] = field(\n    init=False, compare=False\n)\n</code></pre> <p>The symbol table.</p>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.void","title":"void  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>void: ValueType = field(init=False)\n</code></pre> <p>What to return when the interpreter evaluates nothing.</p>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.build_signature","title":"build_signature","text":"<pre><code>build_signature(\n    frame: FrameType, stmt: Statement\n) -&gt; Signature\n</code></pre> <p>build signature for querying the statement implementation.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def build_signature(self, frame: FrameType, stmt: Statement) -&gt; \"Signature\":\n    \"\"\"build signature for querying the statement implementation.\"\"\"\n    return Signature(stmt.__class__, tuple(arg.type for arg in stmt.args))\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.eval_stmt","title":"eval_stmt","text":"<pre><code>eval_stmt(\n    frame: FrameType, stmt: Statement\n) -&gt; StatementResult[ValueType]\n</code></pre> <p>Run a statement within the current frame. This is the entry point of running a statement. It will look up the statement implementation in the dialect registry, or optionally call a fallback implementation.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>FrameType</code> <p>the current frame</p> required <code>stmt</code> <code>Statement</code> <p>the statement to run</p> required <p>Returns:</p> Name Type Description <code>StatementResult</code> <code>StatementResult[ValueType]</code> <p>the result of running the statement</p> Note <p>Overload this method for the following reasons: - to change the source tracking information - to take control of how to run a statement - to change the implementation lookup behavior that cannot acheive     by overloading <code>lookup_registry</code></p> Example <ul> <li>implement an interpreter that only handles MyStmt: <pre><code>    class MyInterpreter(BaseInterpreter):\n        ...\n        def eval_stmt(self, frame: FrameType, stmt: Statement) -&gt; StatementResult[ValueType]:\n            if isinstance(stmt, MyStmt):\n                return self.run_my_stmt(frame, stmt)\n            else:\n                return ()\n</code></pre></li> </ul> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def eval_stmt(\n    self, frame: FrameType, stmt: Statement\n) -&gt; StatementResult[ValueType]:\n    \"\"\"Run a statement within the current frame. This is the entry\n    point of running a statement. It will look up the statement implementation\n    in the dialect registry, or optionally call a fallback implementation.\n\n    Args:\n        frame: the current frame\n        stmt: the statement to run\n\n    Returns:\n        StatementResult: the result of running the statement\n\n    Note:\n        Overload this method for the following reasons:\n        - to change the source tracking information\n        - to take control of how to run a statement\n        - to change the implementation lookup behavior that cannot acheive\n            by overloading [`lookup_registry`][kirin.interp.base.BaseInterpreter.lookup_registry]\n\n    Example:\n        * implement an interpreter that only handles MyStmt:\n        ```python\n            class MyInterpreter(BaseInterpreter):\n                ...\n                def eval_stmt(self, frame: FrameType, stmt: Statement) -&gt; StatementResult[ValueType]:\n                    if isinstance(stmt, MyStmt):\n                        return self.run_my_stmt(frame, stmt)\n                    else:\n                        return ()\n        ```\n\n    \"\"\"\n    # TODO: update tracking information\n    method = self.lookup_registry(frame, stmt)\n    if method is not None:\n        results = method(self, frame, stmt)\n        if self.debug and not isinstance(results, (tuple, SpecialValue)):\n            raise InterpreterError(\n                f\"method must return tuple or SpecialResult, got {results}\"\n            )\n        return results\n\n    return self.eval_stmt_fallback(frame, stmt)\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.eval_stmt_fallback","title":"eval_stmt_fallback","text":"<pre><code>eval_stmt_fallback(\n    frame: FrameType, stmt: Statement\n) -&gt; StatementResult[ValueType]\n</code></pre> <p>The fallback implementation of statements.</p> <p>This is called when no implementation is found for the statement.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>FrameType</code> <p>the current frame</p> required <code>stmt</code> <code>Statement</code> <p>the statement to run</p> required <p>Returns:</p> Name Type Description <code>StatementResult</code> <code>StatementResult[ValueType]</code> <p>the result of running the statement</p> Note <p>Overload this method to provide a fallback implementation for statements.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def eval_stmt_fallback(\n    self, frame: FrameType, stmt: Statement\n) -&gt; StatementResult[ValueType]:\n    \"\"\"The fallback implementation of statements.\n\n    This is called when no implementation is found for the statement.\n\n    Args:\n        frame: the current frame\n        stmt: the statement to run\n\n    Returns:\n        StatementResult: the result of running the statement\n\n    Note:\n        Overload this method to provide a fallback implementation for statements.\n    \"\"\"\n    # NOTE: not using f-string here because 3.10 and 3.11 have\n    #  parser bug that doesn't allow f-string in raise statement\n    raise ValueError(\n        \"no implementation for stmt \"\n        + stmt.print_str(end=\"\")\n        + \" from \"\n        + str(type(self))\n    )\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.finalize","title":"finalize","text":"<pre><code>finalize(frame: FrameType, results: ValueType) -&gt; ValueType\n</code></pre> <p>Postprocess a frame after it is popped from the stack. This is called after a method is evaluated and the frame is popped.</p> Note <p>Default implementation does nothing.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def finalize(self, frame: FrameType, results: ValueType) -&gt; ValueType:\n    \"\"\"Postprocess a frame after it is popped from the stack. This is\n    called after a method is evaluated and the frame is popped.\n\n    Note:\n        Default implementation does nothing.\n    \"\"\"\n    return results\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.initialize","title":"initialize","text":"<pre><code>initialize() -&gt; Self\n</code></pre> <p>Initialize the interpreter global states.</p> <p>This method is called before calling <code>eval</code> to initialize the interpreter global states.</p> <p>Override this method to add custom global states.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def initialize(self) -&gt; Self:\n    \"\"\"Initialize the interpreter global states.\n\n    This method is called before calling `eval` to initialize the\n    interpreter global states.\n\n    Override this method to add custom global states.\n    \"\"\"\n    self.symbol_table: dict[str, Statement] = {}\n    self.state: InterpreterState[FrameType] = InterpreterState()\n    return self\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.new_frame","title":"new_frame  <code>abstractmethod</code>","text":"<pre><code>new_frame(code: Statement) -&gt; FrameType\n</code></pre> <p>Create a new frame for the given method.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>@abstractmethod\ndef new_frame(self, code: Statement) -&gt; FrameType:\n    \"\"\"Create a new frame for the given method.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.permute_values","title":"permute_values  <code>staticmethod</code>","text":"<pre><code>permute_values(\n    arg_names: Sequence[str],\n    values: tuple[ValueType, ...],\n    kwarg_names: tuple[str, ...],\n) -&gt; tuple[ValueType, ...]\n</code></pre> <p>Permute the arguments according to the method signature and the given keyword arguments, where the keyword argument names refer to the last n arguments in the values tuple.</p> <p>Parameters:</p> Name Type Description Default <code>arg_names</code> <code>Sequence[str]</code> <p>the argument names</p> required <code>values</code> <code>tuple[ValueType, ...]</code> <p>the values tuple (should not contain method itself)</p> required <code>kwarg_names</code> <code>tuple[str, ...]</code> <p>the keyword argument names</p> required Source code in <code>src/kirin/interp/base.py</code> <pre><code>@staticmethod\ndef permute_values(\n    arg_names: Sequence[str],\n    values: tuple[ValueType, ...],\n    kwarg_names: tuple[str, ...],\n) -&gt; tuple[ValueType, ...]:\n    \"\"\"Permute the arguments according to the method signature and\n    the given keyword arguments, where the keyword argument names\n    refer to the last n arguments in the values tuple.\n\n    Args:\n        arg_names: the argument names\n        values: the values tuple (should not contain method itself)\n        kwarg_names: the keyword argument names\n    \"\"\"\n    n_total = len(values)\n    if kwarg_names:\n        kwargs = dict(zip(kwarg_names, values[n_total - len(kwarg_names) :]))\n    else:\n        kwargs = None\n\n    positionals = values[: n_total - len(kwarg_names)]\n    args = BaseInterpreter.get_args(\n        arg_names[len(positionals) + 1 :], positionals, kwargs\n    )\n    return args\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.run","title":"run","text":"<pre><code>run(\n    mt: Method,\n    args: tuple[ValueType, ...],\n    kwargs: dict[str, ValueType] | None = None,\n) -&gt; Result[ValueType]\n</code></pre> <p>Run a method.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def run(\n    self,\n    mt: Method,\n    args: tuple[ValueType, ...],\n    kwargs: dict[str, ValueType] | None = None,\n) -&gt; Result[ValueType]:\n    \"\"\"Run a method.\"\"\"\n    if self._eval_lock:\n        raise InterpreterError(\n            \"recursive eval is not allowed, use run_method instead\"\n        )\n\n    self._eval_lock = True\n    self.initialize()\n    current_recursion_limit = sys.getrecursionlimit()\n    sys.setrecursionlimit(self.max_python_recursion_depth)\n    args = self.get_args(mt.arg_names[len(args) + 1 :], args, kwargs)\n    try:\n        results = self.run_method(mt, args)\n    except InterpreterError as e:\n        # NOTE: initialize will create new State\n        # so we don't need to copy the frames.\n        return Err(e, self.state.frames)\n    finally:\n        self._eval_lock = False\n        sys.setrecursionlimit(current_recursion_limit)\n    return Ok(results)\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.run_callable","title":"run_callable","text":"<pre><code>run_callable(\n    code: Statement, args: tuple[ValueType, ...]\n) -&gt; ValueType\n</code></pre> <p>Run a callable statement.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>Statement</code> <p>the statement to run.</p> required <code>args</code> <code>tuple[ValueType]</code> <p>the arguments to the statement, includes self if the corresponding callable region contains a self argument.</p> required <p>Returns:</p> Name Type Description <code>ValueType</code> <code>ValueType</code> <p>the result of the statement.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def run_callable(self, code: Statement, args: tuple[ValueType, ...]) -&gt; ValueType:\n    \"\"\"Run a callable statement.\n\n    Args:\n        code (Statement): the statement to run.\n        args (tuple[ValueType]): the arguments to the statement,\n            includes self if the corresponding callable region contains a self argument.\n\n    Returns:\n        ValueType: the result of the statement.\n    \"\"\"\n    interface = code.get_trait(traits.CallableStmtInterface)\n    if interface is None:\n        raise InterpreterError(f\"statement {code.name} is not callable\")\n\n    frame = self.new_frame(code)\n    self.state.push_frame(frame)\n    body = interface.get_callable_region(code)\n    if not body.blocks:\n        return self.finalize(self.state.pop_frame(), self.void)\n    frame.set_values(body.blocks[0].args, args)\n    results = self.run_callable_region(frame, code, body)\n    return self.finalize(self.state.pop_frame(), results)\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.run_callable_region","title":"run_callable_region","text":"<pre><code>run_callable_region(\n    frame: FrameType, code: Statement, region: Region\n) -&gt; ValueType\n</code></pre> <p>A hook defines how to run the callable region given the interpreter context.</p> Note <p>This is experimental API, don't subclass it. The current reason of having it is mainly because we need to dispatch back to the MethodTable for emit.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def run_callable_region(\n    self, frame: FrameType, code: Statement, region: Region\n) -&gt; ValueType:\n    \"\"\"A hook defines how to run the callable region given\n    the interpreter context.\n\n    Note:\n        This is experimental API, don't\n        subclass it. The current reason of having it is mainly\n        because we need to dispatch back to the MethodTable for\n        emit.\n    \"\"\"\n    return self.run_ssacfg_region(frame, region)\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.run_method","title":"run_method  <code>abstractmethod</code>","text":"<pre><code>run_method(\n    method: Method, args: tuple[ValueType, ...]\n) -&gt; ValueType\n</code></pre> <p>How to run a method.</p> <p>This is defined by subclasses to describe what's the corresponding value of a method during the interpretation.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Method</code> <p>the method to run.</p> required <code>args</code> <code>tuple[ValueType]</code> <p>the arguments to the method, does not include self.</p> required <p>Returns:</p> Name Type Description <code>ValueType</code> <code>ValueType</code> <p>the result of the method.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>@abstractmethod\ndef run_method(self, method: Method, args: tuple[ValueType, ...]) -&gt; ValueType:\n    \"\"\"How to run a method.\n\n    This is defined by subclasses to describe what's the corresponding\n    value of a method during the interpretation.\n\n    Args:\n        method (Method): the method to run.\n        args (tuple[ValueType]): the arguments to the method, does not include self.\n\n    Returns:\n        ValueType: the result of the method.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.FrameABC","title":"FrameABC  <code>dataclass</code>","text":"<pre><code>FrameABC(code: Statement)\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[ValueType]</code></p>"},{"location":"reference/kirin/registry/#kirin.registry.FrameABC.code","title":"code  <code>instance-attribute</code>","text":"<pre><code>code: Statement\n</code></pre> <p>func statement being interpreted.</p>"},{"location":"reference/kirin/registry/#kirin.registry.FrameABC.from_func_like","title":"from_func_like  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>from_func_like(code: Statement) -&gt; Self\n</code></pre> <p>Create a new frame for the given method.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>@classmethod\n@abstractmethod\ndef from_func_like(cls, code: Statement) -&gt; Self:\n    \"\"\"Create a new frame for the given method.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.FrameABC.get_values","title":"get_values","text":"<pre><code>get_values(\n    keys: Iterable[SSAValue],\n) -&gt; tuple[ValueType, ...]\n</code></pre> <p>Get the values of the given <code>SSAValue</code> keys.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>def get_values(self, keys: Iterable[SSAValue]) -&gt; tuple[ValueType, ...]:\n    \"\"\"Get the values of the given `SSAValue` keys.\"\"\"\n    return tuple(self.get(key) for key in keys)\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.FrameABC.set_stmt","title":"set_stmt  <code>abstractmethod</code>","text":"<pre><code>set_stmt(stmt: Statement) -&gt; Self\n</code></pre> <p>Set the current statement.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>@abstractmethod\ndef set_stmt(self, stmt: Statement) -&gt; Self:\n    \"\"\"Set the current statement.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.FrameABC.set_values","title":"set_values","text":"<pre><code>set_values(\n    keys: Iterable[SSAValue], values: Iterable[ValueType]\n) -&gt; None\n</code></pre> <p>Set the values of the given <code>SSAValue</code> keys.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>def set_values(self, keys: Iterable[SSAValue], values: Iterable[ValueType]) -&gt; None:\n    \"\"\"Set the values of the given `SSAValue` keys.\"\"\"\n    for key, value in zip(keys, values):\n        self.set(key, value)\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.Registry","title":"Registry  <code>dataclass</code>","text":"<pre><code>Registry(dialects: DialectGroup)\n</code></pre> <p>Proxy class to build different registries from a dialect group.</p>"},{"location":"reference/kirin/registry/#kirin.registry.Registry.dialects","title":"dialects  <code>instance-attribute</code>","text":"<pre><code>dialects: DialectGroup\n</code></pre> <p>The dialect group to build the registry from.</p>"},{"location":"reference/kirin/registry/#kirin.registry.Registry.ast","title":"ast","text":"<pre><code>ast(keys: Iterable[str]) -&gt; dict[str, FromPythonAST]\n</code></pre> <p>select the dialect lowering interpreters for the given key.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>Iterable[str]</code> <p>the keys to search for in the dialects</p> required <p>Returns:</p> Type Description <code>dict[str, FromPythonAST]</code> <p>a map of dialects to their lowering interpreters</p> Source code in <code>src/kirin/registry.py</code> <pre><code>def ast(self, keys: Iterable[str]) -&gt; dict[str, \"FromPythonAST\"]:\n    \"\"\"select the dialect lowering interpreters for the given key.\n\n    Args:\n        keys (Iterable[str]): the keys to search for in the dialects\n\n    Returns:\n        a map of dialects to their lowering interpreters\n    \"\"\"\n    ret: dict[str, \"FromPythonAST\"] = {}\n    from_ast = None\n    for dialect in self.dialects.data:\n        for key in keys:\n            if key in dialect.lowering:\n                from_ast = dialect.lowering[key]\n                break\n\n        if from_ast is None:\n            msg = \",\".join(keys)\n            raise KeyError(f\"Lowering not found for {msg}\")\n\n        for name in from_ast.names:\n            if name in ret:\n                raise KeyError(f\"Lowering {name} already exists\")\n\n            ret[name] = from_ast\n    return ret\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.Registry.interpreter","title":"interpreter","text":"<pre><code>interpreter(keys: Iterable[str]) -&gt; InterpreterRegistry\n</code></pre> <p>select the dialect interpreter for the given key.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>Iterable[str]</code> <p>the keys to search for in the dialects</p> required <p>Returns:</p> Type Description <code>InterpreterRegistry</code> <p>a map of statement signatures to their interpretation functions,</p> <code>InterpreterRegistry</code> <p>and a map of dialects to their fallback interpreters.</p> Source code in <code>src/kirin/registry.py</code> <pre><code>def interpreter(self, keys: Iterable[str]):\n    \"\"\"select the dialect interpreter for the given key.\n\n    Args:\n        keys (Iterable[str]): the keys to search for in the dialects\n\n    Returns:\n        a map of statement signatures to their interpretation functions,\n        and a map of dialects to their fallback interpreters.\n    \"\"\"\n    attributes: dict[type[\"Attribute\"], \"AttributeImpl\"] = {}\n    table: dict[\"Signature\", \"StatementImpl\"] = {}\n    for dialect in self.dialects.data:\n        dialect_table = None\n        for key in keys:\n            if key not in dialect.interps:\n                continue\n\n            dialect_table = dialect.interps[key]\n            for sig, func in dialect_table.attribute.items():\n                if sig not in attributes:\n                    attributes[sig] = AttributeImpl(dialect_table, func)\n\n            for sig, func in dialect_table.table.items():\n                if sig not in table:\n                    table[sig] = StatementImpl(dialect_table, func)\n\n    return InterpreterRegistry(attributes, table)\n</code></pre>"},{"location":"reference/kirin/source/","title":"Source","text":""},{"location":"reference/kirin/symbol_table/","title":"Symbol table","text":""},{"location":"reference/kirin/symbol_table/#kirin.symbol_table.SymbolTable","title":"SymbolTable  <code>dataclass</code>","text":"<pre><code>SymbolTable(\n    names: dict[str, T] = dict(),\n    *,\n    prefix: str = \"\",\n    name_count: dict[str, int] = dict()\n)\n</code></pre> <p>               Bases: <code>Generic[T]</code></p>"},{"location":"reference/kirin/symbol_table/#kirin.symbol_table.SymbolTable.name_count","title":"name_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name_count: dict[str, int] = field(\n    default_factory=dict, kw_only=True\n)\n</code></pre> <p>The count of names that have been requested.</p>"},{"location":"reference/kirin/symbol_table/#kirin.symbol_table.SymbolTable.names","title":"names  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>names: dict[str, T] = field(default_factory=dict)\n</code></pre> <p>The table that maps names to values.</p>"},{"location":"reference/kirin/worklist/","title":"WorkList","text":""},{"location":"reference/kirin/worklist/#kirin.worklist.WorkList","title":"WorkList  <code>dataclass</code>","text":"<pre><code>WorkList()\n</code></pre> <p>               Bases: <code>Generic[ElemType]</code></p> <p>The worklist data structure.</p> <p>The worklist is a stack that allows for O(1) removal of elements from the stack.</p>"},{"location":"reference/kirin/analysis/","title":"Index","text":""},{"location":"reference/kirin/analysis/callgraph/","title":"Callgraph","text":""},{"location":"reference/kirin/analysis/cfg/","title":"CFG","text":""},{"location":"reference/kirin/analysis/cfg/#kirin.analysis.cfg.CFG","title":"CFG  <code>dataclass</code>","text":"<pre><code>CFG(parent: ir.Region, entry: ir.Block | None = None)\n</code></pre> <p>               Bases: <code>Printable</code></p> <p>Control Flow Graph of a given IR statement.</p>"},{"location":"reference/kirin/analysis/cfg/#kirin.analysis.cfg.CFG.entry","title":"entry  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>entry: Block | None = None\n</code></pre> <p>Entry block of the CFG.</p>"},{"location":"reference/kirin/analysis/cfg/#kirin.analysis.cfg.CFG.parent","title":"parent  <code>instance-attribute</code>","text":"<pre><code>parent: Region\n</code></pre> <p>Parent IR statement.</p>"},{"location":"reference/kirin/analysis/cfg/#kirin.analysis.cfg.CFG.predecessors","title":"predecessors  <code>cached</code> <code>property</code>","text":"<pre><code>predecessors\n</code></pre> <p>CFG data, mapping a block to its predecessors.</p>"},{"location":"reference/kirin/analysis/cfg/#kirin.analysis.cfg.CFG.successors","title":"successors  <code>cached</code> <code>property</code>","text":"<pre><code>successors\n</code></pre> <p>CFG data, mapping a block to its neighbors.</p>"},{"location":"reference/kirin/analysis/forward/","title":"Forward","text":""},{"location":"reference/kirin/analysis/forward/#kirin.analysis.forward.ForwardExtra","title":"ForwardExtra  <code>dataclass</code>","text":"<pre><code>ForwardExtra(\n    dialects: DialectGroup,\n    *,\n    fuel: int | None = None,\n    debug: bool = False,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192,\n    save_all_ssa: bool = False\n)\n</code></pre> <p>               Bases: <code>AbstractInterpreter[ForwardFrame[LatticeElemType, ExtraType], LatticeElemType]</code>, <code>ABC</code></p> <p>Abstract interpreter but record results for each SSA value.</p> <p>Parameters:</p> Name Type Description Default <code>LatticeElemType</code> <p>The lattice element type.</p> required <code>ExtraType</code> <p>The type of extra information to be stored in the frame.</p> required"},{"location":"reference/kirin/analysis/forward/#kirin.analysis.forward.ForwardExtra.finalize","title":"finalize","text":"<pre><code>finalize(\n    frame: ForwardFrame[LatticeElemType, ExtraType],\n    results: LatticeElemType,\n) -&gt; LatticeElemType\n</code></pre> <p>Postprocess a frame after it is popped from the stack. This is called after a method is evaluated and the frame is popped.</p> Note <p>Default implementation does nothing.</p> Source code in <code>src/kirin/analysis/forward.py</code> <pre><code>def finalize(\n    self,\n    frame: ForwardFrame[LatticeElemType, ExtraType],\n    results: LatticeElemType,\n) -&gt; LatticeElemType:\n    if self.save_all_ssa:\n        self.results.update(frame.entries)\n    else:\n        self.results = frame.entries\n    return results\n</code></pre>"},{"location":"reference/kirin/analysis/forward/#kirin.analysis.forward.ForwardExtra.initialize","title":"initialize","text":"<pre><code>initialize()\n</code></pre> <p>Initialize the interpreter global states.</p> <p>This method is called before calling <code>eval</code> to initialize the interpreter global states.</p> <p>Override this method to add custom global states.</p> Source code in <code>src/kirin/analysis/forward.py</code> <pre><code>def initialize(self):\n    super().initialize()\n    self.results: dict[ir.SSAValue, LatticeElemType] = {}\n    return self\n</code></pre>"},{"location":"reference/kirin/analysis/forward/#kirin.analysis.forward.ForwardExtra.new_frame","title":"new_frame","text":"<pre><code>new_frame(\n    code: ir.Statement,\n) -&gt; ForwardFrame[LatticeElemType, ExtraType]\n</code></pre> <p>Create a new frame for the given method.</p> Source code in <code>src/kirin/analysis/forward.py</code> <pre><code>def new_frame(self, code: ir.Statement) -&gt; ForwardFrame[LatticeElemType, ExtraType]:\n    return ForwardFrame.from_func_like(code)\n</code></pre>"},{"location":"reference/kirin/analysis/forward/#kirin.analysis.forward.ForwardExtra.run_analysis","title":"run_analysis","text":"<pre><code>run_analysis(\n    method: ir.Method,\n    args: tuple[LatticeElemType, ...] | None = None,\n) -&gt; tuple[\n    dict[ir.SSAValue, LatticeElemType], LatticeElemType\n]\n</code></pre> <p>Run the forward dataflow analysis.</p> <p>Parameters:</p> Name Type Description Default <code>method(ir.Method)</code> <p>The method to analyze.</p> required <code>args(tuple[LatticeElemType])</code> <p>The arguments to the method. Defaults to tuple of top values.</p> required <p>Other Parameters:</p> Name Type Description <code>save_all_ssa(bool)</code> <p>If True, save all SSA values in the results.</p> <p>Returns:</p> Name Type Description <code>dict[SSAValue, LatticeElemType]</code> <p>dict[ir.SSAValue, LatticeElemType]: The results of the analysis for each SSA value.</p> <code>LatticeElemType</code> <code>LatticeElemType</code> <p>The result of the analysis for the method return value.</p> Source code in <code>src/kirin/analysis/forward.py</code> <pre><code>def run_analysis(\n    self,\n    method: ir.Method,\n    args: tuple[LatticeElemType, ...] | None = None,\n) -&gt; tuple[dict[ir.SSAValue, LatticeElemType], LatticeElemType]:\n    \"\"\"Run the forward dataflow analysis.\n\n    Args:\n        method(ir.Method): The method to analyze.\n        args(tuple[LatticeElemType]): The arguments to the method. Defaults to tuple of top values.\n\n    Keyword Args:\n        save_all_ssa(bool): If True, save all SSA values in the results.\n\n    Returns:\n        dict[ir.SSAValue, LatticeElemType]: The results of the analysis for each SSA value.\n        LatticeElemType: The result of the analysis for the method return value.\n    \"\"\"\n    args = args or tuple(self.lattice.top() for _ in method.args)\n    result = self.eval(method, args)\n    if isinstance(result, interp.result.Err):\n        return self.results, self.lattice.bottom()\n    return self.results, result.expect()\n</code></pre>"},{"location":"reference/kirin/analysis/const/","title":"Index","text":""},{"location":"reference/kirin/analysis/const/lattice/","title":"Lattice","text":""},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.Bottom","title":"Bottom  <code>dataclass</code>","text":"<pre><code>Bottom()\n</code></pre> <p>               Bases: <code>Result</code></p>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.Bottom.is_subseteq","title":"is_subseteq","text":"<pre><code>is_subseteq(other: Result) -&gt; bool\n</code></pre> <p>Subseteq operation.</p> Source code in <code>src/kirin/analysis/const/lattice.py</code> <pre><code>def is_subseteq(self, other: Result) -&gt; bool:\n    return True\n</code></pre>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.JointResult","title":"JointResult  <code>dataclass</code>","text":"<pre><code>JointResult(const: Result, purity: Purity = Purity.top())\n</code></pre> <p>               Bases: <code>BoundedLattice['JointResult']</code></p>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.JointResult.is_subseteq","title":"is_subseteq","text":"<pre><code>is_subseteq(other: JointResult) -&gt; bool\n</code></pre> <p>Subseteq operation.</p> Source code in <code>src/kirin/analysis/const/lattice.py</code> <pre><code>def is_subseteq(self, other: \"JointResult\") -&gt; bool:\n    return self.const.is_subseteq(other.const) and self.purity.is_subseteq(\n        other.purity\n    )\n</code></pre>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.JointResult.join","title":"join","text":"<pre><code>join(other: JointResult) -&gt; JointResult\n</code></pre> <p>Join operation.</p> Source code in <code>src/kirin/analysis/const/lattice.py</code> <pre><code>def join(self, other: \"JointResult\") -&gt; \"JointResult\":\n    return JointResult(self.const.join(other.const), self.purity.join(other.purity))\n</code></pre>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.JointResult.meet","title":"meet","text":"<pre><code>meet(other: JointResult) -&gt; JointResult\n</code></pre> <p>Meet operation.</p> Source code in <code>src/kirin/analysis/const/lattice.py</code> <pre><code>def meet(self, other: \"JointResult\") -&gt; \"JointResult\":\n    return JointResult(self.const.meet(other.const), self.purity.join(other.purity))\n</code></pre>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.NotPure","title":"NotPure  <code>dataclass</code>","text":"<pre><code>NotPure()\n</code></pre> <p>               Bases: <code>Purity</code></p>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.NotPure.is_subseteq","title":"is_subseteq","text":"<pre><code>is_subseteq(other: Purity) -&gt; bool\n</code></pre> <p>Subseteq operation.</p> Source code in <code>src/kirin/analysis/const/lattice.py</code> <pre><code>def is_subseteq(self, other: Purity) -&gt; bool:\n    return isinstance(other, NotPure)\n</code></pre>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.PartialLambda","title":"PartialLambda  <code>dataclass</code>","text":"<pre><code>PartialLambda(\n    argnames: list[str],\n    code: ir.Statement,\n    captured: tuple[Result, ...],\n)\n</code></pre> <p>               Bases: <code>PartialConst</code></p>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.PartialLambda.join","title":"join","text":"<pre><code>join(other: Result) -&gt; Result\n</code></pre> <p>Join operation.</p> Source code in <code>src/kirin/analysis/const/lattice.py</code> <pre><code>def join(self, other: Result) -&gt; Result:\n    if other is other.bottom():\n        return self\n\n    if not isinstance(other, PartialLambda):\n        return Unknown().join(other)  # widen self\n\n    if self.code is not other.code:\n        return Unknown()  # lambda stmt is pure\n\n    if len(self.captured) != len(other.captured):\n        return self.bottom()  # err\n\n    return PartialLambda(\n        self.argnames,\n        self.code,\n        tuple(x.join(y) for x, y in zip(self.captured, other.captured)),\n    )\n</code></pre>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.PartialLambda.meet","title":"meet","text":"<pre><code>meet(other: Result) -&gt; Result\n</code></pre> <p>Meet operation.</p> Source code in <code>src/kirin/analysis/const/lattice.py</code> <pre><code>def meet(self, other: Result) -&gt; Result:\n    if not isinstance(other, PartialLambda):\n        return Unknown().meet(other)\n\n    if self.code is not other.code:\n        return self.bottom()\n\n    if len(self.captured) != len(other.captured):\n        return Unknown()\n\n    return PartialLambda(\n        self.argnames,\n        self.code,\n        tuple(x.meet(y) for x, y in zip(self.captured, other.captured)),\n    )\n</code></pre>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.PartialTuple","title":"PartialTuple  <code>dataclass</code>","text":"<pre><code>PartialTuple(data: tuple[Result, ...])\n</code></pre> <p>               Bases: <code>PartialConst</code></p>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.PartialTuple.is_equal","title":"is_equal","text":"<pre><code>is_equal(other: Result) -&gt; bool\n</code></pre> <p>Check if two lattices are equal.</p> Source code in <code>src/kirin/analysis/const/lattice.py</code> <pre><code>def is_equal(self, other: Result) -&gt; bool:\n    if isinstance(other, PartialTuple):\n        return all(x.is_equal(y) for x, y in zip(self.data, other.data))\n    elif isinstance(other, Value) and isinstance(other.data, tuple):\n        return all(x.is_equal(Value(y)) for x, y in zip(self.data, other.data))\n    return False\n</code></pre>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.PartialTuple.join","title":"join","text":"<pre><code>join(other: Result) -&gt; Result\n</code></pre> <p>Join operation.</p> Source code in <code>src/kirin/analysis/const/lattice.py</code> <pre><code>def join(self, other: Result) -&gt; Result:\n    if other.is_subseteq(self):\n        return self\n    elif self.is_subseteq(other):\n        return other\n    elif isinstance(other, PartialTuple):\n        return PartialTuple(tuple(x.join(y) for x, y in zip(self.data, other.data)))\n    elif isinstance(other, Value) and isinstance(other.data, tuple):\n        return PartialTuple(\n            tuple(x.join(Value(y)) for x, y in zip(self.data, other.data))\n        )\n    return Unknown()\n</code></pre>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.PartialTuple.meet","title":"meet","text":"<pre><code>meet(other: Result) -&gt; Result\n</code></pre> <p>Meet operation.</p> Source code in <code>src/kirin/analysis/const/lattice.py</code> <pre><code>def meet(self, other: Result) -&gt; Result:\n    if self.is_subseteq(other):\n        return self\n    elif other.is_subseteq(self):\n        return other\n    elif isinstance(other, PartialTuple):\n        return PartialTuple(tuple(x.meet(y) for x, y in zip(self.data, other.data)))\n    elif isinstance(other, Value) and isinstance(other.data, tuple):\n        return PartialTuple(\n            tuple(x.meet(Value(y)) for x, y in zip(self.data, other.data))\n        )\n    return self.bottom()\n</code></pre>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.Pure","title":"Pure  <code>dataclass</code>","text":"<pre><code>Pure()\n</code></pre> <p>               Bases: <code>Purity</code></p>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.Pure.is_subseteq","title":"is_subseteq","text":"<pre><code>is_subseteq(other: Purity) -&gt; bool\n</code></pre> <p>Subseteq operation.</p> Source code in <code>src/kirin/analysis/const/lattice.py</code> <pre><code>def is_subseteq(self, other: Purity) -&gt; bool:\n    return isinstance(other, (NotPure, Pure))\n</code></pre>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.PurityBottom","title":"PurityBottom  <code>dataclass</code>","text":"<pre><code>PurityBottom()\n</code></pre> <p>               Bases: <code>Purity</code></p>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.PurityBottom.is_subseteq","title":"is_subseteq","text":"<pre><code>is_subseteq(other: Purity) -&gt; bool\n</code></pre> <p>Subseteq operation.</p> Source code in <code>src/kirin/analysis/const/lattice.py</code> <pre><code>def is_subseteq(self, other: Purity) -&gt; bool:\n    return True\n</code></pre>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.Unknown","title":"Unknown  <code>dataclass</code>","text":"<pre><code>Unknown()\n</code></pre> <p>               Bases: <code>Result</code></p>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.Unknown.is_subseteq","title":"is_subseteq","text":"<pre><code>is_subseteq(other: Result) -&gt; bool\n</code></pre> <p>Subseteq operation.</p> Source code in <code>src/kirin/analysis/const/lattice.py</code> <pre><code>def is_subseteq(self, other: Result) -&gt; bool:\n    return isinstance(other, Unknown)\n</code></pre>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.Value","title":"Value  <code>dataclass</code>","text":"<pre><code>Value(data: Any)\n</code></pre> <p>               Bases: <code>Result</code></p>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.Value.is_equal","title":"is_equal","text":"<pre><code>is_equal(other: Result) -&gt; bool\n</code></pre> <p>Check if two lattices are equal.</p> Source code in <code>src/kirin/analysis/const/lattice.py</code> <pre><code>def is_equal(self, other: Result) -&gt; bool:\n    if isinstance(other, Value):\n        return self.data == other.data\n    return False\n</code></pre>"},{"location":"reference/kirin/analysis/const/prop/","title":"Prop","text":""},{"location":"reference/kirin/analysis/const/prop/#kirin.analysis.const.prop.Propagate","title":"Propagate  <code>dataclass</code>","text":"<pre><code>Propagate(\n    dialects: DialectGroup,\n    *,\n    fuel: int | None = None,\n    debug: bool = False,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192,\n    save_all_ssa: bool = False\n)\n</code></pre> <p>               Bases: <code>ForwardExtra[JointResult, ExtraFrameInfo]</code></p>"},{"location":"reference/kirin/analysis/const/prop/#kirin.analysis.const.prop.Propagate.keys","title":"keys  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>keys = ['constprop']\n</code></pre> <p>The name of the interpreter to select from dialects by order.</p>"},{"location":"reference/kirin/analysis/const/prop/#kirin.analysis.const.prop.Propagate.lattice","title":"lattice  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lattice = JointResult\n</code></pre> <p>lattice type for the abstract interpreter.</p>"},{"location":"reference/kirin/analysis/const/prop/#kirin.analysis.const.prop.Propagate.eval_stmt","title":"eval_stmt","text":"<pre><code>eval_stmt(\n    frame: ForwardFrame[JointResult, ExtraFrameInfo],\n    stmt: ir.Statement,\n) -&gt; interp.StatementResult[JointResult]\n</code></pre> <p>Run a statement within the current frame. This is the entry point of running a statement. It will look up the statement implementation in the dialect registry, or optionally call a fallback implementation.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>FrameType</code> <p>the current frame</p> required <code>stmt</code> <code>Statement</code> <p>the statement to run</p> required <p>Returns:</p> Name Type Description <code>StatementResult</code> <code>StatementResult[ValueType]</code> <p>the result of running the statement</p> Note <p>Overload this method for the following reasons: - to change the source tracking information - to take control of how to run a statement - to change the implementation lookup behavior that cannot acheive     by overloading <code>lookup_registry</code></p> Example <ul> <li>implement an interpreter that only handles MyStmt: <pre><code>    class MyInterpreter(BaseInterpreter):\n        ...\n        def eval_stmt(self, frame: FrameType, stmt: Statement) -&gt; StatementResult[ValueType]:\n            if isinstance(stmt, MyStmt):\n                return self.run_my_stmt(frame, stmt)\n            else:\n                return ()\n</code></pre></li> </ul> Source code in <code>src/kirin/analysis/const/prop.py</code> <pre><code>def eval_stmt(\n    self, frame: ForwardFrame[JointResult, ExtraFrameInfo], stmt: ir.Statement\n) -&gt; interp.StatementResult[JointResult]:\n    if stmt.has_trait(ir.ConstantLike):\n        return self._try_eval_const_pure(frame, stmt, ())\n    elif stmt.has_trait(ir.Pure):\n        values = tuple(x.const for x in frame.get_values(stmt.args))\n        if ir.types.is_tuple_of(values, Value):\n            return self._try_eval_const_pure(frame, stmt, values)\n\n    method = self.lookup_registry(frame, stmt)\n    if method is not None:\n        ret = method(self, frame, stmt)\n        self._set_frame_not_pure(ret)\n        return ret\n    elif stmt.has_trait(ir.Pure):\n        # fallback to top for other statements\n        return (JointResult(Unknown(), Pure()),)\n    else:\n        if frame.extra is None:\n            frame.extra = ExtraFrameInfo(True)\n        return (JointResult(Unknown(), NotPure()),)\n</code></pre>"},{"location":"reference/kirin/analysis/const/prop/#kirin.analysis.const.prop.Propagate.finalize","title":"finalize","text":"<pre><code>finalize(\n    frame: ForwardFrame[JointResult, ExtraFrameInfo],\n    results: JointResult,\n) -&gt; JointResult\n</code></pre> <p>Postprocess a frame after it is popped from the stack. This is called after a method is evaluated and the frame is popped.</p> Note <p>Default implementation does nothing.</p> Source code in <code>src/kirin/analysis/const/prop.py</code> <pre><code>def finalize(\n    self,\n    frame: ForwardFrame[JointResult, ExtraFrameInfo],\n    results: JointResult,\n) -&gt; JointResult:\n    results = super().finalize(frame, results)\n    if frame.extra is not None and frame.extra.frame_is_not_pure:\n        return JointResult(results.const, NotPure())\n    return results\n</code></pre>"},{"location":"reference/kirin/analysis/const/prop/#kirin.analysis.const.prop.Propagate.initialize","title":"initialize","text":"<pre><code>initialize()\n</code></pre> <p>Initialize the interpreter global states.</p> <p>This method is called before calling <code>eval</code> to initialize the interpreter global states.</p> <p>Override this method to add custom global states.</p> Source code in <code>src/kirin/analysis/const/prop.py</code> <pre><code>def initialize(self):\n    super().initialize()\n    self._interp.initialize()\n    return self\n</code></pre>"},{"location":"reference/kirin/analysis/const/prop/#kirin.analysis.const.prop.Propagate.run_method","title":"run_method","text":"<pre><code>run_method(\n    method: ir.Method, args: tuple[JointResult, ...]\n) -&gt; JointResult\n</code></pre> <p>How to run a method.</p> <p>This is defined by subclasses to describe what's the corresponding value of a method during the interpretation.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Method</code> <p>the method to run.</p> required <code>args</code> <code>tuple[ValueType]</code> <p>the arguments to the method, does not include self.</p> required <p>Returns:</p> Name Type Description <code>ValueType</code> <code>ValueType</code> <p>the result of the method.</p> Source code in <code>src/kirin/analysis/const/prop.py</code> <pre><code>def run_method(\n    self, method: ir.Method, args: tuple[JointResult, ...]\n) -&gt; JointResult:\n    if len(self.state.frames) &gt;= self.max_depth:\n        return self.void\n    return self.run_callable(\n        method.code, (JointResult(Value(method), NotPure()),) + args\n    )\n</code></pre>"},{"location":"reference/kirin/analysis/typeinfer/","title":"Index","text":""},{"location":"reference/kirin/analysis/typeinfer/analysis/","title":"Analysis","text":""},{"location":"reference/kirin/analysis/typeinfer/analysis/#kirin.analysis.typeinfer.analysis.TypeInference","title":"TypeInference  <code>dataclass</code>","text":"<pre><code>TypeInference(\n    dialects: DialectGroup,\n    *,\n    fuel: int | None = None,\n    debug: bool = False,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192,\n    save_all_ssa: bool = False\n)\n</code></pre> <p>               Bases: <code>Forward[TypeAttribute]</code></p>"},{"location":"reference/kirin/analysis/typeinfer/analysis/#kirin.analysis.typeinfer.analysis.TypeInference.keys","title":"keys  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>keys = ['typeinfer']\n</code></pre> <p>The name of the interpreter to select from dialects by order.</p>"},{"location":"reference/kirin/analysis/typeinfer/analysis/#kirin.analysis.typeinfer.analysis.TypeInference.lattice","title":"lattice  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lattice = TypeAttribute\n</code></pre> <p>lattice type for the abstract interpreter.</p>"},{"location":"reference/kirin/analysis/typeinfer/analysis/#kirin.analysis.typeinfer.analysis.TypeInference.build_signature","title":"build_signature","text":"<pre><code>build_signature(\n    frame: ForwardFrame[types.TypeAttribute, None],\n    stmt: ir.Statement,\n) -&gt; Signature\n</code></pre> <p>build signature for querying the statement implementation.</p> Source code in <code>src/kirin/analysis/typeinfer/analysis.py</code> <pre><code>def build_signature(\n    self, frame: ForwardFrame[types.TypeAttribute, None], stmt: ir.Statement\n) -&gt; Signature:\n    _args = ()\n    for x in frame.get_values(stmt.args):\n        _args += (self._unwrap(x),)\n    return Signature(stmt.__class__, _args)\n</code></pre>"},{"location":"reference/kirin/analysis/typeinfer/analysis/#kirin.analysis.typeinfer.analysis.TypeInference.eval_stmt_fallback","title":"eval_stmt_fallback","text":"<pre><code>eval_stmt_fallback(\n    frame: ForwardFrame[types.TypeAttribute, None],\n    stmt: ir.Statement,\n) -&gt; (\n    tuple[types.TypeAttribute, ...]\n    | interp.SpecialValue[types.TypeAttribute]\n)\n</code></pre> <p>The fallback implementation of statements.</p> <p>This is called when no implementation is found for the statement.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>FrameType</code> <p>the current frame</p> required <code>stmt</code> <code>Statement</code> <p>the statement to run</p> required <p>Returns:</p> Name Type Description <code>StatementResult</code> <code>StatementResult[ValueType]</code> <p>the result of running the statement</p> Note <p>Overload this method to provide a fallback implementation for statements.</p> Source code in <code>src/kirin/analysis/typeinfer/analysis.py</code> <pre><code>def eval_stmt_fallback(\n    self, frame: ForwardFrame[types.TypeAttribute, None], stmt: ir.Statement\n) -&gt; tuple[types.TypeAttribute, ...] | interp.SpecialValue[types.TypeAttribute]:\n    resolve = TypeResolution()\n    for arg, value in zip(stmt.args, frame.get_values(stmt.args)):\n        resolve.solve(arg.type, value)\n    return tuple(resolve.substitute(result.type) for result in stmt.results)\n</code></pre>"},{"location":"reference/kirin/analysis/typeinfer/analysis/#kirin.analysis.typeinfer.analysis.TypeInference.run_method","title":"run_method","text":"<pre><code>run_method(\n    method: ir.Method, args: tuple[types.TypeAttribute, ...]\n) -&gt; types.TypeAttribute\n</code></pre> <p>How to run a method.</p> <p>This is defined by subclasses to describe what's the corresponding value of a method during the interpretation.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Method</code> <p>the method to run.</p> required <code>args</code> <code>tuple[ValueType]</code> <p>the arguments to the method, does not include self.</p> required <p>Returns:</p> Name Type Description <code>ValueType</code> <code>ValueType</code> <p>the result of the method.</p> Source code in <code>src/kirin/analysis/typeinfer/analysis.py</code> <pre><code>def run_method(\n    self, method: ir.Method, args: tuple[types.TypeAttribute, ...]\n) -&gt; types.TypeAttribute:\n    if len(self.state.frames) &lt; self.max_depth:\n        # NOTE: widen method type here\n        return self.run_callable(\n            method.code, (types.Hinted(types.PyClass(ir.Method), method),) + args\n        )\n    return types.Bottom\n</code></pre>"},{"location":"reference/kirin/analysis/typeinfer/solve/","title":"Solve","text":""},{"location":"reference/kirin/decl/","title":"Index","text":""},{"location":"reference/kirin/decl/#kirin.decl.statement","title":"statement","text":"<pre><code>statement(\n    cls=None, **kwargs: Unpack[StatementOptions]\n) -&gt; Callable[[type[StmtType]], type[StmtType]]\n</code></pre> <p>Declare a new statement class.</p> <p>This decorator is used to declare a new statement class. It is used to generate the necessary boilerplate code for the class. The class should inherit from <code>kirin.ir.Statement</code>.</p> <p>Parameters:</p> Name Type Description Default <code>init(bool)</code> <p>Whether to generate an <code>__init__</code> method.</p> required <code>repr(bool)</code> <p>Whether to generate a <code>__repr__</code> method.</p> required <code>kw_only(bool)</code> <p>Whether to use keyword-only arguments in the <code>__init__</code> method.</p> required <code>dialect(Optional[Dialect])</code> <p>The dialect of the statement.</p> required <code>property(bool)</code> <p>Whether to generate property methods for attributes.</p> required Example <p>The following is an example of how to use the <code>statement</code> decorator.</p> <pre><code># optionally register the statement with\n# @statement(dialect=my_dialect_object)\n@statement\nclass MyStatement(ir.Statement):\n    name = \"some_name\"\n    traits = frozenset({TraitA(), TraitB()})\n    some_input: ir.SSAValue = info.argument()\n    some_output: ir.ResultValue = info.result()\n    body: ir.Region = info.region()\n    successor: ir.Block = info.block()\n</code></pre> Source code in <code>src/kirin/decl/__init__.py</code> <pre><code>@dataclass_transform(\n    field_specifiers=(\n        info.attribute,\n        info.argument,\n        info.region,\n        info.result,\n        info.block,\n    )\n)\ndef statement(\n    cls=None,\n    **kwargs: Unpack[StatementOptions],\n) -&gt; Callable[[type[StmtType]], type[StmtType]]:\n    \"\"\"Declare a new statement class.\n\n    This decorator is used to declare a new statement class. It is used to\n    generate the necessary boilerplate code for the class. The class should\n    inherit from `kirin.ir.Statement`.\n\n    Args:\n        init(bool): Whether to generate an `__init__` method.\n        repr(bool): Whether to generate a `__repr__` method.\n        kw_only(bool): Whether to use keyword-only arguments in the `__init__`\n            method.\n        dialect(Optional[Dialect]): The dialect of the statement.\n        property(bool): Whether to generate property methods for attributes.\n\n    Example:\n        The following is an example of how to use the `statement` decorator.\n\n        ```python\n        # optionally register the statement with\n        # @statement(dialect=my_dialect_object)\n        @statement\n        class MyStatement(ir.Statement):\n            name = \"some_name\"\n            traits = frozenset({TraitA(), TraitB()})\n            some_input: ir.SSAValue = info.argument()\n            some_output: ir.ResultValue = info.result()\n            body: ir.Region = info.region()\n            successor: ir.Block = info.block()\n        ```\n    \"\"\"\n\n    def wrap(cls):\n        decl = StatementDecl(cls, **kwargs)\n        decl.scan_fields()\n        decl.verify()\n        decl.emit()\n        decl.register()\n        return cls\n\n    if cls is None:\n        return wrap\n    return wrap(cls)\n</code></pre>"},{"location":"reference/kirin/decl/base/","title":"Base","text":""},{"location":"reference/kirin/decl/camel2snake/","title":"Camel2snake","text":""},{"location":"reference/kirin/decl/info/","title":"Info","text":""},{"location":"reference/kirin/decl/info/#kirin.decl.info.ArgumentField","title":"ArgumentField  <code>dataclass</code>","text":"<pre><code>ArgumentField(\n    kw_only: bool,\n    alias: Optional[str],\n    type: types.TypeAttribute,\n    print: bool = True,\n    group: bool = False,\n)\n</code></pre> <p>               Bases: <code>Field</code></p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.ArgumentField.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>group: bool = False\n</code></pre> <p>if <code>True</code>, this argument is annotated with Tuple[SSAValue, ...]</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.ArgumentField.print","title":"print  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>print: bool = True\n</code></pre> <p>if <code>True</code>, this argument name is printed in the signature.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.ArgumentField.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: TypeAttribute\n</code></pre> <p>type of the argument, will be used in validation.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.AttributeField","title":"AttributeField  <code>dataclass</code>","text":"<pre><code>AttributeField(\n    kw_only: bool,\n    alias: Optional[str],\n    default: Any,\n    init: bool,\n    repr: bool,\n    default_factory: Optional[Callable[[], Attribute]],\n    type: types.TypeAttribute,\n    property: bool,\n    pytype: bool = False,\n)\n</code></pre> <p>               Bases: <code>Field</code></p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.AttributeField.pytype","title":"pytype  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pytype: bool = False\n</code></pre> <p>if <code>True</code>, annotation is a python type hint instead of <code>TypeAttribute</code></p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields","title":"StatementFields  <code>dataclass</code>","text":"<pre><code>StatementFields(\n    std_args: dict[str, ArgumentField] = dict(),\n    kw_args: dict[str, ArgumentField] = dict(),\n    results: dict[str, ResultField] = dict(),\n    regions: dict[str, RegionField] = dict(),\n    blocks: dict[str, BlockField] = dict(),\n    attributes: dict[str, AttributeField] = dict(),\n    properties: dict[str, AttributeField] = dict(),\n)\n</code></pre>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.args","title":"args  <code>property</code>","text":"<pre><code>args\n</code></pre> <p>iterable of all argument fields.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.attributes","title":"attributes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>attributes: dict[str, AttributeField] = field(\n    default_factory=dict\n)\n</code></pre> <p>attributes of the statement.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.blocks","title":"blocks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>blocks: dict[str, BlockField] = field(default_factory=dict)\n</code></pre> <p>blocks of the statement.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.kw_args","title":"kw_args  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kw_args: dict[str, ArgumentField] = field(\n    default_factory=dict\n)\n</code></pre> <p>keyword-only arguments of the statement.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.properties","title":"properties  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>properties: dict[str, AttributeField] = field(\n    default_factory=dict\n)\n</code></pre> <p>properties of the statement.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.regions","title":"regions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>regions: dict[str, RegionField] = field(\n    default_factory=dict\n)\n</code></pre> <p>regions of the statement.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.required_names","title":"required_names  <code>cached</code> <code>property</code>","text":"<pre><code>required_names\n</code></pre> <p>set of all fields that do not have a default value.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.results","title":"results  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>results: dict[str, ResultField] = field(\n    default_factory=dict\n)\n</code></pre> <p>results of the statement.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.std_args","title":"std_args  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>std_args: dict[str, ArgumentField] = field(\n    default_factory=dict\n)\n</code></pre> <p>standard arguments of the statement.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.argument","title":"argument","text":"<pre><code>argument(\n    type: types.TypeAttribute = types.Any,\n    *,\n    print: bool = True,\n    kw_only: bool = False,\n    alias: Optional[str] = None\n) -&gt; Any\n</code></pre> <p>Field specifier for arguments.</p> <p>Parameters:</p> Name Type Description Default <code>type(TypeAttribute)</code> <p>type of the argument, will be used in validation.</p> required <code>print(bool)</code> <p>if <code>True</code>, this argument name is printed in the signature.</p> required <code>kw_only(bool)</code> <p>if <code>True</code>, this argument is keyword-only.</p> required <code>alias(Optional[str])</code> <p>an alias for the argument name in the <code>__init__</code> method.</p> required Source code in <code>src/kirin/decl/info.py</code> <pre><code>def argument(\n    type: types.TypeAttribute = types.Any,\n    *,\n    print: bool = True,\n    kw_only: bool = False,\n    alias: Optional[str] = None,\n) -&gt; Any:\n    \"\"\"Field specifier for arguments.\n\n    Args:\n        type(TypeAttribute): type of the argument, will be used in validation.\n        print(bool): if `True`, this argument name is printed in the signature.\n        kw_only(bool): if `True`, this argument is keyword-only.\n        alias(Optional[str]): an alias for the argument name in the `__init__` method.\n    \"\"\"\n    return ArgumentField(\n        type=type,\n        print=print,\n        kw_only=kw_only,\n        alias=alias,\n    )\n</code></pre>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.block","title":"block","text":"<pre><code>block(\n    *,\n    init: bool = True,\n    repr: bool = True,\n    kw_only: bool = True,\n    alias: Optional[str] = None,\n    default_factory: Callable[[], Block] = Block\n) -&gt; Any\n</code></pre> <p>Field specifier for blocks.</p> <p>Parameters:</p> Name Type Description Default <code>init(bool)</code> <p>if <code>True</code>, this block field is included in the <code>__init__</code> method.</p> required <code>repr(bool)</code> <p>if <code>True</code>, this block field is included in the <code>__repr__</code> and pretty printing.</p> required <code>kw_only(bool)</code> <p>if <code>True</code>, this block field is keyword-only.</p> required <code>alias(Optional[str])</code> <p>an alias for the block field name in the <code>__init__</code> method.</p> required <code>default_factory(Callable[[],</code> <code>Block]</code> <p>a factory function to create a default block.</p> required Source code in <code>src/kirin/decl/info.py</code> <pre><code>def block(\n    *,\n    init: bool = True,\n    repr: bool = True,\n    kw_only: bool = True,\n    alias: Optional[str] = None,\n    default_factory: Callable[[], Block] = Block,\n) -&gt; Any:\n    \"\"\"Field specifier for blocks.\n\n    Args:\n        init(bool): if `True`, this block field is included in the `__init__` method.\n        repr(bool): if `True`, this block field is included in the `__repr__` and pretty printing.\n        kw_only(bool): if `True`, this block field is keyword-only.\n        alias(Optional[str]): an alias for the block field name in the `__init__` method.\n        default_factory(Callable[[], Block]): a factory function to create a default block.\n    \"\"\"\n    if kw_only is False:\n        raise TypeError(\"block fields must be keyword-only\")\n\n    return BlockField(\n        init=init,\n        repr=repr,\n        kw_only=kw_only,\n        alias=alias,\n        default_factory=default_factory,\n    )\n</code></pre>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.region","title":"region","text":"<pre><code>region(\n    *,\n    init: bool = True,\n    repr: bool = True,\n    kw_only: bool = True,\n    alias: Optional[str] = None,\n    multi: bool = False,\n    default_factory: Callable[[], Region] = Region\n) -&gt; Any\n</code></pre> <p>Field specifier for regions.</p> <p>Parameters:</p> Name Type Description Default <code>init(bool)</code> <p>if <code>True</code>, this region field is included in the <code>__init__</code> method.</p> required <code>repr(bool)</code> <p>if <code>True</code>, this region field is included in the <code>__repr__</code> and pretty printing.</p> required <code>kw_only(bool)</code> <p>if <code>True</code>, this region field is keyword-only.</p> required <code>alias(Optional[str])</code> <p>an alias for the region field name in the <code>__init__</code> method.</p> required <code>multi(bool)</code> <p>if <code>True</code>, this region can contain multiple blocks.</p> required <code>default_factory(Callable[[],</code> <code>Region]</code> <p>a factory function to create a default region.</p> required Source code in <code>src/kirin/decl/info.py</code> <pre><code>def region(\n    *,\n    init: bool = True,  # so we can use the default_factory\n    repr: bool = True,\n    kw_only: bool = True,\n    alias: Optional[str] = None,\n    multi: bool = False,\n    default_factory: Callable[[], Region] = Region,\n) -&gt; Any:\n    \"\"\"Field specifier for regions.\n\n    Args:\n        init(bool): if `True`, this region field is included in the `__init__` method.\n        repr(bool): if `True`, this region field is included in the `__repr__` and pretty printing.\n        kw_only(bool): if `True`, this region field is keyword-only.\n        alias(Optional[str]): an alias for the region field name in the `__init__` method.\n        multi(bool): if `True`, this region can contain multiple blocks.\n        default_factory(Callable[[], Region]): a factory function to create a default region.\n    \"\"\"\n    if kw_only is False:\n        raise TypeError(\"region fields must be keyword-only\")\n\n    return RegionField(\n        init=init,\n        repr=repr,\n        kw_only=kw_only,\n        alias=alias,\n        multi=multi,\n        default_factory=default_factory,\n    )\n</code></pre>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.result","title":"result","text":"<pre><code>result(\n    type: types.TypeAttribute = types.Any,\n    *,\n    init: bool = False,\n    repr: bool = True,\n    kw_only: bool = True,\n    alias: Optional[str] = None\n) -&gt; Any\n</code></pre> <p>Field specifier for results.</p> <p>Parameters:</p> Name Type Description Default <code>type(TypeAttribute)</code> <p>type of the result.</p> required <code>init(bool)</code> <p>if <code>True</code>, this result field is included in the <code>__init__</code> method.</p> required <code>repr(bool)</code> <p>if <code>True</code>, this result field is included in the <code>__repr__</code> and pretty printing.</p> required <code>kw_only(bool)</code> <p>if <code>True</code>, this result field is keyword-only.</p> required <code>alias(Optional[str])</code> <p>an alias for the result field name in the <code>__init__</code> method.</p> required Source code in <code>src/kirin/decl/info.py</code> <pre><code>def result(\n    type: types.TypeAttribute = types.Any,\n    *,\n    # NOTE: init is false, use other hooks to set custom results\n    # or just mutate the statement after creation\n    init: bool = False,\n    repr: bool = True,\n    kw_only: bool = True,\n    alias: Optional[str] = None,\n) -&gt; Any:\n    \"\"\"Field specifier for results.\n\n    Args:\n        type(TypeAttribute): type of the result.\n        init(bool): if `True`, this result field is included in the `__init__` method.\n        repr(bool): if `True`, this result field is included in the `__repr__` and pretty printing.\n        kw_only(bool): if `True`, this result field is keyword-only.\n        alias(Optional[str]): an alias for the result field name in the `__init__` method.\n    \"\"\"\n    if kw_only is False:  # for linting\n        raise TypeError(\"result fields must be keyword-only\")\n\n    if init is True:\n        raise TypeError(\"result fields cannot appear in __init__\")\n\n    return ResultField(\n        type=type,\n        init=init,\n        repr=repr,\n        kw_only=kw_only,\n        alias=alias,\n    )\n</code></pre>"},{"location":"reference/kirin/decl/scan_fields/","title":"Scan fields","text":""},{"location":"reference/kirin/decl/scan_fields/#kirin.decl.scan_fields.ScanFields","title":"ScanFields","text":"<pre><code>ScanFields(cls: type, **kwargs: Unpack[StatementOptions])\n</code></pre> <p>               Bases: <code>BaseModifier</code></p> Source code in <code>src/kirin/decl/base.py</code> <pre><code>def __init__(self, cls: type, **kwargs: Unpack[StatementOptions]) -&gt; None:\n    self.cls = cls\n    self.cls_module = sys.modules.get(cls.__module__)\n\n    if \"dialect\" in kwargs:\n        self.dialect = kwargs[\"dialect\"]\n    else:\n        self.dialect = None\n    self.params = kwargs\n    setattr(cls, self._PARAMS, self.params)\n\n    if cls.__module__ in sys.modules:\n        self.globals = sys.modules[cls.__module__].__dict__\n    else:\n        # Theoretically this can happen if someone writes\n        # a custom string to cls.__module__.  In which case\n        # such dataclass won't be fully introspectable\n        # (w.r.t. typing.get_type_hints) but will still function\n        # correctly.\n        self.globals: dict[str, Any] = {}\n\n    # analysis state, used by scan_field, etc.\n    self.fields = StatementFields()\n    self.has_statement_bases = False\n    self.kw_only = self.params.get(\"kw_only\", False)\n    self.KW_ONLY_seen = False\n</code></pre>"},{"location":"reference/kirin/decl/verify/","title":"Verify","text":""},{"location":"reference/kirin/decl/emit/","title":"Index","text":""},{"location":"reference/kirin/decl/emit/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/decl/emit/init/","title":"Init","text":""},{"location":"reference/kirin/decl/emit/name/","title":"Name","text":""},{"location":"reference/kirin/decl/emit/property/","title":"Property","text":""},{"location":"reference/kirin/decl/emit/repr/","title":"Repr","text":""},{"location":"reference/kirin/decl/emit/traits/","title":"Traits","text":""},{"location":"reference/kirin/decl/emit/typecheck/","title":"Typecheck","text":""},{"location":"reference/kirin/decl/emit/verify/","title":"Verify","text":""},{"location":"reference/kirin/dialects/","title":"Index","text":""},{"location":"reference/kirin/dialects/module/","title":"Module","text":"<p>Module dialect provides a simple module that is roughly a list of function statements.</p> <p>This dialect provides the dialect necessary for compiling a function into lower-level IR with all its callee functions.</p>"},{"location":"reference/kirin/dialects/module/#kirin.dialects.module.Invoke","title":"Invoke  <code>dataclass</code>","text":"<pre><code>Invoke(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>A special statement that represents a function calling functions by symbol name.</p> Note <p>This statement is here for completeness, for interpretation, it is recommended to rewrite this statement into a <code>func.Invoke</code> after looking up the symbol table.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/module/#kirin.dialects.module.Invoke.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>run mandatory validation checks. This is not same as typecheck, which may be optional.</p> Source code in <code>src/kirin/dialects/module.py</code> <pre><code>def verify(self) -&gt; None:\n    if self.kwargs:\n        for name in self.kwargs:\n            if name not in self.callee:\n                raise VerificationError(\n                    self,\n                    f\"method {self.callee} does not have argument {name}\",\n                )\n    elif len(self.callee) - 1 != len(self.args):\n        raise VerificationError(\n            self,\n            f\"expected {len(self.callee)} arguments, got {len(self.args)}\",\n        )\n</code></pre>"},{"location":"reference/kirin/dialects/cf/","title":"Index","text":""},{"location":"reference/kirin/dialects/cf/constprop/","title":"Constprop","text":""},{"location":"reference/kirin/dialects/cf/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/dialects/cf/emit/","title":"Emit","text":""},{"location":"reference/kirin/dialects/cf/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/cf/lower/","title":"Lower","text":""},{"location":"reference/kirin/dialects/cf/stmts/","title":"Stmts","text":""},{"location":"reference/kirin/dialects/cf/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/dialects/func/","title":"Index","text":"<p>A function dialect that is compatible with python semantics.</p>"},{"location":"reference/kirin/dialects/func/attrs/","title":"Attrs","text":""},{"location":"reference/kirin/dialects/func/attrs/#kirin.dialects.func.attrs.Signature","title":"Signature  <code>dataclass</code>","text":"<pre><code>Signature(\n    inputs: tuple[TypeLatticeElem, ...],\n    output: TypeLatticeElem,\n)\n</code></pre> <p>               Bases: <code>Generic[TypeLatticeElem]</code>, <code>Attribute</code></p> <p>function body signature.</p> <p>This is not a type attribute because it just stores the signature of a function at its definition site. We don't perform type inference on this directly.</p> <p>The type of a function is the type of <code>inputs[0]</code>, which typically is a <code>MethodType</code>.</p>"},{"location":"reference/kirin/dialects/func/attrs/#kirin.dialects.func.attrs.Signature.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'Signature'\n</code></pre> <p>Name of the attribute in printing and other text format.</p>"},{"location":"reference/kirin/dialects/func/constprop/","title":"Constprop","text":""},{"location":"reference/kirin/dialects/func/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/dialects/func/emit/","title":"Emit","text":""},{"location":"reference/kirin/dialects/func/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/func/lower/","title":"Lower","text":""},{"location":"reference/kirin/dialects/func/stmts/","title":"Stmts","text":""},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.ConstantNone","title":"ConstantNone  <code>dataclass</code>","text":"<pre><code>ConstantNone(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>A constant None value.</p> <p>This is mainly used to represent the None return value of a function to match Python semantics.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.FuncOpCallableInterface","title":"FuncOpCallableInterface  <code>dataclass</code>","text":"<pre><code>FuncOpCallableInterface()\n</code></pre> <p>               Bases: <code>CallableStmtInterface['Function']</code></p>"},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.FuncOpCallableInterface.get_callable_region","title":"get_callable_region  <code>classmethod</code>","text":"<pre><code>get_callable_region(stmt: Function) -&gt; Region\n</code></pre> <p>Returns the body of the callable region</p> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>@classmethod\ndef get_callable_region(cls, stmt: \"Function\") -&gt; Region:\n    return stmt.body\n</code></pre>"},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.Invoke","title":"Invoke  <code>dataclass</code>","text":"<pre><code>Invoke(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.Invoke.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>run mandatory validation checks. This is not same as typecheck, which may be optional.</p> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>def verify(self) -&gt; None:\n    if self.kwargs:\n        for name in self.kwargs:\n            if name not in self.callee.arg_names:\n                raise VerificationError(\n                    self,\n                    f\"method {self.callee.sym_name} does not have argument {name}\",\n                )\n    elif len(self.callee.arg_names) - 1 != len(self.args):\n        raise VerificationError(\n            self,\n            f\"expected {len(self.callee.arg_names)} arguments, got {len(self.args)}\",\n        )\n</code></pre>"},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.Lambda","title":"Lambda  <code>dataclass</code>","text":"<pre><code>Lambda(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.Lambda.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>run mandatory validation checks. This is not same as typecheck, which may be optional.</p> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>def verify(self) -&gt; None:\n    if self.body.blocks.isempty():\n        raise VerificationError(self, \"lambda body must not be empty\")\n</code></pre>"},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.Return","title":"Return","text":"<pre><code>Return(value_or_stmt: SSAValue | Statement | None = None)\n</code></pre> <p>               Bases: <code>Statement</code></p> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>def __init__(self, value_or_stmt: SSAValue | Statement | None = None) -&gt; None:\n    if isinstance(value_or_stmt, SSAValue):\n        args = [value_or_stmt]\n    elif isinstance(value_or_stmt, Statement):\n        if len(value_or_stmt._results) == 1:\n            args = [value_or_stmt._results[0]]\n        else:\n            raise ValueError(\n                f\"expected a single result, got {len(value_or_stmt._results)} results from {value_or_stmt.name}\"\n            )\n    elif value_or_stmt is None:\n        args = []\n    else:\n        raise ValueError(f\"expected SSAValue or Statement, got {value_or_stmt}\")\n\n    super().__init__(args=args, args_slice={\"value\": 0})\n</code></pre>"},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.Return.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>run mandatory validation checks. This is not same as typecheck, which may be optional.</p> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>def verify(self) -&gt; None:\n    if not self.args:\n        raise VerificationError(\n            self, \"return statement must have at least one value\"\n        )\n\n    if len(self.args) &gt; 1:\n        raise VerificationError(\n            self,\n            \"return statement must have at most one value\"\n            \", wrap multiple values in a tuple\",\n        )\n</code></pre>"},{"location":"reference/kirin/dialects/func/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/dialects/ilist/","title":"Index","text":"<p>Immutable list dialect for Python.</p> <p>This dialect provides a simple, immutable list dialect similar to Python's built-in list type.</p>"},{"location":"reference/kirin/dialects/ilist/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/ilist/lowering/","title":"Lowering","text":""},{"location":"reference/kirin/dialects/ilist/passes/","title":"Passes","text":""},{"location":"reference/kirin/dialects/ilist/passes/#kirin.dialects.ilist.passes.IListDesugar","title":"IListDesugar  <code>dataclass</code>","text":"<pre><code>IListDesugar(dialects: DialectGroup)\n</code></pre> <p>               Bases: <code>Pass</code></p> <p>This pass desugars the Python list dialect to the immutable list dialect by rewriting all constant <code>list</code> type into <code>IList</code> type.</p>"},{"location":"reference/kirin/dialects/ilist/runtime/","title":"Runtime","text":""},{"location":"reference/kirin/dialects/ilist/runtime/#kirin.dialects.ilist.runtime.IList","title":"IList  <code>dataclass</code>","text":"<pre><code>IList(data: Sequence[T])\n</code></pre> <p>               Bases: <code>Generic[T, L]</code></p> <p>A simple immutable list.</p>"},{"location":"reference/kirin/dialects/ilist/stmts/","title":"Stmts","text":""},{"location":"reference/kirin/dialects/ilist/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/dialects/ilist/rewrite/","title":"Index","text":""},{"location":"reference/kirin/dialects/ilist/rewrite/const/","title":"Const","text":""},{"location":"reference/kirin/dialects/ilist/rewrite/const/#kirin.dialects.ilist.rewrite.const.RewriteHinted","title":"RewriteHinted  <code>dataclass</code>","text":"<pre><code>RewriteHinted()\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <p>Rewrite type annotation for SSAValue with constant <code>IList</code> in <code>Hinted</code> type. This should be run after constant folding and <code>WrapConst</code> rule.</p>"},{"location":"reference/kirin/dialects/ilist/rewrite/list/","title":"List","text":""},{"location":"reference/kirin/dialects/ilist/rewrite/unroll/","title":"Unroll","text":""},{"location":"reference/kirin/dialects/math/","title":"Index","text":"<p>math dialect, modeling functions in python's <code>math</code> stdlib</p>"},{"location":"reference/kirin/dialects/math/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/dialects/math/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/math/stmts/","title":"Stmts","text":""},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.acos","title":"acos  <code>dataclass</code>","text":"<pre><code>acos(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>acos statement, wrapping the math.acos function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.asin","title":"asin  <code>dataclass</code>","text":"<pre><code>asin(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>asin statement, wrapping the math.asin function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.asinh","title":"asinh  <code>dataclass</code>","text":"<pre><code>asinh(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>asinh statement, wrapping the math.asinh function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.atan","title":"atan  <code>dataclass</code>","text":"<pre><code>atan(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>atan statement, wrapping the math.atan function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.atan2","title":"atan2  <code>dataclass</code>","text":"<pre><code>atan2(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>atan2 statement, wrapping the math.atan2 function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.atanh","title":"atanh  <code>dataclass</code>","text":"<pre><code>atanh(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>atanh statement, wrapping the math.atanh function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.ceil","title":"ceil  <code>dataclass</code>","text":"<pre><code>ceil(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>ceil statement, wrapping the math.ceil function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.copysign","title":"copysign  <code>dataclass</code>","text":"<pre><code>copysign(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>copysign statement, wrapping the math.copysign function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.cos","title":"cos  <code>dataclass</code>","text":"<pre><code>cos(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>cos statement, wrapping the math.cos function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.cosh","title":"cosh  <code>dataclass</code>","text":"<pre><code>cosh(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>cosh statement, wrapping the math.cosh function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.degrees","title":"degrees  <code>dataclass</code>","text":"<pre><code>degrees(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>degrees statement, wrapping the math.degrees function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.erf","title":"erf  <code>dataclass</code>","text":"<pre><code>erf(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>erf statement, wrapping the math.erf function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.erfc","title":"erfc  <code>dataclass</code>","text":"<pre><code>erfc(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>erfc statement, wrapping the math.erfc function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.exp","title":"exp  <code>dataclass</code>","text":"<pre><code>exp(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>exp statement, wrapping the math.exp function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.expm1","title":"expm1  <code>dataclass</code>","text":"<pre><code>expm1(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>expm1 statement, wrapping the math.expm1 function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.fabs","title":"fabs  <code>dataclass</code>","text":"<pre><code>fabs(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>fabs statement, wrapping the math.fabs function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.floor","title":"floor  <code>dataclass</code>","text":"<pre><code>floor(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>floor statement, wrapping the math.floor function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.fmod","title":"fmod  <code>dataclass</code>","text":"<pre><code>fmod(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>fmod statement, wrapping the math.fmod function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.gamma","title":"gamma  <code>dataclass</code>","text":"<pre><code>gamma(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>gamma statement, wrapping the math.gamma function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.isfinite","title":"isfinite  <code>dataclass</code>","text":"<pre><code>isfinite(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>isfinite statement, wrapping the math.isfinite function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.isinf","title":"isinf  <code>dataclass</code>","text":"<pre><code>isinf(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>isinf statement, wrapping the math.isinf function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.isnan","title":"isnan  <code>dataclass</code>","text":"<pre><code>isnan(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>isnan statement, wrapping the math.isnan function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.lgamma","title":"lgamma  <code>dataclass</code>","text":"<pre><code>lgamma(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>lgamma statement, wrapping the math.lgamma function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.log10","title":"log10  <code>dataclass</code>","text":"<pre><code>log10(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>log10 statement, wrapping the math.log10 function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.log1p","title":"log1p  <code>dataclass</code>","text":"<pre><code>log1p(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>log1p statement, wrapping the math.log1p function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.log2","title":"log2  <code>dataclass</code>","text":"<pre><code>log2(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>log2 statement, wrapping the math.log2 function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.pow","title":"pow  <code>dataclass</code>","text":"<pre><code>pow(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>pow statement, wrapping the math.pow function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.radians","title":"radians  <code>dataclass</code>","text":"<pre><code>radians(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>radians statement, wrapping the math.radians function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.remainder","title":"remainder  <code>dataclass</code>","text":"<pre><code>remainder(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>remainder statement, wrapping the math.remainder function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.sin","title":"sin  <code>dataclass</code>","text":"<pre><code>sin(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>sin statement, wrapping the math.sin function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.sinh","title":"sinh  <code>dataclass</code>","text":"<pre><code>sinh(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>sinh statement, wrapping the math.sinh function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.sqrt","title":"sqrt  <code>dataclass</code>","text":"<pre><code>sqrt(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>sqrt statement, wrapping the math.sqrt function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.tan","title":"tan  <code>dataclass</code>","text":"<pre><code>tan(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>tan statement, wrapping the math.tan function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.tanh","title":"tanh  <code>dataclass</code>","text":"<pre><code>tanh(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>tanh statement, wrapping the math.tanh function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.trunc","title":"trunc  <code>dataclass</code>","text":"<pre><code>trunc(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>trunc statement, wrapping the math.trunc function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.ulp","title":"ulp  <code>dataclass</code>","text":"<pre><code>ulp(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>ulp statement, wrapping the math.ulp function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/py/","title":"Index","text":""},{"location":"reference/kirin/dialects/py/#kirin.dialects.py.statement","title":"statement","text":"<pre><code>statement(\n    cls=None, **kwargs: Unpack[StatementOptions]\n) -&gt; Callable[[type[StmtType]], type[StmtType]]\n</code></pre> <p>Declare a new statement class.</p> <p>This decorator is used to declare a new statement class. It is used to generate the necessary boilerplate code for the class. The class should inherit from <code>kirin.ir.Statement</code>.</p> <p>Parameters:</p> Name Type Description Default <code>init(bool)</code> <p>Whether to generate an <code>__init__</code> method.</p> required <code>repr(bool)</code> <p>Whether to generate a <code>__repr__</code> method.</p> required <code>kw_only(bool)</code> <p>Whether to use keyword-only arguments in the <code>__init__</code> method.</p> required <code>dialect(Optional[Dialect])</code> <p>The dialect of the statement.</p> required <code>property(bool)</code> <p>Whether to generate property methods for attributes.</p> required Example <p>The following is an example of how to use the <code>statement</code> decorator.</p> <pre><code># optionally register the statement with\n# @statement(dialect=my_dialect_object)\n@statement\nclass MyStatement(ir.Statement):\n    name = \"some_name\"\n    traits = frozenset({TraitA(), TraitB()})\n    some_input: ir.SSAValue = info.argument()\n    some_output: ir.ResultValue = info.result()\n    body: ir.Region = info.region()\n    successor: ir.Block = info.block()\n</code></pre> Source code in <code>src/kirin/decl/__init__.py</code> <pre><code>@dataclass_transform(\n    field_specifiers=(\n        info.attribute,\n        info.argument,\n        info.region,\n        info.result,\n        info.block,\n    )\n)\ndef statement(\n    cls=None,\n    **kwargs: Unpack[StatementOptions],\n) -&gt; Callable[[type[StmtType]], type[StmtType]]:\n    \"\"\"Declare a new statement class.\n\n    This decorator is used to declare a new statement class. It is used to\n    generate the necessary boilerplate code for the class. The class should\n    inherit from `kirin.ir.Statement`.\n\n    Args:\n        init(bool): Whether to generate an `__init__` method.\n        repr(bool): Whether to generate a `__repr__` method.\n        kw_only(bool): Whether to use keyword-only arguments in the `__init__`\n            method.\n        dialect(Optional[Dialect]): The dialect of the statement.\n        property(bool): Whether to generate property methods for attributes.\n\n    Example:\n        The following is an example of how to use the `statement` decorator.\n\n        ```python\n        # optionally register the statement with\n        # @statement(dialect=my_dialect_object)\n        @statement\n        class MyStatement(ir.Statement):\n            name = \"some_name\"\n            traits = frozenset({TraitA(), TraitB()})\n            some_input: ir.SSAValue = info.argument()\n            some_output: ir.ResultValue = info.result()\n            body: ir.Region = info.region()\n            successor: ir.Block = info.block()\n        ```\n    \"\"\"\n\n    def wrap(cls):\n        decl = StatementDecl(cls, **kwargs)\n        decl.scan_fields()\n        decl.verify()\n        decl.emit()\n        decl.register()\n        return cls\n\n    if cls is None:\n        return wrap\n    return wrap(cls)\n</code></pre>"},{"location":"reference/kirin/dialects/py/assign/","title":"Assign","text":""},{"location":"reference/kirin/dialects/py/attr/","title":"Attr","text":""},{"location":"reference/kirin/dialects/py/base/","title":"Base","text":"<p>Base dialect for Python.</p> <p>This dialect does not contain statements. It only contains lowering rules for <code>ast.Name</code> and <code>ast.Expr</code>.</p>"},{"location":"reference/kirin/dialects/py/boolop/","title":"Boolop","text":""},{"location":"reference/kirin/dialects/py/builtin/","title":"Builtin","text":""},{"location":"reference/kirin/dialects/py/constant/","title":"Constant","text":""},{"location":"reference/kirin/dialects/py/constant/#kirin.dialects.py.constant.Constant","title":"Constant","text":"<pre><code>Constant(value: T | ir.PyAttr[T])\n</code></pre> <p>               Bases: <code>Statement</code>, <code>Generic[T]</code></p> Source code in <code>src/kirin/dialects/py/constant.py</code> <pre><code>def __init__(self, value: T | ir.PyAttr[T]) -&gt; None:\n    if not isinstance(value, ir.PyAttr):\n        value = ir.PyAttr(value)\n    super().__init__(\n        properties={\"value\": value},\n        result_types=(value.type,),\n    )\n</code></pre>"},{"location":"reference/kirin/dialects/py/constant/#kirin.dialects.py.constant.Constant.typecheck","title":"typecheck","text":"<pre><code>typecheck() -&gt; None\n</code></pre> <p>check the type of the statement.</p> Note <ol> <li>Statement should implement typecheck. this is done automatically via @statement, but in the case manualy implementation is needed, it should be implemented here.</li> <li>This API should be called after all the types are figured out (by typeinfer)</li> </ol> Source code in <code>src/kirin/dialects/py/constant.py</code> <pre><code>def typecheck(self) -&gt; None:\n    if not isinstance(self.result.type, ir.types.TypeAttribute):\n        raise exceptions.VerificationError(\n            self, f\"Expected result type to be PyType, got {self.result.type}\"\n        )\n</code></pre>"},{"location":"reference/kirin/dialects/py/indexing/","title":"Indexing","text":""},{"location":"reference/kirin/dialects/py/len/","title":"Len","text":""},{"location":"reference/kirin/dialects/py/range/","title":"Range","text":""},{"location":"reference/kirin/dialects/py/slice/","title":"Slice","text":""},{"location":"reference/kirin/dialects/py/tuple/","title":"Tuple","text":""},{"location":"reference/kirin/dialects/py/binop/","title":"Index","text":""},{"location":"reference/kirin/dialects/py/binop/#kirin.dialects.py.binop.statement","title":"statement","text":"<pre><code>statement(\n    cls=None, **kwargs: Unpack[StatementOptions]\n) -&gt; Callable[[type[StmtType]], type[StmtType]]\n</code></pre> <p>Declare a new statement class.</p> <p>This decorator is used to declare a new statement class. It is used to generate the necessary boilerplate code for the class. The class should inherit from <code>kirin.ir.Statement</code>.</p> <p>Parameters:</p> Name Type Description Default <code>init(bool)</code> <p>Whether to generate an <code>__init__</code> method.</p> required <code>repr(bool)</code> <p>Whether to generate a <code>__repr__</code> method.</p> required <code>kw_only(bool)</code> <p>Whether to use keyword-only arguments in the <code>__init__</code> method.</p> required <code>dialect(Optional[Dialect])</code> <p>The dialect of the statement.</p> required <code>property(bool)</code> <p>Whether to generate property methods for attributes.</p> required Example <p>The following is an example of how to use the <code>statement</code> decorator.</p> <pre><code># optionally register the statement with\n# @statement(dialect=my_dialect_object)\n@statement\nclass MyStatement(ir.Statement):\n    name = \"some_name\"\n    traits = frozenset({TraitA(), TraitB()})\n    some_input: ir.SSAValue = info.argument()\n    some_output: ir.ResultValue = info.result()\n    body: ir.Region = info.region()\n    successor: ir.Block = info.block()\n</code></pre> Source code in <code>src/kirin/decl/__init__.py</code> <pre><code>@dataclass_transform(\n    field_specifiers=(\n        info.attribute,\n        info.argument,\n        info.region,\n        info.result,\n        info.block,\n    )\n)\ndef statement(\n    cls=None,\n    **kwargs: Unpack[StatementOptions],\n) -&gt; Callable[[type[StmtType]], type[StmtType]]:\n    \"\"\"Declare a new statement class.\n\n    This decorator is used to declare a new statement class. It is used to\n    generate the necessary boilerplate code for the class. The class should\n    inherit from `kirin.ir.Statement`.\n\n    Args:\n        init(bool): Whether to generate an `__init__` method.\n        repr(bool): Whether to generate a `__repr__` method.\n        kw_only(bool): Whether to use keyword-only arguments in the `__init__`\n            method.\n        dialect(Optional[Dialect]): The dialect of the statement.\n        property(bool): Whether to generate property methods for attributes.\n\n    Example:\n        The following is an example of how to use the `statement` decorator.\n\n        ```python\n        # optionally register the statement with\n        # @statement(dialect=my_dialect_object)\n        @statement\n        class MyStatement(ir.Statement):\n            name = \"some_name\"\n            traits = frozenset({TraitA(), TraitB()})\n            some_input: ir.SSAValue = info.argument()\n            some_output: ir.ResultValue = info.result()\n            body: ir.Region = info.region()\n            successor: ir.Block = info.block()\n        ```\n    \"\"\"\n\n    def wrap(cls):\n        decl = StatementDecl(cls, **kwargs)\n        decl.scan_fields()\n        decl.verify()\n        decl.emit()\n        decl.register()\n        return cls\n\n    if cls is None:\n        return wrap\n    return wrap(cls)\n</code></pre>"},{"location":"reference/kirin/dialects/py/binop/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/py/binop/julia/","title":"Julia","text":""},{"location":"reference/kirin/dialects/py/binop/lowering/","title":"Lowering","text":""},{"location":"reference/kirin/dialects/py/binop/stmts/","title":"Stmts","text":""},{"location":"reference/kirin/dialects/py/binop/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/dialects/py/cmp/","title":"Index","text":""},{"location":"reference/kirin/dialects/py/cmp/#kirin.dialects.py.cmp.statement","title":"statement","text":"<pre><code>statement(\n    cls=None, **kwargs: Unpack[StatementOptions]\n) -&gt; Callable[[type[StmtType]], type[StmtType]]\n</code></pre> <p>Declare a new statement class.</p> <p>This decorator is used to declare a new statement class. It is used to generate the necessary boilerplate code for the class. The class should inherit from <code>kirin.ir.Statement</code>.</p> <p>Parameters:</p> Name Type Description Default <code>init(bool)</code> <p>Whether to generate an <code>__init__</code> method.</p> required <code>repr(bool)</code> <p>Whether to generate a <code>__repr__</code> method.</p> required <code>kw_only(bool)</code> <p>Whether to use keyword-only arguments in the <code>__init__</code> method.</p> required <code>dialect(Optional[Dialect])</code> <p>The dialect of the statement.</p> required <code>property(bool)</code> <p>Whether to generate property methods for attributes.</p> required Example <p>The following is an example of how to use the <code>statement</code> decorator.</p> <pre><code># optionally register the statement with\n# @statement(dialect=my_dialect_object)\n@statement\nclass MyStatement(ir.Statement):\n    name = \"some_name\"\n    traits = frozenset({TraitA(), TraitB()})\n    some_input: ir.SSAValue = info.argument()\n    some_output: ir.ResultValue = info.result()\n    body: ir.Region = info.region()\n    successor: ir.Block = info.block()\n</code></pre> Source code in <code>src/kirin/decl/__init__.py</code> <pre><code>@dataclass_transform(\n    field_specifiers=(\n        info.attribute,\n        info.argument,\n        info.region,\n        info.result,\n        info.block,\n    )\n)\ndef statement(\n    cls=None,\n    **kwargs: Unpack[StatementOptions],\n) -&gt; Callable[[type[StmtType]], type[StmtType]]:\n    \"\"\"Declare a new statement class.\n\n    This decorator is used to declare a new statement class. It is used to\n    generate the necessary boilerplate code for the class. The class should\n    inherit from `kirin.ir.Statement`.\n\n    Args:\n        init(bool): Whether to generate an `__init__` method.\n        repr(bool): Whether to generate a `__repr__` method.\n        kw_only(bool): Whether to use keyword-only arguments in the `__init__`\n            method.\n        dialect(Optional[Dialect]): The dialect of the statement.\n        property(bool): Whether to generate property methods for attributes.\n\n    Example:\n        The following is an example of how to use the `statement` decorator.\n\n        ```python\n        # optionally register the statement with\n        # @statement(dialect=my_dialect_object)\n        @statement\n        class MyStatement(ir.Statement):\n            name = \"some_name\"\n            traits = frozenset({TraitA(), TraitB()})\n            some_input: ir.SSAValue = info.argument()\n            some_output: ir.ResultValue = info.result()\n            body: ir.Region = info.region()\n            successor: ir.Block = info.block()\n        ```\n    \"\"\"\n\n    def wrap(cls):\n        decl = StatementDecl(cls, **kwargs)\n        decl.scan_fields()\n        decl.verify()\n        decl.emit()\n        decl.register()\n        return cls\n\n    if cls is None:\n        return wrap\n    return wrap(cls)\n</code></pre>"},{"location":"reference/kirin/dialects/py/cmp/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/py/cmp/julia/","title":"Julia","text":""},{"location":"reference/kirin/dialects/py/cmp/lowering/","title":"Lowering","text":""},{"location":"reference/kirin/dialects/py/cmp/stmts/","title":"Stmts","text":""},{"location":"reference/kirin/dialects/py/list/","title":"Index","text":""},{"location":"reference/kirin/dialects/py/list/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/py/list/lowering/","title":"Lowering","text":""},{"location":"reference/kirin/dialects/py/list/stmts/","title":"Stmts","text":""},{"location":"reference/kirin/dialects/py/list/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/dialects/py/unary/","title":"Index","text":""},{"location":"reference/kirin/dialects/py/unary/#kirin.dialects.py.unary.statement","title":"statement","text":"<pre><code>statement(\n    cls=None, **kwargs: Unpack[StatementOptions]\n) -&gt; Callable[[type[StmtType]], type[StmtType]]\n</code></pre> <p>Declare a new statement class.</p> <p>This decorator is used to declare a new statement class. It is used to generate the necessary boilerplate code for the class. The class should inherit from <code>kirin.ir.Statement</code>.</p> <p>Parameters:</p> Name Type Description Default <code>init(bool)</code> <p>Whether to generate an <code>__init__</code> method.</p> required <code>repr(bool)</code> <p>Whether to generate a <code>__repr__</code> method.</p> required <code>kw_only(bool)</code> <p>Whether to use keyword-only arguments in the <code>__init__</code> method.</p> required <code>dialect(Optional[Dialect])</code> <p>The dialect of the statement.</p> required <code>property(bool)</code> <p>Whether to generate property methods for attributes.</p> required Example <p>The following is an example of how to use the <code>statement</code> decorator.</p> <pre><code># optionally register the statement with\n# @statement(dialect=my_dialect_object)\n@statement\nclass MyStatement(ir.Statement):\n    name = \"some_name\"\n    traits = frozenset({TraitA(), TraitB()})\n    some_input: ir.SSAValue = info.argument()\n    some_output: ir.ResultValue = info.result()\n    body: ir.Region = info.region()\n    successor: ir.Block = info.block()\n</code></pre> Source code in <code>src/kirin/decl/__init__.py</code> <pre><code>@dataclass_transform(\n    field_specifiers=(\n        info.attribute,\n        info.argument,\n        info.region,\n        info.result,\n        info.block,\n    )\n)\ndef statement(\n    cls=None,\n    **kwargs: Unpack[StatementOptions],\n) -&gt; Callable[[type[StmtType]], type[StmtType]]:\n    \"\"\"Declare a new statement class.\n\n    This decorator is used to declare a new statement class. It is used to\n    generate the necessary boilerplate code for the class. The class should\n    inherit from `kirin.ir.Statement`.\n\n    Args:\n        init(bool): Whether to generate an `__init__` method.\n        repr(bool): Whether to generate a `__repr__` method.\n        kw_only(bool): Whether to use keyword-only arguments in the `__init__`\n            method.\n        dialect(Optional[Dialect]): The dialect of the statement.\n        property(bool): Whether to generate property methods for attributes.\n\n    Example:\n        The following is an example of how to use the `statement` decorator.\n\n        ```python\n        # optionally register the statement with\n        # @statement(dialect=my_dialect_object)\n        @statement\n        class MyStatement(ir.Statement):\n            name = \"some_name\"\n            traits = frozenset({TraitA(), TraitB()})\n            some_input: ir.SSAValue = info.argument()\n            some_output: ir.ResultValue = info.result()\n            body: ir.Region = info.region()\n            successor: ir.Block = info.block()\n        ```\n    \"\"\"\n\n    def wrap(cls):\n        decl = StatementDecl(cls, **kwargs)\n        decl.scan_fields()\n        decl.verify()\n        decl.emit()\n        decl.register()\n        return cls\n\n    if cls is None:\n        return wrap\n    return wrap(cls)\n</code></pre>"},{"location":"reference/kirin/dialects/py/unary/constprop/","title":"Constprop","text":""},{"location":"reference/kirin/dialects/py/unary/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/py/unary/julia/","title":"Julia","text":""},{"location":"reference/kirin/dialects/py/unary/lowering/","title":"Lowering","text":""},{"location":"reference/kirin/dialects/py/unary/stmts/","title":"Stmts","text":""},{"location":"reference/kirin/dialects/py/unary/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/emit/","title":"Index","text":""},{"location":"reference/kirin/emit/abc/","title":"Abc","text":""},{"location":"reference/kirin/emit/abc/#kirin.emit.abc.EmitABC","title":"EmitABC  <code>dataclass</code>","text":"<pre><code>EmitABC(\n    dialects: DialectGroup,\n    *,\n    fuel: int | None = None,\n    debug: bool = False,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192\n)\n</code></pre> <p>               Bases: <code>BaseInterpreter[FrameType, ValueType]</code>, <code>ABC</code></p>"},{"location":"reference/kirin/emit/abc/#kirin.emit.abc.EmitABC.run_callable_region","title":"run_callable_region","text":"<pre><code>run_callable_region(\n    frame: FrameType, code: ir.Statement, region: ir.Region\n) -&gt; ValueType\n</code></pre> <p>A hook defines how to run the callable region given the interpreter context.</p> Note <p>This is experimental API, don't subclass it. The current reason of having it is mainly because we need to dispatch back to the MethodTable for emit.</p> Source code in <code>src/kirin/emit/abc.py</code> <pre><code>def run_callable_region(\n    self, frame: FrameType, code: ir.Statement, region: ir.Region\n) -&gt; ValueType:\n    results = self.eval_stmt(frame, code)\n    if isinstance(results, tuple):\n        if len(results) == 0:\n            return self.void\n        elif len(results) == 1:\n            return results[0]\n    raise interp.InterpreterError(f\"Unexpected results {results}\")\n</code></pre>"},{"location":"reference/kirin/emit/julia/","title":"Julia","text":""},{"location":"reference/kirin/emit/julia/#kirin.emit.julia.EmitJulia","title":"EmitJulia  <code>dataclass</code>","text":"<pre><code>EmitJulia(\n    dialects: DialectGroup,\n    file: IO_t,\n    *,\n    fuel: int | None = None,\n    debug: bool = False,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192,\n    prefix: str = \"\",\n    prefix_if_none: str = \"var_\"\n)\n</code></pre> <p>               Bases: <code>EmitStr[IO_t]</code></p>"},{"location":"reference/kirin/emit/julia/#kirin.emit.julia.EmitJulia.keys","title":"keys  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>keys = ['emit.julia']\n</code></pre> <p>The name of the interpreter to select from dialects by order.</p>"},{"location":"reference/kirin/emit/str/","title":"Str","text":""},{"location":"reference/kirin/emit/str/#kirin.emit.str.EmitStr","title":"EmitStr  <code>dataclass</code>","text":"<pre><code>EmitStr(\n    dialects: DialectGroup,\n    file: IO_t,\n    *,\n    fuel: int | None = None,\n    debug: bool = False,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192,\n    prefix: str = \"\",\n    prefix_if_none: str = \"var_\"\n)\n</code></pre> <p>               Bases: <code>EmitABC[EmitStrFrame, str]</code>, <code>ABC</code>, <code>Generic[IO_t]</code></p>"},{"location":"reference/kirin/emit/str/#kirin.emit.str.EmitStr.void","title":"void  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>void = ''\n</code></pre> <p>What to return when the interpreter evaluates nothing.</p>"},{"location":"reference/kirin/emit/str/#kirin.emit.str.EmitStr.initialize","title":"initialize","text":"<pre><code>initialize()\n</code></pre> <p>Initialize the interpreter global states.</p> <p>This method is called before calling <code>eval</code> to initialize the interpreter global states.</p> <p>Override this method to add custom global states.</p> Source code in <code>src/kirin/emit/str.py</code> <pre><code>def initialize(self):\n    super().initialize()\n    self.ssa_id = idtable.IdTable[ir.SSAValue](\n        prefix=self.prefix, prefix_if_none=self.prefix_if_none\n    )\n    self.block_id = idtable.IdTable[ir.Block](prefix=self.prefix + \"block_\")\n</code></pre>"},{"location":"reference/kirin/emit/str/#kirin.emit.str.EmitStr.new_frame","title":"new_frame","text":"<pre><code>new_frame(code: ir.Statement) -&gt; EmitStrFrame\n</code></pre> <p>Create a new frame for the given method.</p> Source code in <code>src/kirin/emit/str.py</code> <pre><code>def new_frame(self, code: ir.Statement) -&gt; EmitStrFrame:\n    return EmitStrFrame.from_func_like(code)\n</code></pre>"},{"location":"reference/kirin/emit/str/#kirin.emit.str.EmitStr.run_method","title":"run_method","text":"<pre><code>run_method(method: ir.Method, args: tuple[str, ...]) -&gt; str\n</code></pre> <p>How to run a method.</p> <p>This is defined by subclasses to describe what's the corresponding value of a method during the interpretation.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Method</code> <p>the method to run.</p> required <code>args</code> <code>tuple[ValueType]</code> <p>the arguments to the method, does not include self.</p> required <p>Returns:</p> Name Type Description <code>ValueType</code> <code>ValueType</code> <p>the result of the method.</p> Source code in <code>src/kirin/emit/str.py</code> <pre><code>def run_method(self, method: ir.Method, args: tuple[str, ...]) -&gt; str:\n    if len(self.state.frames) &gt;= self.max_depth:\n        raise interp.InterpreterError(\"maximum recursion depth exceeded\")\n    return self.run_callable(method.code, (method.sym_name,) + args)\n</code></pre>"},{"location":"reference/kirin/interp/","title":"Index","text":""},{"location":"reference/kirin/interp/abstract/","title":"Abstract","text":""},{"location":"reference/kirin/interp/abstract/#kirin.interp.abstract.AbstractInterpreter","title":"AbstractInterpreter  <code>dataclass</code>","text":"<pre><code>AbstractInterpreter(\n    dialects: DialectGroup,\n    *,\n    fuel: int | None = None,\n    debug: bool = False,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192\n)\n</code></pre> <p>               Bases: <code>BaseInterpreter[AbstractFrameType, ResultType]</code>, <code>ABC</code></p>"},{"location":"reference/kirin/interp/abstract/#kirin.interp.abstract.AbstractInterpreter.lattice","title":"lattice  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lattice: type[BoundedLattice[ResultType]] = field(\n    init=False\n)\n</code></pre> <p>lattice type for the abstract interpreter.</p>"},{"location":"reference/kirin/interp/base/","title":"Base","text":""},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter","title":"BaseInterpreter  <code>dataclass</code>","text":"<pre><code>BaseInterpreter(\n    dialects: DialectGroup,\n    *,\n    fuel: int | None = None,\n    debug: bool = False,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192\n)\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[FrameType, ValueType]</code></p> <p>A base class for interpreters.</p> <p>This class defines the basic structure of an interpreter. It is designed to be subclassed to provide the actual implementation of the interpreter.</p> <p>When subclassing, if the bases contains <code>ABC</code> no checks will be performed on the subclass. If the subclass does not contain <code>ABC</code>, the subclass must define the following attributes:</p> <ul> <li><code>keys</code>: a list of strings that defines the order of dialects to select from.</li> <li><code>void</code>: the value to return when the interpreter evaluates nothing.</li> </ul>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.debug","title":"debug  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug: bool = field(default=False, kw_only=True)\n</code></pre> <p>Whether to enable debug mode.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.dialects","title":"dialects  <code>instance-attribute</code>","text":"<pre><code>dialects: DialectGroup\n</code></pre> <p>The dialects to interpret.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.fuel","title":"fuel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fuel: int | None = field(default=None, kw_only=True)\n</code></pre> <p>The fuel limit for the interpreter.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.keys","title":"keys  <code>class-attribute</code>","text":"<pre><code>keys: list[str]\n</code></pre> <p>The name of the interpreter to select from dialects by order.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.max_depth","title":"max_depth  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_depth: int = field(default=128, kw_only=True)\n</code></pre> <p>The maximum depth of the interpreter stack.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.max_python_recursion_depth","title":"max_python_recursion_depth  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_python_recursion_depth: int = field(\n    default=8192, kw_only=True\n)\n</code></pre> <p>The maximum recursion depth of the Python interpreter.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.registry","title":"registry  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>registry: InterpreterRegistry = field(\n    init=False, compare=False\n)\n</code></pre> <p>The interpreter registry.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.state","title":"state  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>state: InterpreterState[FrameType] = field(\n    init=False, compare=False\n)\n</code></pre> <p>The interpreter state.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.symbol_table","title":"symbol_table  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol_table: dict[str, Statement] = field(\n    init=False, compare=False\n)\n</code></pre> <p>The symbol table.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.void","title":"void  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>void: ValueType = field(init=False)\n</code></pre> <p>What to return when the interpreter evaluates nothing.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.build_signature","title":"build_signature","text":"<pre><code>build_signature(\n    frame: FrameType, stmt: Statement\n) -&gt; Signature\n</code></pre> <p>build signature for querying the statement implementation.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def build_signature(self, frame: FrameType, stmt: Statement) -&gt; \"Signature\":\n    \"\"\"build signature for querying the statement implementation.\"\"\"\n    return Signature(stmt.__class__, tuple(arg.type for arg in stmt.args))\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.eval_stmt","title":"eval_stmt","text":"<pre><code>eval_stmt(\n    frame: FrameType, stmt: Statement\n) -&gt; StatementResult[ValueType]\n</code></pre> <p>Run a statement within the current frame. This is the entry point of running a statement. It will look up the statement implementation in the dialect registry, or optionally call a fallback implementation.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>FrameType</code> <p>the current frame</p> required <code>stmt</code> <code>Statement</code> <p>the statement to run</p> required <p>Returns:</p> Name Type Description <code>StatementResult</code> <code>StatementResult[ValueType]</code> <p>the result of running the statement</p> Note <p>Overload this method for the following reasons: - to change the source tracking information - to take control of how to run a statement - to change the implementation lookup behavior that cannot acheive     by overloading <code>lookup_registry</code></p> Example <ul> <li>implement an interpreter that only handles MyStmt: <pre><code>    class MyInterpreter(BaseInterpreter):\n        ...\n        def eval_stmt(self, frame: FrameType, stmt: Statement) -&gt; StatementResult[ValueType]:\n            if isinstance(stmt, MyStmt):\n                return self.run_my_stmt(frame, stmt)\n            else:\n                return ()\n</code></pre></li> </ul> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def eval_stmt(\n    self, frame: FrameType, stmt: Statement\n) -&gt; StatementResult[ValueType]:\n    \"\"\"Run a statement within the current frame. This is the entry\n    point of running a statement. It will look up the statement implementation\n    in the dialect registry, or optionally call a fallback implementation.\n\n    Args:\n        frame: the current frame\n        stmt: the statement to run\n\n    Returns:\n        StatementResult: the result of running the statement\n\n    Note:\n        Overload this method for the following reasons:\n        - to change the source tracking information\n        - to take control of how to run a statement\n        - to change the implementation lookup behavior that cannot acheive\n            by overloading [`lookup_registry`][kirin.interp.base.BaseInterpreter.lookup_registry]\n\n    Example:\n        * implement an interpreter that only handles MyStmt:\n        ```python\n            class MyInterpreter(BaseInterpreter):\n                ...\n                def eval_stmt(self, frame: FrameType, stmt: Statement) -&gt; StatementResult[ValueType]:\n                    if isinstance(stmt, MyStmt):\n                        return self.run_my_stmt(frame, stmt)\n                    else:\n                        return ()\n        ```\n\n    \"\"\"\n    # TODO: update tracking information\n    method = self.lookup_registry(frame, stmt)\n    if method is not None:\n        results = method(self, frame, stmt)\n        if self.debug and not isinstance(results, (tuple, SpecialValue)):\n            raise InterpreterError(\n                f\"method must return tuple or SpecialResult, got {results}\"\n            )\n        return results\n\n    return self.eval_stmt_fallback(frame, stmt)\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.eval_stmt_fallback","title":"eval_stmt_fallback","text":"<pre><code>eval_stmt_fallback(\n    frame: FrameType, stmt: Statement\n) -&gt; StatementResult[ValueType]\n</code></pre> <p>The fallback implementation of statements.</p> <p>This is called when no implementation is found for the statement.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>FrameType</code> <p>the current frame</p> required <code>stmt</code> <code>Statement</code> <p>the statement to run</p> required <p>Returns:</p> Name Type Description <code>StatementResult</code> <code>StatementResult[ValueType]</code> <p>the result of running the statement</p> Note <p>Overload this method to provide a fallback implementation for statements.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def eval_stmt_fallback(\n    self, frame: FrameType, stmt: Statement\n) -&gt; StatementResult[ValueType]:\n    \"\"\"The fallback implementation of statements.\n\n    This is called when no implementation is found for the statement.\n\n    Args:\n        frame: the current frame\n        stmt: the statement to run\n\n    Returns:\n        StatementResult: the result of running the statement\n\n    Note:\n        Overload this method to provide a fallback implementation for statements.\n    \"\"\"\n    # NOTE: not using f-string here because 3.10 and 3.11 have\n    #  parser bug that doesn't allow f-string in raise statement\n    raise ValueError(\n        \"no implementation for stmt \"\n        + stmt.print_str(end=\"\")\n        + \" from \"\n        + str(type(self))\n    )\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.finalize","title":"finalize","text":"<pre><code>finalize(frame: FrameType, results: ValueType) -&gt; ValueType\n</code></pre> <p>Postprocess a frame after it is popped from the stack. This is called after a method is evaluated and the frame is popped.</p> Note <p>Default implementation does nothing.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def finalize(self, frame: FrameType, results: ValueType) -&gt; ValueType:\n    \"\"\"Postprocess a frame after it is popped from the stack. This is\n    called after a method is evaluated and the frame is popped.\n\n    Note:\n        Default implementation does nothing.\n    \"\"\"\n    return results\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.initialize","title":"initialize","text":"<pre><code>initialize() -&gt; Self\n</code></pre> <p>Initialize the interpreter global states.</p> <p>This method is called before calling <code>eval</code> to initialize the interpreter global states.</p> <p>Override this method to add custom global states.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def initialize(self) -&gt; Self:\n    \"\"\"Initialize the interpreter global states.\n\n    This method is called before calling `eval` to initialize the\n    interpreter global states.\n\n    Override this method to add custom global states.\n    \"\"\"\n    self.symbol_table: dict[str, Statement] = {}\n    self.state: InterpreterState[FrameType] = InterpreterState()\n    return self\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.new_frame","title":"new_frame  <code>abstractmethod</code>","text":"<pre><code>new_frame(code: Statement) -&gt; FrameType\n</code></pre> <p>Create a new frame for the given method.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>@abstractmethod\ndef new_frame(self, code: Statement) -&gt; FrameType:\n    \"\"\"Create a new frame for the given method.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.permute_values","title":"permute_values  <code>staticmethod</code>","text":"<pre><code>permute_values(\n    arg_names: Sequence[str],\n    values: tuple[ValueType, ...],\n    kwarg_names: tuple[str, ...],\n) -&gt; tuple[ValueType, ...]\n</code></pre> <p>Permute the arguments according to the method signature and the given keyword arguments, where the keyword argument names refer to the last n arguments in the values tuple.</p> <p>Parameters:</p> Name Type Description Default <code>arg_names</code> <code>Sequence[str]</code> <p>the argument names</p> required <code>values</code> <code>tuple[ValueType, ...]</code> <p>the values tuple (should not contain method itself)</p> required <code>kwarg_names</code> <code>tuple[str, ...]</code> <p>the keyword argument names</p> required Source code in <code>src/kirin/interp/base.py</code> <pre><code>@staticmethod\ndef permute_values(\n    arg_names: Sequence[str],\n    values: tuple[ValueType, ...],\n    kwarg_names: tuple[str, ...],\n) -&gt; tuple[ValueType, ...]:\n    \"\"\"Permute the arguments according to the method signature and\n    the given keyword arguments, where the keyword argument names\n    refer to the last n arguments in the values tuple.\n\n    Args:\n        arg_names: the argument names\n        values: the values tuple (should not contain method itself)\n        kwarg_names: the keyword argument names\n    \"\"\"\n    n_total = len(values)\n    if kwarg_names:\n        kwargs = dict(zip(kwarg_names, values[n_total - len(kwarg_names) :]))\n    else:\n        kwargs = None\n\n    positionals = values[: n_total - len(kwarg_names)]\n    args = BaseInterpreter.get_args(\n        arg_names[len(positionals) + 1 :], positionals, kwargs\n    )\n    return args\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.run","title":"run","text":"<pre><code>run(\n    mt: Method,\n    args: tuple[ValueType, ...],\n    kwargs: dict[str, ValueType] | None = None,\n) -&gt; Result[ValueType]\n</code></pre> <p>Run a method.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def run(\n    self,\n    mt: Method,\n    args: tuple[ValueType, ...],\n    kwargs: dict[str, ValueType] | None = None,\n) -&gt; Result[ValueType]:\n    \"\"\"Run a method.\"\"\"\n    if self._eval_lock:\n        raise InterpreterError(\n            \"recursive eval is not allowed, use run_method instead\"\n        )\n\n    self._eval_lock = True\n    self.initialize()\n    current_recursion_limit = sys.getrecursionlimit()\n    sys.setrecursionlimit(self.max_python_recursion_depth)\n    args = self.get_args(mt.arg_names[len(args) + 1 :], args, kwargs)\n    try:\n        results = self.run_method(mt, args)\n    except InterpreterError as e:\n        # NOTE: initialize will create new State\n        # so we don't need to copy the frames.\n        return Err(e, self.state.frames)\n    finally:\n        self._eval_lock = False\n        sys.setrecursionlimit(current_recursion_limit)\n    return Ok(results)\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.run_callable","title":"run_callable","text":"<pre><code>run_callable(\n    code: Statement, args: tuple[ValueType, ...]\n) -&gt; ValueType\n</code></pre> <p>Run a callable statement.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>Statement</code> <p>the statement to run.</p> required <code>args</code> <code>tuple[ValueType]</code> <p>the arguments to the statement, includes self if the corresponding callable region contains a self argument.</p> required <p>Returns:</p> Name Type Description <code>ValueType</code> <code>ValueType</code> <p>the result of the statement.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def run_callable(self, code: Statement, args: tuple[ValueType, ...]) -&gt; ValueType:\n    \"\"\"Run a callable statement.\n\n    Args:\n        code (Statement): the statement to run.\n        args (tuple[ValueType]): the arguments to the statement,\n            includes self if the corresponding callable region contains a self argument.\n\n    Returns:\n        ValueType: the result of the statement.\n    \"\"\"\n    interface = code.get_trait(traits.CallableStmtInterface)\n    if interface is None:\n        raise InterpreterError(f\"statement {code.name} is not callable\")\n\n    frame = self.new_frame(code)\n    self.state.push_frame(frame)\n    body = interface.get_callable_region(code)\n    if not body.blocks:\n        return self.finalize(self.state.pop_frame(), self.void)\n    frame.set_values(body.blocks[0].args, args)\n    results = self.run_callable_region(frame, code, body)\n    return self.finalize(self.state.pop_frame(), results)\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.run_callable_region","title":"run_callable_region","text":"<pre><code>run_callable_region(\n    frame: FrameType, code: Statement, region: Region\n) -&gt; ValueType\n</code></pre> <p>A hook defines how to run the callable region given the interpreter context.</p> Note <p>This is experimental API, don't subclass it. The current reason of having it is mainly because we need to dispatch back to the MethodTable for emit.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def run_callable_region(\n    self, frame: FrameType, code: Statement, region: Region\n) -&gt; ValueType:\n    \"\"\"A hook defines how to run the callable region given\n    the interpreter context.\n\n    Note:\n        This is experimental API, don't\n        subclass it. The current reason of having it is mainly\n        because we need to dispatch back to the MethodTable for\n        emit.\n    \"\"\"\n    return self.run_ssacfg_region(frame, region)\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.run_method","title":"run_method  <code>abstractmethod</code>","text":"<pre><code>run_method(\n    method: Method, args: tuple[ValueType, ...]\n) -&gt; ValueType\n</code></pre> <p>How to run a method.</p> <p>This is defined by subclasses to describe what's the corresponding value of a method during the interpretation.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Method</code> <p>the method to run.</p> required <code>args</code> <code>tuple[ValueType]</code> <p>the arguments to the method, does not include self.</p> required <p>Returns:</p> Name Type Description <code>ValueType</code> <code>ValueType</code> <p>the result of the method.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>@abstractmethod\ndef run_method(self, method: Method, args: tuple[ValueType, ...]) -&gt; ValueType:\n    \"\"\"How to run a method.\n\n    This is defined by subclasses to describe what's the corresponding\n    value of a method during the interpretation.\n\n    Args:\n        method (Method): the method to run.\n        args (tuple[ValueType]): the arguments to the method, does not include self.\n\n    Returns:\n        ValueType: the result of the method.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/interp/concrete/","title":"Concrete","text":""},{"location":"reference/kirin/interp/concrete/#kirin.interp.concrete.Interpreter","title":"Interpreter  <code>dataclass</code>","text":"<pre><code>Interpreter(\n    dialects: DialectGroup,\n    *,\n    fuel: int | None = None,\n    debug: bool = False,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192\n)\n</code></pre> <p>               Bases: <code>BaseInterpreter[Frame[Any], Any]</code></p>"},{"location":"reference/kirin/interp/concrete/#kirin.interp.concrete.Interpreter.keys","title":"keys  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>keys = ['main']\n</code></pre> <p>The name of the interpreter to select from dialects by order.</p>"},{"location":"reference/kirin/interp/concrete/#kirin.interp.concrete.Interpreter.void","title":"void  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>void = None\n</code></pre> <p>What to return when the interpreter evaluates nothing.</p>"},{"location":"reference/kirin/interp/concrete/#kirin.interp.concrete.Interpreter.new_frame","title":"new_frame","text":"<pre><code>new_frame(code: Statement) -&gt; Frame[Any]\n</code></pre> <p>Create a new frame for the given method.</p> Source code in <code>src/kirin/interp/concrete.py</code> <pre><code>def new_frame(self, code: Statement) -&gt; Frame[Any]:\n    return Frame.from_func_like(code)\n</code></pre>"},{"location":"reference/kirin/interp/concrete/#kirin.interp.concrete.Interpreter.run_method","title":"run_method","text":"<pre><code>run_method(method: Method, args: tuple[Any, ...]) -&gt; Any\n</code></pre> <p>How to run a method.</p> <p>This is defined by subclasses to describe what's the corresponding value of a method during the interpretation.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Method</code> <p>the method to run.</p> required <code>args</code> <code>tuple[ValueType]</code> <p>the arguments to the method, does not include self.</p> required <p>Returns:</p> Name Type Description <code>ValueType</code> <code>ValueType</code> <p>the result of the method.</p> Source code in <code>src/kirin/interp/concrete.py</code> <pre><code>def run_method(self, method: Method, args: tuple[Any, ...]) -&gt; Any:\n    if len(self.state.frames) &gt;= self.max_depth:\n        raise InterpreterError(\"maximum recursion depth exceeded\")\n    return self.run_callable(method.code, (method,) + args)\n</code></pre>"},{"location":"reference/kirin/interp/exceptions/","title":"Exceptions","text":""},{"location":"reference/kirin/interp/frame/","title":"Frame","text":""},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame","title":"Frame  <code>dataclass</code>","text":"<pre><code>Frame(\n    code: Statement,\n    lino: int = 0,\n    stmt: Statement | None = None,\n    globals: dict[str, Any] = dict(),\n    entries: dict[SSAValue, ValueType] = dict(),\n)\n</code></pre> <p>               Bases: <code>FrameABC[ValueType]</code></p>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame.entries","title":"entries  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>entries: dict[SSAValue, ValueType] = field(\n    default_factory=dict\n)\n</code></pre> <p>SSA values and their corresponding values.</p>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame.globals","title":"globals  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>globals: dict[str, Any] = field(default_factory=dict)\n</code></pre> <p>Global variables this frame has access to.</p>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame.stmt","title":"stmt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stmt: Statement | None = None\n</code></pre> <p>statement being interpreted.</p>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame.from_func_like","title":"from_func_like  <code>classmethod</code>","text":"<pre><code>from_func_like(code: Statement) -&gt; Self\n</code></pre> <p>Create a new frame for the given method.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>@classmethod\ndef from_func_like(cls, code: Statement) -&gt; Self:\n    return cls(code=code)\n</code></pre>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame.get","title":"get","text":"<pre><code>get(key: SSAValue) -&gt; ValueType\n</code></pre> <p>Get the value for the given <code>SSAValue</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key(SSAValue)</code> <p>The key to get the value for.</p> required <p>Returns:</p> Name Type Description <code>ValueType</code> <code>ValueType</code> <p>The value.</p> <p>Raises:</p> Type Description <code>InterpreterError</code> <p>If the value is not found. This will be catched by the interpreter and will be converted to an <code>interp.Err</code> in the interpretation results.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>def get(self, key: SSAValue) -&gt; ValueType:\n    \"\"\"Get the value for the given [`SSAValue`][kirin.ir.SSAValue].\n\n    Args:\n        key(SSAValue): The key to get the value for.\n\n    Returns:\n        ValueType: The value.\n\n    Raises:\n        InterpreterError: If the value is not found. This will be catched by the interpreter\n            and will be converted to an [`interp.Err`][kirin.interp.Err] in the interpretation\n            results.\n    \"\"\"\n    err = InterpreterError(f\"SSAValue {key} not found\")\n    value = self.entries.get(key, err)\n    if isinstance(value, InterpreterError):\n        raise err\n    else:\n        return value\n</code></pre>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame.get_typed","title":"get_typed","text":"<pre><code>get_typed(\n    key: SSAValue, type_: type[ExpectedType]\n) -&gt; ExpectedType\n</code></pre> <p>Similar to <code>get</code> but also checks the type.</p> <p>Parameters:</p> Name Type Description Default <code>key(SSAValue)</code> <p>The key to get the value for.</p> required <code>type_(type)</code> <p>The expected type.</p> required <p>Returns:</p> Name Type Description <code>ExpectedType</code> <code>ExpectedType</code> <p>The value.</p> <p>Raises:</p> Type Description <code>InterpreterError</code> <p>If the value is not of the expected type. This will be catched by the interpreter and will be converted to an <code>interp.Err</code> in the interpretation results.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>def get_typed(self, key: SSAValue, type_: type[ExpectedType]) -&gt; ExpectedType:\n    \"\"\"Similar to [`get`][kirin.interp.frame.Frame.get] but also checks the type.\n\n    Args:\n        key(SSAValue): The key to get the value for.\n        type_(type): The expected type.\n\n    Returns:\n        ExpectedType: The value.\n\n    Raises:\n        InterpreterError: If the value is not of the expected type. This will be catched\n            by the interpreter and will be converted to an [`interp.Err`][kirin.interp.Err]\n            in the interpretation results.\n    \"\"\"\n    value = self.get(key)\n    if not isinstance(value, type_):\n        raise InterpreterError(f\"expected {type_}, got {type(value)}\")\n    return value\n</code></pre>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame.set_stmt","title":"set_stmt","text":"<pre><code>set_stmt(stmt: Statement) -&gt; Self\n</code></pre> <p>Set the current statement.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>def set_stmt(self, stmt: Statement) -&gt; Self:\n    self.stmt = stmt\n    return self\n</code></pre>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.FrameABC","title":"FrameABC  <code>dataclass</code>","text":"<pre><code>FrameABC(code: Statement)\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[ValueType]</code></p>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.FrameABC.code","title":"code  <code>instance-attribute</code>","text":"<pre><code>code: Statement\n</code></pre> <p>func statement being interpreted.</p>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.FrameABC.from_func_like","title":"from_func_like  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>from_func_like(code: Statement) -&gt; Self\n</code></pre> <p>Create a new frame for the given method.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>@classmethod\n@abstractmethod\ndef from_func_like(cls, code: Statement) -&gt; Self:\n    \"\"\"Create a new frame for the given method.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.FrameABC.get_values","title":"get_values","text":"<pre><code>get_values(\n    keys: Iterable[SSAValue],\n) -&gt; tuple[ValueType, ...]\n</code></pre> <p>Get the values of the given <code>SSAValue</code> keys.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>def get_values(self, keys: Iterable[SSAValue]) -&gt; tuple[ValueType, ...]:\n    \"\"\"Get the values of the given `SSAValue` keys.\"\"\"\n    return tuple(self.get(key) for key in keys)\n</code></pre>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.FrameABC.set_stmt","title":"set_stmt  <code>abstractmethod</code>","text":"<pre><code>set_stmt(stmt: Statement) -&gt; Self\n</code></pre> <p>Set the current statement.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>@abstractmethod\ndef set_stmt(self, stmt: Statement) -&gt; Self:\n    \"\"\"Set the current statement.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.FrameABC.set_values","title":"set_values","text":"<pre><code>set_values(\n    keys: Iterable[SSAValue], values: Iterable[ValueType]\n) -&gt; None\n</code></pre> <p>Set the values of the given <code>SSAValue</code> keys.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>def set_values(self, keys: Iterable[SSAValue], values: Iterable[ValueType]) -&gt; None:\n    \"\"\"Set the values of the given `SSAValue` keys.\"\"\"\n    for key, value in zip(keys, values):\n        self.set(key, value)\n</code></pre>"},{"location":"reference/kirin/interp/impl/","title":"Impl","text":""},{"location":"reference/kirin/interp/impl/#kirin.interp.impl.impl","title":"impl","text":"<pre><code>impl(\n    stmt_or_attribute: Type[HeadType],\n    *args: types.TypeAttribute\n)\n</code></pre> <p>               Bases: <code>Generic[HeadType]</code></p> <p>Decorator to define an Interpreter implementation for a statement.</p> Source code in <code>src/kirin/interp/impl.py</code> <pre><code>def __init__(\n    self, stmt_or_attribute: Type[HeadType], *args: types.TypeAttribute\n) -&gt; None:\n    if args and issubclass(stmt_or_attribute, Attribute):\n        raise ValueError(\"Attributes do not take arguments\")\n    self.stmt_or_attribute: type[HeadType] = stmt_or_attribute\n    self.args = args\n</code></pre>"},{"location":"reference/kirin/interp/result/","title":"Result","text":""},{"location":"reference/kirin/interp/result/#kirin.interp.result.Err","title":"Err  <code>dataclass</code>","text":"<pre><code>Err(exception: Exception, frames: list[FrameType])\n</code></pre> <p>               Bases: <code>Result[ValueType]</code>, <code>Generic[FrameType, ValueType]</code></p> Source code in <code>src/kirin/interp/result.py</code> <pre><code>def __init__(self, exception: Exception, frames: list[FrameType]):\n    super().__init__()\n    self.exception = exception\n    self.frames = frames\n</code></pre>"},{"location":"reference/kirin/interp/result/#kirin.interp.result.Err.print_stack","title":"print_stack","text":"<pre><code>print_stack()\n</code></pre> <p>Print the stack trace of the error.</p> Source code in <code>src/kirin/interp/result.py</code> <pre><code>def print_stack(self):\n    \"\"\"Print the stack trace of the error.\"\"\"\n    top_method_code = self.frames[0].code\n    if (call_trait := top_method_code.get_trait(CallableStmtInterface)) is None:\n        raise ValueError(f\"Method code {top_method_code} is not callable\")\n\n    region = call_trait.get_callable_region(top_method_code)\n    name = (\n        top_method_code.get_trait(SymbolOpInterface)\n        .get_sym_name(top_method_code)  # type: ignore\n        .data\n    )\n    args = \",\".join(\n        [\n            (\n                f\"{arg.name}\"\n                if arg.type is arg.type.top()\n                else f\"{arg.name}:{arg.type}\"\n            )\n            for arg in region.blocks[0].args[1:]\n        ]\n    )\n    print(\"Traceback (most recent call last):\")\n    print(f\"  {name}({args})\")\n    for frame in reversed(self.frames):\n        if frame.code:\n            frame.code.print()\n    print(f\"{self.exception.__class__.__name__}: {self.exception}\")\n    print(\n        \"================================ Python Stacktrace ================================\"\n    )\n</code></pre>"},{"location":"reference/kirin/interp/state/","title":"State","text":""},{"location":"reference/kirin/interp/table/","title":"Table","text":""},{"location":"reference/kirin/interp/table/#kirin.interp.table.MethodTable","title":"MethodTable  <code>dataclass</code>","text":"<pre><code>MethodTable()\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Base class to define lookup tables for interpreting code for IR nodes in a dialect.</p>"},{"location":"reference/kirin/interp/table/#kirin.interp.table.MethodTable.attribute","title":"attribute  <code>class-attribute</code>","text":"<pre><code>attribute: dict[type[Attribute], AttributeFunction]\n</code></pre> <p>Lookup table for interpreting code for IR attributes in a dialect.</p>"},{"location":"reference/kirin/interp/table/#kirin.interp.table.MethodTable.table","title":"table  <code>class-attribute</code>","text":"<pre><code>table: dict[Signature, MethodFunction]\n</code></pre> <p>Lookup table for interpreting code for IR nodes in a dialect.</p>"},{"location":"reference/kirin/interp/value/","title":"Value","text":""},{"location":"reference/kirin/interp/value/#kirin.interp.value.ReturnValue","title":"ReturnValue  <code>dataclass</code>","text":"<pre><code>ReturnValue(result: ValueType)\n</code></pre> <p>               Bases: <code>SpecialValue[ValueType]</code></p> <p>Return value from a statement evaluation.</p> Source code in <code>src/kirin/interp/value.py</code> <pre><code>def __init__(self, result: ValueType):\n    super().__init__()\n    self.result = result\n</code></pre>"},{"location":"reference/kirin/interp/value/#kirin.interp.value.Successor","title":"Successor  <code>dataclass</code>","text":"<pre><code>Successor(block: Block, *block_args: ValueType)\n</code></pre> <p>               Bases: <code>SpecialValue[ValueType]</code></p> <p>Successor block from a statement evaluation.</p> Source code in <code>src/kirin/interp/value.py</code> <pre><code>def __init__(self, block: Block, *block_args: ValueType):\n    super().__init__()\n    self.block = block\n    self.block_args = block_args\n</code></pre>"},{"location":"reference/kirin/ir/","title":"Index","text":"<p>IR module for kirin.</p> <p>This module contains the data structure definition of the intermediate representation (IR) for kirin.</p>"},{"location":"reference/kirin/ir/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/ir/dialect/#kirin.ir.dialect.Dialect","title":"Dialect  <code>dataclass</code>","text":"<pre><code>Dialect(\n    name: str,\n    stmts: list[type[Statement]] = list(),\n    attrs: list[type[Attribute]] = list(),\n    interps: dict[str, MethodTable] = dict(),\n    lowering: dict[str, FromPythonAST] = dict(),\n)\n</code></pre> <p>Dialect is a collection of statements, attributes, interpreters, lowerings, and codegen.</p> Example <pre><code>    from kirin import ir\n\n    my_dialect = ir.Dialect(name=\"my_dialect\")\n</code></pre>"},{"location":"reference/kirin/ir/dialect/#kirin.ir.dialect.Dialect.attrs","title":"attrs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>attrs: list[type[Attribute]] = field(\n    default_factory=list, init=True\n)\n</code></pre> <p>A list of attributes in the dialect.</p>"},{"location":"reference/kirin/ir/dialect/#kirin.ir.dialect.Dialect.interps","title":"interps  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>interps: dict[str, MethodTable] = field(\n    default_factory=dict, init=True\n)\n</code></pre> <p>A dictionary of registered method table in the dialect.</p>"},{"location":"reference/kirin/ir/dialect/#kirin.ir.dialect.Dialect.lowering","title":"lowering  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lowering: dict[str, FromPythonAST] = field(\n    default_factory=dict, init=True\n)\n</code></pre> <p>A dictionary of registered python lowering implmentations in the dialect.</p>"},{"location":"reference/kirin/ir/dialect/#kirin.ir.dialect.Dialect.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the dialect.</p>"},{"location":"reference/kirin/ir/dialect/#kirin.ir.dialect.Dialect.stmts","title":"stmts  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stmts: list[type[Statement]] = field(\n    default_factory=list, init=True\n)\n</code></pre> <p>A list of statements in the dialect.</p>"},{"location":"reference/kirin/ir/dialect/#kirin.ir.dialect.Dialect.register","title":"register","text":"<pre><code>register(node: type | None = None, key: str | None = None)\n</code></pre> <p>register is a decorator to register a node to the dialect.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>type | None</code> <p>The node to register. Defaults to None.</p> <code>None</code> <code>key</code> <code>str | None</code> <p>The key to register the node to. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the node is not a subclass of Statement, Attribute, DialectInterpreter, FromPythonAST, or DialectEmit.</p> Example <ul> <li> <p>Register a method table for concrete interpreter (by default key=\"main\") to the dialect: <pre><code>    from kirin import ir\n\n    my_dialect = ir.Dialect(name=\"my_dialect\")\n\n    @my_dialect.register\n    class MyMethodTable(ir.MethodTable):\n        ...\n</code></pre></p> </li> <li> <p>Register a method table for the interpreter specified by <code>key</code> to the dialect: <pre><code>    from kirin import ir\n\n    my_dialect = ir.Dialect(name=\"my_dialect\")\n\n    @my_dialect.register(key=\"my_interp\")\n    class MyMethodTable(ir.MethodTable):\n        ...\n</code></pre></p> </li> </ul> Source code in <code>src/kirin/ir/dialect.py</code> <pre><code>@dataclass_transform()\ndef register(self, node: type | None = None, key: str | None = None):\n    \"\"\"register is a decorator to register a node to the dialect.\n\n    Args:\n        node (type | None): The node to register. Defaults to None.\n        key (str | None): The key to register the node to. Defaults to None.\n\n    Raises:\n        ValueError: If the node is not a subclass of Statement, Attribute, DialectInterpreter, FromPythonAST, or DialectEmit.\n\n    Example:\n        * Register a method table for concrete interpreter (by default key=\"main\") to the dialect:\n        ```python\n            from kirin import ir\n\n            my_dialect = ir.Dialect(name=\"my_dialect\")\n\n            @my_dialect.register\n            class MyMethodTable(ir.MethodTable):\n                ...\n        ```\n\n        * Register a method table for the interpreter specified by `key` to the dialect:\n        ```python\n            from kirin import ir\n\n            my_dialect = ir.Dialect(name=\"my_dialect\")\n\n            @my_dialect.register(key=\"my_interp\")\n            class MyMethodTable(ir.MethodTable):\n                ...\n        ```\n\n\n    \"\"\"\n    from kirin.interp.table import MethodTable\n    from kirin.lowering.dialect import FromPythonAST\n\n    if key is None:\n        key = \"main\"\n\n    def wrapper(node: type[T]) -&gt; type[T]:\n        if issubclass(node, Statement):\n            self.stmts.append(node)\n        elif issubclass(node, Attribute):\n            assert (\n                Attribute in node.__mro__\n            ), f\"{node} is not a subclass of Attribute\"\n            setattr(node, \"dialect\", self)\n            assert hasattr(node, \"name\"), f\"{node} does not have a name attribute\"\n            self.attrs.append(node)\n        elif issubclass(node, MethodTable):\n            if key in self.interps:\n                raise ValueError(\n                    f\"Cannot register {node} to Dialect, key {key} exists\"\n                )\n            self.interps[key] = node()\n        elif issubclass(node, FromPythonAST):\n            if key in self.lowering:\n                raise ValueError(\n                    f\"Cannot register {node} to Dialect, key {key} exists\"\n                )\n            self.lowering[key] = node()\n        else:\n            raise ValueError(f\"Cannot register {node} to Dialect\")\n        return node\n\n    if node is None:\n        return wrapper\n\n    return wrapper(node)\n</code></pre>"},{"location":"reference/kirin/ir/group/","title":"Dialect Group","text":""},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup","title":"DialectGroup  <code>dataclass</code>","text":"<pre><code>DialectGroup(\n    dialects: Iterable[Union[Dialect, ModuleType]],\n    run_pass: RunPassGen[PassParams] | None = None,\n)\n</code></pre> <p>               Bases: <code>Generic[PassParams]</code></p> Source code in <code>src/kirin/ir/group.py</code> <pre><code>def __init__(\n    self,\n    dialects: Iterable[Union[\"Dialect\", ModuleType]],\n    run_pass: RunPassGen[PassParams] | None = None,\n):\n    def identity(code: Method):\n        pass\n\n    self.data = frozenset(self.map_module(dialect) for dialect in dialects)\n    if run_pass is None:\n        self.run_pass_gen = None\n        self.run_pass = None\n    else:\n        self.run_pass_gen = run_pass\n        self.run_pass = run_pass(self)\n</code></pre>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data: frozenset[Dialect] = frozenset(\n    map_module(dialect) for dialect in dialects\n)\n</code></pre> <p>The set of dialects in the group.</p>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup.registry","title":"registry  <code>property</code>","text":"<pre><code>registry: Registry\n</code></pre> <p>return the registry for the dialect group. This returns a proxy object that can be used to select the lowering interpreters, interpreters, and codegen for the dialects in the group.</p> <p>Returns:</p> Name Type Description <code>Registry</code> <code>Registry</code> <p>the registry object.</p>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup.run_pass","title":"run_pass  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>run_pass: RunPass[PassParams] | None = None\n</code></pre> <p>the function that runs the passes on the method.</p>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup.run_pass_gen","title":"run_pass_gen  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>run_pass_gen: RunPassGen[PassParams] | None = None\n</code></pre> <p>the function that generates the <code>run_pass</code> function.</p> <p>This is used to create new dialect groups from existing ones, while keeping the same <code>run_pass</code> function.</p>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup.__call__","title":"__call__","text":"<pre><code>__call__(\n    py_func: Callable[Param, RetType],\n    *args: PassParams.args,\n    **options: PassParams.kwargs\n) -&gt; Method[Param, RetType]\n</code></pre><pre><code>__call__(\n    py_func: None = None,\n    *args: PassParams.args,\n    **options: PassParams.kwargs\n) -&gt; MethodTransform[Param, RetType]\n</code></pre> <pre><code>__call__(\n    py_func: Callable[Param, RetType] | None = None,\n    *args: PassParams.args,\n    **options: PassParams.kwargs\n) -&gt; (\n    Method[Param, RetType] | MethodTransform[Param, RetType]\n)\n</code></pre> <p>create a method from the python function.</p> <p>Parameters:</p> Name Type Description Default <code>py_func</code> <code>Callable</code> <p>the python function to create the method from.</p> <code>None</code> <code>args</code> <code>args</code> <p>the arguments to pass to the run_pass function.</p> <code>()</code> <code>options</code> <code>kwargs</code> <p>the keyword arguments to pass to the run_pass function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Method</code> <code>Method[Param, RetType] | MethodTransform[Param, RetType]</code> <p>the method created from the python function.</p> Source code in <code>src/kirin/ir/group.py</code> <pre><code>def __call__(\n    self,\n    py_func: Callable[Param, RetType] | None = None,\n    *args: PassParams.args,\n    **options: PassParams.kwargs,\n) -&gt; Method[Param, RetType] | MethodTransform[Param, RetType]:\n    \"\"\"create a method from the python function.\n\n    Args:\n        py_func (Callable): the python function to create the method from.\n        args (PassParams.args): the arguments to pass to the run_pass function.\n        options (PassParams.kwargs): the keyword arguments to pass to the run_pass function.\n\n    Returns:\n        Method: the method created from the python function.\n    \"\"\"\n    from kirin.lowering import Lowering\n\n    emit_ir = Lowering(self)\n\n    def wrapper(py_func: Callable) -&gt; Method:\n        if py_func.__name__ == \"&lt;lambda&gt;\":\n            raise ValueError(\"Cannot compile lambda functions\")\n\n        lineno_offset, file = 0, \"\"\n        frame = inspect.currentframe()\n        if frame and frame.f_back is not None and frame.f_back.f_back is not None:\n            call_site_frame = frame.f_back.f_back\n            if py_func.__name__ in call_site_frame.f_locals:\n                raise CompilerError(\n                    f\"overwriting function definition of `{py_func.__name__}`\"\n                )\n\n            lineno_offset = call_site_frame.f_lineno - 1\n            file = call_site_frame.f_code.co_filename\n\n        code = emit_ir.run(py_func, lineno_offset=lineno_offset)\n        mt = Method(\n            mod=inspect.getmodule(py_func),\n            py_func=py_func,\n            sym_name=py_func.__name__,\n            arg_names=[\"#self#\"] + inspect.getfullargspec(py_func).args,\n            dialects=self,\n            code=code,\n            file=file,\n        )\n        if doc := inspect.getdoc(py_func):\n            mt.__doc__ = doc\n\n        if self.run_pass is not None:\n            self.run_pass(mt, *args, **options)\n        return mt\n\n    if py_func is not None:\n        return wrapper(py_func)\n    return wrapper\n</code></pre>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup.add","title":"add","text":"<pre><code>add(dialect: Union[Dialect, ModuleType]) -&gt; DialectGroup\n</code></pre> <p>add a dialect to the group.</p> <p>Parameters:</p> Name Type Description Default <code>dialect</code> <code>Union[Dialect, ModuleType]</code> <p>the dialect to add</p> required <p>Returns:</p> Name Type Description <code>DialectGroup</code> <code>DialectGroup</code> <p>the new dialect group with the added</p> Source code in <code>src/kirin/ir/group.py</code> <pre><code>def add(self, dialect: Union[\"Dialect\", ModuleType]) -&gt; \"DialectGroup\":\n    \"\"\"add a dialect to the group.\n\n    Args:\n        dialect (Union[Dialect, ModuleType]): the dialect to add\n\n    Returns:\n        DialectGroup: the new dialect group with the added\n    \"\"\"\n    return self.union([dialect])\n</code></pre>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup.map_module","title":"map_module  <code>staticmethod</code>","text":"<pre><code>map_module(dialect)\n</code></pre> <p>map the module to the dialect if it is a module. It assumes that the module has a <code>dialect</code> attribute that is an instance of <code>Dialect</code>.</p> Source code in <code>src/kirin/ir/group.py</code> <pre><code>@staticmethod\ndef map_module(dialect):\n    \"\"\"map the module to the dialect if it is a module.\n    It assumes that the module has a `dialect` attribute\n    that is an instance of [`Dialect`][kirin.ir.Dialect].\n    \"\"\"\n    if isinstance(dialect, ModuleType):\n        return getattr(dialect, \"dialect\")\n    return dialect\n</code></pre>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup.union","title":"union","text":"<pre><code>union(\n    dialect: Iterable[Union[Dialect, ModuleType]]\n) -&gt; DialectGroup\n</code></pre> <p>union a set of dialects to the group.</p> <p>Parameters:</p> Name Type Description Default <code>dialect</code> <code>Iterable[Union[Dialect, ModuleType]]</code> <p>the dialects to union</p> required <p>Returns:</p> Name Type Description <code>DialectGroup</code> <code>DialectGroup</code> <p>the new dialect group with the union.</p> Source code in <code>src/kirin/ir/group.py</code> <pre><code>def union(self, dialect: Iterable[Union[\"Dialect\", ModuleType]]) -&gt; \"DialectGroup\":\n    \"\"\"union a set of dialects to the group.\n\n    Args:\n        dialect (Iterable[Union[Dialect, ModuleType]]): the dialects to union\n\n    Returns:\n        DialectGroup: the new dialect group with the union.\n    \"\"\"\n    return DialectGroup(\n        dialects=self.data.union(frozenset(self.map_module(d) for d in dialect)),\n        run_pass=self.run_pass_gen,  # pass the run_pass_gen function\n    )\n</code></pre>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.dialect_group","title":"dialect_group","text":"<pre><code>dialect_group(\n    dialects: Iterable[Union[Dialect, ModuleType]]\n) -&gt; Callable[\n    [RunPassGen[PassParams]], DialectGroup[PassParams]\n]\n</code></pre> <p>Create a dialect group from the given dialects based on the definition of <code>run_pass</code> function.</p> <p>Parameters:</p> Name Type Description Default <code>dialects</code> <code>Iterable[Union[Dialect, ModuleType]]</code> <p>the dialects to include in the group.</p> required <p>Returns:</p> Type Description <code>Callable[[RunPassGen[PassParams]], DialectGroup[PassParams]]</code> <p>Callable[[RunPassGen[PassParams]], DialectGroup[PassParams]]: the dialect group.</p> Example <pre><code>from kirin.dialects import cf, fcf, func, math\n\n@dialect_group([cf, fcf, func, math])\ndef basic_no_opt(self):\n    # initializations\n    def run_pass(mt: Method) -&gt; None:\n        # how passes are applied to the method\n        pass\n\n    return run_pass\n</code></pre> Source code in <code>src/kirin/ir/group.py</code> <pre><code>def dialect_group(\n    dialects: Iterable[Union[\"Dialect\", ModuleType]]\n) -&gt; Callable[[RunPassGen[PassParams]], DialectGroup[PassParams]]:\n    \"\"\"Create a dialect group from the given dialects based on the\n    definition of `run_pass` function.\n\n    Args:\n        dialects (Iterable[Union[Dialect, ModuleType]]): the dialects to include in the group.\n\n    Returns:\n        Callable[[RunPassGen[PassParams]], DialectGroup[PassParams]]: the dialect group.\n\n    Example:\n        ```python\n        from kirin.dialects import cf, fcf, func, math\n\n        @dialect_group([cf, fcf, func, math])\n        def basic_no_opt(self):\n            # initializations\n            def run_pass(mt: Method) -&gt; None:\n                # how passes are applied to the method\n                pass\n\n            return run_pass\n        ```\n    \"\"\"\n\n    # NOTE: do not alias the annotation below\n    def wrapper(\n        transform: RunPassGen[PassParams],\n    ) -&gt; DialectGroup[PassParams]:\n        ret = DialectGroup(dialects, run_pass=transform)\n        update_wrapper(ret, transform)\n        return ret\n\n    return wrapper\n</code></pre>"},{"location":"reference/kirin/ir/method/","title":"Method","text":""},{"location":"reference/kirin/ir/method/#kirin.ir.method.Method","title":"Method  <code>dataclass</code>","text":"<pre><code>Method(\n    mod: ModuleType | None,\n    py_func: Callable[Param, RetType] | None,\n    sym_name: str,\n    arg_names: list[str],\n    dialects: DialectGroup,\n    code: Statement,\n    fields: tuple = tuple(),\n    file: str = \"\",\n    inferred: bool = False,\n    verified: bool = False,\n)\n</code></pre> <p>               Bases: <code>Printable</code>, <code>Generic[Param, RetType]</code></p>"},{"location":"reference/kirin/ir/method/#kirin.ir.method.Method.inferred","title":"inferred  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inferred: bool = False\n</code></pre> <p>if typeinfer has been run on this method</p>"},{"location":"reference/kirin/ir/method/#kirin.ir.method.Method.verified","title":"verified  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>verified: bool = False\n</code></pre> <p>if <code>code.verify</code> has been run on this method</p>"},{"location":"reference/kirin/ir/method/#kirin.ir.method.Method.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>verify the method body.</p> Source code in <code>src/kirin/ir/method.py</code> <pre><code>def verify(self) -&gt; None:\n    \"\"\"verify the method body.\"\"\"\n    try:\n        self.code.verify()\n    except VerificationError as e:\n        msg = f'File \"{self.file}\"'\n        if isinstance(e.node, Statement):\n            if e.node.source:\n                msg += f\", line {e.node.source.lineno}\"\n            msg += f\", in {e.node.name}\"\n\n        msg += f\":\\n    Verification failed for {self.sym_name}: {e.args[0]}\"\n        raise Exception(msg) from e\n    self.verified = True\n    return\n</code></pre>"},{"location":"reference/kirin/ir/ssa/","title":"SSA values","text":""},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.BlockArgument","title":"BlockArgument  <code>dataclass</code>","text":"<pre><code>BlockArgument(\n    block: Block,\n    index: int,\n    type: TypeAttribute = AnyType(),\n)\n</code></pre> <p>               Bases: <code>SSAValue</code></p> <p>SSAValue that is an argument to a <code>Block</code>.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def __init__(\n    self, block: Block, index: int, type: TypeAttribute = AnyType()\n) -&gt; None:\n    super().__init__()\n    self.type = type\n    self.block = block\n    self.index = index\n</code></pre>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.BlockArgument.block","title":"block  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>block: Block = block\n</code></pre> <p>The block that this argument belongs to.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.BlockArgument.index","title":"index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>index: int = index\n</code></pre> <p>The index of this argument in the block's argument list.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.BlockArgument.owner","title":"owner  <code>property</code>","text":"<pre><code>owner: Block\n</code></pre> <p>The object that owns this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.BlockArgument.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type = type\n</code></pre> <p>The type of this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.DeletedSSAValue","title":"DeletedSSAValue  <code>dataclass</code>","text":"<pre><code>DeletedSSAValue(value: SSAValue)\n</code></pre> <p>               Bases: <code>SSAValue</code></p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def __init__(self, value: SSAValue) -&gt; None:\n    super().__init__()\n    self.value = value\n    self.type = value.type\n</code></pre>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.DeletedSSAValue.owner","title":"owner  <code>property</code>","text":"<pre><code>owner: Statement | Block\n</code></pre> <p>The object that owns this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.DeletedSSAValue.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type = type\n</code></pre> <p>The type of this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.ResultValue","title":"ResultValue  <code>dataclass</code>","text":"<pre><code>ResultValue(\n    stmt: Statement,\n    index: int,\n    type: TypeAttribute | None = None,\n)\n</code></pre> <p>               Bases: <code>SSAValue</code></p> <p>SSAValue that is a result of a <code>Statement</code>.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def __init__(\n    self, stmt: Statement, index: int, type: TypeAttribute | None = None\n) -&gt; None:\n    super().__init__()\n    self.type = type or AnyType()\n    self.stmt = stmt\n    self.index = index\n</code></pre>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.ResultValue.index","title":"index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>index: int = index\n</code></pre> <p>The index of this value in the statement's result list.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.ResultValue.owner","title":"owner  <code>property</code>","text":"<pre><code>owner: Statement\n</code></pre> <p>The object that owns this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.ResultValue.stmt","title":"stmt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stmt: Statement = stmt\n</code></pre> <p>The statement that this value is a result of.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.ResultValue.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type = type or AnyType()\n</code></pre> <p>The type of this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue","title":"SSAValue  <code>dataclass</code>","text":"<pre><code>SSAValue()\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Printable</code></p> <p>Base class for all SSA values in the IR.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue.name","title":"name  <code>property</code> <code>writable</code>","text":"<pre><code>name: str | None\n</code></pre> <p>The name of this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue.name_pattern","title":"name_pattern  <code>class-attribute</code>","text":"<pre><code>name_pattern: Pattern[str] = compile(\n    \"([A-Za-z_$.-][\\\\w$.-]*)\"\n)\n</code></pre> <p>The pattern that the name of this SSA value must match.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue.owner","title":"owner  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>owner: Statement | Block\n</code></pre> <p>The object that owns this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type: TypeAttribute = field(\n    default_factory=AnyType, init=False, repr=True\n)\n</code></pre> <p>The type of this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue.uses","title":"uses  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>uses: set[Use] = field(\n    init=False, default_factory=set, repr=False\n)\n</code></pre> <p>The uses of this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue.add_use","title":"add_use","text":"<pre><code>add_use(use: Use) -&gt; Self\n</code></pre> <p>Add a use to this SSA value.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def add_use(self, use: Use) -&gt; Self:\n    \"\"\"Add a use to this SSA value.\"\"\"\n    self.uses.add(use)\n    return self\n</code></pre>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue.delete","title":"delete","text":"<pre><code>delete(safe: bool = True) -&gt; None\n</code></pre> <p>Delete this SSA value. If <code>safe</code> is <code>True</code>, raise an error if there are uses.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def delete(self, safe: bool = True) -&gt; None:\n    \"\"\"Delete this SSA value. If `safe` is `True`, raise an error if there are uses.\"\"\"\n    if safe and len(self.uses) &gt; 0:\n        raise ValueError(\"Cannot delete SSA value with uses\")\n    self.replace_by(DeletedSSAValue(self))\n</code></pre>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue.remove_use","title":"remove_use","text":"<pre><code>remove_use(use: Use) -&gt; Self\n</code></pre> <p>Remove a use from this SSA value.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def remove_use(self, use: Use) -&gt; Self:\n    \"\"\"Remove a use from this SSA value.\"\"\"\n    # print(use)\n    # assert use in self.uses, \"Use not found\"\n    if use in self.uses:\n        self.uses.remove(use)\n    return self\n</code></pre>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue.replace_by","title":"replace_by","text":"<pre><code>replace_by(other: SSAValue) -&gt; None\n</code></pre> <p>Replace this SSA value with another SSA value. Update all uses.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def replace_by(self, other: SSAValue) -&gt; None:\n    \"\"\"Replace this SSA value with another SSA value. Update all uses.\"\"\"\n    for use in self.uses.copy():\n        use.stmt.args[use.index] = other\n\n    if other.name is None and self.name is not None:\n        other.name = self.name\n\n    assert len(self.uses) == 0, \"Uses not empty\"\n</code></pre>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.TestValue","title":"TestValue  <code>dataclass</code>","text":"<pre><code>TestValue(type: TypeAttribute = AnyType())\n</code></pre> <p>               Bases: <code>SSAValue</code></p> <p>Test SSAValue for testing IR construction.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def __init__(self, type: TypeAttribute = AnyType()) -&gt; None:\n    super().__init__()\n    self.type = type\n</code></pre>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.TestValue.owner","title":"owner  <code>property</code>","text":"<pre><code>owner: Statement | Block\n</code></pre> <p>The object that owns this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.TestValue.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type = type\n</code></pre> <p>The type of this SSA value.</p>"},{"location":"reference/kirin/ir/use/","title":"Use","text":""},{"location":"reference/kirin/ir/use/#kirin.ir.use.Use","title":"Use  <code>dataclass</code>","text":"<pre><code>Use(stmt: Statement, index: int)\n</code></pre> <p>A use of an SSA value in a statement.</p>"},{"location":"reference/kirin/ir/use/#kirin.ir.use.Use.index","title":"index  <code>instance-attribute</code>","text":"<pre><code>index: int\n</code></pre> <p>The index of the use in the statement.</p>"},{"location":"reference/kirin/ir/use/#kirin.ir.use.Use.stmt","title":"stmt  <code>instance-attribute</code>","text":"<pre><code>stmt: Statement\n</code></pre> <p>The statement that uses the SSA value.</p>"},{"location":"reference/kirin/ir/attrs/","title":"Index","text":"<p>Compile-time values in Kirin IR.</p> <p>This module contains the following:</p>"},{"location":"reference/kirin/ir/attrs/#kirin.ir.attrs--abc-module","title":"<code>abc</code> module","text":"<p><code>abc.AttributeMeta</code>: The metaclass for all attributes. <code>abc.Attribute</code>: The base class for all attributes.</p>"},{"location":"reference/kirin/ir/attrs/#kirin.ir.attrs--types-module","title":"<code>types</code> module","text":"<p><code>types.TypeAttribute</code>: The base class for all type attributes. <code>types.PyClass</code>: A type attribute representing a Python class. <code>types.TypeVar</code>: A type attribute representing a type variable. <code>types.Literal</code>: A type attribute representing a literal type. <code>types.Generic</code>: A type attribute representing a generic type. <code>types.Hinted</code>: A type attribute representing a hinted type. <code>types.Union</code>: A type attribute representing a union type.</p>"},{"location":"reference/kirin/ir/attrs/#kirin.ir.attrs--py-module","title":"<code>py</code> module","text":"<p><code>py.PyAttr</code>: An attribute representing a Python value.</p>"},{"location":"reference/kirin/ir/attrs/abc/","title":"Abc","text":""},{"location":"reference/kirin/ir/attrs/abc/#kirin.ir.attrs.abc.Attribute","title":"Attribute  <code>dataclass</code>","text":"<pre><code>Attribute()\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Printable</code></p> <p>ABC for compile-time values.</p>"},{"location":"reference/kirin/ir/attrs/abc/#kirin.ir.attrs.abc.Attribute.dialect","title":"dialect  <code>class-attribute</code>","text":"<pre><code>dialect: Optional[Dialect] = field(\n    default=None, init=False, repr=False\n)\n</code></pre> <p>Dialect of the attribute. (default: None)</p>"},{"location":"reference/kirin/ir/attrs/abc/#kirin.ir.attrs.abc.Attribute.name","title":"name  <code>class-attribute</code>","text":"<pre><code>name: str = field(init=False, repr=False)\n</code></pre> <p>Name of the attribute in printing and other text format.</p>"},{"location":"reference/kirin/ir/attrs/abc/#kirin.ir.attrs.abc.AttributeMeta","title":"AttributeMeta","text":"<p>               Bases: <code>ABCMeta</code></p> <p>Metaclass for attributes.</p>"},{"location":"reference/kirin/ir/attrs/py/","title":"Py","text":""},{"location":"reference/kirin/ir/attrs/py/#kirin.ir.attrs.py.PyAttr","title":"PyAttr  <code>dataclass</code>","text":"<pre><code>PyAttr(data: T, pytype: TypeAttribute | None = None)\n</code></pre> <p>               Bases: <code>Generic[T]</code>, <code>Attribute</code></p> Source code in <code>src/kirin/ir/attrs/py.py</code> <pre><code>def __init__(self, data: T, pytype: TypeAttribute | None = None):\n    self.data = data\n\n    if pytype is None:\n        self.type = PyClass(type(data))\n    else:\n        self.type = pytype\n</code></pre>"},{"location":"reference/kirin/ir/attrs/py/#kirin.ir.attrs.py.PyAttr.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'PyAttr'\n</code></pre> <p>Name of the attribute in printing and other text format.</p>"},{"location":"reference/kirin/ir/attrs/types/","title":"Types","text":""},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.AnyType","title":"AnyType  <code>dataclass</code>","text":"<pre><code>AnyType()\n</code></pre> <p>               Bases: <code>TypeAttribute</code></p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.AnyType.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'Any'\n</code></pre> <p>Name of the attribute in printing and other text format.</p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.BottomType","title":"BottomType  <code>dataclass</code>","text":"<pre><code>BottomType()\n</code></pre> <p>               Bases: <code>TypeAttribute</code></p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.BottomType.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'Bottom'\n</code></pre> <p>Name of the attribute in printing and other text format.</p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.BottomType.is_subseteq","title":"is_subseteq","text":"<pre><code>is_subseteq(other: TypeAttribute) -&gt; bool\n</code></pre> <p>Subseteq operation.</p> Source code in <code>src/kirin/ir/attrs/types.py</code> <pre><code>def is_subseteq(self, other: TypeAttribute) -&gt; bool:\n    if isinstance(other, TypeVar):\n        return self.is_subseteq(other.bound)\n    return True\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Generic","title":"Generic  <code>dataclass</code>","text":"<pre><code>Generic(\n    body: type[PyClassType] | PyClass[PyClassType],\n    *vars: TypeAttribute | list | Vararg\n)\n</code></pre> <p>               Bases: <code>TypeAttribute</code>, <code>Generic[PyClassType]</code></p> Source code in <code>src/kirin/ir/attrs/types.py</code> <pre><code>def __init__(\n    self,\n    body: type[PyClassType] | PyClass[PyClassType],\n    *vars: TypeAttribute | list | Vararg,\n):\n    if isinstance(body, PyClass):\n        self.body = body\n    else:\n        self.body = PyClass(body)\n    self.vars, self.vararg = _split_type_args(vars)\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Generic.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'Generic'\n</code></pre> <p>Name of the attribute in printing and other text format.</p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Hinted","title":"Hinted  <code>dataclass</code>","text":"<pre><code>Hinted(type: TypeAttribute, data: HintedData)\n</code></pre> <p>               Bases: <code>TypeAttribute</code>, <code>Generic[HintedData]</code></p> <p>Type wrapped with a hint.</p> <p><code>Hinted</code> is used to represent a type with additional data that can be used as a hint for type inference. The additional data is only used for specific type inference purposes, or improve certain type inference precision, it does not affect the order of types in the lattice.</p> Source code in <code>src/kirin/ir/attrs/types.py</code> <pre><code>def __init__(self, type: TypeAttribute, data: HintedData):\n    self.data = data\n    if isinstance(type, Hinted):\n        type = type.type\n    self.type = type\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Hinted.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'Hinted'\n</code></pre> <p>Name of the attribute in printing and other text format.</p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Hinted.is_equal","title":"is_equal","text":"<pre><code>is_equal(other: TypeAttribute) -&gt; bool\n</code></pre> <p>Check if two lattices are equal.</p> Source code in <code>src/kirin/ir/attrs/types.py</code> <pre><code>def is_equal(self, other: TypeAttribute) -&gt; bool:\n    return (\n        isinstance(other, Hinted)\n        and self.data == other.data\n        and self.type.is_equal(other.type)\n    )\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Literal","title":"Literal  <code>dataclass</code>","text":"<pre><code>Literal(data: LiteralType)\n</code></pre> <p>               Bases: <code>TypeAttribute</code>, <code>Generic[LiteralType]</code></p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Literal.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'Literal'\n</code></pre> <p>Name of the attribute in printing and other text format.</p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Literal.is_equal","title":"is_equal","text":"<pre><code>is_equal(other: TypeAttribute) -&gt; bool\n</code></pre> <p>Check if two lattices are equal.</p> Source code in <code>src/kirin/ir/attrs/types.py</code> <pre><code>def is_equal(self, other: TypeAttribute) -&gt; bool:\n    return self is other\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.PyClass","title":"PyClass  <code>dataclass</code>","text":"<pre><code>PyClass(typ: type[PyClassType])\n</code></pre> <p>               Bases: <code>TypeAttribute</code>, <code>Generic[PyClassType]</code></p> Source code in <code>src/kirin/ir/attrs/types.py</code> <pre><code>def __init__(self, typ: type[PyClassType]) -&gt; None:\n    self.typ = typ\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.PyClass.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'PyClass'\n</code></pre> <p>Name of the attribute in printing and other text format.</p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.SingletonTypeMeta","title":"SingletonTypeMeta","text":"<pre><code>SingletonTypeMeta(name, bases, attrs)\n</code></pre> <p>               Bases: <code>TypeAttributeMeta</code>, <code>SingletonMeta</code></p> <p>Metaclass for singleton type attributes.</p> <p>Singleton type attributes are attributes that have only one instance.</p> <p>Examples: - <code>AnyType</code> - <code>BottomType</code></p> Source code in <code>src/kirin/lattice/abc.py</code> <pre><code>def __init__(cls, name, bases, attrs):\n    super().__init__(name, bases, attrs)\n    cls._instance = None\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.TypeAttribute","title":"TypeAttribute  <code>dataclass</code>","text":"<pre><code>TypeAttribute()\n</code></pre> <p>               Bases: <code>_TypeAttribute</code>, <code>SimpleMeetMixin['TypeAttribute']</code>, <code>IsSubsetEqMixin['TypeAttribute']</code>, <code>BoundedLattice['TypeAttribute']</code></p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.TypeAttribute.join","title":"join","text":"<pre><code>join(other: TypeAttribute) -&gt; TypeAttribute\n</code></pre> <p>Join operation.</p> Source code in <code>src/kirin/ir/attrs/types.py</code> <pre><code>def join(self, other: \"TypeAttribute\") -&gt; \"TypeAttribute\":\n    if self.is_subseteq(other):\n        return other\n    elif other.is_subseteq(self):\n        return self\n    elif isinstance(other, TypeAttribute):\n        return Union(self, other)\n    return AnyType()  # don't know how to join\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.TypeAttributeMeta","title":"TypeAttributeMeta","text":"<p>               Bases: <code>AttributeMeta</code>, <code>LatticeMeta</code></p> <p>Metaclass for type attributes.</p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.TypeVar","title":"TypeVar  <code>dataclass</code>","text":"<pre><code>TypeVar(name: str, bound: TypeAttribute | None = None)\n</code></pre> <p>               Bases: <code>TypeAttribute</code></p> Source code in <code>src/kirin/ir/attrs/types.py</code> <pre><code>def __init__(self, name: str, bound: TypeAttribute | None = None):\n    self.varname = name\n    self.bound = bound or AnyType()\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.TypeVar.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'TypeVar'\n</code></pre> <p>Name of the attribute in printing and other text format.</p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.TypeVar.is_equal","title":"is_equal","text":"<pre><code>is_equal(other: TypeAttribute) -&gt; bool\n</code></pre> <p>Check if two lattices are equal.</p> Source code in <code>src/kirin/ir/attrs/types.py</code> <pre><code>def is_equal(self, other: TypeAttribute) -&gt; bool:\n    return (\n        isinstance(other, TypeVar)\n        and self.varname == other.varname\n        and self.bound.is_equal(other.bound)\n    )\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Union","title":"Union  <code>dataclass</code>","text":"<pre><code>Union(\n    typ_or_set: (\n        TypeAttribute | typing.Iterable[TypeAttribute]\n    ),\n    *typs: TypeAttribute\n)\n</code></pre> <p>               Bases: <code>TypeAttribute</code></p> Source code in <code>src/kirin/ir/attrs/types.py</code> <pre><code>def __init__(\n    self,\n    typ_or_set: TypeAttribute | typing.Iterable[TypeAttribute],\n    *typs: TypeAttribute,\n):\n    if isinstance(typ_or_set, TypeAttribute):\n        params: typing.Iterable[TypeAttribute] = (typ_or_set, *typs)\n    else:\n        params = typ_or_set\n        assert not typs, \"Cannot pass multiple arguments when passing a set\"\n\n    types: frozenset[TypeAttribute] = frozenset()\n    for typ in params:\n        if isinstance(typ, Union):\n            types = types.union(typ.types)\n        else:\n            types = types.union({typ})\n    self.types = types\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Union.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'Union'\n</code></pre> <p>Name of the attribute in printing and other text format.</p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Union.is_equal","title":"is_equal","text":"<pre><code>is_equal(other: TypeAttribute) -&gt; bool\n</code></pre> <p>Check if two lattices are equal.</p> Source code in <code>src/kirin/ir/attrs/types.py</code> <pre><code>def is_equal(self, other: TypeAttribute) -&gt; bool:\n    return isinstance(other, Union) and self.types == other.types\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Union.join","title":"join","text":"<pre><code>join(other: TypeAttribute) -&gt; TypeAttribute\n</code></pre> <p>Join operation.</p> Source code in <code>src/kirin/ir/attrs/types.py</code> <pre><code>def join(self, other: TypeAttribute) -&gt; TypeAttribute:\n    if self.is_subseteq(other):\n        return other\n    elif other.is_subseteq(self):\n        return self\n    elif isinstance(other, Union):\n        return Union(self.types | other.types)\n    elif isinstance(other, TypeAttribute):\n        return Union(self.types | {other})\n    return BottomType()\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Union.meet","title":"meet","text":"<pre><code>meet(other: TypeAttribute) -&gt; TypeAttribute\n</code></pre> <p>Meet operation.</p> Source code in <code>src/kirin/ir/attrs/types.py</code> <pre><code>def meet(self, other: TypeAttribute) -&gt; TypeAttribute:\n    if self.is_subseteq(other):\n        return self\n    elif other.is_subseteq(self):\n        return other\n    elif isinstance(other, Union):\n        return Union(self.types &amp; other.types)\n    elif isinstance(other, TypeAttribute):\n        return Union(self.types &amp; {other})\n    return BottomType()\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Vararg","title":"Vararg  <code>dataclass</code>","text":"<pre><code>Vararg(typ: TypeAttribute)\n</code></pre> <p>               Bases: <code>Attribute</code></p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Vararg.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'Vararg'\n</code></pre> <p>Name of the attribute in printing and other text format.</p>"},{"location":"reference/kirin/ir/nodes/","title":"Index","text":""},{"location":"reference/kirin/ir/nodes/base/","title":"Base","text":""},{"location":"reference/kirin/ir/nodes/base/#kirin.ir.nodes.base.IRNode","title":"IRNode  <code>dataclass</code>","text":"<pre><code>IRNode()\n</code></pre> <p>               Bases: <code>Generic[ParentType]</code>, <code>ABC</code>, <code>Printable</code></p>"},{"location":"reference/kirin/ir/nodes/base/#kirin.ir.nodes.base.IRNode.typecheck","title":"typecheck  <code>abstractmethod</code>","text":"<pre><code>typecheck() -&gt; None\n</code></pre> <p>check if types are correct.</p> Source code in <code>src/kirin/ir/nodes/base.py</code> <pre><code>@abstractmethod\ndef typecheck(self) -&gt; None:\n    \"\"\"check if types are correct.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/ir/nodes/base/#kirin.ir.nodes.base.IRNode.verify","title":"verify  <code>abstractmethod</code>","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>run mandatory validation checks. This is not same as typecheck, which may be optional.</p> Source code in <code>src/kirin/ir/nodes/base.py</code> <pre><code>@abstractmethod\ndef verify(self) -&gt; None:\n    \"\"\"run mandatory validation checks. This is not same as typecheck, which may be optional.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/","title":"Block","text":""},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block","title":"Block  <code>dataclass</code>","text":"<pre><code>Block(\n    stmts: Sequence[Statement] = (),\n    argtypes: Iterable[TypeAttribute] = (),\n)\n</code></pre> <p>               Bases: <code>IRNode['Region']</code></p> <p>Block consist of a list of Statements and optionally input arguments.</p> <pre><code>argtypes (Iterable[TypeAttribute], optional): The type of the block arguments. Defaults to ().\n</code></pre> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def __init__(\n    self,\n    stmts: Sequence[Statement] = (),\n    argtypes: Iterable[TypeAttribute] = (),\n):\n    \"\"\"\n    Args:\n        stmts (Sequence[Statement], optional): A list of statements. Defaults to ().\n        argtypes (Iterable[TypeAttribute], optional): The type of the block arguments. Defaults to ().\n    \"\"\"\n    super().__init__()\n    self._args = tuple(\n        BlockArgument(self, i, argtype) for i, argtype in enumerate(argtypes)\n    )\n\n    self._first_stmt = None\n    self._last_stmt = None\n    self._first_branch = None\n    self._last_branch = None\n    self._stmt_len = 0\n    self.stmts.extend(stmts)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.args","title":"args  <code>property</code>","text":"<pre><code>args: BlockArguments\n</code></pre> <p>Get the  arguments of the Block.</p> <p>Returns:</p> Name Type Description <code>BlockArguments</code> <code>BlockArguments</code> <p>The arguments view of the Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.first_stmt","title":"first_stmt  <code>property</code>","text":"<pre><code>first_stmt: Statement | None\n</code></pre> <p>Get the first Statement of the Block.</p> <p>Returns:</p> Type Description <code>Statement | None</code> <p>Statement | None: The first Statement of the Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.last_stmt","title":"last_stmt  <code>property</code>","text":"<pre><code>last_stmt: Statement | None\n</code></pre> <p>Get the last Statement of the Block.</p> <p>Returns:</p> Type Description <code>Statement | None</code> <p>Statement | None: The last Statement of the Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.parent_node","title":"parent_node  <code>property</code> <code>writable</code>","text":"<pre><code>parent_node: Region | None\n</code></pre> <p>Get parent Region of the Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.parent_stmt","title":"parent_stmt  <code>property</code>","text":"<pre><code>parent_stmt: Statement | None\n</code></pre> <p>parent statement of the Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.stmts","title":"stmts  <code>property</code>","text":"<pre><code>stmts: BlockStmts\n</code></pre> <p>Get the list of Statements of the Block.</p> <p>Returns:</p> Name Type Description <code>BlockStmts</code> <code>BlockStmts</code> <p>The Statements of the Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.delete","title":"delete","text":"<pre><code>delete(safe: bool = True) -&gt; None\n</code></pre> <p>Delete the Block completely from the IR.</p> Note <p>This method will detach + remove references of the block.</p> <p>Parameters:</p> Name Type Description Default <code>safe</code> <code>bool</code> <p>If True, raise error if there is anything that still reference components in the block. Defaults to True.</p> <code>True</code> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def delete(self, safe: bool = True) -&gt; None:\n    \"\"\"Delete the Block completely from the IR.\n\n    Note:\n        This method will detach + remove references of the block.\n\n    Args:\n        safe (bool, optional): If True, raise error if there is anything that still reference components in the block. Defaults to True.\n    \"\"\"\n    self.detach()\n    self.drop_all_references()\n    for stmt in self.stmts:\n        stmt.delete(safe=safe)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.detach","title":"detach","text":"<pre><code>detach() -&gt; None\n</code></pre> <p>Detach this Block from the IR.</p> Note <p>Detach only detach the Block from the IR graph. It does not remove uses that reference the Block.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def detach(self) -&gt; None:\n    \"\"\"Detach this Block from the IR.\n\n    Note:\n        Detach only detach the Block from the IR graph. It does not remove uses that reference the Block.\n    \"\"\"\n    if self.parent is None:\n        return\n\n    idx = self.parent[self]\n    del self.parent._blocks[idx]\n    del self.parent._block_idx[self]\n    for block in self.parent._blocks[idx:]:\n        self.parent._block_idx[block] -= 1\n    self.parent = None\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.drop_all_references","title":"drop_all_references","text":"<pre><code>drop_all_references() -&gt; None\n</code></pre> <p>Remove all the dependency that reference/uses this Block.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def drop_all_references(self) -&gt; None:\n    \"\"\"Remove all the dependency that reference/uses this Block.\"\"\"\n    self.parent = None\n    for stmt in self.stmts:\n        stmt.drop_all_references()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.is_structurally_equal","title":"is_structurally_equal","text":"<pre><code>is_structurally_equal(\n    other: Self,\n    context: (\n        dict[IRNode | SSAValue, IRNode | SSAValue] | None\n    ) = None,\n) -&gt; bool\n</code></pre> <p>Check if the Block is structurally equal to another Block.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>The other Block to compare with.</p> required <code>context</code> <code>dict[IRNode | SSAValue, IRNode | SSAValue] | None</code> <p>A map of IRNode/SSAValue to hint that they are equivalent so the check will treat them as equivalent. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the Block is structurally equal to the other Block.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def is_structurally_equal(\n    self,\n    other: Self,\n    context: dict[IRNode | SSAValue, IRNode | SSAValue] | None = None,\n) -&gt; bool:\n    \"\"\"Check if the Block is structurally equal to another Block.\n\n    Args:\n        other (Self): The other Block to compare with.\n        context (dict[IRNode  |  SSAValue, IRNode  |  SSAValue] | None, optional): A map of IRNode/SSAValue to hint that they are equivalent so the check will treat them as equivalent. Defaults to None.\n\n    Returns:\n        bool: True if the Block is structurally equal to the other Block.\n    \"\"\"\n    if context is None:\n        context = {}\n\n    if len(self._args) != len(other._args) or len(self.stmts) != len(other.stmts):\n        return False\n\n    for arg, other_arg in zip(self._args, other._args):\n        if arg.type != other_arg.type:\n            return False\n        context[arg] = other_arg\n\n    context[self] = other\n    if not all(\n        stmt.is_structurally_equal(other_stmt, context)\n        for stmt, other_stmt in zip(self.stmts, other.stmts)\n    ):\n        return False\n\n    return True\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.typecheck","title":"typecheck","text":"<pre><code>typecheck() -&gt; None\n</code></pre> <p>Checking the types of the Statments in the Block.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def typecheck(self) -&gt; None:\n    \"\"\"Checking the types of the Statments in the Block.\"\"\"\n    for stmt in self.stmts:\n        stmt.typecheck()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>Verify the correctness of the Block.</p> <p>Raises:</p> Type Description <code>VerificationError</code> <p>If the Block is not correct.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def verify(self) -&gt; None:\n    \"\"\"Verify the correctness of the Block.\n\n    Raises:\n        VerificationError: If the Block is not correct.\n    \"\"\"\n    from kirin.ir.nodes.stmt import Region\n\n    if not isinstance(self.parent, Region):\n        raise VerificationError(self, \"Parent is not a region\")\n\n    for stmt in self.stmts:\n        stmt.verify()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.walk","title":"walk","text":"<pre><code>walk(\n    *, reverse: bool = False, region_first: bool = False\n) -&gt; Iterator[Statement]\n</code></pre> <p>Traversal the Statements in a Block.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>If walk in the reversed manner. Defaults to False.</p> <code>False</code> <code>region_first</code> <code>bool</code> <p>If the walk should go through the Statement first or the Region of a Statement first. Defaults to False.</p> <code>False</code> <p>Yields:</p> Type Description <code>Statement</code> <p>Iterator[Statement]: An iterator that yield Statements in the Block in the specified order.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def walk(\n    self, *, reverse: bool = False, region_first: bool = False\n) -&gt; Iterator[Statement]:\n    \"\"\"Traversal the Statements in a Block.\n\n    Args:\n        reverse (bool, optional): If walk in the reversed manner. Defaults to False.\n        region_first (bool, optional): If the walk should go through the Statement first or the Region of a Statement first. Defaults to False.\n\n    Yields:\n        Iterator[Statement]: An iterator that yield Statements in the Block in the specified order.\n    \"\"\"\n    for stmt in reversed(self.stmts) if reverse else self.stmts:\n        yield from stmt.walk(reverse=reverse, region_first=region_first)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockArguments","title":"BlockArguments  <code>dataclass</code>","text":"<pre><code>BlockArguments(node: NodeType, field: FieldType)\n</code></pre> <p>               Bases: <code>MutableSequenceView[tuple, 'Block', BlockArgument]</code></p> <p>A View object that contains a list of BlockArgument.</p> Description <p>This is a proxy object that provide safe API to manipulate the arguments of a Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockArguments.append_from","title":"append_from","text":"<pre><code>append_from(\n    typ: TypeAttribute, name: str | None = None\n) -&gt; BlockArgument\n</code></pre> <p>Append a new argument to the Block that this View reference to.</p> Description <p>This method will create a new <code>BlockArgument</code> and append it to the argument list of the reference <code>Block</code>.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>TypeAttribute</code> <p>The type of the argument.</p> required <code>name</code> <code>str | None</code> <p>name of the argument. Defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>BlockArgument</code> <code>BlockArgument</code> <p>The newly created <code>BlockArgument</code>.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def append_from(self, typ: TypeAttribute, name: str | None = None) -&gt; BlockArgument:\n    \"\"\"Append a new argument to the Block that this View reference to.\n\n    Description:\n        This method will create a new [`BlockArgument`][kirin.ir.BlockArgument] and append it to the argument list\n        of the reference `Block`.\n\n    Args:\n        typ (TypeAttribute): The type of the argument.\n        name (str | None, optional): name of the argument. Defaults to `None`.\n\n    Returns:\n        BlockArgument: The newly created [`BlockArgument`][kirin.ir.BlockArgument].\n\n    \"\"\"\n    new_arg = BlockArgument(self.node, len(self.node._args), typ)\n    if name:\n        new_arg.name = name\n\n    self.node._args += (new_arg,)\n    return new_arg\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockArguments.delete","title":"delete","text":"<pre><code>delete(arg: BlockArgument, safe: bool = True) -&gt; None\n</code></pre> <p>Delete a BlockArgument from the Block that this View reference to.</p> <p>Parameters:</p> Name Type Description Default <code>arg</code> <code>BlockArgument</code> <p>description</p> required <code>safe</code> <code>bool</code> <p>If True, error will be raised if the BlockArgument has any Use by others.  Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the argument does not belong to the reference block.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def delete(self, arg: BlockArgument, safe: bool = True) -&gt; None:\n    \"\"\"Delete a BlockArgument from the Block that this View reference to.\n\n\n    Args:\n        arg (BlockArgument): _description_\n        safe (bool, optional): If True, error will be raised if the BlockArgument has any Use by others.  Defaults to True.\n\n    Raises:\n        ValueError: If the argument does not belong to the reference block.\n    \"\"\"\n    if arg.block is not self.node:\n        raise ValueError(\"Attempt to delete an argument that is not in the block\")\n\n    for block_arg in self.field[arg.index + 1 :]:\n        block_arg.index -= 1\n    self.node._args = (*self.field[: arg.index], *self.field[arg.index + 1 :])\n    arg.delete(safe=safe)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockArguments.insert_from","title":"insert_from","text":"<pre><code>insert_from(\n    idx: int, typ: TypeAttribute, name: str | None = None\n) -&gt; BlockArgument\n</code></pre> <p>Insert a new argument to the Block that this View reference to.</p> Description <p>This method will create a new <code>BlockArgument</code> and insert it to the argument list of the reference Block at the specified index</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>Insert location index.</p> required <code>typ</code> <code>TypeAttribute</code> <p>The type of the argument.</p> required <code>name</code> <code>str | None</code> <p>Name of the argument. Defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>BlockArgument</code> <code>BlockArgument</code> <p>The newly created BlockArgument.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def insert_from(\n    self, idx: int, typ: TypeAttribute, name: str | None = None\n) -&gt; BlockArgument:\n    \"\"\"Insert a new argument to the Block that this View reference to.\n\n    Description:\n        This method will create a new `BlockArgument` and insert it to the argument list\n        of the reference Block at the specified index\n\n    Args:\n        idx (int): Insert location index.\n        typ (TypeAttribute): The type of the argument.\n        name (str | None, optional): Name of the argument. Defaults to `None`.\n\n    Returns:\n        BlockArgument: The newly created BlockArgument.\n    \"\"\"\n    if idx &lt; 0 or idx &gt; len(self.node._args):\n        raise ValueError(\"Invalid index\")\n\n    new_arg = BlockArgument(self.node, idx, typ)\n    if name:\n        new_arg.name = name\n\n    for arg in self.node._args[idx:]:\n        arg.index += 1\n    self.node._args = self.node._args[:idx] + (new_arg,) + self.node._args[idx:]\n    return new_arg\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockStmts","title":"BlockStmts  <code>dataclass</code>","text":"<pre><code>BlockStmts(node: NodeType)\n</code></pre> <p>               Bases: <code>View['Block', 'Statement']</code></p> <p>A View object that contains a list of Statements.</p> Description <p>This is a proxy object that provide safe API to manipulate the statements of a Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockStmts.append","title":"append","text":"<pre><code>append(value: Statement) -&gt; None\n</code></pre> <p>Append a Statement to the reference Block.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Statement</code> <p>A Statement to be appended.</p> required Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def append(self, value: Statement) -&gt; None:\n    \"\"\"Append a Statement to the reference Block.\n\n    Args:\n        value (Statement): A Statement to be appended.\n    \"\"\"\n    from kirin.ir.nodes.stmt import Statement\n\n    if not isinstance(value, Statement):\n        raise ValueError(f\"Expected Statement, got {type(value).__name__}\")\n\n    if self.node._stmt_len == 0:  # empty block\n        value.attach(self.node)\n        self.node._first_stmt = value\n        self.node._last_stmt = value\n        self.node._stmt_len += 1\n    elif self.node._last_stmt:\n        value.insert_after(self.node._last_stmt)\n    else:\n        raise ValueError(\"Invalid block, last_stmt is None\")\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockStmts.at","title":"at","text":"<pre><code>at(index: int) -&gt; Statement\n</code></pre> <p>This is similar to getitem but due to the nature of the linked list, it is less efficient than getitem.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def at(self, index: int) -&gt; Statement:\n    \"\"\"This is similar to __getitem__ but due to the nature of the linked list,\n    it is less efficient than __getitem__.\n    \"\"\"\n    if index &gt;= len(self):\n        raise IndexError(\"Index out of range\")\n\n    if index &lt; 0:\n        return self._at_reverse(-index - 1)\n\n    return self._at_forward(index)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/","title":"Region","text":""},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region","title":"Region  <code>dataclass</code>","text":"<pre><code>Region(\n    blocks: Block | Iterable[Block] = (),\n    parent: Statement | None = None,\n)\n</code></pre> <p>               Bases: <code>IRNode['Statement']</code></p> <p>Region consist of a list of Blocks</p> <p>Parameters:</p> Name Type Description Default <code>blocks</code> <code>Block | Iterable[Block]</code> <p>A single <code>Block</code> object or an iterable of Block objects. Defaults to ().</p> <code>()</code> <code>parent</code> <code>Statement | None</code> <p>The parent <code>Statement</code> object. Defaults to None.</p> <code>None</code> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def __init__(\n    self,\n    blocks: Block | Iterable[Block] = (),\n    parent: Statement | None = None,\n):\n    \"\"\"Initialize a Region object.\n\n    Args:\n        blocks (Block | Iterable[Block], optional): A single [`Block`][kirin.ir.Block] object or an iterable of Block objects. Defaults to ().\n        parent (Statement | None, optional): The parent [`Statement`][kirin.ir.Statement] object. Defaults to None.\n    \"\"\"\n    self._blocks = []\n    self._block_idx = {}\n    self.parent_node = parent\n    if isinstance(blocks, Block):\n        blocks = (blocks,)\n    for block in blocks:\n        self.blocks.append(block)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.blocks","title":"blocks  <code>property</code>","text":"<pre><code>blocks: RegionBlocks\n</code></pre> <p>Get the Blocks in the region.</p> <p>Returns:</p> Name Type Description <code>RegionBlocks</code> <code>RegionBlocks</code> <p>The blocks View object of the region.</p>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.parent_node","title":"parent_node  <code>property</code> <code>writable</code>","text":"<pre><code>parent_node: Statement | None\n</code></pre> <p>Get the parent statement of the region.</p>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.region_index","title":"region_index  <code>property</code>","text":"<pre><code>region_index: int\n</code></pre> <p>Get the index of the region within the parent scope.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The index of the region within the parent scope.</p>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(block: Block) -&gt; int\n</code></pre> <p>Get the index of a block within the region.</p> <p>Parameters:</p> Name Type Description Default <code>block</code> <code>Block</code> <p>The block to get the index of.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the block does not belong to the region.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The index of the block within the region.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def __getitem__(self, block: Block) -&gt; int:\n    \"\"\"Get the index of a block within the region.\n\n    Args:\n        block (Block): The block to get the index of.\n\n    Raises:\n        ValueError: If the block does not belong to the region.\n\n    Returns:\n        int: The index of the block within the region.\n    \"\"\"\n    if block.parent is not self:\n        raise ValueError(\"Block does not belong to the region\")\n    return self._block_idx[block]\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.clone","title":"clone","text":"<pre><code>clone(\n    ssamap: dict[SSAValue, SSAValue] | None = None\n) -&gt; Region\n</code></pre> <p>Clone a region. This will clone all blocks and statements in the region. <code>SSAValue</code> defined outside the region will not be cloned unless provided in <code>ssamap</code>.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def clone(self, ssamap: dict[SSAValue, SSAValue] | None = None) -&gt; Region:\n    \"\"\"Clone a region. This will clone all blocks and statements in the region.\n    `SSAValue` defined outside the region will not be cloned unless provided in `ssamap`.\n    \"\"\"\n    ret = Region()\n    successor_map: dict[Block, Block] = {}\n    _ssamap = ssamap or {}\n    for block in self.blocks:\n        new_block = Block()\n        ret.blocks.append(new_block)\n        successor_map[block] = new_block\n        for arg in block.args:\n            new_arg = new_block.args.append_from(arg.type, arg.name)\n            _ssamap[arg] = new_arg\n\n    # update statements\n    for block in self.blocks:\n        for stmt in block.stmts:\n            new_stmt = stmt.from_stmt(\n                stmt,\n                args=[_ssamap[arg] for arg in stmt.args],\n                regions=[region.clone(_ssamap) for region in stmt.regions],\n                successors=[\n                    successor_map[successor] for successor in stmt.successors\n                ],\n            )\n            successor_map[block].stmts.append(new_stmt)\n            for result, new_result in zip(stmt.results, new_stmt.results):\n                _ssamap[result] = new_result\n\n    return ret\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.delete","title":"delete","text":"<pre><code>delete(safe: bool = True) -&gt; None\n</code></pre> <p>Delete the Region completely from the IR graph.</p> Note <p>This method will detach + remove references of the Region.</p> <p>Parameters:</p> Name Type Description Default <code>safe</code> <code>bool</code> <p>If True, raise error if there is anything that still reference components in the Region. Defaults to True.</p> <code>True</code> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def delete(self, safe: bool = True) -&gt; None:\n    \"\"\"Delete the Region completely from the IR graph.\n\n    Note:\n        This method will detach + remove references of the Region.\n\n    Args:\n        safe (bool, optional): If True, raise error if there is anything that still reference components in the Region. Defaults to True.\n    \"\"\"\n    self.detach()\n    self.drop_all_references()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.detach","title":"detach","text":"<pre><code>detach(index: int | None = None) -&gt; None\n</code></pre> <p>Detach this Region from the IR tree graph.</p> Note <p>Detach only detach the Region from the IR graph. It does not remove uses that reference the Region.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def detach(self, index: int | None = None) -&gt; None:\n    \"\"\"Detach this Region from the IR tree graph.\n\n    Note:\n        Detach only detach the Region from the IR graph. It does not remove uses that reference the Region.\n    \"\"\"\n    # already detached\n    if self.parent_node is None:\n        return\n\n    if index is not None:\n        region_idx = index\n    else:\n        region_idx = self.region_index\n\n    del self.parent_node._regions[region_idx]\n    self.parent_node = None\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.drop_all_references","title":"drop_all_references","text":"<pre><code>drop_all_references() -&gt; None\n</code></pre> <p>Remove all the dependency that reference/uses this Region.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def drop_all_references(self) -&gt; None:\n    \"\"\"Remove all the dependency that reference/uses this Region.\"\"\"\n    self.parent_node = None\n    for block in self._blocks:\n        block.drop_all_references()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.is_structurally_equal","title":"is_structurally_equal","text":"<pre><code>is_structurally_equal(\n    other: Self,\n    context: (\n        dict[IRNode | SSAValue, IRNode | SSAValue] | None\n    ) = None,\n) -&gt; bool\n</code></pre> <p>Check if the Region is structurally equal to another Region.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>The other Region to compare with.</p> required <code>context</code> <code>dict[IRNode | SSAValue, IRNode | SSAValue] | None</code> <p>A map of IRNode/SSAValue to hint that they are equivalent so the check will treat them as equivalent. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the Region is structurally equal to the other Region.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def is_structurally_equal(\n    self,\n    other: Self,\n    context: dict[IRNode | SSAValue, IRNode | SSAValue] | None = None,\n) -&gt; bool:\n    \"\"\"Check if the Region is structurally equal to another Region.\n\n    Args:\n        other (Self): The other Region to compare with.\n        context (dict[IRNode  |  SSAValue, IRNode  |  SSAValue] | None, optional): A map of IRNode/SSAValue to hint that they are equivalent so the check will treat them as equivalent. Defaults to None.\n\n    Returns:\n        bool: True if the Region is structurally equal to the other Region.\n    \"\"\"\n    if context is None:\n        context = {}\n\n    if len(self.blocks) != len(other.blocks):\n        return False\n\n    for block, other_block in zip(self.blocks, other.blocks):\n        context[block] = other_block\n\n    if not all(\n        block.is_structurally_equal(other_block, context)\n        for block, other_block in zip(self.blocks, other.blocks)\n    ):\n        return False\n\n    return True\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.typecheck","title":"typecheck","text":"<pre><code>typecheck() -&gt; None\n</code></pre> <p>Checking the types of the Statments of Blocks in the Region.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def typecheck(self) -&gt; None:\n    \"\"\"Checking the types of the Statments of Blocks in the Region.\"\"\"\n    for block in self.blocks:\n        block.typecheck()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>Verify the correctness of the Region.</p> <p>Raises:</p> Type Description <code>VerificationError</code> <p>If the Region is not correct.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def verify(self) -&gt; None:\n    \"\"\"Verify the correctness of the Region.\n\n    Raises:\n        VerificationError: If the Region is not correct.\n    \"\"\"\n    from kirin.ir.nodes.stmt import Statement\n\n    if not isinstance(self.parent_node, Statement):\n        raise VerificationError(\n            self, \"expect Region to have a parent of type Statement\"\n        )\n\n    for block in self.blocks:\n        block.verify()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.walk","title":"walk","text":"<pre><code>walk(\n    *, reverse: bool = False, region_first: bool = False\n) -&gt; Iterator[Statement]\n</code></pre> <p>Traversal the Statements of Blocks in the Region.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>If walk in the reversed manner. Defaults to False.</p> <code>False</code> <code>region_first</code> <code>bool</code> <p>If the walk should go through the Statement first or the Region of a Statement first. Defaults to False.</p> <code>False</code> <p>Yields:</p> Type Description <code>Statement</code> <p>Iterator[Statement]: An iterator that yield Statements of Blocks in the Region, in the specified order.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def walk(\n    self, *, reverse: bool = False, region_first: bool = False\n) -&gt; Iterator[Statement]:\n    \"\"\"Traversal the Statements of Blocks in the Region.\n\n    Args:\n        reverse (bool, optional): If walk in the reversed manner. Defaults to False.\n        region_first (bool, optional): If the walk should go through the Statement first or the Region of a Statement first. Defaults to False.\n\n    Yields:\n        Iterator[Statement]: An iterator that yield Statements of Blocks in the Region, in the specified order.\n    \"\"\"\n    for block in reversed(self.blocks) if reverse else self.blocks:\n        yield from block.walk(reverse=reverse, region_first=region_first)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.RegionBlocks","title":"RegionBlocks  <code>dataclass</code>","text":"<pre><code>RegionBlocks(node: NodeType, field: FieldType)\n</code></pre> <p>               Bases: <code>MutableSequenceView[list[Block], 'Region', Block]</code></p> <p>A View object that contains a list of Blocks of a Region.</p> Description <p>This is a proxy object that provide safe API to manipulate the Blocks of a Region.</p>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.RegionBlocks.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(\n    idx: int | slice,\n    block_or_blocks: Block | Iterable[Block],\n) -&gt; None\n</code></pre> <p>Replace/Set the Blocks of the Region.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int | slice</code> <p>The index or slice to replace the <code>Blocks</code>.</p> required <code>block_or_blocks</code> <code>Block | Iterable[Block]</code> <p>The Block or Blocks to replace the Blocks.</p> required Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def __setitem__(\n    self, idx: int | slice, block_or_blocks: Block | Iterable[Block]\n) -&gt; None:\n    \"\"\"Replace/Set the Blocks of the Region.\n\n    Args:\n        idx (int | slice): The index or slice to replace the [`Blocks`][kirin.ir.Block].\n        block_or_blocks (Block | Iterable[Block]): The Block or Blocks to replace the Blocks.\n\n    \"\"\"\n    if isinstance(idx, int) and isinstance(block_or_blocks, Block):\n        self.field[idx].detach()\n        block_or_blocks.attach(self.node)\n        self.field[idx] = block_or_blocks\n        self.node._block_idx[block_or_blocks] = idx\n    elif isinstance(idx, slice) and isinstance(block_or_blocks, Iterable):\n        for block in block_or_blocks:\n            block.attach(self.node)\n        self.field[idx] = block_or_blocks\n        self.node._block_idx = {\n            block: i for i, block in enumerate(self.field)\n        }  # reindex\n    else:\n        raise ValueError(\"Invalid assignment\")\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.RegionBlocks.append","title":"append","text":"<pre><code>append(value: Block) -&gt; None\n</code></pre> <p>Append a Block to the Region.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Block</code> <p>The block to be appended.</p> required Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def append(self, value: Block) -&gt; None:\n    \"\"\"Append a Block to the Region.\n\n    Args:\n        value (Block): The block to be appended.\n    \"\"\"\n    value.attach(self.node)\n    self.node._block_idx[value] = len(self.field)\n    self.field.append(value)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.RegionBlocks.insert","title":"insert","text":"<pre><code>insert(idx: int, value: Block) -&gt; None\n</code></pre> <p>Inserts a Block at the specified index.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>The index at which to insert the block.</p> required <code>value</code> <code>Block</code> <p>The block to be inserted.</p> required Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def insert(self, idx: int, value: Block) -&gt; None:\n    \"\"\"Inserts a Block at the specified index.\n\n    Args:\n        idx (int): The index at which to insert the block.\n        value (Block): The block to be inserted.\n    \"\"\"\n    value.attach(self.node)\n    self.field.insert(idx, value)\n    for i, value in enumerate(self.field[idx:], idx):\n        self.node._block_idx[value] = i\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/","title":"Stmt","text":""},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.ArgumentList","title":"ArgumentList  <code>dataclass</code>","text":"<pre><code>ArgumentList(node: NodeType, field: FieldType)\n</code></pre> <p>               Bases: <code>MutableSequenceView[tuple, 'Statement', SSAValue]</code>, <code>Printable</code></p> <p>A View object that contains a list of Arguemnts of a Statement.</p> Description <p>This is a proxy object that provide safe API to manipulate the arguemnts of a statement.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.ArgumentList.get_slice","title":"get_slice","text":"<pre><code>get_slice(name: str) -&gt; slice\n</code></pre> <p>Get the slice of the arguments.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the slice.</p> required <p>Returns:</p> Name Type Description <code>slice</code> <code>slice</code> <p>The slice of the arguments.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def get_slice(self, name: str) -&gt; slice:\n    \"\"\"Get the slice of the arguments.\n\n    Args:\n        name (str): The name of the slice.\n\n    Returns:\n        slice: The slice of the arguments.\n    \"\"\"\n    index = self.node._name_args_slice[name]\n    if isinstance(index, int):\n        return slice(index, index + 1)\n    return index\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.ArgumentList.insert","title":"insert","text":"<pre><code>insert(idx: int, value: SSAValue) -&gt; None\n</code></pre> <p>Insert the argument SSAValue at the specified index.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>The index to insert the value.</p> required <code>value</code> <code>SSAValue</code> <p>The value to insert.</p> required Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def insert(self, idx: int, value: SSAValue) -&gt; None:\n    \"\"\"Insert the argument SSAValue at the specified index.\n\n    Args:\n        idx (int): The index to insert the value.\n        value (SSAValue): The value to insert.\n    \"\"\"\n    args = self.field\n    value.add_use(Use(self.node, idx))\n    new_args = (*args[:idx], value, *args[idx:])\n    self.node._args = new_args\n    self.field = new_args\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.ArgumentList.set_item","title":"set_item","text":"<pre><code>set_item(idx: int, value: SSAValue) -&gt; None\n</code></pre> <p>Set the argument SSAVAlue at the specified index.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>The index of the item to set.</p> required <code>value</code> <code>SSAValue</code> <p>The value to set.</p> required Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def set_item(self, idx: int, value: SSAValue) -&gt; None:\n    \"\"\"Set the argument SSAVAlue at the specified index.\n\n    Args:\n        idx (int): The index of the item to set.\n        value (SSAValue): The value to set.\n    \"\"\"\n    args = self.field\n    args[idx].remove_use(Use(self.node, idx))\n    value.add_use(Use(self.node, idx))\n    new_args = (*args[:idx], value, *args[idx + 1 :])\n    self.node._args = new_args\n    self.field = new_args\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.ResultList","title":"ResultList  <code>dataclass</code>","text":"<pre><code>ResultList(node: NodeType, field: FieldType)\n</code></pre> <p>               Bases: <code>MutableSequenceView[list, 'Statement', ResultValue]</code></p> <p>A View object that contains a list of ResultValue of a Statement.</p> Description <p>This is a proxy object that provide safe API to manipulate the result values of a statement</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.ResultList.types","title":"types  <code>property</code>","text":"<pre><code>types: Sequence[TypeAttribute]\n</code></pre> <p>Get the result types of the Statement.</p> <p>Returns:</p> Type Description <code>Sequence[TypeAttribute]</code> <p>Sequence[TypeAttribute]: type of each result value.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement","title":"Statement  <code>dataclass</code>","text":"<pre><code>Statement(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>IRNode['Block']</code></p> <p>The Statment is an instruction in the IR</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.args","title":"args  <code>instance-attribute</code> <code>property</code> <code>writable</code>","text":"<pre><code>args: ArgumentList = args\n</code></pre> <p>Get the arguments of the Statement.</p> <p>Returns:</p> Name Type Description <code>ArgumentList</code> <code>ArgumentList</code> <p>The arguments View of the Statement.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.next_stmt","title":"next_stmt  <code>property</code> <code>writable</code>","text":"<pre><code>next_stmt: Statement | None\n</code></pre> <p>Get the next statement.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.parent_block","title":"parent_block  <code>property</code>","text":"<pre><code>parent_block: Block | None\n</code></pre> <p>Get the parent Block.</p> <p>Returns:</p> Type Description <code>Block | None</code> <p>Block | None: The parent Block.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.parent_node","title":"parent_node  <code>property</code> <code>writable</code>","text":"<pre><code>parent_node: Block | None\n</code></pre> <p>Get the parent node.</p> <p>Returns:</p> Type Description <code>Block | None</code> <p>Block | None: The parent node.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.parent_region","title":"parent_region  <code>property</code>","text":"<pre><code>parent_region: Region | None\n</code></pre> <p>Get the parent Region. Returns:     Region | None: The parent Region.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.parent_stmt","title":"parent_stmt  <code>property</code>","text":"<pre><code>parent_stmt: Statement | None\n</code></pre> <p>Get the parent statement.</p> <p>Returns:</p> Type Description <code>Statement | None</code> <p>Statement | None: The parent statement.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.prev_stmt","title":"prev_stmt  <code>property</code> <code>writable</code>","text":"<pre><code>prev_stmt: Statement | None\n</code></pre> <p>Get the previous statement.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.regions","title":"regions  <code>instance-attribute</code> <code>property</code> <code>writable</code>","text":"<pre><code>regions: list[Region] = list(regions)\n</code></pre> <p>Get a list of regions of the Statement.</p> <p>Returns:</p> Type Description <code>list[Region]</code> <p>list[Region]: The list of regions of the Statement.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.results","title":"results  <code>property</code>","text":"<pre><code>results: ResultList\n</code></pre> <p>Get the result values of the Statement.</p> <p>Returns:</p> Name Type Description <code>ResultList</code> <code>ResultList</code> <p>The result values View of the Statement.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.delete","title":"delete","text":"<pre><code>delete(safe: bool = True) -&gt; None\n</code></pre> <p>Delete the Statement completely from the IR graph.</p> Note <p>This method will detach + remove references of the Statement.</p> <p>Parameters:</p> Name Type Description Default <code>safe</code> <code>bool</code> <p>If True, raise error if there is anything that still reference components in the Statement. Defaults to True.</p> <code>True</code> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def delete(self, safe: bool = True) -&gt; None:\n    \"\"\"Delete the Statement completely from the IR graph.\n\n    Note:\n        This method will detach + remove references of the Statement.\n\n    Args:\n        safe (bool, optional): If True, raise error if there is anything that still reference components in the Statement. Defaults to True.\n    \"\"\"\n    self.detach()\n    self.drop_all_references()\n    for result in self._results:\n        result.delete(safe=safe)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.detach","title":"detach","text":"<pre><code>detach() -&gt; None\n</code></pre> <p>detach the statement from its parent block.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def detach(self) -&gt; None:\n    \"\"\"detach the statement from its parent block.\"\"\"\n    if self.parent is None:\n        return\n\n    parent: Block = self.parent\n    prev_stmt = self.prev_stmt\n    next_stmt = self.next_stmt\n\n    if prev_stmt is not None:\n        prev_stmt._next_stmt = next_stmt\n        self._prev_stmt = None\n    else:\n        assert (\n            parent._first_stmt is self\n        ), \"Invalid statement, has no prev_stmt but not first_stmt\"\n        parent._first_stmt = next_stmt\n\n    if next_stmt is not None:\n        next_stmt._prev_stmt = prev_stmt\n        self._next_stmt = None\n    else:\n        assert (\n            parent._last_stmt is self\n        ), \"Invalid statement, has no next_stmt but not last_stmt\"\n        parent._last_stmt = prev_stmt\n\n    self.parent = None\n    parent._stmt_len -= 1\n    return\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.drop_all_references","title":"drop_all_references","text":"<pre><code>drop_all_references() -&gt; None\n</code></pre> <p>Remove all the dependency that reference/uses this Statement.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def drop_all_references(self) -&gt; None:\n    \"\"\"Remove all the dependency that reference/uses this Statement.\"\"\"\n    self.parent = None\n    for idx, arg in enumerate(self._args):\n        arg.remove_use(Use(self, idx))\n    for region in self._regions:\n        region.drop_all_references()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.expect_one_result","title":"expect_one_result","text":"<pre><code>expect_one_result() -&gt; ResultValue\n</code></pre> <p>Check if the statement contain only one result, and return it</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def expect_one_result(self) -&gt; ResultValue:\n    \"\"\"Check if the statement contain only one result, and return it\"\"\"\n    if len(self._results) != 1:\n        raise ValueError(f\"expected one result, got {len(self._results)}\")\n    return self._results[0]\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.from_stmt","title":"from_stmt  <code>classmethod</code>","text":"<pre><code>from_stmt(\n    other: Statement,\n    args: Sequence[SSAValue] | None = None,\n    regions: list[Region] | None = None,\n    successors: list[Block] | None = None,\n    attributes: dict[str, Attribute] | None = None,\n) -&gt; Self\n</code></pre> <p>Create a similar Statement with new <code>ResultValue</code> and without attaching to any parent block. This still references to the old successor and regions.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>@classmethod\ndef from_stmt(\n    cls,\n    other: Statement,\n    args: Sequence[SSAValue] | None = None,\n    regions: list[Region] | None = None,\n    successors: list[Block] | None = None,\n    attributes: dict[str, Attribute] | None = None,\n) -&gt; Self:\n    \"\"\"Create a similar Statement with new `ResultValue` and without\n    attaching to any parent block. This still references to the old successor\n    and regions.\n    \"\"\"\n    obj = cls.__new__(cls)\n    Statement.__init__(\n        obj,\n        args=args or other._args,\n        regions=regions or other._regions,\n        successors=successors or other.successors,\n        attributes=attributes or other.attributes,\n        properties=other.properties,  # properties are immutable, thus no need to copy\n        result_types=[result.type for result in other._results],\n        args_slice=other._name_args_slice,\n    )\n    return obj\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.get_attr_or_prop","title":"get_attr_or_prop","text":"<pre><code>get_attr_or_prop(key: str) -&gt; Attribute | None\n</code></pre> <p>Get the attribute or property of the Statement.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the attribute or property.</p> required <p>Returns:</p> Type Description <code>Attribute | None</code> <p>Attribute | None: The attribute or property of the Statement.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def get_attr_or_prop(self, key: str) -&gt; Attribute | None:\n    \"\"\"Get the attribute or property of the Statement.\n\n    Args:\n        key (str): The key of the attribute or property.\n\n    Returns:\n        Attribute | None: The attribute or property of the Statement.\n    \"\"\"\n    return self.attributes.get(key, self.properties.get(key))\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.get_trait","title":"get_trait  <code>classmethod</code>","text":"<pre><code>get_trait(trait: type[TraitType]) -&gt; TraitType | None\n</code></pre> <p>Get the trait of the Statement.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>@classmethod\ndef get_trait(cls, trait: type[TraitType]) -&gt; TraitType | None:\n    \"\"\"Get the trait of the Statement.\"\"\"\n    for t in cls.traits:\n        if isinstance(t, trait):\n            return t\n    return None\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.has_trait","title":"has_trait  <code>classmethod</code>","text":"<pre><code>has_trait(trait_type: type[StmtTrait]) -&gt; bool\n</code></pre> <p>Check if the Statement has a specific trait.</p> <p>Parameters:</p> Name Type Description Default <code>trait_type</code> <code>type[StmtTrait]</code> <p>The type of trait to check for.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the class has the specified trait, False otherwise.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>@classmethod\ndef has_trait(cls, trait_type: type[StmtTrait]) -&gt; bool:\n    \"\"\"Check if the Statement has a specific trait.\n\n    Args:\n        trait_type (type[StmtTrait]): The type of trait to check for.\n\n    Returns:\n        bool: True if the class has the specified trait, False otherwise.\n    \"\"\"\n    for trait in cls.traits:\n        if isinstance(trait, trait_type):\n            return True\n    return False\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.insert_after","title":"insert_after","text":"<pre><code>insert_after(stmt: Statement) -&gt; None\n</code></pre> <p>Insert the current Statement after the input Statement.</p> <p>Parameters:</p> Name Type Description Default <code>stmt</code> <code>Statement</code> <p>Input Statement.</p> required Example <p>The following example demonstrates how to insert a Statement after another Statement. After <code>insert_after</code> is called, <code>stmt1</code> will be inserted after <code>stmt2</code>, which appears in IR in the order (stmt2 -&gt; stmt1) <pre><code>stmt1 = Statement()\nstmt2 = Statement()\nstmt1.insert_after(stmt2)\n</code></pre></p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def insert_after(self, stmt: Statement) -&gt; None:\n    \"\"\"Insert the current Statement after the input Statement.\n\n    Args:\n        stmt (Statement): Input Statement.\n\n    Example:\n        The following example demonstrates how to insert a Statement after another Statement.\n        After `insert_after` is called, `stmt1` will be inserted after `stmt2`, which appears in IR in the order (stmt2 -&gt; stmt1)\n        ```python\n        stmt1 = Statement()\n        stmt2 = Statement()\n        stmt1.insert_after(stmt2)\n        ```\n    \"\"\"\n    if self._next_stmt is not None and self._prev_stmt is not None:\n        raise ValueError(\n            f\"Cannot insert before a statement that is already in a block: {self.name}\"\n        )\n\n    if stmt._next_stmt is not None:\n        stmt._next_stmt._prev_stmt = self\n\n    self._prev_stmt = stmt\n    self._next_stmt = stmt._next_stmt\n\n    self.parent = stmt.parent\n    stmt._next_stmt = self\n\n    if self.parent:\n        self.parent._stmt_len += 1\n\n        if self._next_stmt is None:\n            self.parent._last_stmt = self\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.insert_before","title":"insert_before","text":"<pre><code>insert_before(stmt: Statement) -&gt; None\n</code></pre> <p>Insert the current Statement before the input Statement.</p> <p>Parameters:</p> Name Type Description Default <code>stmt</code> <code>Statement</code> <p>Input Statement.</p> required Example <p>The following example demonstrates how to insert a Statement before another Statement. After <code>insert_before</code> is called, <code>stmt1</code> will be inserted before <code>stmt2</code>, which appears in IR in the order (stmt1 -&gt; stmt2) <pre><code>stmt1 = Statement()\nstmt2 = Statement()\nstmt1.insert_before(stmt2)\n</code></pre></p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def insert_before(self, stmt: Statement) -&gt; None:\n    \"\"\"Insert the current Statement before the input Statement.\n\n    Args:\n        stmt (Statement): Input Statement.\n\n    Example:\n        The following example demonstrates how to insert a Statement before another Statement.\n        After `insert_before` is called, `stmt1` will be inserted before `stmt2`, which appears in IR in the order (stmt1 -&gt; stmt2)\n        ```python\n        stmt1 = Statement()\n        stmt2 = Statement()\n        stmt1.insert_before(stmt2)\n        ```\n    \"\"\"\n    if self._next_stmt is not None and self._prev_stmt is not None:\n        raise ValueError(\n            f\"Cannot insert before a statement that is already in a block: {self.name}\"\n        )\n\n    if stmt._prev_stmt is not None:\n        stmt._prev_stmt._next_stmt = self\n\n    self._next_stmt = stmt\n    self._prev_stmt = stmt._prev_stmt\n\n    self.parent = stmt.parent\n    stmt._prev_stmt = self\n\n    if self.parent:\n        self.parent._stmt_len += 1\n\n        if self._prev_stmt is None:\n            self.parent._first_stmt = self\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.is_structurally_equal","title":"is_structurally_equal","text":"<pre><code>is_structurally_equal(\n    other: Self,\n    context: (\n        dict[IRNode | SSAValue, IRNode | SSAValue] | None\n    ) = None,\n) -&gt; bool\n</code></pre> <p>Check if the Statement is structurally equal to another Statement.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>The other Statelemt to compare with.</p> required <code>context</code> <code>dict[IRNode | SSAValue, IRNode | SSAValue] | None</code> <p>A map of IRNode/SSAValue to hint that they are equivalent so the check will treat them as equivalent. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the IRNode is structurally equal to the other.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def is_structurally_equal(\n    self,\n    other: Self,\n    context: dict[IRNode | SSAValue, IRNode | SSAValue] | None = None,\n) -&gt; bool:\n    \"\"\"Check if the Statement is structurally equal to another Statement.\n\n    Args:\n        other (Self): The other Statelemt to compare with.\n        context (dict[IRNode  |  SSAValue, IRNode  |  SSAValue] | None, optional): A map of IRNode/SSAValue to hint that they are equivalent so the check will treat them as equivalent. Defaults to None.\n\n    Returns:\n        bool: True if the IRNode is structurally equal to the other.\n    \"\"\"\n    if context is None:\n        context = {}\n\n    if self.name != other.name:\n        return False\n\n    if (\n        len(self.args) != len(other.args)\n        or len(self.regions) != len(other.regions)\n        or len(self.successors) != len(other.successors)\n        or self.attributes != other.attributes\n        or self.properties != other.properties\n    ):\n        return False\n\n    if (\n        self.parent is not None\n        and other.parent is not None\n        and context.get(self.parent) != other.parent\n    ):\n        return False\n\n    if not all(\n        context.get(arg, arg) == other_arg\n        for arg, other_arg in zip(self.args, other.args)\n    ):\n        return False\n\n    if not all(\n        context.get(successor, successor) == other_successor\n        for successor, other_successor in zip(self.successors, other.successors)\n    ):\n        return False\n\n    if not all(\n        region.is_structurally_equal(other_region, context)\n        for region, other_region in zip(self.regions, other.regions)\n    ):\n        return False\n\n    for result, other_result in zip(self._results, other._results):\n        context[result] = other_result\n\n    return True\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.replace_by","title":"replace_by","text":"<pre><code>replace_by(stmt: Statement) -&gt; None\n</code></pre> <p>Replace the current Statement by the input Statement.</p> <p>Parameters:</p> Name Type Description Default <code>stmt</code> <code>Statement</code> <p>Input Statement.</p> required Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def replace_by(self, stmt: Statement) -&gt; None:\n    \"\"\"Replace the current Statement by the input Statement.\n\n    Args:\n        stmt (Statement): Input Statement.\n    \"\"\"\n    stmt.insert_before(self)\n    for result, old_result in zip(stmt._results, self._results):\n        old_result.replace_by(result)\n        if old_result.name:\n            result.name = old_result.name\n    self.delete()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.typecheck","title":"typecheck","text":"<pre><code>typecheck() -&gt; None\n</code></pre> <p>check the type of the statement.</p> Note <ol> <li>Statement should implement typecheck. this is done automatically via @statement, but in the case manualy implementation is needed, it should be implemented here.</li> <li>This API should be called after all the types are figured out (by typeinfer)</li> </ol> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def typecheck(self) -&gt; None:\n    \"\"\"check the type of the statement.\n\n    Note:\n        1. Statement should implement typecheck.\n        this is done automatically via @statement, but\n        in the case manualy implementation is needed,\n        it should be implemented here.\n        2. This API should be called after all the types are figured out (by typeinfer)\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>run mandatory validation checks. This is not same as typecheck, which may be optional.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def verify(self) -&gt; None:\n    return\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.walk","title":"walk","text":"<pre><code>walk(\n    *,\n    reverse: bool = False,\n    region_first: bool = False,\n    include_self: bool = True\n) -&gt; Iterator[Statement]\n</code></pre> <p>Traversal the Statements of Regions.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>If walk in the reversed manner. Defaults to False.</p> <code>False</code> <code>region_first</code> <code>bool</code> <p>If the walk should go through the Statement first or the Region of a Statement first. Defaults to False.</p> <code>False</code> <code>include_self</code> <code>bool</code> <p>If the walk should include the Statement itself. Defaults to True.</p> <code>True</code> <p>Yields:</p> Type Description <code>Statement</code> <p>Iterator[Statement]: An iterator that yield Statements of Blocks in the Region, in the specified order.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def walk(\n    self,\n    *,\n    reverse: bool = False,\n    region_first: bool = False,\n    include_self: bool = True,\n) -&gt; Iterator[Statement]:\n    \"\"\"Traversal the Statements of Regions.\n\n    Args:\n        reverse (bool, optional): If walk in the reversed manner. Defaults to False.\n        region_first (bool, optional): If the walk should go through the Statement first or the Region of a Statement first. Defaults to False.\n        include_self (bool, optional): If the walk should include the Statement itself. Defaults to True.\n\n    Yields:\n        Iterator[Statement]: An iterator that yield Statements of Blocks in the Region, in the specified order.\n    \"\"\"\n    if include_self and not region_first:\n        yield self\n\n    for region in reversed(self.regions) if reverse else self.regions:\n        yield from region.walk(reverse=reverse, region_first=region_first)\n\n    if include_self and region_first:\n        yield self\n</code></pre>"},{"location":"reference/kirin/ir/nodes/view/","title":"View","text":""},{"location":"reference/kirin/ir/nodes/view/#kirin.ir.nodes.view.MutableSequenceView","title":"MutableSequenceView  <code>dataclass</code>","text":"<pre><code>MutableSequenceView(node: NodeType, field: FieldType)\n</code></pre> <p>               Bases: <code>SequenceView[FieldType, NodeType, ElemType]</code></p>"},{"location":"reference/kirin/ir/nodes/view/#kirin.ir.nodes.view.MutableSequenceView.popfirst","title":"popfirst","text":"<pre><code>popfirst() -&gt; ElemType | None\n</code></pre> <p>Pop the first element from the view.</p> <p>Returns:</p> Type Description <code>ElemType | None</code> <p>The first element in the view.</p> Source code in <code>src/kirin/ir/nodes/view.py</code> <pre><code>def popfirst(self) -&gt; ElemType | None:\n    \"\"\"Pop the first element from the view.\n\n    Returns:\n        The first element in the view.\n    \"\"\"\n    if self:\n        return self.pop(0)\n    return None\n</code></pre>"},{"location":"reference/kirin/ir/nodes/view/#kirin.ir.nodes.view.MutableSequenceView.poplast","title":"poplast","text":"<pre><code>poplast() -&gt; ElemType | None\n</code></pre> <p>Pop the last element from the view.</p> <p>Returns:</p> Type Description <code>ElemType | None</code> <p>The last element in the view.</p> Source code in <code>src/kirin/ir/nodes/view.py</code> <pre><code>def poplast(self) -&gt; ElemType | None:\n    \"\"\"Pop the last element from the view.\n\n    Returns:\n        The last element in the view.\n    \"\"\"\n    if self:\n        return self.pop(-1)\n    return None\n</code></pre>"},{"location":"reference/kirin/ir/traits/","title":"Index","text":""},{"location":"reference/kirin/ir/traits/abc/","title":"Abc","text":""},{"location":"reference/kirin/ir/traits/abc/#kirin.ir.traits.abc.StmtTrait","title":"StmtTrait  <code>dataclass</code>","text":"<pre><code>StmtTrait()\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Base class for all statement traits.</p>"},{"location":"reference/kirin/ir/traits/basic/","title":"Basic","text":""},{"location":"reference/kirin/ir/traits/callable/","title":"Callable","text":""},{"location":"reference/kirin/ir/traits/callable/#kirin.ir.traits.callable.CallableStmtInterface","title":"CallableStmtInterface  <code>dataclass</code>","text":"<pre><code>CallableStmtInterface()\n</code></pre> <p>               Bases: <code>StmtTrait</code>, <code>Generic[StmtType]</code></p>"},{"location":"reference/kirin/ir/traits/callable/#kirin.ir.traits.callable.CallableStmtInterface.get_callable_region","title":"get_callable_region  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>get_callable_region(stmt: StmtType) -&gt; Region\n</code></pre> <p>Returns the body of the callable region</p> Source code in <code>src/kirin/ir/traits/callable.py</code> <pre><code>@classmethod\n@abstractmethod\ndef get_callable_region(cls, stmt: \"StmtType\") -&gt; \"Region\":\n    \"\"\"Returns the body of the callable region\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/ir/traits/symbol/","title":"Symbol","text":""},{"location":"reference/kirin/ir/traits/symbol/#kirin.ir.traits.symbol.SymbolTable","title":"SymbolTable  <code>dataclass</code>","text":"<pre><code>SymbolTable()\n</code></pre> <p>               Bases: <code>StmtTrait</code></p> <p>Statement with SymbolTable trait can only have one region with one block.</p>"},{"location":"reference/kirin/ir/traits/lowering/","title":"Index","text":""},{"location":"reference/kirin/ir/traits/lowering/call/","title":"Call","text":""},{"location":"reference/kirin/ir/traits/lowering/call/#kirin.ir.traits.lowering.call.FromPythonCall","title":"FromPythonCall  <code>dataclass</code>","text":"<pre><code>FromPythonCall()\n</code></pre> <p>               Bases: <code>PythonLoweringTrait[StatementType, Call]</code></p> <p>Trait for customizing lowering of Python calls to a statement.</p> <p>Declared in a statement definition to indicate that the statement can be constructed from a Python call (i.e., a function call <code>ast.Call</code> in the Python AST).</p> <p>Subclassing this trait allows for customizing the lowering of Python calls to the statement. The <code>lower</code> method should be implemented to parse the arguments from the Python call and construct the statement instance.</p>"},{"location":"reference/kirin/ir/traits/lowering/context/","title":"Context","text":"<p>Traits for customizing lowering of Python <code>with</code> syntax to a statement.</p>"},{"location":"reference/kirin/ir/traits/lowering/context/#kirin.ir.traits.lowering.context.FromPythonWith","title":"FromPythonWith  <code>dataclass</code>","text":"<pre><code>FromPythonWith()\n</code></pre> <p>               Bases: <code>PythonLoweringTrait[StatementType, With]</code></p> <p>Trait for customizing lowering of Python with statements to a statement.</p> <p>Subclassing this trait allows for customizing the lowering of Python with statements to the statement. The <code>lower</code> method should be implemented to parse the arguments from the Python with statement and construct the statement instance.</p>"},{"location":"reference/kirin/ir/traits/lowering/context/#kirin.ir.traits.lowering.context.FromPythonWithSingleItem","title":"FromPythonWithSingleItem  <code>dataclass</code>","text":"<pre><code>FromPythonWithSingleItem()\n</code></pre> <p>               Bases: <code>FromPythonWith[StatementType]</code></p> <p>Trait for customizing lowering of the following Python with syntax to a statement:</p> <pre><code>with &lt;stmt&gt;[ as &lt;name&gt;]:\n    &lt;body&gt;\n</code></pre> <p>where <code>&lt;stmt&gt;</code> is the statement being lowered, <code>&lt;name&gt;</code> is an optional name for the result of the statement, and <code>&lt;body&gt;</code> is the body of the with statement. The optional <code>as &lt;name&gt;</code> is not valid when the statement has no results.</p> <p>This syntax is slightly different from the standard Python <code>with</code> statement in that <code>&lt;name&gt;</code> refers to the result of the statement, not the context manager. Thus typically one sould access <code>&lt;name&gt;</code> in <code>&lt;body&gt;</code> to use the result of the statement.</p> <p>In some cases, however, <code>&lt;name&gt;</code> may be used as a reference of a special value <code>self</code> that is passed to the <code>&lt;body&gt;</code> of the statement. This is useful for statements that have a similar behavior to a closure.</p>"},{"location":"reference/kirin/ir/traits/region/","title":"Index","text":""},{"location":"reference/kirin/ir/traits/region/ssacfg/","title":"Ssacfg","text":""},{"location":"reference/kirin/lattice/","title":"Index","text":""},{"location":"reference/kirin/lattice/abc/","title":"Lattice","text":""},{"location":"reference/kirin/lattice/abc/#kirin.lattice.abc.Lattice","title":"Lattice","text":"<p>               Bases: <code>ABC</code>, <code>Generic[LatticeType]</code></p> <p>ABC for lattices as Python class.</p> <p>While <code>Lattice</code> is only an interface, <code>LatticeABC</code> is an abstract class that can be inherited from. This provides a few default implementations for the lattice operations.</p>"},{"location":"reference/kirin/lattice/abc/#kirin.lattice.abc.Lattice.is_equal","title":"is_equal","text":"<pre><code>is_equal(other: LatticeType) -&gt; bool\n</code></pre> <p>Check if two lattices are equal.</p> Source code in <code>src/kirin/lattice/abc.py</code> <pre><code>def is_equal(self, other: LatticeType) -&gt; bool:\n    \"\"\"Check if two lattices are equal.\"\"\"\n    if self is other:\n        return True\n    else:\n        return self.is_subseteq(other) and other.is_subseteq(self)\n</code></pre>"},{"location":"reference/kirin/lattice/abc/#kirin.lattice.abc.Lattice.is_subseteq","title":"is_subseteq  <code>abstractmethod</code>","text":"<pre><code>is_subseteq(other: LatticeType) -&gt; bool\n</code></pre> <p>Subseteq operation.</p> Source code in <code>src/kirin/lattice/abc.py</code> <pre><code>@abstractmethod\ndef is_subseteq(self, other: LatticeType) -&gt; bool:\n    \"\"\"Subseteq operation.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/lattice/abc/#kirin.lattice.abc.Lattice.join","title":"join  <code>abstractmethod</code>","text":"<pre><code>join(other: LatticeType) -&gt; LatticeType\n</code></pre> <p>Join operation.</p> Source code in <code>src/kirin/lattice/abc.py</code> <pre><code>@abstractmethod\ndef join(self, other: LatticeType) -&gt; LatticeType:\n    \"\"\"Join operation.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/lattice/abc/#kirin.lattice.abc.Lattice.meet","title":"meet  <code>abstractmethod</code>","text":"<pre><code>meet(other: LatticeType) -&gt; LatticeType\n</code></pre> <p>Meet operation.</p> Source code in <code>src/kirin/lattice/abc.py</code> <pre><code>@abstractmethod\ndef meet(self, other: LatticeType) -&gt; LatticeType:\n    \"\"\"Meet operation.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/lattice/abc/#kirin.lattice.abc.SingletonMeta","title":"SingletonMeta","text":"<pre><code>SingletonMeta(name, bases, attrs)\n</code></pre> <p>               Bases: <code>LatticeMeta</code></p> <p>Singleton metaclass for lattices. It ensures that only one instance of a lattice is created.</p> <p>See https://stackoverflow.com/questions/674304/why-is-init-always-called-after-new/8665179#8665179</p> Source code in <code>src/kirin/lattice/abc.py</code> <pre><code>def __init__(cls, name, bases, attrs):\n    super().__init__(name, bases, attrs)\n    cls._instance = None\n</code></pre>"},{"location":"reference/kirin/lattice/abc/#kirin.lattice.abc.UnionMeta","title":"UnionMeta","text":"<p>               Bases: <code>LatticeMeta</code></p> <p>Meta class for union types. It simplifies the union if possible.</p>"},{"location":"reference/kirin/lattice/empty/","title":"Empty","text":""},{"location":"reference/kirin/lattice/empty/#kirin.lattice.empty.EmptyLattice","title":"EmptyLattice","text":"<p>               Bases: <code>BoundedLattice['EmptyLattice']</code></p> <p>Empty lattice.</p>"},{"location":"reference/kirin/lattice/empty/#kirin.lattice.empty.EmptyLattice.is_subseteq","title":"is_subseteq","text":"<pre><code>is_subseteq(other: EmptyLattice) -&gt; bool\n</code></pre> <p>Subseteq operation.</p> Source code in <code>src/kirin/lattice/empty.py</code> <pre><code>def is_subseteq(self, other: \"EmptyLattice\") -&gt; bool:\n    return True\n</code></pre>"},{"location":"reference/kirin/lattice/empty/#kirin.lattice.empty.EmptyLattice.join","title":"join","text":"<pre><code>join(other: EmptyLattice) -&gt; EmptyLattice\n</code></pre> <p>Join operation.</p> Source code in <code>src/kirin/lattice/empty.py</code> <pre><code>def join(self, other: \"EmptyLattice\") -&gt; \"EmptyLattice\":\n    return self\n</code></pre>"},{"location":"reference/kirin/lattice/empty/#kirin.lattice.empty.EmptyLattice.meet","title":"meet","text":"<pre><code>meet(other: EmptyLattice) -&gt; EmptyLattice\n</code></pre> <p>Meet operation.</p> Source code in <code>src/kirin/lattice/empty.py</code> <pre><code>def meet(self, other: \"EmptyLattice\") -&gt; \"EmptyLattice\":\n    return self\n</code></pre>"},{"location":"reference/kirin/lattice/mixin/","title":"Mixin","text":""},{"location":"reference/kirin/lattice/mixin/#kirin.lattice.mixin.IsSubsetEqMixin","title":"IsSubsetEqMixin","text":"<p>               Bases: <code>BoundedLattice[BoundedLatticeType]</code></p> <p>A special mixin for lattices that provides a default implementation for <code>is_subseteq</code> by using the visitor pattern. This is useful if the lattice has a lot of different subclasses that need to be compared.</p> <p>Must be used before <code>BoundedLattice</code> in the inheritance chain.</p>"},{"location":"reference/kirin/lattice/mixin/#kirin.lattice.mixin.IsSubsetEqMixin.is_subseteq","title":"is_subseteq","text":"<pre><code>is_subseteq(other: BoundedLatticeType) -&gt; bool\n</code></pre> <p>Subseteq operation.</p> Source code in <code>src/kirin/lattice/mixin.py</code> <pre><code>def is_subseteq(self, other: BoundedLatticeType) -&gt; bool:\n    if other is self.top():\n        return True\n    elif other is self.bottom():\n        return False\n\n    method = getattr(\n        self,\n        \"is_subseteq_\" + other.__class__.__name__,\n        getattr(self, \"is_subseteq_fallback\", None),\n    )\n    if method is not None:\n        return method(other)\n    return False\n</code></pre>"},{"location":"reference/kirin/lattice/mixin/#kirin.lattice.mixin.SimpleJoinMixin","title":"SimpleJoinMixin","text":"<p>               Bases: <code>BoundedLattice[BoundedLatticeType]</code></p> <p>A mixin that provides a simple implementation for the join operation.</p>"},{"location":"reference/kirin/lattice/mixin/#kirin.lattice.mixin.SimpleJoinMixin.join","title":"join","text":"<pre><code>join(other: BoundedLatticeType) -&gt; BoundedLatticeType\n</code></pre> <p>Join operation.</p> Source code in <code>src/kirin/lattice/mixin.py</code> <pre><code>def join(self, other: BoundedLatticeType) -&gt; BoundedLatticeType:\n    if self.is_subseteq(other):\n        return other\n    elif other.is_subseteq(self):\n        return self  # type: ignore\n    return self.top()\n</code></pre>"},{"location":"reference/kirin/lattice/mixin/#kirin.lattice.mixin.SimpleMeetMixin","title":"SimpleMeetMixin","text":"<p>               Bases: <code>BoundedLattice[BoundedLatticeType]</code></p> <p>A mixin that provides a simple implementation for the meet operation.</p>"},{"location":"reference/kirin/lattice/mixin/#kirin.lattice.mixin.SimpleMeetMixin.meet","title":"meet","text":"<pre><code>meet(other: BoundedLatticeType) -&gt; BoundedLatticeType\n</code></pre> <p>Meet operation.</p> Source code in <code>src/kirin/lattice/mixin.py</code> <pre><code>def meet(self, other: BoundedLatticeType) -&gt; BoundedLatticeType:\n    if self.is_subseteq(other):\n        return self  # type: ignore\n    elif other.is_subseteq(self):\n        return other\n    return self.bottom()\n</code></pre>"},{"location":"reference/kirin/lowering/","title":"Index","text":""},{"location":"reference/kirin/lowering/binding/","title":"Binding","text":""},{"location":"reference/kirin/lowering/binding/#kirin.lowering.binding.wraps","title":"wraps","text":"<pre><code>wraps(parent: type[Statement])\n</code></pre> <p>Wraps a <code>Statement</code> to a <code>Binding</code> object which will be special cased in the lowering process.</p> <p>This is useful for providing type hints by faking the call signature of a <code>Statement</code>.</p>"},{"location":"reference/kirin/lowering/binding/#kirin.lowering.binding.wraps--example","title":"Example","text":"<p>Directly writing a function with the statement will let Python linter think you intend to call the constructor of the statement class. However, given the context of a kernel, our intention is to actually \"call\" the statement, e.g the following will produce type errors with pyright or mypy:</p> <pre><code>from kirin.dialects import math\nfrom kirin.prelude import basic_no_opt\n\n@basic_no_opt\ndef main(x: float):\n    return math.sin(x) # this is a statement, not a function\n</code></pre> <p>the <code>@lowering.wraps</code> decorator allows us to provide a type hint for the statement, e.g:</p> <pre><code>from kirin import lowering\n\n@lowering.wraps(math.sin)\ndef sin(value: float) -&gt; float: ...\n\n@basic_no_opt\ndef main(x: float):\n    return sin(x) # linter now thinks this is a function\n\nsin(1.0) # this will raise a NotImplementedError(\"Binding of sin can only be called from a kernel\")\n</code></pre> Source code in <code>src/kirin/lowering/binding.py</code> <pre><code>def wraps(parent: type[\"Statement\"]):\n    \"\"\"Wraps a [`Statement`][kirin.ir.nodes.stmt.Statement] to a `Binding` object\n    which will be special cased in the lowering process.\n\n    This is useful for providing type hints by faking the call signature of a\n    [`Statement`][kirin.ir.nodes.stmt.Statement].\n\n    ## Example\n\n    Directly writing a function with the statement will let Python linter think\n    you intend to call the constructor of the statement class. However, given the\n    context of a kernel, our intention is to actually \"call\" the statement, e.g\n    the following will produce type errors with pyright or mypy:\n\n    ```python\n    from kirin.dialects import math\n    from kirin.prelude import basic_no_opt\n\n    @basic_no_opt\n    def main(x: float):\n        return math.sin(x) # this is a statement, not a function\n    ```\n\n    the `@lowering.wraps` decorator allows us to provide a type hint for the\n    statement, e.g:\n\n    ```python\n    from kirin import lowering\n\n    @lowering.wraps(math.sin)\n    def sin(value: float) -&gt; float: ...\n\n    @basic_no_opt\n    def main(x: float):\n        return sin(x) # linter now thinks this is a function\n\n    sin(1.0) # this will raise a NotImplementedError(\"Binding of sin can only be called from a kernel\")\n    ```\n    \"\"\"\n\n    def wrapper(func: Callable[Params, RetType]) -&gt; Binding[Params, RetType]:\n        return Binding(parent)\n\n    return wrapper\n</code></pre>"},{"location":"reference/kirin/lowering/core/","title":"Core","text":""},{"location":"reference/kirin/lowering/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.FromPythonAST","title":"FromPythonAST","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.FromPythonAST.lower","title":"lower","text":"<pre><code>lower(state: LoweringState, node: ast.AST) -&gt; Result\n</code></pre> <p>Entry point of dialect specific lowering.</p> Source code in <code>src/kirin/lowering/dialect.py</code> <pre><code>def lower(self, state: LoweringState, node: ast.AST) -&gt; Result:\n    \"\"\"Entry point of dialect specific lowering.\"\"\"\n    return getattr(self, f\"lower_{node.__class__.__name__}\", self.unreachable)(\n        state, node\n    )\n</code></pre>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.Method","title":"Method  <code>dataclass</code>","text":"<pre><code>Method(\n    mod: ModuleType | None,\n    py_func: Callable[Param, RetType] | None,\n    sym_name: str,\n    arg_names: list[str],\n    dialects: DialectGroup,\n    code: Statement,\n    fields: tuple = tuple(),\n    file: str = \"\",\n    inferred: bool = False,\n    verified: bool = False,\n)\n</code></pre> <p>               Bases: <code>Printable</code>, <code>Generic[Param, RetType]</code></p>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.Method.inferred","title":"inferred  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inferred: bool = False\n</code></pre> <p>if typeinfer has been run on this method</p>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.Method.verified","title":"verified  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>verified: bool = False\n</code></pre> <p>if <code>code.verify</code> has been run on this method</p>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.Method.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>verify the method body.</p> Source code in <code>src/kirin/ir/method.py</code> <pre><code>def verify(self) -&gt; None:\n    \"\"\"verify the method body.\"\"\"\n    try:\n        self.code.verify()\n    except VerificationError as e:\n        msg = f'File \"{self.file}\"'\n        if isinstance(e.node, Statement):\n            if e.node.source:\n                msg += f\", line {e.node.source.lineno}\"\n            msg += f\", in {e.node.name}\"\n\n        msg += f\":\\n    Verification failed for {self.sym_name}: {e.args[0]}\"\n        raise Exception(msg) from e\n    self.verified = True\n    return\n</code></pre>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.SSAValue","title":"SSAValue  <code>dataclass</code>","text":"<pre><code>SSAValue()\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Printable</code></p> <p>Base class for all SSA values in the IR.</p>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.SSAValue.name","title":"name  <code>property</code> <code>writable</code>","text":"<pre><code>name: str | None\n</code></pre> <p>The name of this SSA value.</p>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.SSAValue.name_pattern","title":"name_pattern  <code>class-attribute</code>","text":"<pre><code>name_pattern: Pattern[str] = compile(\n    \"([A-Za-z_$.-][\\\\w$.-]*)\"\n)\n</code></pre> <p>The pattern that the name of this SSA value must match.</p>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.SSAValue.owner","title":"owner  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>owner: Statement | Block\n</code></pre> <p>The object that owns this SSA value.</p>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.SSAValue.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type: TypeAttribute = field(\n    default_factory=AnyType, init=False, repr=True\n)\n</code></pre> <p>The type of this SSA value.</p>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.SSAValue.uses","title":"uses  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>uses: set[Use] = field(\n    init=False, default_factory=set, repr=False\n)\n</code></pre> <p>The uses of this SSA value.</p>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.SSAValue.add_use","title":"add_use","text":"<pre><code>add_use(use: Use) -&gt; Self\n</code></pre> <p>Add a use to this SSA value.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def add_use(self, use: Use) -&gt; Self:\n    \"\"\"Add a use to this SSA value.\"\"\"\n    self.uses.add(use)\n    return self\n</code></pre>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.SSAValue.delete","title":"delete","text":"<pre><code>delete(safe: bool = True) -&gt; None\n</code></pre> <p>Delete this SSA value. If <code>safe</code> is <code>True</code>, raise an error if there are uses.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def delete(self, safe: bool = True) -&gt; None:\n    \"\"\"Delete this SSA value. If `safe` is `True`, raise an error if there are uses.\"\"\"\n    if safe and len(self.uses) &gt; 0:\n        raise ValueError(\"Cannot delete SSA value with uses\")\n    self.replace_by(DeletedSSAValue(self))\n</code></pre>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.SSAValue.remove_use","title":"remove_use","text":"<pre><code>remove_use(use: Use) -&gt; Self\n</code></pre> <p>Remove a use from this SSA value.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def remove_use(self, use: Use) -&gt; Self:\n    \"\"\"Remove a use from this SSA value.\"\"\"\n    # print(use)\n    # assert use in self.uses, \"Use not found\"\n    if use in self.uses:\n        self.uses.remove(use)\n    return self\n</code></pre>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.SSAValue.replace_by","title":"replace_by","text":"<pre><code>replace_by(other: SSAValue) -&gt; None\n</code></pre> <p>Replace this SSA value with another SSA value. Update all uses.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def replace_by(self, other: SSAValue) -&gt; None:\n    \"\"\"Replace this SSA value with another SSA value. Update all uses.\"\"\"\n    for use in self.uses.copy():\n        use.stmt.args[use.index] = other\n\n    if other.name is None and self.name is not None:\n        other.name = self.name\n\n    assert len(self.uses) == 0, \"Uses not empty\"\n</code></pre>"},{"location":"reference/kirin/lowering/frame/","title":"Frame","text":""},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame","title":"Frame  <code>dataclass</code>","text":"<pre><code>Frame(\n    state: LoweringState,\n    parent: Optional[Frame],\n    stream: StmtStream[ast.stmt],\n    current_region: Region,\n    entry_block: Block,\n    current_block: Block,\n    next_block: Block | None = None,\n    defs: dict[str, SSAValue | set[SSAValue]] = dict(),\n    globals: dict[str, Any] = dict(),\n    captures: dict[str, SSAValue] = dict(),\n    capture_callback: Optional[CallbackFn] = None,\n)\n</code></pre>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.capture_callback","title":"capture_callback  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>capture_callback: Optional[CallbackFn] = None\n</code></pre> <p>callback function that creates a local SSAValue value when an captured value was used.</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.captures","title":"captures  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>captures: dict[str, SSAValue] = field(default_factory=dict)\n</code></pre> <p>values accessed from the parent frame</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.current_block","title":"current_block  <code>instance-attribute</code>","text":"<pre><code>current_block: Block\n</code></pre> <p>current block being lowered</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.current_region","title":"current_region  <code>instance-attribute</code>","text":"<pre><code>current_region: Region\n</code></pre> <p>current region being lowered</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.defs","title":"defs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>defs: dict[str, SSAValue | set[SSAValue]] = field(\n    default_factory=dict\n)\n</code></pre> <p>values defined in the current frame</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.entry_block","title":"entry_block  <code>instance-attribute</code>","text":"<pre><code>entry_block: Block\n</code></pre> <p>entry block of the frame</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.globals","title":"globals  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>globals: dict[str, Any] = field(default_factory=dict)\n</code></pre> <p>global values known to the current frame</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.next_block","title":"next_block  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_block: Block | None = None\n</code></pre> <p>next block, if any</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.from_stmts","title":"from_stmts  <code>classmethod</code>","text":"<pre><code>from_stmts(\n    stmts: Sequence[ast.stmt] | StmtStream[ast.stmt],\n    state: LoweringState,\n    parent: Optional[Frame] = None,\n    region: Optional[Region] = None,\n    block: Optional[Block] = None,\n    globals: dict[str, Any] | None = None,\n    capture_callback: Optional[CallbackFn] = None,\n)\n</code></pre> <p>Create a new frame from a list of statements or a new <code>StmtStream</code>.</p> <ul> <li><code>stmts</code>: list of statements or a <code>StmtStream</code> to be lowered.</li> <li><code>region</code>: <code>Region</code> to append the new block to, <code>None</code> to create a new one, default <code>None</code>.</li> <li><code>block</code>: <code>Block</code> to append the new statements to, <code>None</code> to create a new one, default <code>None</code>.</li> <li><code>globals</code>: global variables, default <code>None</code>.</li> </ul> Source code in <code>src/kirin/lowering/frame.py</code> <pre><code>@classmethod\ndef from_stmts(\n    cls,\n    stmts: Sequence[ast.stmt] | StmtStream[ast.stmt],\n    state: \"LoweringState\",\n    parent: Optional[\"Frame\"] = None,\n    region: Optional[Region] = None,\n    block: Optional[Block] = None,\n    globals: dict[str, Any] | None = None,\n    capture_callback: Optional[CallbackFn] = None,\n):\n    \"\"\"Create a new frame from a list of statements or a new `StmtStream`.\n\n    - `stmts`: list of statements or a `StmtStream` to be lowered.\n    - `region`: `Region` to append the new block to, `None` to create a new one, default `None`.\n    - `block`: `Block` to append the new statements to, `None` to create a new one, default `None`.\n    - `globals`: global variables, default `None`.\n    \"\"\"\n    if not isinstance(stmts, StmtStream):\n        stmts = StmtStream(stmts)\n\n    block = block or Block()\n    if region:\n        region.blocks.append(block)\n\n    return cls(\n        state=state,\n        parent=parent,\n        stream=stmts,\n        current_region=region or Region(block),\n        entry_block=block,\n        current_block=block,\n        globals=globals or {},\n        capture_callback=capture_callback,\n    )\n</code></pre>"},{"location":"reference/kirin/lowering/result/","title":"Result","text":""},{"location":"reference/kirin/lowering/state/","title":"State","text":""},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.LoweringState","title":"LoweringState  <code>dataclass</code>","text":"<pre><code>LoweringState(\n    dialects: DialectGroup,\n    registry: dict[str, FromPythonAST],\n    lines: list[str],\n    lineno_offset: int,\n    col_offset: int,\n    source: SourceInfo,\n    max_lines: int = 3,\n    _current_frame: Frame | None = None,\n)\n</code></pre> <p>               Bases: <code>NodeVisitor</code></p>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.LoweringState.col_offset","title":"col_offset  <code>instance-attribute</code>","text":"<pre><code>col_offset: int\n</code></pre> <p>column offset at the beginning of the source</p>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.LoweringState.lineno_offset","title":"lineno_offset  <code>instance-attribute</code>","text":"<pre><code>lineno_offset: int\n</code></pre> <p>lineno offset at the beginning of the source</p>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.LoweringState.source","title":"source  <code>instance-attribute</code>","text":"<pre><code>source: SourceInfo\n</code></pre> <p>source info of the current node</p>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.LoweringState.append_stmt","title":"append_stmt","text":"<pre><code>append_stmt(stmt: StmtType) -&gt; StmtType\n</code></pre> <p>Shorthand for appending a statement to the current block of current frame.</p> Source code in <code>src/kirin/lowering/state.py</code> <pre><code>def append_stmt(self, stmt: StmtType) -&gt; StmtType:\n    \"\"\"Shorthand for appending a statement to the current block of current frame.\"\"\"\n    return self.current_frame.append_stmt(stmt)\n</code></pre>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.LoweringState.default_Call_lower","title":"default_Call_lower","text":"<pre><code>default_Call_lower(\n    stmt: type[Statement], node: ast.Call\n) -&gt; Result\n</code></pre> <p>Default lowering for Python call to statement.</p> <p>This method is intended to be used by traits like <code>FromPythonCall</code> to provide a default lowering for Python calls to statements.</p> <p>Parameters:</p> Name Type Description Default <code>stmt(type[Statement])</code> <p>Statement class to construct.</p> required <code>node(ast.Call)</code> <p>Python call node to lower.</p> required <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>Result of lowering the Python call to statement.</p> Source code in <code>src/kirin/lowering/state.py</code> <pre><code>def default_Call_lower(self, stmt: type[Statement], node: ast.Call) -&gt; Result:\n    \"\"\"Default lowering for Python call to statement.\n\n    This method is intended to be used by traits like `FromPythonCall` to\n    provide a default lowering for Python calls to statements.\n\n    Args:\n        stmt(type[Statement]): Statement class to construct.\n        node(ast.Call): Python call node to lower.\n\n    Returns:\n        Result: Result of lowering the Python call to statement.\n    \"\"\"\n    args, kwargs = self.default_Call_inputs(stmt, node)\n    return Result(self.append_stmt(stmt(*args.values(), **kwargs)))\n</code></pre>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.LoweringState.exhaust","title":"exhaust","text":"<pre><code>exhaust(frame: Frame | None = None) -&gt; Frame\n</code></pre> <p>Exhaust given frame's stream. If not given, exhaust current frame's stream.</p> Source code in <code>src/kirin/lowering/state.py</code> <pre><code>def exhaust(self, frame: Frame | None = None) -&gt; Frame:\n    \"\"\"Exhaust given frame's stream. If not given, exhaust current frame's stream.\"\"\"\n    if not frame:\n        current_frame = self.current_frame\n    else:\n        current_frame = frame\n\n    stream = current_frame.stream\n    while stream.has_next():\n        stmt = stream.pop()\n        self.visit(stmt)\n    return current_frame\n</code></pre>"},{"location":"reference/kirin/lowering/stream/","title":"Stream","text":""},{"location":"reference/kirin/passes/","title":"Index","text":""},{"location":"reference/kirin/passes/abc/","title":"Abc","text":""},{"location":"reference/kirin/passes/abc/#kirin.passes.abc.Pass","title":"Pass  <code>dataclass</code>","text":"<pre><code>Pass(dialects: DialectGroup)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>A pass is a transformation that is applied to a method. It wraps the analysis and rewrites needed to transform the method as an independent unit.</p> <p>Unlike LLVM/MLIR passes, a pass in Kirin does not apply to a module, this is because we focus on individual methods defined within python modules. This is a design choice to allow seamless integration within the Python interpreter.</p> <p>A Kirin compile unit is a <code>ir.Method</code> object, which is always equivalent to a LLVM/MLIR module if it were lowered to LLVM/MLIR just like other JIT compilers.</p>"},{"location":"reference/kirin/passes/fold/","title":"Fold","text":""},{"location":"reference/kirin/passes/inline/","title":"Inline","text":""},{"location":"reference/kirin/passes/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/passes/aggressive/","title":"Index","text":""},{"location":"reference/kirin/passes/aggressive/fold/","title":"Fold","text":""},{"location":"reference/kirin/print/","title":"Index","text":""},{"location":"reference/kirin/print/printable/","title":"Printable","text":""},{"location":"reference/kirin/print/printable/#kirin.print.printable.Printable","title":"Printable","text":""},{"location":"reference/kirin/print/printable/#kirin.print.printable.Printable.print","title":"print","text":"<pre><code>print(\n    printer: Printer | None = None,\n    analysis: dict[ir.SSAValue, Any] | None = None,\n    end: str = \"\\n\",\n) -&gt; None\n</code></pre> <p>Entry point of the printing process.</p> <p>Parameters:</p> Name Type Description Default <code>printer</code> <code>Printer</code> <p><code>Printer</code> object to use for printing. If None, a new <code>Printer</code> object will be created.</p> <code>None</code> <code>analysis</code> <code>dict[SSAValue, Printable]</code> <p>Analysis results to use for printing. If <code>None</code>, no analysis results</p> <code>None</code> Source code in <code>src/kirin/print/printable.py</code> <pre><code>def print(\n    self,\n    printer: Printer | None = None,\n    analysis: dict[ir.SSAValue, Any] | None = None,\n    end: str = \"\\n\",\n) -&gt; None:\n    \"\"\"\n    Entry point of the printing process.\n\n    Args:\n        printer (Printer):\n            `Printer` object to use for printing.\n            If None, a new `Printer` object will be created.\n        analysis (dict[ir.SSAValue, Printable]):\n            Analysis results to use for printing. If `None`, no analysis results\n    \"\"\"\n    printer = self.__get_printer(printer, analysis)\n    self.print_impl(printer)\n    printer.plain_print(end)\n</code></pre>"},{"location":"reference/kirin/print/printer/","title":"Printer","text":""},{"location":"reference/kirin/print/printer/#kirin.print.printer.PrintState","title":"PrintState  <code>dataclass</code>","text":"<pre><code>PrintState(\n    ssa_id: IdTable[ir.SSAValue] = IdTable[\"ir.SSAValue\"](),\n    block_id: IdTable[ir.Block] = lambda: IdTable[\n        \"ir.Block\"\n    ](prefix=\"^\")(),\n    indent: int = 0,\n    result_width: int = 0,\n    indent_marks: list[int] = list(),\n    rich_style: str | None = None,\n    rich_highlight: bool | None = False,\n    messages: list[str] = list(),\n)\n</code></pre>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.PrintState.result_width","title":"result_width  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result_width: int = 0\n</code></pre> <p>SSA-value column width in printing</p>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer","title":"Printer  <code>dataclass</code>","text":"<pre><code>Printer(\n    stream: IOType | None = None,\n    analysis: dict[ir.SSAValue, Printable] | None = None,\n    show_indent_mark: bool = True,\n)\n</code></pre> <p>               Bases: <code>Generic[IOType]</code></p> Source code in <code>src/kirin/print/printer.py</code> <pre><code>def __init__(\n    self,\n    stream: IOType | None = None,\n    analysis: dict[\"ir.SSAValue\", Printable] | None = None,\n    show_indent_mark: bool = True,\n):\n    self.stream = stream\n    self.analysis = analysis\n    self.console = Console(file=self.stream, highlight=False)\n    self.state = PrintState()\n    self.color = ColorScheme()\n    self.show_indent_mark = show_indent_mark\n</code></pre>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.show_indent_mark","title":"show_indent_mark  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>show_indent_mark: bool = show_indent_mark\n</code></pre> <p>Whether to show indent marks, e.g \u2502</p>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.print","title":"print","text":"<pre><code>print(object)\n</code></pre> <p>entry point for printing an object</p> Source code in <code>src/kirin/print/printer.py</code> <pre><code>def print(self, object):\n    \"\"\"entry point for printing an object\"\"\"\n    if isinstance(object, Printable):\n        object.print_impl(self)\n    else:\n        fn = getattr(self, f\"print_{object.__class__.__name__}\", None)\n        if fn is None:\n            raise NotImplementedError(\n                f\"Printer for {object.__class__.__name__} not found\"\n            )\n        fn(object)\n</code></pre>"},{"location":"reference/kirin/rewrite/","title":"Index","text":""},{"location":"reference/kirin/rewrite/abc/","title":"Abc","text":""},{"location":"reference/kirin/rewrite/abc/#kirin.rewrite.abc.RewriteRule","title":"RewriteRule  <code>dataclass</code>","text":"<pre><code>RewriteRule()\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>A rewrite rule that matches and rewrites IR nodes.</p> <p>The rewrite rule is applied to an IR node by calling the instance with the node as an argument. The rewrite rule should mutate the node instead of returning a new node. A <code>RewriteResult</code> should be returned to indicate whether the rewrite rule has done something, whether the rewrite rule should terminate, and whether the rewrite rule has exceeded the maximum number of iterations.</p>"},{"location":"reference/kirin/rewrite/alias/","title":"Alias","text":""},{"location":"reference/kirin/rewrite/apply_type/","title":"Apply type","text":""},{"location":"reference/kirin/rewrite/call2invoke/","title":"Call2invoke","text":""},{"location":"reference/kirin/rewrite/call2invoke/#kirin.rewrite.call2invoke.Call2Invoke","title":"Call2Invoke  <code>dataclass</code>","text":"<pre><code>Call2Invoke(results: dict[ir.SSAValue, const.JointResult])\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <p>Rewrite a <code>Call</code> statement to an <code>Invoke</code> statement.</p>"},{"location":"reference/kirin/rewrite/cfg_compactify/","title":"Cfg compactify","text":""},{"location":"reference/kirin/rewrite/chain/","title":"Chain","text":""},{"location":"reference/kirin/rewrite/chain/#kirin.rewrite.chain.Chain","title":"Chain  <code>dataclass</code>","text":"<pre><code>Chain(\n    rule: RewriteRule | Iterable[RewriteRule],\n    *others: RewriteRule\n)\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <p>Chain multiple rewrites together.</p> <p>The chain will apply each rewrite in order until one of the rewrites terminates.</p> Source code in <code>src/kirin/rewrite/chain.py</code> <pre><code>def __init__(self, rule: RewriteRule | Iterable[RewriteRule], *others: RewriteRule):\n    if isinstance(rule, RewriteRule):\n        self.rules = [rule, *others]\n    else:\n        assert (\n            others == ()\n        ), \"Cannot pass multiple positional arguments if the first argument is an iterable\"\n        self.rules = list(rule)\n</code></pre>"},{"location":"reference/kirin/rewrite/cse/","title":"Cse","text":""},{"location":"reference/kirin/rewrite/dce/","title":"Dce","text":""},{"location":"reference/kirin/rewrite/fixpoint/","title":"Fixpoint","text":""},{"location":"reference/kirin/rewrite/fixpoint/#kirin.rewrite.fixpoint.Fixpoint","title":"Fixpoint  <code>dataclass</code>","text":"<pre><code>Fixpoint(rule: RewriteRule, max_iter: int = 32)\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <p>Apply a rewrite rule until a fixpoint is reached.</p> <p>The rewrite rule is applied to the node until the rewrite rule does not do anything.</p>"},{"location":"reference/kirin/rewrite/fixpoint/#kirin.rewrite.fixpoint.Fixpoint--parameters","title":"Parameters","text":"<ul> <li><code>map</code>: The rewrite rule to apply.</li> <li><code>max_iter</code>: The maximum number of iterations to apply the rewrite rule. Default is 32.</li> </ul>"},{"location":"reference/kirin/rewrite/fold/","title":"Fold","text":""},{"location":"reference/kirin/rewrite/getfield/","title":"Getfield","text":""},{"location":"reference/kirin/rewrite/getitem/","title":"Getitem","text":""},{"location":"reference/kirin/rewrite/inline/","title":"Inline","text":""},{"location":"reference/kirin/rewrite/inline/#kirin.rewrite.inline.Inline","title":"Inline  <code>dataclass</code>","text":"<pre><code>Inline(heuristic: Callable[[ir.IRNode], bool])\n</code></pre> <p>               Bases: <code>RewriteRule</code></p>"},{"location":"reference/kirin/rewrite/inline/#kirin.rewrite.inline.Inline.heuristic","title":"heuristic  <code>instance-attribute</code>","text":"<pre><code>heuristic: Callable[[IRNode], bool]\n</code></pre> <p>inline heuristic that determines whether a function should be inlined</p>"},{"location":"reference/kirin/rewrite/inline/#kirin.rewrite.inline.Inline.inline_call_like","title":"inline_call_like","text":"<pre><code>inline_call_like(\n    call_like: ir.Statement,\n    args: tuple[ir.SSAValue, ...],\n    region: ir.Region,\n)\n</code></pre> <p>Inline a function call-like statement</p> <p>Parameters:</p> Name Type Description Default <code>call_like</code> <code>Statement</code> <p>the call-like statement</p> required <code>args</code> <code>tuple[SSAValue, ...]</code> <p>the arguments of the call (first one is the callee)</p> required <code>region</code> <code>Region</code> <p>the region of the callee</p> required Source code in <code>src/kirin/rewrite/inline.py</code> <pre><code>def inline_call_like(\n    self,\n    call_like: ir.Statement,\n    args: tuple[ir.SSAValue, ...],\n    region: ir.Region,\n):\n    \"\"\"\n    Inline a function call-like statement\n\n    Args:\n        call_like (ir.Statement): the call-like statement\n        args (tuple[ir.SSAValue, ...]): the arguments of the call (first one is the callee)\n        region (ir.Region): the region of the callee\n    \"\"\"\n    # &lt;stmt&gt;\n    # &lt;stmt&gt;\n    # &lt;br (a, b, c)&gt;\n\n    # &lt;block (a, b,c)&gt;:\n    # &lt;block&gt;:\n    # &lt;block&gt;:\n    # &lt;br&gt;\n\n    # ^&lt;block&gt;:\n    # &lt;stmt&gt;\n    # &lt;stmt&gt;\n\n    # 1. we insert the entry block of the callee function\n    # 2. we insert the rest of the blocks into the parent region\n    # 3.1 if the return is in the entry block, means no control flow,\n    #     replace the call results with the return values\n    # 3.2 if the return is some of the blocks, means control flow,\n    #     split the current block into two, and replace the return with\n    #     the branch instruction\n    # 4. remove the call\n    if not call_like.parent_block:\n        return\n\n    if not call_like.parent_region:\n        return\n\n    # NOTE: we cannot change region because it may be used elsewhere\n    inline_region: ir.Region = region.clone()\n    parent_block: ir.Block = call_like.parent_block\n    parent_region: ir.Region = call_like.parent_region\n\n    # wrap what's after invoke into a block\n    after_block = ir.Block()\n    stmt = call_like.next_stmt\n    while stmt is not None:\n        stmt.detach()\n        after_block.stmts.append(stmt)\n        stmt = call_like.next_stmt\n\n    for result in call_like.results:\n        block_arg = after_block.args.append_from(result.type, result.name)\n        result.replace_by(block_arg)\n\n    parent_block_idx = parent_region._block_idx[parent_block]\n    entry_block = inline_region.blocks.popfirst()\n    idx, block = 0, entry_block\n    while block is not None:\n        idx += 1\n\n        if block.last_stmt and isinstance(block.last_stmt, func.Return):\n            block.last_stmt.replace_by(\n                cf.Branch(\n                    arguments=(block.last_stmt.value,),\n                    successor=after_block,\n                )\n            )\n\n        parent_region.blocks.insert(parent_block_idx + idx, block)\n        block = inline_region.blocks.popfirst()\n\n    parent_region.blocks.append(after_block)\n\n    # NOTE: we expect always to have an entry block\n    # but we still check for it cuz we are not gonna\n    # error for empty regions here.\n    if entry_block:\n        cf.Branch(\n            arguments=args,\n            successor=entry_block,\n        ).insert_before(call_like)\n    call_like.delete()\n    return\n</code></pre>"},{"location":"reference/kirin/rewrite/result/","title":"Result","text":""},{"location":"reference/kirin/rewrite/walk/","title":"Walk","text":""},{"location":"reference/kirin/rewrite/walk/#kirin.rewrite.walk.Walk","title":"Walk  <code>dataclass</code>","text":"<pre><code>Walk(\n    rule: RewriteRule,\n    worklist: WorkList[IRNode] = WorkList(),\n    reverse: bool = False,\n    region_first: bool = False,\n)\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <p>Walk through the IR nodes and apply a rewrite rule.</p> <p>The walk will apply the rewrite rule to each node in the IR tree in a depth-first order.</p>"},{"location":"reference/kirin/rewrite/walk/#kirin.rewrite.walk.Walk--parameters","title":"Parameters","text":"<ul> <li><code>map</code>: The rewrite rule to apply.</li> <li><code>reverse</code>: Whether to traverse the IR tree in reverse order. Default is <code>False</code>.</li> <li><code>region_first</code>: Whether to traverse the regions before the blocks. Default is <code>False</code>.</li> </ul>"},{"location":"reference/kirin/rewrite/wrap_const/","title":"Wrap const","text":""},{"location":"reference/kirin/rewrite/aggressive/","title":"Index","text":""},{"location":"reference/kirin/rewrite/aggressive/fold/","title":"Fold","text":""},{"location":"blog/archive/2024/","title":"2024","text":""}]}