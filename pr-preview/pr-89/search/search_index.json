{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\: )\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Kirin","text":"<p>Kirin is the Kernel Intermediate Representation Infrastructure. It is a compiler infrastructure for building compilers for domain-specific languages (DSLs) that target scientific computing kernels.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>MLIR-like dialects as composable python packages</li> <li>Generated Python frontend for your DSLs</li> <li>Pythonic API for building compiler passes</li> <li>Julia-like abstract interpretation framework</li> <li>Builtin support for interpretation</li> <li>Builtin support Python type system and type inference</li> <li>Type hinted via modern Python type hints</li> </ul>"},{"location":"#kirins-mission","title":"Kirin's mission","text":"<p>Compiler toolchain for scientists. Scientists are building domain-specific languages (DSLs) for scientific purposes. These DSLs are often high-level, and their instructions are usually slower than the low-level instructions and thus result in smaller programs. The performance does not need to be as good as a native program, but scientists want good interactivity and fast prototyping. Most importantly, scientists usually just want to write Python as their frontend.</p>"},{"location":"#quick-example-the-beer-language","title":"Quick Example: the <code>beer</code> language","text":"<p>In this example, we will mutate python's semantics to support a small eDSL (embedded domain-specific language) called <code>beer</code>. It describes the process of brewing beer and get drunk.</p> <p>First, let's define the dialect object, which is a registry for all the objects modeling the semantics.</p> <pre><code>from kirin import ir\n\ndialect = ir.Dialect(\"beer\")\n</code></pre> <p>Next, we want to define a runtime value <code>Beer</code> for the <code>beer</code> language so that we may use later in our interpreter.</p> <pre><code>from dataclasses import dataclass\n\n@dataclass\nclass Beer:\n    brand: str\n</code></pre> <p>Now, we can define the <code>beer</code> language's statements.</p> <pre><code>from kirin.decl import statement, info\nfrom kirin.dialects.py import types\n\n@statement(dialect=dialect)\nclass NewBeer(Statement):\n    name = \"new_beer\"\n    traits = frozenset({ir.Pure()})\n    brand: ir.SSAValue = info.argument(types.String)\n    result: ir.ResultValue = info.result(types.PyClass(Beer))\n</code></pre> <p>the <code>NewBeer</code> statement creates a new beer object with a given brand. Thus it takes a string as an argument and returns a <code>Beer</code> object. The <code>name</code> field specifies the name of the statement in the IR text format (e.g printing). The <code>traits</code> field specifies the statement's traits, in this case, it is a pure function because each brand name uniquely identifies a beer object.</p> <pre><code>@statement(dialect=dialect)\nclass Drink(Statement):\n    name = \"drink\"\n    beverage: SSAValue = info.argument(types.PyClass(Beer))\n\n\n@statement(dialect=dialect)\nclass Pour(Statement):\n    name = \"pour\"\n    beverage: SSAValue = info.argument(types.PyClass(Beer))\n    amount: SSAValue = info.argument(types.Int)\n\n\n@statement(dialect=dialect)\nclass RandomBranch(Statement):\n    name = \"random_br\"\n    traits = frozenset({IsTerminator()})\n    cond: SSAValue = info.argument(types.Bool)\n    then_arguments: tuple[SSAValue, ...] = info.argument()\n    else_arguments: tuple[SSAValue, ...] = info.argument()\n    then_successor: Block = info.block()\n    else_successor: Block = info.block()\n\n\n@statement(dialect=dialect)\nclass Puke(Statement):\n    name = \"puke\"\n</code></pre>"},{"location":"101/","title":"Compiler 101 for scientists","text":""},{"location":"101/#what-is-purity","title":"What is purity?","text":""},{"location":"def/","title":"Understanding Kirin IR Declarations","text":""},{"location":"def/#dialects","title":"Dialects","text":""},{"location":"def/#statements","title":"Statements","text":""},{"location":"def/#attributes","title":"Attributes","text":""},{"location":"def/#traits","title":"Traits","text":""},{"location":"def/#blocks","title":"Blocks","text":""},{"location":"def/#regions","title":"Regions","text":""},{"location":"install/","title":"Installation","text":"<p>Kirin is available in PyPI and thus can be installed via <code>pip</code>. Install Kirin using the following command:</p> <pre><code>pip install kirin-toolchain\n</code></pre> <p>Kirin supports Python 3.9 or later. We recommend using Python 3.10+ for the best experience.</p> <p>We strongly recommend developing your compiler project using <code>uv</code>, which is the official development environment for Kirin. You can install <code>uv</code> using the following command:</p> Linux and macOSWindows <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <p>then</p> <pre><code>uv add kirin-toolchain\n</code></pre> <pre><code>powershell -ExecutionPolicy ByPass -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n</code></pre> <p>then</p> <pre><code>uv add kirin-toolchain\n</code></pre>"},{"location":"install/#kirin-and-its-friends","title":"Kirin and its friends","text":"<p>Kirin also comes with a few friends that you might find useful:</p> <ul> <li><code>kirin-qasm</code>: (coming soon) A quantum assembly language (QASM 2.0) dialect for Kirin with a builtin QASM 2.0 text format parser.</li> <li><code>bloqade</code>: (available soon) QuEra's SDK for next-gen error-corrected neutral-atom quantum computers.</li> </ul>"},{"location":"install/#development","title":"Development","text":"<p>If you want to contribute to Kirin, you can clone the repository from GitHub:</p> <pre><code>git clone https://github.com/QuEraComputing/kirin.git\n</code></pre> <p>We use <code>uv</code> to manage the development environment, after you install <code>uv</code>, you can install the development dependencies using the following command:</p> <pre><code>uv sync\n</code></pre> <p>Our code review requires that you pass the tests and the linting checks. We recommend you to install <code>pre-commit</code> to run the checks before you commit your changes, the command line tool <code>pre-commit</code> has been installed as part of the development dependencies. You can setup <code>pre-commit</code> using the following command:</p> <pre><code>pre-commit install\n</code></pre>"},{"location":"install/#requirements","title":"Requirements","text":"<p>Kirin requires the following dependencies:</p> <ul> <li><code>rich</code>: for pretty-printing</li> <li><code>type-extensions</code>: for type hints</li> <li><code>beartype</code>: for runtime type checking and analysis of type hints in the python dialect</li> </ul>"},{"location":"reference/kirin/","title":"Index","text":""},{"location":"reference/kirin/exceptions/","title":"Exceptions","text":""},{"location":"reference/kirin/graph/","title":"Graph","text":""},{"location":"reference/kirin/graph/#kirin.graph.Graph","title":"Graph","text":"<p>               Bases: <code>Protocol</code>, <code>Generic[Node]</code></p> <p>The graph interface.</p> <p>This interface defines the methods that a graph object must implement. The graph interface is mainly for compatibility reasons so that one can use multiple graph implementations interchangeably.</p>"},{"location":"reference/kirin/graph/#kirin.graph.Graph.get_edges","title":"get_edges","text":"<pre><code>get_edges()\n</code></pre> <p>Get all the edges in the graph.</p> Source code in <code>src/kirin/graph.py</code> <pre><code>def get_edges(self) -&gt; Iterable[tuple[Node, Node]]:\n    \"\"\"Get all the edges in the graph.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/graph/#kirin.graph.Graph.get_neighbors","title":"get_neighbors","text":"<pre><code>get_neighbors(node)\n</code></pre> <p>Get the neighbors of a node.</p> Source code in <code>src/kirin/graph.py</code> <pre><code>def get_neighbors(self, node: Node) -&gt; Iterable[Node]:\n    \"\"\"Get the neighbors of a node.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/graph/#kirin.graph.Graph.get_nodes","title":"get_nodes","text":"<pre><code>get_nodes()\n</code></pre> <p>Get all the nodes in the graph.</p> Source code in <code>src/kirin/graph.py</code> <pre><code>def get_nodes(self) -&gt; Iterable[Node]:\n    \"\"\"Get all the nodes in the graph.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/idtable/","title":"IdTable","text":""},{"location":"reference/kirin/idtable/#kirin.idtable.IdTable","title":"IdTable  <code>dataclass</code>","text":"<pre><code>IdTable(\n    prefix=\"%\", table=dict(), name_count=dict(), next_id=0\n)\n</code></pre> <p>               Bases: <code>Generic[T]</code></p> <p>A table that maps values to \"human readable\" unique names. This is used for IR printing and code generation of SSA values and basic blocks, or anything else required to have a unique name.</p>"},{"location":"reference/kirin/idtable/#kirin.idtable.IdTable--example","title":"Example","text":"<pre><code>from kirin import ir\nfrom kirin.idtable import IdTable\ntable = IdTable()\nx = ir.TestValue()\ntable[x] # \"%0\"\ntable[x] # \"%0\"\ny = ir.TestValue()\ntable[y] # \"%1\"\n</code></pre>"},{"location":"reference/kirin/idtable/#kirin.idtable.IdTable.name_count","title":"name_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name_count = field(default_factory=dict)\n</code></pre> <p>The count of names that have been generated.</p>"},{"location":"reference/kirin/idtable/#kirin.idtable.IdTable.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id = 0\n</code></pre> <p>The next ID to use for generating names.</p>"},{"location":"reference/kirin/idtable/#kirin.idtable.IdTable.prefix","title":"prefix  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>prefix = '%'\n</code></pre> <p>The prefix to use for generated names.</p>"},{"location":"reference/kirin/idtable/#kirin.idtable.IdTable.table","title":"table  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>table = field(default_factory=dict)\n</code></pre> <p>The table that maps values to names.</p>"},{"location":"reference/kirin/idtable/#kirin.idtable.IdTable.add","title":"add","text":"<pre><code>add(value)\n</code></pre> <p>Add a value to the table and return the name.</p> Source code in <code>src/kirin/idtable.py</code> <pre><code>def add(self, value: T) -&gt; str:\n    \"\"\"Add a value to the table and return the name.\"\"\"\n    id = self.next_id\n    if (value_name := getattr(value, \"name\", None)) is not None:\n        curr_ind = self.name_count.get(value_name, 0)\n        suffix = f\"_{curr_ind}\" if curr_ind != 0 else \"\"\n        self.name_count[value_name] = curr_ind + 1\n        name = self.prefix + value_name + suffix\n        self.table[value] = name\n    else:\n        name = f\"{self.prefix}{id}\"\n        self.next_id += 1\n        self.table[value] = name\n    return name\n</code></pre>"},{"location":"reference/kirin/lattice/","title":"Lattice","text":""},{"location":"reference/kirin/lattice/#kirin.lattice.EmptyLattice","title":"EmptyLattice","text":"<p>               Bases: <code>Lattice['EmptyLattice']</code></p> <p>Empty lattice.</p>"},{"location":"reference/kirin/lattice/#kirin.lattice.Lattice","title":"Lattice","text":"<p>               Bases: <code>ABC</code>, <code>Generic[LatticeParent]</code></p> <p>Abstract base class for lattices.</p>"},{"location":"reference/kirin/lattice/#kirin.lattice.LatticeMeta","title":"LatticeMeta","text":"<p>               Bases: <code>ABCMeta</code></p> <p>Metaclass for lattices.</p>"},{"location":"reference/kirin/lattice/#kirin.lattice.SingletonMeta","title":"SingletonMeta","text":"<pre><code>SingletonMeta(name, bases, attrs)\n</code></pre> <p>               Bases: <code>LatticeMeta</code></p> <p>Singleton metaclass for lattices. It ensures that only one instance of a lattice is created.</p> <p>See https://stackoverflow.com/questions/674304/why-is-init-always-called-after-new/8665179#8665179</p> Source code in <code>src/kirin/lattice.py</code> <pre><code>def __init__(cls, name, bases, attrs):\n    super().__init__(name, bases, attrs)\n    cls._instance = None\n</code></pre>"},{"location":"reference/kirin/lattice/#kirin.lattice.UnionMeta","title":"UnionMeta","text":"<p>               Bases: <code>LatticeMeta</code></p> <p>Meta class for union types. It simplifies the union if possible.</p>"},{"location":"reference/kirin/prelude/","title":"Prelude","text":""},{"location":"reference/kirin/source/","title":"Source","text":""},{"location":"reference/kirin/worklist/","title":"WorkList","text":""},{"location":"reference/kirin/worklist/#kirin.worklist.WorkList","title":"WorkList  <code>dataclass</code>","text":"<pre><code>WorkList()\n</code></pre> <p>               Bases: <code>Generic[ElemType]</code></p> <p>The worklist data structure.</p> <p>The worklist is a stack that allows for O(1) removal of elements from the stack.</p>"},{"location":"reference/kirin/analysis/","title":"Index","text":""},{"location":"reference/kirin/analysis/cfg/","title":"CFG","text":""},{"location":"reference/kirin/analysis/cfg/#kirin.analysis.cfg.CFG","title":"CFG  <code>dataclass</code>","text":"<pre><code>CFG(parent, entry=None)\n</code></pre> <p>               Bases: <code>Printable</code></p> <p>Control Flow Graph of a given IR statement.</p>"},{"location":"reference/kirin/analysis/cfg/#kirin.analysis.cfg.CFG.entry","title":"entry  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>entry = None\n</code></pre> <p>Entry block of the CFG.</p>"},{"location":"reference/kirin/analysis/cfg/#kirin.analysis.cfg.CFG.parent","title":"parent  <code>instance-attribute</code>","text":"<pre><code>parent\n</code></pre> <p>Parent IR statement.</p>"},{"location":"reference/kirin/analysis/cfg/#kirin.analysis.cfg.CFG.predecessors","title":"predecessors  <code>cached</code> <code>property</code>","text":"<pre><code>predecessors\n</code></pre> <p>CFG data, mapping a block to its predecessors.</p>"},{"location":"reference/kirin/analysis/cfg/#kirin.analysis.cfg.CFG.successors","title":"successors  <code>cached</code> <code>property</code>","text":"<pre><code>successors\n</code></pre> <p>CFG data, mapping a block to its neighbors.</p>"},{"location":"reference/kirin/analysis/dataflow/","title":"Index","text":""},{"location":"reference/kirin/analysis/dataflow/constprop/","title":"Constprop","text":""},{"location":"reference/kirin/analysis/dataflow/forward/","title":"Forward","text":""},{"location":"reference/kirin/analysis/dataflow/forward/#kirin.analysis.dataflow.forward.ForwardExtra","title":"ForwardExtra","text":"<pre><code>ForwardExtra(\n    dialects,\n    *,\n    fuel=None,\n    max_depth=128,\n    max_python_recursion_depth=8192\n)\n</code></pre> <p>               Bases: <code>AbstractInterpreter[ForwardFrame[LatticeElemType, ExtraType], LatticeElemType]</code>, <code>Generic[LatticeElemType, ExtraType]</code></p> <p>Abstract interpreter but record results for each SSA value.</p> Source code in <code>src/kirin/analysis/dataflow/forward.py</code> <pre><code>def __init__(\n    self,\n    dialects: DialectGroup | Iterable[Dialect],\n    *,\n    fuel: int | None = None,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192,\n):\n    super().__init__(\n        dialects,\n        fuel=fuel,\n        max_depth=max_depth,\n        max_python_recursion_depth=max_python_recursion_depth,\n    )\n    self.results = {}\n</code></pre>"},{"location":"reference/kirin/analysis/dataflow/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/analysis/dataflow/typeinfer/#kirin.analysis.dataflow.typeinfer.TypeInference","title":"TypeInference","text":"<pre><code>TypeInference(\n    dialects,\n    *,\n    fuel=None,\n    max_depth=128,\n    max_python_recursion_depth=8192\n)\n</code></pre> <p>               Bases: <code>Forward[TypeAttribute]</code></p> Source code in <code>src/kirin/analysis/dataflow/forward.py</code> <pre><code>def __init__(\n    self,\n    dialects: DialectGroup | Iterable[Dialect],\n    *,\n    fuel: int | None = None,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192,\n):\n    super().__init__(\n        dialects,\n        fuel=fuel,\n        max_depth=max_depth,\n        max_python_recursion_depth=max_python_recursion_depth,\n    )\n    self.results = {}\n</code></pre>"},{"location":"reference/kirin/analysis/dataflow/typeinfer/#kirin.analysis.dataflow.typeinfer.TypeInference.build_signature","title":"build_signature","text":"<pre><code>build_signature(stmt, args)\n</code></pre> <p>we use value here as signature as they will be types</p> Source code in <code>src/kirin/analysis/dataflow/typeinfer.py</code> <pre><code>def build_signature(self, stmt: Statement, args: tuple):\n    \"\"\"we use value here as signature as they will be types\"\"\"\n    _args = []\n    for x in args:\n        if isinstance(x, types.PyConst):\n            _args.append(x.typ)\n        elif isinstance(x, types.PyGeneric):\n            _args.append(x.body)\n        else:\n            _args.append(x)\n\n    return (\n        stmt.__class__,\n        tuple(_args),\n    )\n</code></pre>"},{"location":"reference/kirin/codegen/","title":"Index","text":""},{"location":"reference/kirin/codegen/base/","title":"Base","text":""},{"location":"reference/kirin/codegen/base/#kirin.codegen.base.CodeGen","title":"CodeGen  <code>dataclass</code>","text":"<pre><code>CodeGen(dialects)\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[Target]</code></p> Source code in <code>src/kirin/codegen/base.py</code> <pre><code>def __init__(self, dialects: ir.DialectGroup | Iterable[ir.Dialect]):\n    if not isinstance(dialects, ir.DialectGroup):\n        dialects = ir.DialectGroup(dialects)\n    self.dialects = dialects\n    self.registry = dialects.registry.codegen(self.keys)\n</code></pre>"},{"location":"reference/kirin/codegen/base/#kirin.codegen.base.CodeGen.build_signature","title":"build_signature","text":"<pre><code>build_signature(stmt)\n</code></pre> <p>build signature for querying the statement implementation.</p> Source code in <code>src/kirin/codegen/base.py</code> <pre><code>def build_signature(self, stmt: ir.Statement) -&gt; \"Signature\":\n    \"\"\"build signature for querying the statement implementation.\"\"\"\n    return (stmt.__class__, tuple(arg.type for arg in stmt.args))\n</code></pre>"},{"location":"reference/kirin/codegen/base/#kirin.codegen.base.CodeGen.emit","title":"emit","text":"<pre><code>emit(mt)\n</code></pre> <p>top-level entry point for code generation.</p> Source code in <code>src/kirin/codegen/base.py</code> <pre><code>def emit(self, mt: ir.Method) -&gt; Target:\n    \"\"\"top-level entry point for code generation.\"\"\"\n    return self.emit_Method(mt)\n</code></pre>"},{"location":"reference/kirin/codegen/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/codegen/dict/","title":"Dict","text":""},{"location":"reference/kirin/codegen/impl/","title":"Impl","text":""},{"location":"reference/kirin/codegen/ssa/","title":"Ssa","text":""},{"location":"reference/kirin/decl/","title":"Index","text":""},{"location":"reference/kirin/decl/base/","title":"Base","text":""},{"location":"reference/kirin/decl/camel2snake/","title":"Camel2snake","text":""},{"location":"reference/kirin/decl/info/","title":"Info","text":""},{"location":"reference/kirin/decl/info/#kirin.decl.info.ArgumentField","title":"ArgumentField  <code>dataclass</code>","text":"<pre><code>ArgumentField(\n    kw_only, alias, type, print=True, group=False\n)\n</code></pre> <p>               Bases: <code>Field</code></p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.ArgumentField.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>group = False\n</code></pre> <p>if <code>True</code>, this argument is annotated with Tuple[SSAValue, ...]</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.ArgumentField.print","title":"print  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>print = True\n</code></pre> <p>if <code>True</code>, this argument name is printed in the signature.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.ArgumentField.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type\n</code></pre> <p>type of the argument, will be used in validation.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.AttributeField","title":"AttributeField  <code>dataclass</code>","text":"<pre><code>AttributeField(\n    kw_only,\n    alias,\n    default,\n    init,\n    repr,\n    default_factory,\n    type,\n    property,\n    pytype=False,\n)\n</code></pre> <p>               Bases: <code>Field</code></p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.AttributeField.pytype","title":"pytype  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pytype = False\n</code></pre> <p>if <code>True</code>, annotation is a python type hint instead of <code>TypeAttribute</code></p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields","title":"StatementFields  <code>dataclass</code>","text":"<pre><code>StatementFields(\n    std_args=dict(),\n    kw_args=dict(),\n    results=dict(),\n    regions=dict(),\n    blocks=dict(),\n    attributes=dict(),\n    properties=dict(),\n)\n</code></pre>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.args","title":"args  <code>property</code>","text":"<pre><code>args\n</code></pre> <p>iterable of all argument fields.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.attributes","title":"attributes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>attributes = field(default_factory=dict)\n</code></pre> <p>attributes of the statement.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.blocks","title":"blocks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>blocks = field(default_factory=dict)\n</code></pre> <p>blocks of the statement.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.kw_args","title":"kw_args  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kw_args = field(default_factory=dict)\n</code></pre> <p>keyword-only arguments of the statement.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.properties","title":"properties  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>properties = field(default_factory=dict)\n</code></pre> <p>properties of the statement.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.regions","title":"regions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>regions = field(default_factory=dict)\n</code></pre> <p>regions of the statement.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.required_names","title":"required_names  <code>cached</code> <code>property</code>","text":"<pre><code>required_names\n</code></pre> <p>set of all fields that do not have a default value.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.results","title":"results  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>results = field(default_factory=dict)\n</code></pre> <p>results of the statement.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.std_args","title":"std_args  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>std_args = field(default_factory=dict)\n</code></pre> <p>standard arguments of the statement.</p>"},{"location":"reference/kirin/decl/scan_fields/","title":"Scan fields","text":""},{"location":"reference/kirin/decl/scan_fields/#kirin.decl.scan_fields.ScanFields","title":"ScanFields","text":"<pre><code>ScanFields(cls, **kwargs)\n</code></pre> <p>               Bases: <code>BaseModifier</code></p> Source code in <code>src/kirin/decl/base.py</code> <pre><code>def __init__(self, cls: type, **kwargs: Unpack[StatementOptions]) -&gt; None:\n    self.cls = cls\n    self.cls_module = sys.modules.get(cls.__module__)\n\n    if \"dialect\" in kwargs:\n        self.dialect = kwargs[\"dialect\"]\n    else:\n        self.dialect = None\n    self.params = kwargs\n    setattr(cls, self._PARAMS, self.params)\n\n    if cls.__module__ in sys.modules:\n        self.globals = sys.modules[cls.__module__].__dict__\n    else:\n        # Theoretically this can happen if someone writes\n        # a custom string to cls.__module__.  In which case\n        # such dataclass won't be fully introspectable\n        # (w.r.t. typing.get_type_hints) but will still function\n        # correctly.\n        self.globals: dict[str, Any] = {}\n\n    # analysis state, used by scan_field, etc.\n    self.fields = StatementFields()\n    self.has_statement_bases = False\n    self.kw_only = self.params.get(\"kw_only\", False)\n    self.KW_ONLY_seen = False\n</code></pre>"},{"location":"reference/kirin/decl/verify/","title":"Verify","text":""},{"location":"reference/kirin/decl/emit/","title":"Index","text":""},{"location":"reference/kirin/decl/emit/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/decl/emit/from_python_call/","title":"From python call","text":""},{"location":"reference/kirin/decl/emit/init/","title":"Init","text":""},{"location":"reference/kirin/decl/emit/name/","title":"Name","text":""},{"location":"reference/kirin/decl/emit/property/","title":"Property","text":""},{"location":"reference/kirin/decl/emit/repr/","title":"Repr","text":""},{"location":"reference/kirin/decl/emit/traits/","title":"Traits","text":""},{"location":"reference/kirin/decl/emit/typecheck/","title":"Typecheck","text":""},{"location":"reference/kirin/decl/emit/verify/","title":"Verify","text":""},{"location":"reference/kirin/dialects/","title":"Index","text":""},{"location":"reference/kirin/dialects/cf/","title":"Index","text":""},{"location":"reference/kirin/dialects/cf/constprop/","title":"Constprop","text":""},{"location":"reference/kirin/dialects/cf/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/dialects/cf/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/cf/lower/","title":"Lower","text":""},{"location":"reference/kirin/dialects/cf/stmts/","title":"Stmts","text":""},{"location":"reference/kirin/dialects/cf/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/dialects/fcf/","title":"Index","text":""},{"location":"reference/kirin/dialects/fcf/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/dialects/fcf/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/fcf/stmts/","title":"Stmts","text":""},{"location":"reference/kirin/dialects/fcf/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/dialects/func/","title":"Index","text":"<p>A function dialect that is compatible with python semantics.</p>"},{"location":"reference/kirin/dialects/func/attrs/","title":"Attrs","text":""},{"location":"reference/kirin/dialects/func/attrs/#kirin.dialects.func.attrs.Signature","title":"Signature  <code>dataclass</code>","text":"<pre><code>Signature(inputs, output)\n</code></pre> <p>               Bases: <code>Generic[TypeLatticeElem]</code>, <code>Attribute</code></p> <p>function body signature.</p> <p>This is not a type attribute because it just stores the signature of a function at its definition site. We don't perform type inference on this directly.</p> <p>The type of a function is the type of <code>inputs[0]</code>, which typically is a <code>MethodType</code>.</p>"},{"location":"reference/kirin/dialects/func/constprop/","title":"Constprop","text":""},{"location":"reference/kirin/dialects/func/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/dialects/func/emit/","title":"Emit","text":""},{"location":"reference/kirin/dialects/func/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/func/lower/","title":"Lower","text":""},{"location":"reference/kirin/dialects/func/stmts/","title":"Stmts","text":""},{"location":"reference/kirin/dialects/func/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/dialects/math/","title":"Index","text":"<p>math dialect, modeling functions in python's <code>math</code> stdlib</p>"},{"location":"reference/kirin/dialects/math/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/dialects/math/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/math/stmts/","title":"Stmts","text":""},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.acos","title":"acos  <code>dataclass</code>","text":"<pre><code>acos(\n    *,\n    args=(),\n    regions=(),\n    successors=(),\n    attributes={},\n    properties={},\n    results=(),\n    result_types=(),\n    args_slice={},\n    source=None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>acos statement, wrapping the math.acos function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.asin","title":"asin  <code>dataclass</code>","text":"<pre><code>asin(\n    *,\n    args=(),\n    regions=(),\n    successors=(),\n    attributes={},\n    properties={},\n    results=(),\n    result_types=(),\n    args_slice={},\n    source=None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>asin statement, wrapping the math.asin function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.asinh","title":"asinh  <code>dataclass</code>","text":"<pre><code>asinh(\n    *,\n    args=(),\n    regions=(),\n    successors=(),\n    attributes={},\n    properties={},\n    results=(),\n    result_types=(),\n    args_slice={},\n    source=None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>asinh statement, wrapping the math.asinh function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.atan","title":"atan  <code>dataclass</code>","text":"<pre><code>atan(\n    *,\n    args=(),\n    regions=(),\n    successors=(),\n    attributes={},\n    properties={},\n    results=(),\n    result_types=(),\n    args_slice={},\n    source=None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>atan statement, wrapping the math.atan function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.atan2","title":"atan2  <code>dataclass</code>","text":"<pre><code>atan2(\n    *,\n    args=(),\n    regions=(),\n    successors=(),\n    attributes={},\n    properties={},\n    results=(),\n    result_types=(),\n    args_slice={},\n    source=None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>atan2 statement, wrapping the math.atan2 function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.atanh","title":"atanh  <code>dataclass</code>","text":"<pre><code>atanh(\n    *,\n    args=(),\n    regions=(),\n    successors=(),\n    attributes={},\n    properties={},\n    results=(),\n    result_types=(),\n    args_slice={},\n    source=None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>atanh statement, wrapping the math.atanh function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.ceil","title":"ceil  <code>dataclass</code>","text":"<pre><code>ceil(\n    *,\n    args=(),\n    regions=(),\n    successors=(),\n    attributes={},\n    properties={},\n    results=(),\n    result_types=(),\n    args_slice={},\n    source=None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>ceil statement, wrapping the math.ceil function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.copysign","title":"copysign  <code>dataclass</code>","text":"<pre><code>copysign(\n    *,\n    args=(),\n    regions=(),\n    successors=(),\n    attributes={},\n    properties={},\n    results=(),\n    result_types=(),\n    args_slice={},\n    source=None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>copysign statement, wrapping the math.copysign function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.cos","title":"cos  <code>dataclass</code>","text":"<pre><code>cos(\n    *,\n    args=(),\n    regions=(),\n    successors=(),\n    attributes={},\n    properties={},\n    results=(),\n    result_types=(),\n    args_slice={},\n    source=None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>cos statement, wrapping the math.cos function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.cosh","title":"cosh  <code>dataclass</code>","text":"<pre><code>cosh(\n    *,\n    args=(),\n    regions=(),\n    successors=(),\n    attributes={},\n    properties={},\n    results=(),\n    result_types=(),\n    args_slice={},\n    source=None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>cosh statement, wrapping the math.cosh function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.degrees","title":"degrees  <code>dataclass</code>","text":"<pre><code>degrees(\n    *,\n    args=(),\n    regions=(),\n    successors=(),\n    attributes={},\n    properties={},\n    results=(),\n    result_types=(),\n    args_slice={},\n    source=None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>degrees statement, wrapping the math.degrees function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.erf","title":"erf  <code>dataclass</code>","text":"<pre><code>erf(\n    *,\n    args=(),\n    regions=(),\n    successors=(),\n    attributes={},\n    properties={},\n    results=(),\n    result_types=(),\n    args_slice={},\n    source=None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>erf statement, wrapping the math.erf function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.erfc","title":"erfc  <code>dataclass</code>","text":"<pre><code>erfc(\n    *,\n    args=(),\n    regions=(),\n    successors=(),\n    attributes={},\n    properties={},\n    results=(),\n    result_types=(),\n    args_slice={},\n    source=None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>erfc statement, wrapping the math.erfc function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.exp","title":"exp  <code>dataclass</code>","text":"<pre><code>exp(\n    *,\n    args=(),\n    regions=(),\n    successors=(),\n    attributes={},\n    properties={},\n    results=(),\n    result_types=(),\n    args_slice={},\n    source=None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>exp statement, wrapping the math.exp function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.expm1","title":"expm1  <code>dataclass</code>","text":"<pre><code>expm1(\n    *,\n    args=(),\n    regions=(),\n    successors=(),\n    attributes={},\n    properties={},\n    results=(),\n    result_types=(),\n    args_slice={},\n    source=None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>expm1 statement, wrapping the math.expm1 function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.fabs","title":"fabs  <code>dataclass</code>","text":"<pre><code>fabs(\n    *,\n    args=(),\n    regions=(),\n    successors=(),\n    attributes={},\n    properties={},\n    results=(),\n    result_types=(),\n    args_slice={},\n    source=None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>fabs statement, wrapping the math.fabs function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.floor","title":"floor  <code>dataclass</code>","text":"<pre><code>floor(\n    *,\n    args=(),\n    regions=(),\n    successors=(),\n    attributes={},\n    properties={},\n    results=(),\n    result_types=(),\n    args_slice={},\n    source=None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>floor statement, wrapping the math.floor function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.fmod","title":"fmod  <code>dataclass</code>","text":"<pre><code>fmod(\n    *,\n    args=(),\n    regions=(),\n    successors=(),\n    attributes={},\n    properties={},\n    results=(),\n    result_types=(),\n    args_slice={},\n    source=None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>fmod statement, wrapping the math.fmod function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.gamma","title":"gamma  <code>dataclass</code>","text":"<pre><code>gamma(\n    *,\n    args=(),\n    regions=(),\n    successors=(),\n    attributes={},\n    properties={},\n    results=(),\n    result_types=(),\n    args_slice={},\n    source=None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>gamma statement, wrapping the math.gamma function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.isfinite","title":"isfinite  <code>dataclass</code>","text":"<pre><code>isfinite(\n    *,\n    args=(),\n    regions=(),\n    successors=(),\n    attributes={},\n    properties={},\n    results=(),\n    result_types=(),\n    args_slice={},\n    source=None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>isfinite statement, wrapping the math.isfinite function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.isinf","title":"isinf  <code>dataclass</code>","text":"<pre><code>isinf(\n    *,\n    args=(),\n    regions=(),\n    successors=(),\n    attributes={},\n    properties={},\n    results=(),\n    result_types=(),\n    args_slice={},\n    source=None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>isinf statement, wrapping the math.isinf function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.isnan","title":"isnan  <code>dataclass</code>","text":"<pre><code>isnan(\n    *,\n    args=(),\n    regions=(),\n    successors=(),\n    attributes={},\n    properties={},\n    results=(),\n    result_types=(),\n    args_slice={},\n    source=None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>isnan statement, wrapping the math.isnan function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.lgamma","title":"lgamma  <code>dataclass</code>","text":"<pre><code>lgamma(\n    *,\n    args=(),\n    regions=(),\n    successors=(),\n    attributes={},\n    properties={},\n    results=(),\n    result_types=(),\n    args_slice={},\n    source=None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>lgamma statement, wrapping the math.lgamma function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.log10","title":"log10  <code>dataclass</code>","text":"<pre><code>log10(\n    *,\n    args=(),\n    regions=(),\n    successors=(),\n    attributes={},\n    properties={},\n    results=(),\n    result_types=(),\n    args_slice={},\n    source=None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>log10 statement, wrapping the math.log10 function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.log1p","title":"log1p  <code>dataclass</code>","text":"<pre><code>log1p(\n    *,\n    args=(),\n    regions=(),\n    successors=(),\n    attributes={},\n    properties={},\n    results=(),\n    result_types=(),\n    args_slice={},\n    source=None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>log1p statement, wrapping the math.log1p function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.log2","title":"log2  <code>dataclass</code>","text":"<pre><code>log2(\n    *,\n    args=(),\n    regions=(),\n    successors=(),\n    attributes={},\n    properties={},\n    results=(),\n    result_types=(),\n    args_slice={},\n    source=None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>log2 statement, wrapping the math.log2 function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.pow","title":"pow  <code>dataclass</code>","text":"<pre><code>pow(\n    *,\n    args=(),\n    regions=(),\n    successors=(),\n    attributes={},\n    properties={},\n    results=(),\n    result_types=(),\n    args_slice={},\n    source=None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>pow statement, wrapping the math.pow function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.radians","title":"radians  <code>dataclass</code>","text":"<pre><code>radians(\n    *,\n    args=(),\n    regions=(),\n    successors=(),\n    attributes={},\n    properties={},\n    results=(),\n    result_types=(),\n    args_slice={},\n    source=None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>radians statement, wrapping the math.radians function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.remainder","title":"remainder  <code>dataclass</code>","text":"<pre><code>remainder(\n    *,\n    args=(),\n    regions=(),\n    successors=(),\n    attributes={},\n    properties={},\n    results=(),\n    result_types=(),\n    args_slice={},\n    source=None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>remainder statement, wrapping the math.remainder function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.sin","title":"sin  <code>dataclass</code>","text":"<pre><code>sin(\n    *,\n    args=(),\n    regions=(),\n    successors=(),\n    attributes={},\n    properties={},\n    results=(),\n    result_types=(),\n    args_slice={},\n    source=None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>sin statement, wrapping the math.sin function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.sinh","title":"sinh  <code>dataclass</code>","text":"<pre><code>sinh(\n    *,\n    args=(),\n    regions=(),\n    successors=(),\n    attributes={},\n    properties={},\n    results=(),\n    result_types=(),\n    args_slice={},\n    source=None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>sinh statement, wrapping the math.sinh function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.sqrt","title":"sqrt  <code>dataclass</code>","text":"<pre><code>sqrt(\n    *,\n    args=(),\n    regions=(),\n    successors=(),\n    attributes={},\n    properties={},\n    results=(),\n    result_types=(),\n    args_slice={},\n    source=None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>sqrt statement, wrapping the math.sqrt function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.tan","title":"tan  <code>dataclass</code>","text":"<pre><code>tan(\n    *,\n    args=(),\n    regions=(),\n    successors=(),\n    attributes={},\n    properties={},\n    results=(),\n    result_types=(),\n    args_slice={},\n    source=None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>tan statement, wrapping the math.tan function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.tanh","title":"tanh  <code>dataclass</code>","text":"<pre><code>tanh(\n    *,\n    args=(),\n    regions=(),\n    successors=(),\n    attributes={},\n    properties={},\n    results=(),\n    result_types=(),\n    args_slice={},\n    source=None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>tanh statement, wrapping the math.tanh function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.trunc","title":"trunc  <code>dataclass</code>","text":"<pre><code>trunc(\n    *,\n    args=(),\n    regions=(),\n    successors=(),\n    attributes={},\n    properties={},\n    results=(),\n    result_types=(),\n    args_slice={},\n    source=None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>trunc statement, wrapping the math.trunc function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.ulp","title":"ulp  <code>dataclass</code>","text":"<pre><code>ulp(\n    *,\n    args=(),\n    regions=(),\n    successors=(),\n    attributes={},\n    properties={},\n    results=(),\n    result_types=(),\n    args_slice={},\n    source=None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>ulp statement, wrapping the math.ulp function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/py/","title":"Index","text":""},{"location":"reference/kirin/dialects/py/data/","title":"Data","text":""},{"location":"reference/kirin/dialects/py/rules/","title":"Index","text":""},{"location":"reference/kirin/dialects/py/rules/getitem/","title":"Getitem","text":""},{"location":"reference/kirin/dialects/py/stmts/","title":"Index","text":""},{"location":"reference/kirin/dialects/py/stmts/constprop/","title":"Constprop","text":""},{"location":"reference/kirin/dialects/py/stmts/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/dialects/py/stmts/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/py/stmts/lowering/","title":"Lowering","text":""},{"location":"reference/kirin/dialects/py/stmts/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/","title":"Index","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/assign/","title":"Assign","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/binop/","title":"Binop","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/boolean/","title":"Boolean","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/builtin/","title":"Builtin","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/cmp/","title":"Cmp","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/constant/","title":"Constant","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/getattr/","title":"Getattr","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/getitem/","title":"Getitem","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/list/","title":"List","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/range/","title":"Range","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/slice/","title":"Slice","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/tuple/","title":"Tuple","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/unary/","title":"Unary","text":""},{"location":"reference/kirin/dialects/py/types/","title":"Index","text":""},{"location":"reference/kirin/dialects/py/types/base/","title":"Base","text":""},{"location":"reference/kirin/dialects/py/types/base/#kirin.dialects.py.types.base.PyConst","title":"PyConst  <code>dataclass</code>","text":"<pre><code>PyConst(data, typ=None)\n</code></pre> <p>               Bases: <code>PyType</code>, <code>Generic[Type]</code></p> <p>This will not appear in user-space. It is used to pass around constant values interprocedurally.</p> Source code in <code>src/kirin/dialects/py/types/elem.py</code> <pre><code>def __init__(self, data: Type, typ: PyType | None = None):\n    self.data = data\n    if isinstance(typ, PyConst):\n        typ = widen_const(typ)\n\n    if typ is not None:\n        self.typ = typ\n    else:\n        self.typ = PyClass(type(data))\n</code></pre>"},{"location":"reference/kirin/dialects/py/types/base/#kirin.dialects.py.types.base.PyGeneric","title":"PyGeneric  <code>dataclass</code>","text":"<pre><code>PyGeneric(body, *vars)\n</code></pre> <p>               Bases: <code>PyType</code>, <code>Generic[Type]</code></p> Source code in <code>src/kirin/dialects/py/types/elem.py</code> <pre><code>def __init__(self, body: type[Type] | PyClass[Type], *vars: PyType | PyVararg):\n    if isinstance(body, PyClass):\n        self.body = body\n    else:\n        self.body = PyClass(body)\n\n    self.vars, self.vararg = split_type_args(vars)\n</code></pre>"},{"location":"reference/kirin/dialects/py/types/base/#kirin.dialects.py.types.base.PyGeneric.vararg","title":"vararg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>vararg = None\n</code></pre> <p>unknown type variables</p>"},{"location":"reference/kirin/dialects/py/types/builtin/","title":"Builtin","text":"<p>some convenient singleton wrapper for python.</p> <p>They should be equivalent directly construct PyClass.</p>"},{"location":"reference/kirin/dialects/py/types/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/dialects/py/types/elem/","title":"Elem","text":""},{"location":"reference/kirin/dialects/py/types/elem/#kirin.dialects.py.types.elem.PyConst","title":"PyConst  <code>dataclass</code>","text":"<pre><code>PyConst(data, typ=None)\n</code></pre> <p>               Bases: <code>PyType</code>, <code>Generic[Type]</code></p> <p>This will not appear in user-space. It is used to pass around constant values interprocedurally.</p> Source code in <code>src/kirin/dialects/py/types/elem.py</code> <pre><code>def __init__(self, data: Type, typ: PyType | None = None):\n    self.data = data\n    if isinstance(typ, PyConst):\n        typ = widen_const(typ)\n\n    if typ is not None:\n        self.typ = typ\n    else:\n        self.typ = PyClass(type(data))\n</code></pre>"},{"location":"reference/kirin/dialects/py/types/elem/#kirin.dialects.py.types.elem.PyGeneric","title":"PyGeneric  <code>dataclass</code>","text":"<pre><code>PyGeneric(body, *vars)\n</code></pre> <p>               Bases: <code>PyType</code>, <code>Generic[Type]</code></p> Source code in <code>src/kirin/dialects/py/types/elem.py</code> <pre><code>def __init__(self, body: type[Type] | PyClass[Type], *vars: PyType | PyVararg):\n    if isinstance(body, PyClass):\n        self.body = body\n    else:\n        self.body = PyClass(body)\n\n    self.vars, self.vararg = split_type_args(vars)\n</code></pre>"},{"location":"reference/kirin/dialects/py/types/elem/#kirin.dialects.py.types.elem.PyGeneric.vararg","title":"vararg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>vararg = None\n</code></pre> <p>unknown type variables</p>"},{"location":"reference/kirin/dialects/py/types/emit/","title":"Emit","text":""},{"location":"reference/kirin/interp/","title":"Index","text":""},{"location":"reference/kirin/interp/abstract/","title":"Abstract","text":""},{"location":"reference/kirin/interp/base/","title":"Base","text":""},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter","title":"BaseInterpreter","text":"<pre><code>BaseInterpreter(\n    dialects,\n    *,\n    fuel=None,\n    max_depth=128,\n    max_python_recursion_depth=8192\n)\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[FrameType, ValueType]</code></p> <p>A base class for interpreters.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def __init__(\n    self,\n    dialects: DialectGroup | Iterable[Dialect],\n    *,\n    fuel: int | None = None,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192,\n):\n    if not isinstance(dialects, DialectGroup):\n        dialects = DialectGroup(dialects)\n    self.dialects = dialects\n\n    self.registry, self.fallbacks = self.dialects.registry.interpreter(\n        keys=self.keys\n    )\n    self.state = InterpreterState()\n    self.fuel = fuel\n    self.max_depth = max_depth\n    self.max_python_recursion_depth = max_python_recursion_depth\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.dialects","title":"dialects  <code>instance-attribute</code>","text":"<pre><code>dialects = dialects\n</code></pre> <p>The dialects to interpret.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.fuel","title":"fuel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fuel = fuel\n</code></pre> <p>The fuel limit.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.keys","title":"keys  <code>class-attribute</code>","text":"<pre><code>keys\n</code></pre> <p>The name of the interpreter to select from dialects by order.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.registry","title":"registry  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>registry = field(init=False, repr=False)\n</code></pre> <p>A mapping of statement signature to their implementation.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.state","title":"state  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>state = InterpreterState()\n</code></pre> <p>The interpreter state.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.build_signature","title":"build_signature","text":"<pre><code>build_signature(stmt, args)\n</code></pre> <p>build signature for querying the statement implementation.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def build_signature(self, stmt: Statement, args: tuple) -&gt; \"Signature\":\n    \"\"\"build signature for querying the statement implementation.\"\"\"\n    return (stmt.__class__, tuple(arg.type for arg in stmt.args))\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.eval","title":"eval","text":"<pre><code>eval(mt, args, kwargs=None)\n</code></pre> <p>Evaluate a method.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def eval(\n    self,\n    mt: Method,\n    args: tuple[ValueType, ...],\n    kwargs: dict[str, ValueType] | None = None,\n) -&gt; InterpResult[ValueType]:\n    \"\"\"Evaluate a method.\"\"\"\n    current_recursion_limit = sys.getrecursionlimit()\n    sys.setrecursionlimit(self.max_python_recursion_depth)\n    interface = mt.code.get_trait(traits.CallableStmtInterface)\n    if interface is None:\n        raise InterpreterError(f\"compiled method {mt} is not callable\")\n\n    if len(self.state.frames) &gt;= self.max_depth:\n        raise InterpreterError(\"maximum recursion depth exceeded\")\n\n    self.state.push_frame(self.new_method_frame(mt))\n    body = interface.get_callable_region(mt.code)\n    # NOTE: #self# is not user input so it is not\n    # in the args, +1 is for self\n    args = self.get_args(mt.arg_names[len(args) + 1 :], args, kwargs)\n    # NOTE: this should be checked via static validation, we just assume\n    # number of args is correct here\n    # NOTE: Method is used as if it is a singleton type, but it is not recognized by mypy\n    results = self.run_method_region(mt, body, args)\n    self.postprocess_frame(self.state.pop_frame())\n    sys.setrecursionlimit(current_recursion_limit)\n    return results\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.eval_stmt","title":"eval_stmt","text":"<pre><code>eval_stmt(stmt, args)\n</code></pre> <p>simply evaluate a statement</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def eval_stmt(self, stmt: Statement, args: tuple) -&gt; Result[ValueType]:\n    \"simply evaluate a statement\"\n    sig = self.build_signature(stmt, args)\n    if sig in self.registry:\n        return self.registry[sig](self, stmt, args)\n    elif stmt.__class__ in self.registry:\n        return self.registry[stmt.__class__](self, stmt, args)\n    elif stmt.dialect:\n        return self.fallbacks[stmt.dialect](self, stmt, args)\n    raise ValueError(f\"no dialect for stmt {stmt}\")\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.new_method_frame","title":"new_method_frame  <code>abstractmethod</code>","text":"<pre><code>new_method_frame(mt)\n</code></pre> <p>Create a new frame for the given method.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>@abstractmethod\ndef new_method_frame(self, mt: Method) -&gt; FrameType:\n    \"\"\"Create a new frame for the given method.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.permute_values","title":"permute_values  <code>staticmethod</code>","text":"<pre><code>permute_values(mt, values, kwarg_names)\n</code></pre> <p>Permute the arguments according to the method signature and the given keyword arguments, where the keyword argument names refer to the last n arguments in the values tuple.</p> <p>Args</p> <p>mt: the method values: the values tuple (should not contain method itself) kwarg_names: the keyword argument names</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>@staticmethod\ndef permute_values(\n    mt: Method, values: tuple[ValueType, ...], kwarg_names: tuple[str, ...]\n) -&gt; tuple[ValueType, ...]:\n    \"\"\"Permute the arguments according to the method signature and\n    the given keyword arguments, where the keyword argument names\n    refer to the last n arguments in the values tuple.\n\n    Args\n\n    mt: the method\n    values: the values tuple (should not contain method itself)\n    kwarg_names: the keyword argument names\n    \"\"\"\n    n_total = len(values)\n    if kwarg_names:\n        kwargs = dict(zip(kwarg_names, values[n_total - len(kwarg_names) :]))\n    else:\n        kwargs = None\n\n    positionals = values[: n_total - len(kwarg_names)]\n    args = BaseInterpreter.get_args(\n        mt.arg_names[len(positionals) + 1 :], positionals, kwargs\n    )\n    return args\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.postprocess_frame","title":"postprocess_frame","text":"<pre><code>postprocess_frame(frame)\n</code></pre> <p>Postprocess a frame after it is popped from the stack. This is called after a method is evaluated and the frame is popped. Default implementation does nothing.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def postprocess_frame(self, frame: FrameType) -&gt; None:\n    \"\"\"Postprocess a frame after it is popped from the stack. This is\n    called after a method is evaluated and the frame is popped. Default\n    implementation does nothing.\n    \"\"\"\n    return\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.run_stmt","title":"run_stmt","text":"<pre><code>run_stmt(stmt, args)\n</code></pre> <p>run a statement within the current frame</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def run_stmt(self, stmt: Statement, args: tuple) -&gt; Result[ValueType]:\n    \"run a statement within the current frame\"\n    if self.state.frames:\n        # NOTE: if run_stmt is called directly,\n        # there is no frame being pushed, we only\n        # push a frame when we call a method\n        self.state.current_frame().set_stmt(stmt)\n    return self.eval_stmt(stmt, args)\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.InterpResult","title":"InterpResult  <code>dataclass</code>","text":"<pre><code>InterpResult(result)\n</code></pre> <p>               Bases: <code>Generic[ValueType]</code></p> <p>This is used by the interpreter eval only.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def __init__(self, result: ValueType | NoReturn | Err):\n    if isinstance(result, Err):\n        self.err = result\n        self.value = NoReturn()\n    else:\n        self.value = result\n</code></pre>"},{"location":"reference/kirin/interp/concrete/","title":"Concrete","text":""},{"location":"reference/kirin/interp/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/interp/frame/","title":"Frame","text":""},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame","title":"Frame  <code>dataclass</code>","text":"<pre><code>Frame(\n    method,\n    lino=0,\n    stmt=None,\n    globals=dict(),\n    entries=dict(),\n)\n</code></pre> <p>               Bases: <code>FrameABC[ValueType]</code></p>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame.entries","title":"entries  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>entries = field(default_factory=dict)\n</code></pre> <p>SSA values and their corresponding values.</p>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame.globals","title":"globals  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>globals = field(default_factory=dict)\n</code></pre> <p>Global variables this frame has access to.</p>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame.method","title":"method  <code>instance-attribute</code>","text":"<pre><code>method\n</code></pre> <p>method being interpreted.</p>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame.stmt","title":"stmt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stmt = None\n</code></pre> <p>statement being interpreted.</p>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.FrameABC","title":"FrameABC  <code>dataclass</code>","text":"<pre><code>FrameABC()\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[ValueType]</code></p>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.FrameABC.from_method","title":"from_method  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>from_method(method)\n</code></pre> <p>Create a new frame for the given method.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>@classmethod\n@abstractmethod\ndef from_method(cls, method: Method) -&gt; Self:\n    \"\"\"Create a new frame for the given method.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.FrameABC.get_values","title":"get_values  <code>abstractmethod</code>","text":"<pre><code>get_values(keys)\n</code></pre> <p>Get the values of the given <code>SSAValue</code> keys.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>@abstractmethod\ndef get_values(self, keys: Iterable[SSAValue]) -&gt; tuple:\n    \"\"\"Get the values of the given `SSAValue` keys.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.FrameABC.set_stmt","title":"set_stmt  <code>abstractmethod</code>","text":"<pre><code>set_stmt(stmt)\n</code></pre> <p>Set the current statement.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>@abstractmethod\ndef set_stmt(self, stmt: Statement) -&gt; Self:\n    \"\"\"Set the current statement.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.FrameABC.set_values","title":"set_values  <code>abstractmethod</code>","text":"<pre><code>set_values(keys, values)\n</code></pre> <p>Set the values of the given <code>SSAValue</code> keys.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>@abstractmethod\ndef set_values(self, keys: Iterable[SSAValue], values: Iterable[ValueType]) -&gt; None:\n    \"\"\"Set the values of the given `SSAValue` keys.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/interp/impl/","title":"Impl","text":""},{"location":"reference/kirin/interp/state/","title":"State","text":""},{"location":"reference/kirin/interp/value/","title":"Value","text":""},{"location":"reference/kirin/ir/","title":"Index","text":"<p>IR module for kirin.</p> <p>This module contains the intermediate representation (IR) for kirin.</p>"},{"location":"reference/kirin/ir/attrs/","title":"Attributes","text":""},{"location":"reference/kirin/ir/attrs/#kirin.ir.attrs.AnyType","title":"AnyType  <code>dataclass</code>","text":"<pre><code>AnyType()\n</code></pre> <p>               Bases: <code>TypeAttribute</code></p> <p>Top of any type lattice.</p>"},{"location":"reference/kirin/ir/attrs/#kirin.ir.attrs.AttributeMeta","title":"AttributeMeta","text":"<p>               Bases: <code>ABCMeta</code></p> <p>Metaclass for attributes.</p>"},{"location":"reference/kirin/ir/attrs/#kirin.ir.attrs.BottomType","title":"BottomType  <code>dataclass</code>","text":"<pre><code>BottomType()\n</code></pre> <p>               Bases: <code>TypeAttribute</code></p> <p>Bottom of any type lattice.</p>"},{"location":"reference/kirin/ir/attrs/#kirin.ir.attrs.SingletonTypeMeta","title":"SingletonTypeMeta","text":"<pre><code>SingletonTypeMeta(name, bases, attrs)\n</code></pre> <p>               Bases: <code>TypeAttributeMeta</code>, <code>SingletonMeta</code></p> <p>Metaclass for singleton type attributes.</p> <p>Singleton type attributes are attributes that have only one instance.</p> <p>Examples: - <code>AnyType</code> - <code>BottomType</code></p> Source code in <code>src/kirin/lattice.py</code> <pre><code>def __init__(cls, name, bases, attrs):\n    super().__init__(name, bases, attrs)\n    cls._instance = None\n</code></pre>"},{"location":"reference/kirin/ir/attrs/#kirin.ir.attrs.TypeAttributeMeta","title":"TypeAttributeMeta","text":"<p>               Bases: <code>AttributeMeta</code>, <code>LatticeMeta</code></p> <p>Metaclass for type attributes.</p>"},{"location":"reference/kirin/ir/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/ir/dialect/#kirin.ir.dialect.Dialect","title":"Dialect  <code>dataclass</code>","text":"<pre><code>Dialect(\n    name,\n    stmts=list(),\n    attrs=list(),\n    interps=dict(),\n    lowering=dict(),\n    codegen=dict(),\n)\n</code></pre> <p>Dialect is a collection of statements, attributes, interpreters, lowerings, and codegen.</p>"},{"location":"reference/kirin/ir/dialect/#kirin.ir.dialect.Dialect.register","title":"register","text":"<pre><code>register(node=None, key=None)\n</code></pre> <p>register is a decorator to register a node to the dialect.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>type | None</code> <p>The node to register. Defaults to None.</p> <code>None</code> <code>key</code> <code>str | None</code> <p>The key to register the node to. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the node is not a subclass of Statement, Attribute, DialectInterpreter, FromPythonAST, or DialectEmit.</p> Source code in <code>src/kirin/ir/dialect.py</code> <pre><code>@dataclass_transform()\ndef register(self, node: type | None = None, key: str | None = None):\n    \"\"\"register is a decorator to register a node to the dialect.\n\n    Args:\n        node (type | None): The node to register. Defaults to None.\n        key (str | None): The key to register the node to. Defaults to None.\n\n    Raises:\n        ValueError: If the node is not a subclass of Statement, Attribute, DialectInterpreter, FromPythonAST, or DialectEmit.\n    \"\"\"\n    from kirin.codegen.dialect import DialectEmit\n    from kirin.interp.dialect import DialectInterpreter\n    from kirin.lowering.dialect import FromPythonAST\n\n    if key is None:\n        key = \"main\"\n\n    def wrapper(node: type[T]) -&gt; type[T]:\n        if issubclass(node, Statement):\n            self.stmts.append(node)\n        elif issubclass(node, Attribute):\n            assert (\n                Attribute in node.__mro__\n            ), f\"{node} is not a subclass of Attribute\"\n            setattr(node, \"dialect\", self)\n            assert hasattr(node, \"name\"), f\"{node} does not have a name attribute\"\n            self.attrs.append(node)\n        elif issubclass(node, DialectInterpreter):\n            if key in self.interps:\n                raise ValueError(\n                    f\"Cannot register {node} to Dialect, key {key} exists\"\n                )\n            self.interps[key] = node()\n        elif issubclass(node, FromPythonAST):\n            if key in self.lowering:\n                raise ValueError(\n                    f\"Cannot register {node} to Dialect, key {key} exists\"\n                )\n            self.lowering[key] = node()\n        elif issubclass(node, DialectEmit):\n            if key in self.codegen:\n                raise ValueError(\n                    f\"Cannot register {node} to Dialect, key {key} exists\"\n                )\n            self.codegen[key] = node()\n        else:\n            raise ValueError(f\"Cannot register {node} to Dialect\")\n        return node\n\n    if node is None:\n        return wrapper\n\n    return wrapper(node)\n</code></pre>"},{"location":"reference/kirin/ir/group/","title":"Dialect Group","text":""},{"location":"reference/kirin/ir/group/#kirin.ir.group.Registry","title":"Registry  <code>dataclass</code>","text":"<pre><code>Registry(parent)\n</code></pre>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.Registry.interpreter","title":"interpreter","text":"<pre><code>interpreter(keys)\n</code></pre> <p>select the dialect interpreter for the given key.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>Iterable[str]</code> <p>the keys to search for in the dialects</p> required <p>Returns:</p> Type Description <code>tuple[dict[Signature, StatementImpl], dict[Dialect, StatementImpl]]</code> <p>a map of dialects to their interpreters</p> Source code in <code>src/kirin/ir/group.py</code> <pre><code>def interpreter(\n    self, keys: Iterable[str]\n) -&gt; tuple[dict[\"Signature\", \"InterpImpl\"], dict[\"Dialect\", \"InterpImpl\"]]:\n    \"\"\"select the dialect interpreter for the given key.\n\n    Args:\n        keys (Iterable[str]): the keys to search for in the dialects\n\n    Returns:\n        a map of dialects to their interpreters\n    \"\"\"\n    from kirin.interp.impl import MethodImpl\n\n    ret: dict[\"Signature\", \"InterpImpl\"] = {}\n    fallback: dict[\"Dialect\", \"InterpImpl\"] = {}\n    for dialect in self.parent.data:\n        dialect_interp = None\n        for key in keys:\n            if key in dialect.interps:\n                dialect_interp = dialect.interps[key]\n                if dialect not in fallback:  # use the first fallback\n                    fallback[dialect] = dialect_interp.fallback\n\n                for sig, func in dialect_interp.table.items():\n                    if sig not in ret:\n                        ret[sig] = MethodImpl(dialect_interp, func)\n\n        if dialect not in fallback:\n            msg = \",\".join(keys)\n            raise KeyError(f\"Interpreter of {dialect.name} not found for {msg}\")\n    return ret, fallback\n</code></pre>"},{"location":"reference/kirin/ir/method/","title":"Method","text":""},{"location":"reference/kirin/ir/method/#kirin.ir.method.Method","title":"Method  <code>dataclass</code>","text":"<pre><code>Method(\n    mod,\n    py_func,\n    sym_name,\n    arg_names,\n    dialects,\n    code,\n    fields=tuple(),\n    file=\"\",\n    lineno=list(),\n    backedges=list(),\n    return_type=None,\n    inferred=False,\n    verified=False,\n)\n</code></pre> <p>               Bases: <code>Printable</code>, <code>Generic[Param, RetType]</code></p>"},{"location":"reference/kirin/ir/method/#kirin.ir.method.Method.inferred","title":"inferred  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inferred = False\n</code></pre> <p>if typeinfer has been run on this method</p>"},{"location":"reference/kirin/ir/method/#kirin.ir.method.Method.lineno","title":"lineno  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lineno = field(default_factory=list)\n</code></pre> <p>(, ) at the start of the statement call."},{"location":"reference/kirin/ir/method/#kirin.ir.method.Method.verified","title":"verified  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>verified = False\n</code></pre> <p>if <code>code.verify</code> has been run on this method</p>"},{"location":"reference/kirin/ir/method/#kirin.ir.method.Method.verify","title":"verify","text":"<pre><code>verify()\n</code></pre> <p>verify the method body.</p> Source code in <code>src/kirin/ir/method.py</code> <pre><code>def verify(self) -&gt; None:\n    \"\"\"verify the method body.\"\"\"\n    try:\n        self.code.verify()\n    except VerificationError as e:\n        msg = f'File \"{self.file}\"'\n        if isinstance(e.node, Statement):\n            if e.node.source:\n                msg += f\", line {e.node.source.lineno}\"\n            msg += f\", in {e.node.name}\"\n\n        msg += f\":\\n    Verification failed for {self.sym_name}: {e.args[0]}\"\n        raise Exception(msg) from e\n    self.verified = True\n    return\n</code></pre>"},{"location":"reference/kirin/ir/ssa/","title":"SSA values","text":""},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.TestValue","title":"TestValue  <code>dataclass</code>","text":"<pre><code>TestValue(type=AnyType())\n</code></pre> <p>               Bases: <code>SSAValue</code></p> <p>Test SSAValue for testing IR construction.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def __init__(self, type: TypeAttribute = AnyType()) -&gt; None:\n    super().__init__()\n    self.type = type\n</code></pre>"},{"location":"reference/kirin/ir/traits/","title":"Traits","text":""},{"location":"reference/kirin/ir/traits/#kirin.ir.traits.CallableStmtInterface","title":"CallableStmtInterface  <code>dataclass</code>","text":"<pre><code>CallableStmtInterface()\n</code></pre> <p>               Bases: <code>StmtTrait</code>, <code>Generic[StmtType]</code></p>"},{"location":"reference/kirin/ir/traits/#kirin.ir.traits.CallableStmtInterface.get_callable_region","title":"get_callable_region  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>get_callable_region(stmt)\n</code></pre> <p>Returns the body of the callable region</p> Source code in <code>src/kirin/ir/traits.py</code> <pre><code>@classmethod\n@abstractmethod\ndef get_callable_region(cls, stmt: \"StmtType\") -&gt; Region:\n    \"\"\"Returns the body of the callable region\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/ir/traits/#kirin.ir.traits.SymbolTable","title":"SymbolTable  <code>dataclass</code>","text":"<pre><code>SymbolTable()\n</code></pre> <p>               Bases: <code>StmtTrait</code></p> <p>Statement with SymbolTable trait can only have one region with one block.</p>"},{"location":"reference/kirin/ir/use/","title":"Use","text":""},{"location":"reference/kirin/ir/nodes/","title":"Index","text":""},{"location":"reference/kirin/ir/nodes/base/","title":"Base","text":""},{"location":"reference/kirin/ir/nodes/base/#kirin.ir.nodes.base.IRNode","title":"IRNode  <code>dataclass</code>","text":"<pre><code>IRNode()\n</code></pre> <p>               Bases: <code>Generic[ParentType]</code>, <code>ABC</code>, <code>Printable</code></p>"},{"location":"reference/kirin/ir/nodes/base/#kirin.ir.nodes.base.IRNode.typecheck","title":"typecheck  <code>abstractmethod</code>","text":"<pre><code>typecheck()\n</code></pre> <p>check if types are correct.</p> Source code in <code>src/kirin/ir/nodes/base.py</code> <pre><code>@abstractmethod\ndef typecheck(self) -&gt; None:\n    \"\"\"check if types are correct.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/ir/nodes/base/#kirin.ir.nodes.base.IRNode.verify","title":"verify  <code>abstractmethod</code>","text":"<pre><code>verify()\n</code></pre> <p>run mandatory validation checks. This is not same as typecheck, which may be optional.</p> Source code in <code>src/kirin/ir/nodes/base.py</code> <pre><code>@abstractmethod\ndef verify(self) -&gt; None:\n    \"\"\"run mandatory validation checks. This is not same as typecheck, which may be optional.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/","title":"Block","text":""},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block","title":"Block  <code>dataclass</code>","text":"<pre><code>Block(stmts=(), argtypes=())\n</code></pre> <p>               Bases: <code>IRNode['Region']</code></p> <p>Block consist of a list of Statements and optionally input arguments.</p> <pre><code>argtypes (Iterable[TypeAttribute], optional): The type of the block arguments. Defaults to ().\n</code></pre> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def __init__(\n    self,\n    stmts: Sequence[Statement] = (),\n    argtypes: Iterable[TypeAttribute] = (),\n):\n    \"\"\"\n    Args:\n        stmts (Sequence[Statement], optional): A list of statements. Defaults to ().\n        argtypes (Iterable[TypeAttribute], optional): The type of the block arguments. Defaults to ().\n    \"\"\"\n    super().__init__()\n    self._args = tuple(\n        BlockArgument(self, i, argtype) for i, argtype in enumerate(argtypes)\n    )\n\n    self._first_stmt = None\n    self._last_stmt = None\n    self._first_branch = None\n    self._last_branch = None\n    self._stmt_len = 0\n    self.stmts.extend(stmts)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.args","title":"args  <code>property</code>","text":"<pre><code>args\n</code></pre> <p>Get the  arguments of the Block.</p> <p>Returns:</p> Name Type Description <code>BlockArguments</code> <code>BlockArguments</code> <p>The arguments view of the Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.first_stmt","title":"first_stmt  <code>property</code>","text":"<pre><code>first_stmt\n</code></pre> <p>Get the first Statement of the Block.</p> <p>Returns:</p> Type Description <code>Statement | None</code> <p>Statement | None: The first Statement of the Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.last_stmt","title":"last_stmt  <code>property</code>","text":"<pre><code>last_stmt\n</code></pre> <p>Get the last Statement of the Block.</p> <p>Returns:</p> Type Description <code>Statement | None</code> <p>Statement | None: The last Statement of the Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.parent_node","title":"parent_node  <code>property</code> <code>writable</code>","text":"<pre><code>parent_node\n</code></pre> <p>Get parent Region of the Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.parent_stmt","title":"parent_stmt  <code>property</code>","text":"<pre><code>parent_stmt\n</code></pre> <p>parent statement of the Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.stmts","title":"stmts  <code>property</code>","text":"<pre><code>stmts\n</code></pre> <p>Get the list of Statements of the Block.</p> <p>Returns:</p> Name Type Description <code>BlockStmts</code> <code>BlockStmts</code> <p>The Statements of the Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.delete","title":"delete","text":"<pre><code>delete(safe=True)\n</code></pre> <p>Delete the Block completely from the IR.</p> Note <p>This method will detach + remove references of the block.</p> <p>Parameters:</p> Name Type Description Default <code>safe</code> <code>bool</code> <p>If True, raise error if there is anything that still reference components in the block. Defaults to True.</p> <code>True</code> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def delete(self, safe: bool = True) -&gt; None:\n    \"\"\"Delete the Block completely from the IR.\n\n    Note:\n        This method will detach + remove references of the block.\n\n    Args:\n        safe (bool, optional): If True, raise error if there is anything that still reference components in the block. Defaults to True.\n    \"\"\"\n    self.detach()\n    self.drop_all_references()\n    for stmt in self.stmts:\n        stmt.delete(safe=safe)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.detach","title":"detach","text":"<pre><code>detach()\n</code></pre> <p>Detach this Block from the IR.</p> Note <p>Detach only detach the Block from the IR graph. It does not remove uses that reference the Block.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def detach(self) -&gt; None:\n    \"\"\"Detach this Block from the IR.\n\n    Note:\n        Detach only detach the Block from the IR graph. It does not remove uses that reference the Block.\n    \"\"\"\n    if self.parent is None:\n        return\n\n    idx = self.parent[self]\n    del self.parent._blocks[idx]\n    del self.parent._block_idx[self]\n    for block in self.parent._blocks[idx:]:\n        self.parent._block_idx[block] -= 1\n    self.parent = None\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.drop_all_references","title":"drop_all_references","text":"<pre><code>drop_all_references()\n</code></pre> <p>Remove all the dependency that reference/uses this Block.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def drop_all_references(self) -&gt; None:\n    \"\"\"Remove all the dependency that reference/uses this Block.\"\"\"\n    self.parent = None\n    for stmt in self.stmts:\n        stmt.drop_all_references()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.is_structurally_equal","title":"is_structurally_equal","text":"<pre><code>is_structurally_equal(other, context=None)\n</code></pre> <p>Check if the Block is structurally equal to another Block.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>The other Block to compare with.</p> required <code>context</code> <code>dict[IRNode | SSAValue, IRNode | SSAValue] | None</code> <p>A map of IRNode/SSAValue to hint that they are equivalent so the check will treat them as equivalent. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the Block is structurally equal to the other Block.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def is_structurally_equal(\n    self,\n    other: Self,\n    context: dict[IRNode | SSAValue, IRNode | SSAValue] | None = None,\n) -&gt; bool:\n    \"\"\"Check if the Block is structurally equal to another Block.\n\n    Args:\n        other (Self): The other Block to compare with.\n        context (dict[IRNode  |  SSAValue, IRNode  |  SSAValue] | None, optional): A map of IRNode/SSAValue to hint that they are equivalent so the check will treat them as equivalent. Defaults to None.\n\n    Returns:\n        bool: True if the Block is structurally equal to the other Block.\n    \"\"\"\n    if context is None:\n        context = {}\n\n    if len(self._args) != len(other._args) or len(self.stmts) != len(other.stmts):\n        return False\n\n    for arg, other_arg in zip(self._args, other._args):\n        if arg.type != other_arg.type:\n            return False\n        context[arg] = other_arg\n\n    context[self] = other\n    if not all(\n        stmt.is_structurally_equal(other_stmt, context)\n        for stmt, other_stmt in zip(self.stmts, other.stmts)\n    ):\n        return False\n\n    return True\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.typecheck","title":"typecheck","text":"<pre><code>typecheck()\n</code></pre> <p>Checking the types of the Statments in the Block.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def typecheck(self) -&gt; None:\n    \"\"\"Checking the types of the Statments in the Block.\"\"\"\n    for stmt in self.stmts:\n        stmt.typecheck()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.verify","title":"verify","text":"<pre><code>verify()\n</code></pre> <p>Verify the correctness of the Block.</p> <p>Raises:</p> Type Description <code>VerificationError</code> <p>If the Block is not correct.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def verify(self) -&gt; None:\n    \"\"\"Verify the correctness of the Block.\n\n    Raises:\n        VerificationError: If the Block is not correct.\n    \"\"\"\n    from kirin.ir.nodes.stmt import Region\n\n    if not isinstance(self.parent, Region):\n        raise VerificationError(self, \"Parent is not a region\")\n\n    for stmt in self.stmts:\n        stmt.verify()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.walk","title":"walk","text":"<pre><code>walk(*, reverse=False, region_first=False)\n</code></pre> <p>Traversal the Statements in a Block.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>If walk in the reversed manner. Defaults to False.</p> <code>False</code> <code>region_first</code> <code>bool</code> <p>If the walk should go through the Statement first or the Region of a Statement first. Defaults to False.</p> <code>False</code> <p>Yields:</p> Type Description <code>Statement</code> <p>Iterator[Statement]: An iterator that yield Statements in the Block in the specified order.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def walk(\n    self, *, reverse: bool = False, region_first: bool = False\n) -&gt; Iterator[Statement]:\n    \"\"\"Traversal the Statements in a Block.\n\n    Args:\n        reverse (bool, optional): If walk in the reversed manner. Defaults to False.\n        region_first (bool, optional): If the walk should go through the Statement first or the Region of a Statement first. Defaults to False.\n\n    Yields:\n        Iterator[Statement]: An iterator that yield Statements in the Block in the specified order.\n    \"\"\"\n    for stmt in reversed(self.stmts) if reverse else self.stmts:\n        yield from stmt.walk(reverse=reverse, region_first=region_first)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockArguments","title":"BlockArguments  <code>dataclass</code>","text":"<pre><code>BlockArguments(node, field)\n</code></pre> <p>               Bases: <code>MutableSequenceView[tuple, 'Block', BlockArgument]</code></p> <p>A View object that contains a list of BlockArgument.</p> Description <p>This is a proxy object that provide safe API to manipulate the arguments of a Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockArguments.append_from","title":"append_from","text":"<pre><code>append_from(typ, name=None)\n</code></pre> <p>Append a new argument to the Block that this View reference to.</p> Description <p>This method will create a new <code>BlockArgument</code> and append it to the argument list of the reference <code>Block</code>.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>TypeAttribute</code> <p>The type of the argument.</p> required <code>name</code> <code>str | None</code> <p>name of the argument. Defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>BlockArgument</code> <code>BlockArgument</code> <p>The newly created <code>BlockArgument</code>.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def append_from(self, typ: TypeAttribute, name: str | None = None) -&gt; BlockArgument:\n    \"\"\"Append a new argument to the Block that this View reference to.\n\n    Description:\n        This method will create a new [`BlockArgument`](kirin.ir.BlockArgument) and append it to the argument list\n        of the reference `Block`.\n\n    Args:\n        typ (TypeAttribute): The type of the argument.\n        name (str | None, optional): name of the argument. Defaults to `None`.\n\n    Returns:\n        BlockArgument: The newly created [`BlockArgument`](kirin.ir.BlockArgument).\n\n    \"\"\"\n    new_arg = BlockArgument(self.node, len(self.node._args), typ)\n    if name:\n        new_arg.name = name\n\n    self.node._args += (new_arg,)\n    return new_arg\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockArguments.delete","title":"delete","text":"<pre><code>delete(arg, safe=True)\n</code></pre> <p>Delete a BlockArgument from the Block that this View reference to.</p> <p>Parameters:</p> Name Type Description Default <code>arg</code> <code>BlockArgument</code> <p>description</p> required <code>safe</code> <code>bool</code> <p>If True, error will be raised if the BlockArgument has any Use by others.  Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the argument does not belong to the reference block.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def delete(self, arg: BlockArgument, safe: bool = True) -&gt; None:\n    \"\"\"Delete a BlockArgument from the Block that this View reference to.\n\n\n    Args:\n        arg (BlockArgument): _description_\n        safe (bool, optional): If True, error will be raised if the BlockArgument has any Use by others.  Defaults to True.\n\n    Raises:\n        ValueError: If the argument does not belong to the reference block.\n    \"\"\"\n    if arg.block is not self.node:\n        raise ValueError(\"Attempt to delete an argument that is not in the block\")\n\n    for block_arg in self.field[arg.index + 1 :]:\n        block_arg.index -= 1\n    self.node._args = (*self.field[: arg.index], *self.field[arg.index + 1 :])\n    arg.delete(safe=safe)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockArguments.insert_from","title":"insert_from","text":"<pre><code>insert_from(idx, typ, name=None)\n</code></pre> <p>Insert a new argument to the Block that this View reference to.</p> Description <p>This method will create a new <code>BlockArgument</code> and insert it to the argument list of the reference Block at the specified index</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>Insert location index.</p> required <code>typ</code> <code>TypeAttribute</code> <p>The type of the argument.</p> required <code>name</code> <code>str | None</code> <p>Name of the argument. Defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>BlockArgument</code> <code>BlockArgument</code> <p>The newly created BlockArgument.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def insert_from(\n    self, idx: int, typ: TypeAttribute, name: str | None = None\n) -&gt; BlockArgument:\n    \"\"\"Insert a new argument to the Block that this View reference to.\n\n    Description:\n        This method will create a new `BlockArgument` and insert it to the argument list\n        of the reference Block at the specified index\n\n    Args:\n        idx (int): Insert location index.\n        typ (TypeAttribute): The type of the argument.\n        name (str | None, optional): Name of the argument. Defaults to `None`.\n\n    Returns:\n        BlockArgument: The newly created BlockArgument.\n    \"\"\"\n    if idx &lt; 0 or idx &gt; len(self.node._args):\n        raise ValueError(\"Invalid index\")\n\n    new_arg = BlockArgument(self.node, idx, typ)\n    if name:\n        new_arg.name = name\n\n    for arg in self.node._args[idx:]:\n        arg.index += 1\n    self.node._args = self.node._args[:idx] + (new_arg,) + self.node._args[idx:]\n    return new_arg\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockStmts","title":"BlockStmts  <code>dataclass</code>","text":"<pre><code>BlockStmts(node)\n</code></pre> <p>               Bases: <code>View['Block', 'Statement']</code></p> <p>A View object that contains a list of Statements.</p> Description <p>This is a proxy object that provide safe API to manipulate the statements of a Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockStmts.append","title":"append","text":"<pre><code>append(value)\n</code></pre> <p>Append a Statement to the reference Block.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Statement</code> <p>A Statement to be appended.</p> required Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def append(self, value: Statement) -&gt; None:\n    \"\"\"Append a Statement to the reference Block.\n\n    Args:\n        value (Statement): A Statement to be appended.\n    \"\"\"\n    from kirin.ir.nodes.stmt import Statement\n\n    if not isinstance(value, Statement):\n        raise ValueError(f\"Expected Statement, got {type(value).__name__}\")\n\n    if self.node._stmt_len == 0:  # empty block\n        value.attach(self.node)\n        self.node._first_stmt = value\n        self.node._last_stmt = value\n        self.node._stmt_len += 1\n    elif self.node._last_stmt:\n        value.insert_after(self.node._last_stmt)\n    else:\n        raise ValueError(\"Invalid block, last_stmt is None\")\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockStmts.at","title":"at","text":"<pre><code>at(index)\n</code></pre> <p>This is similar to getitem but due to the nature of the linked list, it is less efficient than getitem.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def at(self, index: int) -&gt; Statement:\n    \"\"\"This is similar to __getitem__ but due to the nature of the linked list,\n    it is less efficient than __getitem__.\n    \"\"\"\n    if index &gt;= len(self):\n        raise IndexError(\"Index out of range\")\n\n    if index &lt; 0:\n        return self._at_reverse(-index - 1)\n\n    return self._at_forward(index)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/","title":"Region","text":""},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region","title":"Region  <code>dataclass</code>","text":"<pre><code>Region(blocks=(), parent=None)\n</code></pre> <p>               Bases: <code>IRNode['Statement']</code></p> <p>Region consist of a list of Blocks</p> <p>Parameters:</p> Name Type Description Default <code>blocks</code> <code>Block | Iterable[Block]</code> <p>A single Block object or an iterable of Block objects. Defaults to ().</p> <code>()</code> <code>parent</code> <code>Statement | None</code> <p>The parent Statement object. Defaults to None.</p> <code>None</code> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def __init__(\n    self,\n    blocks: Block | Iterable[Block] = (),\n    parent: Statement | None = None,\n):\n    \"\"\"Initialize a Region object.\n\n    Args:\n        blocks (Block | Iterable[Block], optional): A single Block object or an iterable of Block objects. Defaults to ().\n        parent (Statement | None, optional): The parent Statement object. Defaults to None.\n    \"\"\"\n    self._blocks = []\n    self._block_idx = {}\n    self.parent_node = parent\n    if isinstance(blocks, Block):\n        blocks = (blocks,)\n    for block in blocks:\n        self.blocks.append(block)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.blocks","title":"blocks  <code>property</code>","text":"<pre><code>blocks\n</code></pre> <p>Get the Blocks in the region.</p> <p>Returns:</p> Name Type Description <code>RegionBlocks</code> <code>RegionBlocks</code> <p>The blocks View object of the region.</p>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.parent_node","title":"parent_node  <code>property</code> <code>writable</code>","text":"<pre><code>parent_node\n</code></pre> <p>Get the parent statement of the region.</p>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.region_index","title":"region_index  <code>property</code>","text":"<pre><code>region_index\n</code></pre> <p>Get the index of the region within the parent scope.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The index of the region within the parent scope.</p>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(block)\n</code></pre> <p>Get the index of a block within the region.</p> <p>Parameters:</p> Name Type Description Default <code>block</code> <code>Block</code> <p>The block to get the index of.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the block does not belong to the region.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The index of the block within the region.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def __getitem__(self, block: Block) -&gt; int:\n    \"\"\"Get the index of a block within the region.\n\n    Args:\n        block (Block): The block to get the index of.\n\n    Raises:\n        ValueError: If the block does not belong to the region.\n\n    Returns:\n        int: The index of the block within the region.\n    \"\"\"\n    if block.parent is not self:\n        raise ValueError(\"Block does not belong to the region\")\n    return self._block_idx[block]\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.clone","title":"clone","text":"<pre><code>clone(ssamap=None)\n</code></pre> <p>Clone a region. This will clone all blocks and statements in the region. <code>SSAValue</code> defined outside the region will not be cloned unless provided in <code>ssamap</code>.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def clone(self, ssamap: dict[SSAValue, SSAValue] | None = None) -&gt; Region:\n    \"\"\"Clone a region. This will clone all blocks and statements in the region.\n    `SSAValue` defined outside the region will not be cloned unless provided in `ssamap`.\n    \"\"\"\n    ret = Region()\n    successor_map: dict[Block, Block] = {}\n    _ssamap = ssamap or {}\n    for block in self.blocks:\n        new_block = Block()\n        ret.blocks.append(new_block)\n        successor_map[block] = new_block\n        for arg in block.args:\n            new_arg = new_block.args.append_from(arg.type, arg.name)\n            _ssamap[arg] = new_arg\n\n    # update statements\n    for block in self.blocks:\n        for stmt in block.stmts:\n            new_stmt = stmt.from_stmt(\n                stmt,\n                args=[_ssamap[arg] for arg in stmt.args],\n                regions=[region.clone(_ssamap) for region in stmt.regions],\n                successors=[\n                    successor_map[successor] for successor in stmt.successors\n                ],\n            )\n            successor_map[block].stmts.append(new_stmt)\n            for result, new_result in zip(stmt.results, new_stmt.results):\n                _ssamap[result] = new_result\n\n    return ret\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.delete","title":"delete","text":"<pre><code>delete(safe=True)\n</code></pre> <p>Delete the Region completely from the IR graph.</p> Note <p>This method will detach + remove references of the Region.</p> <p>Parameters:</p> Name Type Description Default <code>safe</code> <code>bool</code> <p>If True, raise error if there is anything that still reference components in the Region. Defaults to True.</p> <code>True</code> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def delete(self, safe: bool = True) -&gt; None:\n    \"\"\"Delete the Region completely from the IR graph.\n\n    Note:\n        This method will detach + remove references of the Region.\n\n    Args:\n        safe (bool, optional): If True, raise error if there is anything that still reference components in the Region. Defaults to True.\n    \"\"\"\n    self.detach()\n    self.drop_all_references()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.detach","title":"detach","text":"<pre><code>detach(index=None)\n</code></pre> <p>Detach this Region from the IR tree graph.</p> Note <p>Detach only detach the Region from the IR graph. It does not remove uses that reference the Region.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def detach(self, index: int | None = None) -&gt; None:\n    \"\"\"Detach this Region from the IR tree graph.\n\n    Note:\n        Detach only detach the Region from the IR graph. It does not remove uses that reference the Region.\n    \"\"\"\n    # already detached\n    if self.parent_node is None:\n        return\n\n    if index is not None:\n        region_idx = index\n    else:\n        region_idx = self.region_index\n\n    del self.parent_node._regions[region_idx]\n    self.parent_node = None\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.drop_all_references","title":"drop_all_references","text":"<pre><code>drop_all_references()\n</code></pre> <p>Remove all the dependency that reference/uses this Region.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def drop_all_references(self) -&gt; None:\n    \"\"\"Remove all the dependency that reference/uses this Region.\"\"\"\n    self.parent_node = None\n    for block in self._blocks:\n        block.drop_all_references()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.is_structurally_equal","title":"is_structurally_equal","text":"<pre><code>is_structurally_equal(other, context=None)\n</code></pre> <p>Check if the Region is structurally equal to another Region.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>The other Region to compare with.</p> required <code>context</code> <code>dict[IRNode | SSAValue, IRNode | SSAValue] | None</code> <p>A map of IRNode/SSAValue to hint that they are equivalent so the check will treat them as equivalent. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the Region is structurally equal to the other Region.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def is_structurally_equal(\n    self,\n    other: Self,\n    context: dict[IRNode | SSAValue, IRNode | SSAValue] | None = None,\n) -&gt; bool:\n    \"\"\"Check if the Region is structurally equal to another Region.\n\n    Args:\n        other (Self): The other Region to compare with.\n        context (dict[IRNode  |  SSAValue, IRNode  |  SSAValue] | None, optional): A map of IRNode/SSAValue to hint that they are equivalent so the check will treat them as equivalent. Defaults to None.\n\n    Returns:\n        bool: True if the Region is structurally equal to the other Region.\n    \"\"\"\n    if context is None:\n        context = {}\n\n    if len(self.blocks) != len(other.blocks):\n        return False\n\n    for block, other_block in zip(self.blocks, other.blocks):\n        context[block] = other_block\n\n    if not all(\n        block.is_structurally_equal(other_block, context)\n        for block, other_block in zip(self.blocks, other.blocks)\n    ):\n        return False\n\n    return True\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.typecheck","title":"typecheck","text":"<pre><code>typecheck()\n</code></pre> <p>Checking the types of the Statments of Blocks in the Region.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def typecheck(self) -&gt; None:\n    \"\"\"Checking the types of the Statments of Blocks in the Region.\"\"\"\n    for block in self.blocks:\n        block.typecheck()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.verify","title":"verify","text":"<pre><code>verify()\n</code></pre> <p>Verify the correctness of the Region.</p> <p>Raises:</p> Type Description <code>VerificationError</code> <p>If the Region is not correct.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def verify(self) -&gt; None:\n    \"\"\"Verify the correctness of the Region.\n\n    Raises:\n        VerificationError: If the Region is not correct.\n    \"\"\"\n    from kirin.ir.nodes.stmt import Statement\n\n    if not isinstance(self.parent_node, Statement):\n        raise VerificationError(\n            self, \"expect Region to have a parent of type Statement\"\n        )\n\n    for block in self.blocks:\n        block.verify()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.walk","title":"walk","text":"<pre><code>walk(*, reverse=False, region_first=False)\n</code></pre> <p>Traversal the Statements of Blocks in the Region.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>If walk in the reversed manner. Defaults to False.</p> <code>False</code> <code>region_first</code> <code>bool</code> <p>If the walk should go through the Statement first or the Region of a Statement first. Defaults to False.</p> <code>False</code> <p>Yields:</p> Type Description <code>Statement</code> <p>Iterator[Statement]: An iterator that yield Statements of Blocks in the Region, in the specified order.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def walk(\n    self, *, reverse: bool = False, region_first: bool = False\n) -&gt; Iterator[Statement]:\n    \"\"\"Traversal the Statements of Blocks in the Region.\n\n    Args:\n        reverse (bool, optional): If walk in the reversed manner. Defaults to False.\n        region_first (bool, optional): If the walk should go through the Statement first or the Region of a Statement first. Defaults to False.\n\n    Yields:\n        Iterator[Statement]: An iterator that yield Statements of Blocks in the Region, in the specified order.\n    \"\"\"\n    for block in reversed(self.blocks) if reverse else self.blocks:\n        yield from block.walk(reverse=reverse, region_first=region_first)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.RegionBlocks","title":"RegionBlocks  <code>dataclass</code>","text":"<pre><code>RegionBlocks(node, field)\n</code></pre> <p>               Bases: <code>MutableSequenceView[list[Block], 'Region', Block]</code></p> <p>A View object that contains a list of Blocks of a Region.</p> Description <p>This is a proxy object that provide safe API to manipulate the Blocks of a Region.</p>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.RegionBlocks.__delitem__","title":"__delitem__","text":"<pre><code>__delitem__(idx)\n</code></pre> <p>Delete the Block at the specified index.</p> Note <p>This only detach the Block from the Region. It does not remove uses that reference the Block.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>The index of the Block to delete.</p> required Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def __delitem__(self, idx: int) -&gt; None:\n    \"\"\"Delete the Block at the specified index.\n\n    Note:\n        This only detach the Block from the Region. It does not remove uses that reference the Block.\n\n    Args:\n        idx (int): The index of the Block to delete.\n    \"\"\"\n    self.field[idx].detach()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.RegionBlocks.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(idx, block_or_blocks)\n</code></pre> <p>Replace/Set the Blocks of the Region.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int | slice</code> <p>The index or slice to replace the Blocks.</p> required <code>block_or_blocks</code> <code>Block | Iterable[Block]</code> <p>The Block or Blocks to replace the Blocks.</p> required Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def __setitem__(\n    self, idx: int | slice, block_or_blocks: Block | Iterable[Block]\n) -&gt; None:\n    \"\"\"Replace/Set the Blocks of the Region.\n\n    Args:\n        idx (int | slice): The index or slice to replace the Blocks.\n        block_or_blocks (Block | Iterable[Block]): The Block or Blocks to replace the Blocks.\n\n    \"\"\"\n    if isinstance(idx, int) and isinstance(block_or_blocks, Block):\n        self.field[idx].detach()\n        block_or_blocks.attach(self.node)\n        self.field[idx] = block_or_blocks\n        self.node._block_idx[block_or_blocks] = idx\n    elif isinstance(idx, slice) and isinstance(block_or_blocks, Iterable):\n        for block in block_or_blocks:\n            block.attach(self.node)\n        self.field[idx] = block_or_blocks\n        self.node._block_idx = {\n            block: i for i, block in enumerate(self.field)\n        }  # reindex\n    else:\n        raise ValueError(\"Invalid assignment\")\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.RegionBlocks.append","title":"append","text":"<pre><code>append(value)\n</code></pre> <p>Append a Block to the Region.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Block</code> <p>The block to be appended.</p> required Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def append(self, value: Block) -&gt; None:\n    \"\"\"Append a Block to the Region.\n\n    Args:\n        value (Block): The block to be appended.\n    \"\"\"\n    value.attach(self.node)\n    self.node._block_idx[value] = len(self.field)\n    self.field.append(value)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.RegionBlocks.insert","title":"insert","text":"<pre><code>insert(idx, value)\n</code></pre> <p>Inserts a Block at the specified index.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>The index at which to insert the block.</p> required <code>value</code> <code>Block</code> <p>The block to be inserted.</p> required Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def insert(self, idx: int, value: Block) -&gt; None:\n    \"\"\"Inserts a Block at the specified index.\n\n    Args:\n        idx (int): The index at which to insert the block.\n        value (Block): The block to be inserted.\n    \"\"\"\n    value.attach(self.node)\n    self.field.insert(idx, value)\n    for i, value in enumerate(self.field[idx:], idx):\n        self.node._block_idx[value] = i\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/","title":"Stmt","text":""},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement","title":"Statement  <code>dataclass</code>","text":"<pre><code>Statement(\n    *,\n    args=(),\n    regions=(),\n    successors=(),\n    attributes={},\n    properties={},\n    results=(),\n    result_types=(),\n    args_slice={},\n    source=None\n)\n</code></pre> <p>               Bases: <code>IRNode['Block']</code></p> <p>The Statment is an instruction in the IR</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.args","title":"args  <code>instance-attribute</code> <code>property</code> <code>writable</code>","text":"<pre><code>args = args\n</code></pre> <p>Get the arguments of the Statement.</p> <p>Returns:</p> Name Type Description <code>ArgumentList</code> <code>ArgumentList</code> <p>The arguments View of the Statement.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.next_stmt","title":"next_stmt  <code>property</code> <code>writable</code>","text":"<pre><code>next_stmt\n</code></pre> <p>Get the next statement.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.parent_block","title":"parent_block  <code>property</code>","text":"<pre><code>parent_block\n</code></pre> <p>Get the parent Block. FIXME whats the different btwn parent_node and parent_block?</p> <p>Returns:</p> Type Description <code>Block | None</code> <p>Block | None: The parent Block.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.parent_node","title":"parent_node  <code>property</code> <code>writable</code>","text":"<pre><code>parent_node\n</code></pre> <p>Get the parent node. FIXME whats the different btwn parent_node and parent_block?</p> <p>Returns:</p> Type Description <code>Block | None</code> <p>Block | None: The parent node.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.parent_region","title":"parent_region  <code>property</code>","text":"<pre><code>parent_region\n</code></pre> <p>Get the parent Region. Returns:     Region | None: The parent Region.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.parent_stmt","title":"parent_stmt  <code>property</code>","text":"<pre><code>parent_stmt\n</code></pre> <p>Get the parent statement.</p> <p>Returns:</p> Type Description <code>Statement | None</code> <p>Statement | None: The parent statement.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.prev_stmt","title":"prev_stmt  <code>property</code> <code>writable</code>","text":"<pre><code>prev_stmt\n</code></pre> <p>Get the previous statement.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.regions","title":"regions  <code>instance-attribute</code> <code>property</code> <code>writable</code>","text":"<pre><code>regions = list(regions)\n</code></pre> <p>Get a list of regions of the Statement.</p> <p>Returns:</p> Type Description <code>list[Region]</code> <p>list[Region]: The list of regions of the Statement.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.results","title":"results  <code>property</code>","text":"<pre><code>results\n</code></pre> <p>Get the result values of the Statement.</p> <p>Returns:</p> Name Type Description <code>ResultList</code> <code>ResultList</code> <p>The result values View of the Statement.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.delete","title":"delete","text":"<pre><code>delete(safe=True)\n</code></pre> <p>Delete the Statement completely from the IR graph.</p> Note <p>This method will detach + remove references of the Statement.</p> <p>Parameters:</p> Name Type Description Default <code>safe</code> <code>bool</code> <p>If True, raise error if there is anything that still reference components in the Statement. Defaults to True.</p> <code>True</code> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def delete(self, safe: bool = True) -&gt; None:\n    \"\"\"Delete the Statement completely from the IR graph.\n\n    Note:\n        This method will detach + remove references of the Statement.\n\n    Args:\n        safe (bool, optional): If True, raise error if there is anything that still reference components in the Statement. Defaults to True.\n    \"\"\"\n    self.detach()\n    self.drop_all_references()\n    for result in self._results:\n        result.delete(safe=safe)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.detach","title":"detach","text":"<pre><code>detach()\n</code></pre> <p>detach the statement from its parent block.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def detach(self) -&gt; None:\n    \"\"\"detach the statement from its parent block.\"\"\"\n    if self.parent is None:\n        return\n\n    parent: Block = self.parent\n    prev_stmt = self.prev_stmt\n    next_stmt = self.next_stmt\n\n    if prev_stmt is not None:\n        prev_stmt._next_stmt = next_stmt\n        self._prev_stmt = None\n    else:\n        assert (\n            parent._first_stmt is self\n        ), \"Invalid statement, has no prev_stmt but not first_stmt\"\n        parent._first_stmt = next_stmt\n\n    if next_stmt is not None:\n        next_stmt._prev_stmt = prev_stmt\n        self._next_stmt = None\n    else:\n        assert (\n            parent._last_stmt is self\n        ), \"Invalid statement, has no next_stmt but not last_stmt\"\n        parent._last_stmt = prev_stmt\n\n    self.parent = None\n    parent._stmt_len -= 1\n    return\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.drop_all_references","title":"drop_all_references","text":"<pre><code>drop_all_references()\n</code></pre> <p>Remove all the dependency that reference/uses this Statement.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def drop_all_references(self) -&gt; None:\n    \"\"\"Remove all the dependency that reference/uses this Statement.\"\"\"\n    self.parent = None\n    for idx, arg in enumerate(self._args):\n        arg.remove_use(Use(self, idx))\n    for region in self._regions:\n        region.drop_all_references()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.from_stmt","title":"from_stmt  <code>classmethod</code>","text":"<pre><code>from_stmt(\n    other,\n    args=None,\n    regions=None,\n    successors=None,\n    attributes=None,\n)\n</code></pre> <p>Create a similar Statement with new <code>ResultValue</code> and without attaching to any parent block. This still references to the old successor and regions.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>@classmethod\ndef from_stmt(\n    cls,\n    other: Statement,\n    args: Sequence[SSAValue] | None = None,\n    regions: list[Region] | None = None,\n    successors: list[Block] | None = None,\n    attributes: dict[str, Attribute] | None = None,\n) -&gt; Self:\n    \"\"\"Create a similar Statement with new `ResultValue` and without\n    attaching to any parent block. This still references to the old successor\n    and regions.\n    \"\"\"\n    obj = cls.__new__(cls)\n    Statement.__init__(\n        obj,\n        args=args or other._args,\n        regions=regions or other._regions,\n        successors=successors or other.successors,\n        attributes=attributes or other.attributes,\n        properties=other.properties,  # properties are immutable, thus no need to copy\n        result_types=[result.type for result in other._results],\n        args_slice=other._name_args_slice,\n    )\n    return obj\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.insert_after","title":"insert_after","text":"<pre><code>insert_after(stmt)\n</code></pre> <p>Insert the current Statement after the input Statement.</p> <p>Parameters:</p> Name Type Description Default <code>stmt</code> <code>Statement</code> <p>Input Statement.</p> required Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def insert_after(self, stmt: Statement) -&gt; None:\n    \"\"\"Insert the current Statement after the input Statement.\n\n    Args:\n        stmt (Statement): Input Statement.\n\n    \"\"\"\n    if self._next_stmt is not None and self._prev_stmt is not None:\n        raise ValueError(\n            f\"Cannot insert before a statement that is already in a block: {self.name}\"\n        )\n\n    if stmt._next_stmt is not None:\n        stmt._next_stmt._prev_stmt = self\n\n    self._prev_stmt = stmt\n    self._next_stmt = stmt._next_stmt\n\n    self.parent = stmt.parent\n    stmt._next_stmt = self\n\n    if self.parent:\n        self.parent._stmt_len += 1\n\n        if self._next_stmt is None:\n            self.parent._last_stmt = self\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.insert_before","title":"insert_before","text":"<pre><code>insert_before(stmt)\n</code></pre> <p>Insert the current Statement before the input Statement.</p> <p>Parameters:</p> Name Type Description Default <code>stmt</code> <code>Statement</code> <p>Input Statement.</p> required Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def insert_before(self, stmt: Statement) -&gt; None:\n    \"\"\"Insert the current Statement before the input Statement.\n\n    Args:\n        stmt (Statement): Input Statement.\n\n    \"\"\"\n    if self._next_stmt is not None and self._prev_stmt is not None:\n        raise ValueError(\n            f\"Cannot insert before a statement that is already in a block: {self.name}\"\n        )\n\n    if stmt._prev_stmt is not None:\n        stmt._prev_stmt._next_stmt = self\n\n    self._next_stmt = stmt\n    self._prev_stmt = stmt._prev_stmt\n\n    self.parent = stmt.parent\n    stmt._prev_stmt = self\n\n    if self.parent:\n        self.parent._stmt_len += 1\n\n        if self._prev_stmt is None:\n            self.parent._first_stmt = self\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.replace_by","title":"replace_by","text":"<pre><code>replace_by(stmt)\n</code></pre> <p>Replace the current Statement by the input Statement.</p> <p>Parameters:</p> Name Type Description Default <code>stmt</code> <code>Statement</code> <p>Input Statement.</p> required Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def replace_by(self, stmt: Statement) -&gt; None:\n    \"\"\"Replace the current Statement by the input Statement.\n\n    Args:\n        stmt (Statement): Input Statement.\n    \"\"\"\n    stmt.insert_before(self)\n    for result, old_result in zip(stmt._results, self._results):\n        old_result.replace_by(result)\n        if old_result.name:\n            result.name = old_result.name\n    self.delete()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/view/","title":"View","text":""},{"location":"reference/kirin/ir/nodes/view/#kirin.ir.nodes.view.MutableSequenceView","title":"MutableSequenceView  <code>dataclass</code>","text":"<pre><code>MutableSequenceView(node, field)\n</code></pre> <p>               Bases: <code>SequenceView[FieldType, NodeType, ElemType]</code></p>"},{"location":"reference/kirin/ir/nodes/view/#kirin.ir.nodes.view.MutableSequenceView.popfirst","title":"popfirst","text":"<pre><code>popfirst()\n</code></pre> <p>Pop the first element from the view.</p> <p>Returns:</p> Type Description <code>ElemType | None</code> <p>The first element in the view.</p> Source code in <code>src/kirin/ir/nodes/view.py</code> <pre><code>def popfirst(self) -&gt; ElemType | None:\n    \"\"\"Pop the first element from the view.\n\n    Returns:\n        The first element in the view.\n    \"\"\"\n    if self:\n        return self.pop(0)\n    return None\n</code></pre>"},{"location":"reference/kirin/ir/nodes/view/#kirin.ir.nodes.view.MutableSequenceView.poplast","title":"poplast","text":"<pre><code>poplast()\n</code></pre> <p>Pop the last element from the view.</p> <p>Returns:</p> Type Description <code>ElemType | None</code> <p>The last element in the view.</p> Source code in <code>src/kirin/ir/nodes/view.py</code> <pre><code>def poplast(self) -&gt; ElemType | None:\n    \"\"\"Pop the last element from the view.\n\n    Returns:\n        The last element in the view.\n    \"\"\"\n    if self:\n        return self.pop(-1)\n    return None\n</code></pre>"},{"location":"reference/kirin/lowering/","title":"Index","text":""},{"location":"reference/kirin/lowering/core/","title":"Core","text":""},{"location":"reference/kirin/lowering/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.FromPythonAST","title":"FromPythonAST","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.FromPythonAST.lower","title":"lower","text":"<pre><code>lower(state, node)\n</code></pre> <p>Entry point of dialect specific lowering.</p> Source code in <code>src/kirin/lowering/dialect.py</code> <pre><code>def lower(self, state: LoweringState, node: ast.AST) -&gt; Result:\n    \"\"\"Entry point of dialect specific lowering.\"\"\"\n    return getattr(self, f\"lower_{node.__class__.__name__}\", self.unreachable)(\n        state, node\n    )\n</code></pre>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.Method","title":"Method  <code>dataclass</code>","text":"<pre><code>Method(\n    mod,\n    py_func,\n    sym_name,\n    arg_names,\n    dialects,\n    code,\n    fields=tuple(),\n    file=\"\",\n    lineno=list(),\n    backedges=list(),\n    return_type=None,\n    inferred=False,\n    verified=False,\n)\n</code></pre> <p>               Bases: <code>Printable</code>, <code>Generic[Param, RetType]</code></p>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.Method.inferred","title":"inferred  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inferred = False\n</code></pre> <p>if typeinfer has been run on this method</p>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.Method.lineno","title":"lineno  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lineno = field(default_factory=list)\n</code></pre> <p>(, ) at the start of the statement call."},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.Method.verified","title":"verified  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>verified = False\n</code></pre> <p>if <code>code.verify</code> has been run on this method</p>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.Method.verify","title":"verify","text":"<pre><code>verify()\n</code></pre> <p>verify the method body.</p> Source code in <code>src/kirin/ir/method.py</code> <pre><code>def verify(self) -&gt; None:\n    \"\"\"verify the method body.\"\"\"\n    try:\n        self.code.verify()\n    except VerificationError as e:\n        msg = f'File \"{self.file}\"'\n        if isinstance(e.node, Statement):\n            if e.node.source:\n                msg += f\", line {e.node.source.lineno}\"\n            msg += f\", in {e.node.name}\"\n\n        msg += f\":\\n    Verification failed for {self.sym_name}: {e.args[0]}\"\n        raise Exception(msg) from e\n    self.verified = True\n    return\n</code></pre>"},{"location":"reference/kirin/lowering/frame/","title":"Frame","text":""},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame","title":"Frame  <code>dataclass</code>","text":"<pre><code>Frame(\n    state,\n    parent,\n    stream,\n    current_region,\n    entry_block,\n    current_block,\n    next_block=None,\n    defs=dict(),\n    globals=dict(),\n    captures=dict(),\n    capture_callback=None,\n)\n</code></pre>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.capture_callback","title":"capture_callback  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>capture_callback = None\n</code></pre> <p>callback function that creates a local SSAValue value when an captured value was used.</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.captures","title":"captures  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>captures = field(default_factory=dict)\n</code></pre> <p>values accessed from the parent frame</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.current_block","title":"current_block  <code>instance-attribute</code>","text":"<pre><code>current_block\n</code></pre> <p>current block being lowered</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.current_region","title":"current_region  <code>instance-attribute</code>","text":"<pre><code>current_region\n</code></pre> <p>current region being lowered</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.defs","title":"defs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>defs = field(default_factory=dict)\n</code></pre> <p>values defined in the current frame</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.entry_block","title":"entry_block  <code>instance-attribute</code>","text":"<pre><code>entry_block\n</code></pre> <p>entry block of the frame</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.globals","title":"globals  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>globals = field(default_factory=dict)\n</code></pre> <p>global values known to the current frame</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.next_block","title":"next_block  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_block = None\n</code></pre> <p>next block, if any</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.from_stmts","title":"from_stmts  <code>classmethod</code>","text":"<pre><code>from_stmts(\n    stmts,\n    state,\n    parent=None,\n    region=None,\n    block=None,\n    globals=None,\n    capture_callback=None,\n)\n</code></pre> <p>Create a new frame from a list of statements or a new <code>StmtStream</code>.</p> <ul> <li><code>stmts</code>: list of statements or a <code>StmtStream</code> to be lowered.</li> <li><code>region</code>: <code>Region</code> to append the new block to, <code>None</code> to create a new one, default <code>None</code>.</li> <li><code>block</code>: <code>Block</code> to append the new statements to, <code>None</code> to create a new one, default <code>None</code>.</li> <li><code>globals</code>: global variables, default <code>None</code>.</li> </ul> Source code in <code>src/kirin/lowering/frame.py</code> <pre><code>@classmethod\ndef from_stmts(\n    cls,\n    stmts: Sequence[ast.stmt] | StmtStream[ast.stmt],\n    state: \"LoweringState\",\n    parent: Optional[\"Frame\"] = None,\n    region: Optional[Region] = None,\n    block: Optional[Block] = None,\n    globals: dict[str, Any] | None = None,\n    capture_callback: Optional[CallbackFn] = None,\n):\n    \"\"\"Create a new frame from a list of statements or a new `StmtStream`.\n\n    - `stmts`: list of statements or a `StmtStream` to be lowered.\n    - `region`: `Region` to append the new block to, `None` to create a new one, default `None`.\n    - `block`: `Block` to append the new statements to, `None` to create a new one, default `None`.\n    - `globals`: global variables, default `None`.\n    \"\"\"\n    if not isinstance(stmts, StmtStream):\n        stmts = StmtStream(stmts)\n\n    block = block or Block()\n    if region:\n        region.blocks.append(block)\n\n    return cls(\n        state=state,\n        parent=parent,\n        stream=stmts,\n        current_region=region or Region(block),\n        entry_block=block,\n        current_block=block,\n        globals=globals or {},\n        capture_callback=capture_callback,\n    )\n</code></pre>"},{"location":"reference/kirin/lowering/result/","title":"Result","text":""},{"location":"reference/kirin/lowering/state/","title":"State","text":""},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.LoweringState","title":"LoweringState  <code>dataclass</code>","text":"<pre><code>LoweringState(\n    dialects,\n    registry,\n    lines,\n    lineno_offset,\n    col_offset,\n    source,\n    max_lines=3,\n    _current_frame=None,\n)\n</code></pre> <p>               Bases: <code>NodeVisitor</code></p>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.LoweringState.col_offset","title":"col_offset  <code>instance-attribute</code>","text":"<pre><code>col_offset\n</code></pre> <p>column offset at the beginning of the source</p>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.LoweringState.lineno_offset","title":"lineno_offset  <code>instance-attribute</code>","text":"<pre><code>lineno_offset\n</code></pre> <p>lineno offset at the beginning of the source</p>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.LoweringState.source","title":"source  <code>instance-attribute</code>","text":"<pre><code>source\n</code></pre> <p>source info of the current node</p>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.LoweringState.append_stmt","title":"append_stmt","text":"<pre><code>append_stmt(stmt)\n</code></pre> <p>Shorthand for appending a statement to the current block of current frame.</p> Source code in <code>src/kirin/lowering/state.py</code> <pre><code>def append_stmt(self, stmt: StmtType) -&gt; StmtType:\n    \"\"\"Shorthand for appending a statement to the current block of current frame.\"\"\"\n    return self.current_frame.append_stmt(stmt)\n</code></pre>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.LoweringState.exhaust","title":"exhaust","text":"<pre><code>exhaust(frame=None)\n</code></pre> <p>Exhaust given frame's stream. If not given, exhaust current frame's stream.</p> Source code in <code>src/kirin/lowering/state.py</code> <pre><code>def exhaust(self, frame: Frame | None = None) -&gt; Frame:\n    \"\"\"Exhaust given frame's stream. If not given, exhaust current frame's stream.\"\"\"\n    if not frame:\n        current_frame = self.current_frame\n    else:\n        current_frame = frame\n\n    stream = current_frame.stream\n    while stream.has_next():\n        stmt = stream.pop()\n        self.visit(stmt)\n    return current_frame\n</code></pre>"},{"location":"reference/kirin/lowering/stream/","title":"Stream","text":""},{"location":"reference/kirin/passes/","title":"Index","text":""},{"location":"reference/kirin/passes/abc/","title":"Abc","text":""},{"location":"reference/kirin/passes/fold/","title":"Fold","text":""},{"location":"reference/kirin/passes/inline/","title":"Inline","text":""},{"location":"reference/kirin/passes/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/print/","title":"Index","text":""},{"location":"reference/kirin/print/printable/","title":"Printable","text":""},{"location":"reference/kirin/print/printable/#kirin.print.printable.Printable","title":"Printable","text":""},{"location":"reference/kirin/print/printable/#kirin.print.printable.Printable.print","title":"print","text":"<pre><code>print(printer=None, analysis=None)\n</code></pre> <p>Entry point of the printing process.</p> <p>Parameters:</p> Name Type Description Default <code>printer</code> <code>Printer</code> <p><code>Printer</code> object to use for printing. If None, a new <code>Printer</code> object will be created.</p> <code>None</code> <code>analysis</code> <code>dict[SSAValue, Printable]</code> <p>Analysis results to use for printing. If <code>None</code>, no analysis results</p> <code>None</code> Source code in <code>src/kirin/print/printable.py</code> <pre><code>def print(\n    self,\n    printer: Printer | None = None,\n    analysis: dict[ir.SSAValue, Any] | None = None,\n) -&gt; None:\n    \"\"\"\n    Entry point of the printing process.\n\n    Args:\n        printer (Printer):\n            `Printer` object to use for printing.\n            If None, a new `Printer` object will be created.\n        analysis (dict[ir.SSAValue, Printable]):\n            Analysis results to use for printing. If `None`, no analysis results\n    \"\"\"\n    printer = self.__get_printer(printer, analysis)\n    self.print_impl(printer)\n    printer.plain_print(\"\\n\")  # add a new line in the end\n</code></pre>"},{"location":"reference/kirin/print/printer/","title":"Printer","text":""},{"location":"reference/kirin/print/printer/#kirin.print.printer.PrintState","title":"PrintState  <code>dataclass</code>","text":"<pre><code>PrintState(\n    ssa_id=IdTable[\"ir.SSAValue\"](),\n    block_id=lambda: IdTable[\"ir.Block\"](prefix=\"^\")(),\n    indent=0,\n    result_width=0,\n    indent_marks=list(),\n    rich_style=None,\n    rich_highlight=False,\n    messages=list(),\n)\n</code></pre>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.PrintState.result_width","title":"result_width  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result_width = 0\n</code></pre> <p>SSA-value column width in printing</p>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer","title":"Printer  <code>dataclass</code>","text":"<pre><code>Printer(stream=None, analysis=None, show_indent_mark=True)\n</code></pre> <p>               Bases: <code>Generic[IOType]</code></p> Source code in <code>src/kirin/print/printer.py</code> <pre><code>def __init__(\n    self,\n    stream: IOType | None = None,\n    analysis: dict[\"ir.SSAValue\", Printable] | None = None,\n    show_indent_mark: bool = True,\n):\n    self.stream = stream\n    self.analysis = analysis\n    self.console = Console(file=self.stream, highlight=False)\n    self.state = PrintState()\n    self.color = ColorScheme()\n    self.show_indent_mark = show_indent_mark\n</code></pre>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.show_indent_mark","title":"show_indent_mark  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>show_indent_mark = show_indent_mark\n</code></pre> <p>Whether to show indent marks, e.g \u2502</p>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.print","title":"print","text":"<pre><code>print(object)\n</code></pre> <p>entry point for printing an object</p> Source code in <code>src/kirin/print/printer.py</code> <pre><code>def print(self, object):\n    \"\"\"entry point for printing an object\"\"\"\n    if isinstance(object, Printable):\n        object.print_impl(self)\n    else:\n        fn = getattr(self, f\"print_{object.__class__.__name__}\", None)\n        if fn is None:\n            raise NotImplementedError(\n                f\"Printer for {object.__class__.__name__} not found\"\n            )\n        fn(object)\n</code></pre>"},{"location":"reference/kirin/rewrite/","title":"Index","text":""},{"location":"reference/kirin/rewrite/abc/","title":"Abc","text":""},{"location":"reference/kirin/rewrite/abc/#kirin.rewrite.abc.RewriteRule","title":"RewriteRule  <code>dataclass</code>","text":"<pre><code>RewriteRule()\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>A rewrite rule that matches and rewrites IR nodes.</p> <p>The rewrite rule is applied to an IR node by calling the instance with the node as an argument. The rewrite rule should mutate the node instead of returning a new node. A <code>RewriteResult</code> should be returned to indicate whether the rewrite rule has done something, whether the rewrite rule should terminate, and whether the rewrite rule has exceeded the maximum number of iterations.</p>"},{"location":"reference/kirin/rewrite/chain/","title":"Chain","text":""},{"location":"reference/kirin/rewrite/chain/#kirin.rewrite.chain.Chain","title":"Chain  <code>dataclass</code>","text":"<pre><code>Chain(rules)\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <p>Chain multiple rewrites together.</p> <p>The chain will apply each rewrite in order until one of the rewrites terminates.</p>"},{"location":"reference/kirin/rewrite/fixpoint/","title":"Fixpoint","text":""},{"location":"reference/kirin/rewrite/fixpoint/#kirin.rewrite.fixpoint.Fixpoint","title":"Fixpoint  <code>dataclass</code>","text":"<pre><code>Fixpoint(rule, max_iter=32)\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <p>Apply a rewrite rule until a fixpoint is reached.</p> <p>The rewrite rule is applied to the node until the rewrite rule does not do anything.</p>"},{"location":"reference/kirin/rewrite/fixpoint/#kirin.rewrite.fixpoint.Fixpoint--parameters","title":"Parameters","text":"<ul> <li><code>map</code>: The rewrite rule to apply.</li> <li><code>max_iter</code>: The maximum number of iterations to apply the rewrite rule. Default is 32.</li> </ul>"},{"location":"reference/kirin/rewrite/result/","title":"Result","text":""},{"location":"reference/kirin/rewrite/walk/","title":"Walk","text":""},{"location":"reference/kirin/rewrite/walk/#kirin.rewrite.walk.Walk","title":"Walk  <code>dataclass</code>","text":"<pre><code>Walk(\n    rule,\n    worklist=WorkList(),\n    reverse=False,\n    region_first=False,\n)\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <p>Walk through the IR nodes and apply a rewrite rule.</p> <p>The walk will apply the rewrite rule to each node in the IR tree in a depth-first order.</p>"},{"location":"reference/kirin/rewrite/walk/#kirin.rewrite.walk.Walk--parameters","title":"Parameters","text":"<ul> <li><code>map</code>: The rewrite rule to apply.</li> <li><code>reverse</code>: Whether to traverse the IR tree in reverse order. Default is <code>False</code>.</li> <li><code>region_first</code>: Whether to traverse the regions before the blocks. Default is <code>False</code>.</li> </ul>"},{"location":"reference/kirin/rules/","title":"Index","text":""},{"location":"reference/kirin/rules/alias/","title":"Alias","text":""},{"location":"reference/kirin/rules/apply_type/","title":"Apply type","text":""},{"location":"reference/kirin/rules/call2invoke/","title":"Call2invoke","text":""},{"location":"reference/kirin/rules/call2invoke/#kirin.rules.call2invoke.Call2Invoke","title":"Call2Invoke  <code>dataclass</code>","text":"<pre><code>Call2Invoke(results)\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <p>Rewrite a <code>Call</code> statement to an <code>Invoke</code> statement.</p>"},{"location":"reference/kirin/rules/cfg_compatify/","title":"Cfg compatify","text":""},{"location":"reference/kirin/rules/cse/","title":"Cse","text":""},{"location":"reference/kirin/rules/dce/","title":"Dce","text":""},{"location":"reference/kirin/rules/fold/","title":"Fold","text":""},{"location":"reference/kirin/rules/getitem/","title":"Getitem","text":""},{"location":"reference/kirin/rules/inline/","title":"Inline","text":""},{"location":"reference/kirin/rules/inline/#kirin.rules.inline.Inline","title":"Inline  <code>dataclass</code>","text":"<pre><code>Inline(heuristic)\n</code></pre> <p>               Bases: <code>RewriteRule</code></p>"},{"location":"reference/kirin/rules/inline/#kirin.rules.inline.Inline.heuristic","title":"heuristic  <code>instance-attribute</code>","text":"<pre><code>heuristic\n</code></pre> <p>inline heuristic that determines whether a function should be inlined</p>"}]}