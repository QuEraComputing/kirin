{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\: )\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Kirin","text":"<p>Kirin is the Kernel Intermediate Representation Infrastructure. It is a compiler infrastructure for building compilers for domain-specific languages (DSLs) that target scientific computing kernels.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>MLIR-like dialects as composable python packages</li> <li>Generated Python frontend for your DSLs</li> <li>Pythonic API for building compiler passes</li> <li>Julia-like abstract interpretation framework</li> <li>Builtin support for interpretation</li> <li>Builtin support Python type system and type inference</li> <li>Type hinted via modern Python type hints (you get all the auto-completes as you expect!)</li> </ul>"},{"location":"#kirins-mission","title":"Kirin's mission","text":"<p>Compiler toolchain for scientists. Scientists are building domain-specific languages (DSLs) for scientific purposes. These DSLs are often high-level, and their instructions are usually slower than the low-level instructions and thus result in smaller programs. The performance does not need to be as good as a native program, but scientists want good interactivity and fast prototyping. Most importantly, scientists expects writing their DSL in high-level languages like Python as their frontend.</p>"},{"location":"#acknowledgement","title":"Acknowledgement","text":"<p>While the mission and audience may be very different, Kirin has been deeply inspired by a few projects:</p> <ul> <li>MLIR, the concept of dialects and the way it is designed.</li> <li>xDSL, about how IR data structure &amp; interpreter should be designed in Python.</li> <li>Julia, abstract interpretation, and certain design choices for scientific community.</li> <li>JAX and numbda, the frontend syntax and the way it is designed.</li> <li>Symbolics.jl and its predecessors, the design of rule-based rewriter.</li> </ul>"},{"location":"#quick-example-the-beer-language","title":"Quick Example: the <code>beer</code> language","text":"<p>In this example, we will mutate python's semantics to support a small eDSL (embedded domain-specific language) called <code>beer</code>. It describes the process of brewing beer and get drunk.</p> <p>Before we start, let's sketch an example of the <code>beer</code> language:</p> <pre><code>@beer\ndef main(x):\n    beer = NewBeer(\"budlight\") # (1)!\n    Pour(beer, 12) # (2)!\n    Drink(beer) # (3)!\n    Puke() # (4)!\n    if x &gt; 1: # (5)!\n        Drink(NewBeer(\"heineken\")) # (6)!\n    else:\n        Drink(NewBeer(\"tsingdao\")) # (7)!\n    return x + 1 # (8)!\n</code></pre> <ol> <li>The <code>NewBeer</code> statement creates a new beer object with a given brand.</li> <li>The <code>Pour</code> statement pours a beer object.</li> <li>The <code>Drink</code> statement drinks a beer object.</li> <li>The <code>Puke</code> statement pukes. Now we are drunk!</li> <li>Instead of a normal <code>if else</code> branching statement, we execute the branches randomly because we are drunk.</li> <li>The <code>Drink</code> statement drinks a <code>heineken</code> beer object for some possibility.</li> <li>The <code>Drink</code> statement drinks a <code>tsingdao</code> beer object for some possibility.</li> <li>Doing some math to get a result.</li> </ol> <p>The beer language is wrapped with a decorator <code>@beer</code> to indicate that the function is written in the <code>beer</code> language instead of normal Python. (think about how would you program GPU kernels in Python, or how would you use <code>jax.jit</code> and <code>numba.jit</code> decorators).</p>"},{"location":"#defining-the-dialect","title":"Defining the dialect","text":"<p>First, let's define the dialect object, which is a registry for all the objects modeling the semantics.</p> <pre><code>from kirin import ir\n\ndialect = ir.Dialect(\"beer\")\n</code></pre>"},{"location":"#defining-the-statements","title":"Defining the statements","text":"<p>Next, we want to define a runtime value <code>Beer</code> for the <code>beer</code> language so that we may use later in our interpreter. This is just a standard Python <code>dataclass</code>.</p> <pre><code>from dataclasses import dataclass\n\n@dataclass\nclass Beer:\n    brand: str\n</code></pre> <p>Now, we can define the <code>beer</code> language's statements.</p> <pre><code>from kirin.decl import statement, info\nfrom kirin.dialects.py import types\n\n@statement(dialect=dialect)\nclass NewBeer(Statement):\n    name = \"new_beer\" # (1)!\n    traits = frozenset({ir.Pure()}) # (2)!\n    brand: ir.SSAValue = info.argument(types.String) # (3)!\n    result: ir.ResultValue = info.result(types.PyClass(Beer)) # (4)!\n</code></pre> <ol> <li>The <code>name</code> field specifies the name of the statement in the IR text format (e.g printing).</li> <li>The <code>traits</code> field specifies the statement's traits, in this case, it is a    pure function because each brand name uniquely identifies a    beer object.</li> <li>The <code>brand</code> field specifies the argument of the statement. It is a string value. The arguments    of a <code>Statement</code> must be <code>ir.SSAValue</code> objects with a    field specifier <code>info.argument</code> that optionally specifies the type of the argument. The type used    here is <code>types.String</code> which is not Python's type but a <code>TypeAttribute</code> object    from the <code>py.types</code> dialect.</li> <li>The <code>result</code> field specifies the result of the statement. Usually a statement only has one result    value. The type of the result must be <code>ir.ResultValue</code> with a field specifier     <code>info.result</code> that optionally specifies the type of the result.</li> </ol> <p>the <code>NewBeer</code> statement creates a new beer object with a given brand. Thus it takes a string as an argument and returns a <code>Beer</code> object. Click the plus sign above to see the corresponding explanation.</p> <pre><code>@statement(dialect=dialect)\nclass Drink(Statement):\n    name = \"drink\"\n    beverage: ir.SSAValue = info.argument(types.PyClass(Beer))\n</code></pre> <p>Similarly, we define <code>Drink</code> statement that takes a <code>Beer</code> object as an argument. The <code>types.PyClass</code> type from <code>py.type</code> dialect understands Python classes and can take a Python class as an argument to create a type attribute.</p> <pre><code>@statement(dialect=dialect)\nclass Pour(Statement):\n    name = \"pour\"\n    beverage: ir.SSAValue = info.argument(types.PyClass(Beer))\n    amount: ir.SSAValue = info.argument(types.Int)\n</code></pre> <p>The <code>Pour</code> statement takes a <code>Beer</code> object and an integer amount as arguments. The <code>types.Int</code> type is from the <code>py.types</code> dialect. Now we can define a more complicated statement that involves control flow.</p> <pre><code>@statement(dialect=dialect)\nclass RandomBranch(Statement):\n    name = \"random_br\"\n    traits = frozenset({IsTerminator()}) # (1)!\n    cond: SSAValue = info.argument(types.Bool) # (2)!\n    then_arguments: tuple[ir.SSAValue, ...] = info.argument() # (3)!\n    else_arguments: tuple[ir.SSAValue, ...] = info.argument() # (4)!\n    then_successor: ir.Block = info.block() # (5)!\n    else_successor: ir.Block = info.block() # (6)!\n</code></pre> <ol> <li>The <code>traits</code> field specifies that this statement is a terminator. A terminator is a statement that    ends a block. In this case, the <code>RandomBranch</code> statement is a terminator because it decides which    block to go next.</li> <li>The <code>cond</code> field specifies the condition of the branch. It is a boolean value.</li> <li>The <code>then_arguments</code> field specifies the arguments that are passed to the <code>then_successor</code> block. Unlike    previous examples, the <code>then_arguments</code> field is annotated with <code>tuple[ir.SSAValue, ...]</code>, which means    it takes a tuple of <code>ir.SSAValue</code> objects (like what it means in a <code>dataclass</code>).</li> <li>The <code>else_arguments</code> field specifies the arguments that are passed to the <code>else_successor</code> block.</li> <li>The <code>then_successor</code> field specifies the block that the control flow goes to if the condition is true.</li> <li>The <code>else_successor</code> field specifies the block that the control flow goes to if the condition is false.</li> </ol> <p>the <code>RandomBranch</code> statement is a terminator that takes a boolean condition and two tuples of arguments. However, unlike a normal <code>if else</code> branching statement, it does not execute the branches based on the condition. Instead, it randomly chooses one of the branches to execute.</p>"},{"location":"#defining-the-interpreter","title":"Defining the interpreter","text":"<p>Now with the statements defined, we can define how to interpret them</p> <pre><code>from kirin.interp import DialectInterpreter, Interpreter, ResultValue, Successor, impl\n\n@dialect.register\nclass BeerInterpreter(DialectInterpreter):\n    ...\n</code></pre> <p>the <code>BeerInterpreter</code> class is a subclass of <code>DialectInterpreter</code> that registers the implementation of each implementation. The implementation is a method decorated with <code>@impl</code> that executes the statement.</p> <pre><code>    @impl(NewBeer)\n    def new_beer(self, interp: Interpreter, stmt: NewBeer, values: tuple):\n        return ResultValue(Beer(values[0]))\n\n    @impl(Drink)\n    def drink(self, interp: Interpreter, stmt: Drink, values: tuple):\n        print(f\"Drinking {values[0].brand}\")\n        return ResultValue()\n\n    @impl(Pour)\n    def pour(self, interp: Interpreter, stmt: Pour, values: tuple):\n        print(f\"Pouring {values[0].brand} {values[1]}\")\n        return ResultValue()\n\n    @impl(Puke)\n    def puke(self, interp: Interpreter, stmt: Puke, values: tuple):\n        print(\"Puking!!!\")\n        return ResultValue()\n</code></pre> <p>Normally, most implementations are just straightforward like the above except that they will do more meaningful things than printing. The <code>ResultValue</code> object is a result type of the interpreter that saying the return value is just a normal tuple of values. This will be different when we implement interpretation for a terminator:</p> <pre><code>    @impl(RandomBranch)\n    def random_branch(self, interp: Interpreter, stmt: RandomBranch, values: tuple):\n        frame = interp.state.current_frame()\n        if randint(0, 1):\n            return Successor(\n                stmt.then_successor, *frame.get_values(stmt.then_arguments)\n            )\n        else:\n            return Successor(\n                stmt.else_successor, *frame.get_values(stmt.then_arguments)\n            )\n</code></pre> <p>The <code>random_branch</code> implementation randomly chooses one of the branches to execute. The return value is a <code>Successor</code> object that specifies the next block to execute and the arguments to pass to the block.</p>"},{"location":"#rewrite-python-if-else-statement-to-randombranch","title":"Rewrite Python <code>if else</code> statement to <code>RandomBranch</code>","text":"<p>Now we can define a rewrite pass that rewrites Python <code>if else</code> statement to <code>RandomBranch</code> statement. This is done by defining a subclass of <code>RewriteRule</code> and implementing the <code>rewrite_Statement</code> method. The <code>RewriteRule</code> class is a standard Python visitor on Kirin's IR.</p> <p>Here, we only need to implement the <code>rewrite_Statement</code> method to rewrite the <code>if else</code> statement to <code>RandomBranch</code>.</p> <pre><code>from kirin.dialects import cf # (1)!\nfrom kirin.rewrite import RewriteResult, RewriteRule # (2)!\n\n@dataclass\nclass RewriteToRandomBranch(RewriteRule):\n\n    def rewrite_Statement(self, node: ir.Statement) -&gt; RewriteResult: # (3)!\n        if not isinstance(node, cf.ConditionalBranch): # (4)!\n            return RewriteResult()\n        node.replace_by(\n            RandomBranch(\n                cond=node.cond,\n                then_arguments=node.then_arguments,\n                then_successor=node.then_successor,\n                else_arguments=node.else_arguments,\n                else_successor=node.else_successor,\n            )\n        )\n        return RewriteResult(has_done_something=True) # (5)!\n</code></pre> <ol> <li>Import the control flow dialect <code>cf</code> which is what Python <code>if else</code> statement compiles to by default in the <code>basic</code> dialect group.</li> <li>Import the <code>RewriteRule</code> class from the <code>rewrite</code> module.</li> <li>This is the signature of <code>rewrite_Statement</code> method. Your IDE should hint you the type signature so you can auto-complete it.</li> <li>Check if the statement is a <code>ConditionalBranch</code> statement. If it is not, return an empty <code>RewriteResult</code>.</li> <li>Replace the <code>ConditionalBranch</code> statement with a <code>RandomBranch</code> statement and return a <code>RewriteResult</code> that indicates the rewrite has been done. Every statement has a <code>replace_by</code> method that replaces the statement with another statement.</li> </ol>"},{"location":"#putting-everything-together","title":"Putting everything together","text":"<p>Now we can put everything together and finally create the <code>beer</code> decorator, and you do not need to figure out the complicated type hinting and decorator implementation because Kirin will do it for you!</p> <pre><code>from kirin.ir import dialect_group\nfrom kirin.prelude import basic_no_opt\nfrom kirin.rewrite import Fixpoint, Walk\n\n@dialect_group(basic_no_opt.add(dialect)) # (1)!\ndef beer(self): # (2)!\n    # some initialization if you need it\n    def run_pass(mt): # (3)!\n        Fixpoint(Walk(RandomWalkBranch())).rewrite(mt.code) # (4)!\n\n    return run_pass # (5)!\n</code></pre> <ol> <li>The <code>dialect_group</code> decorator specifies the dialect group that the <code>beer</code> dialect belongs to. In this case, instead of rebuilding the whole dialect group, we just add our <code>dialect</code> object to the <code>basic_no_opt</code> dialect group which provides all the basic Python semantics, such as math, function, closure, control flows, etc.</li> <li>The <code>beer</code> function is the decorator that will be used to decorate the <code>main</code> function.</li> <li>The <code>run_pass</code> function wraps all the passes that need to run on the input method. It optionally can take some arguments or keyword arguments that will be passed to the <code>beer</code> decorator.</li> <li>Inside the <code>run_pass</code> function, we will traverse the entire IR and rewrite all the <code>ConditionalBranch</code> statements to <code>RandomBranch</code> statements until no more rewrites can be done.</li> <li>Remember to return the <code>run_pass</code> function at the end of the <code>beer</code> function.</li> </ol> <p>This is it!</p>"},{"location":"#license","title":"License","text":"<p>Apache License 2.0</p>"},{"location":"101/","title":"Compiler 101 for scientists","text":""},{"location":"101/#what-is-purity","title":"What is purity?","text":""},{"location":"def/","title":"Understanding Kirin IR Declarations","text":""},{"location":"def/#ssa-values","title":"SSA Values","text":""},{"location":"def/#dialects","title":"Dialects","text":""},{"location":"def/#statements","title":"Statements","text":""},{"location":"def/#attributes","title":"Attributes","text":""},{"location":"def/#traits","title":"Traits","text":""},{"location":"def/#blocks","title":"Blocks","text":""},{"location":"def/#regions","title":"Regions","text":""},{"location":"install/","title":"Installation","text":"<p>Kirin is available in PyPI and thus can be installed via <code>pip</code>. Install Kirin using the following command:</p> <pre><code>pip install kirin-toolchain\n</code></pre> <p>Kirin supports Python 3.9 or later. We recommend using Python 3.10+ for the best experience.</p> <p>We strongly recommend developing your compiler project using <code>uv</code>, which is the official development environment for Kirin. You can install <code>uv</code> using the following command:</p> Linux and macOSWindows <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <p>then</p> <pre><code>uv add kirin-toolchain\n</code></pre> <pre><code>powershell -ExecutionPolicy ByPass -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n</code></pre> <p>then</p> <pre><code>uv add kirin-toolchain\n</code></pre>"},{"location":"install/#kirin-and-its-friends","title":"Kirin and its friends","text":"<p>Kirin also comes with a few friends that you might find useful:</p> <ul> <li><code>kirin-qasm</code>: (coming soon) A quantum assembly language (QASM 2.0) dialect for Kirin with a builtin QASM 2.0 text format parser.</li> <li><code>bloqade</code>: (available soon) QuEra's SDK for next-gen error-corrected neutral-atom quantum computers.</li> </ul>"},{"location":"install/#development","title":"Development","text":"<p>If you want to contribute to Kirin, you can clone the repository from GitHub:</p> <pre><code>git clone https://github.com/QuEraComputing/kirin.git\n</code></pre> <p>We use <code>uv</code> to manage the development environment, after you install <code>uv</code>, you can install the development dependencies using the following command:</p> <pre><code>uv sync\n</code></pre> <p>Our code review requires that you pass the tests and the linting checks. We recommend you to install <code>pre-commit</code> to run the checks before you commit your changes, the command line tool <code>pre-commit</code> has been installed as part of the development dependencies. You can setup <code>pre-commit</code> using the following command:</p> <pre><code>pre-commit install\n</code></pre>"},{"location":"install/#requirements","title":"Requirements","text":"<p>Kirin requires the following dependencies:</p> <ul> <li><code>rich</code>: for pretty-printing</li> <li><code>type-extensions</code>: for type hints</li> <li><code>beartype</code>: for runtime type checking and analysis of type hints in the python dialect</li> </ul>"},{"location":"reference/kirin/","title":"Index","text":""},{"location":"reference/kirin/exceptions/","title":"Exceptions","text":""},{"location":"reference/kirin/graph/","title":"Graph","text":""},{"location":"reference/kirin/graph/#kirin.graph.Graph","title":"Graph","text":"<p>               Bases: <code>Protocol</code>, <code>Generic[Node]</code></p> <p>The graph interface.</p> <p>This interface defines the methods that a graph object must implement. The graph interface is mainly for compatibility reasons so that one can use multiple graph implementations interchangeably.</p>"},{"location":"reference/kirin/graph/#kirin.graph.Graph.get_edges","title":"get_edges","text":"<pre><code>get_edges() -&gt; Iterable[tuple[Node, Node]]\n</code></pre> <p>Get all the edges in the graph.</p> Source code in <code>src/kirin/graph.py</code> <pre><code>def get_edges(self) -&gt; Iterable[tuple[Node, Node]]:\n    \"\"\"Get all the edges in the graph.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/graph/#kirin.graph.Graph.get_neighbors","title":"get_neighbors","text":"<pre><code>get_neighbors(node: Node) -&gt; Iterable[Node]\n</code></pre> <p>Get the neighbors of a node.</p> Source code in <code>src/kirin/graph.py</code> <pre><code>def get_neighbors(self, node: Node) -&gt; Iterable[Node]:\n    \"\"\"Get the neighbors of a node.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/graph/#kirin.graph.Graph.get_nodes","title":"get_nodes","text":"<pre><code>get_nodes() -&gt; Iterable[Node]\n</code></pre> <p>Get all the nodes in the graph.</p> Source code in <code>src/kirin/graph.py</code> <pre><code>def get_nodes(self) -&gt; Iterable[Node]:\n    \"\"\"Get all the nodes in the graph.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/idtable/","title":"IdTable","text":""},{"location":"reference/kirin/idtable/#kirin.idtable.IdTable","title":"IdTable  <code>dataclass</code>","text":"<pre><code>IdTable(\n    prefix: str = \"%\",\n    table: dict[T, str] = dict(),\n    name_count: dict[str, int] = dict(),\n    next_id: int = 0,\n)\n</code></pre> <p>               Bases: <code>Generic[T]</code></p> <p>A table that maps values to \"human readable\" unique names. This is used for IR printing and code generation of SSA values and basic blocks, or anything else required to have a unique name.</p>"},{"location":"reference/kirin/idtable/#kirin.idtable.IdTable--example","title":"Example","text":"<pre><code>from kirin import ir\nfrom kirin.idtable import IdTable\ntable = IdTable()\nx = ir.TestValue()\ntable[x] # \"%0\"\ntable[x] # \"%0\"\ny = ir.TestValue()\ntable[y] # \"%1\"\n</code></pre>"},{"location":"reference/kirin/idtable/#kirin.idtable.IdTable.name_count","title":"name_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name_count: dict[str, int] = field(default_factory=dict)\n</code></pre> <p>The count of names that have been generated.</p>"},{"location":"reference/kirin/idtable/#kirin.idtable.IdTable.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id: int = 0\n</code></pre> <p>The next ID to use for generating names.</p>"},{"location":"reference/kirin/idtable/#kirin.idtable.IdTable.prefix","title":"prefix  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>prefix: str = '%'\n</code></pre> <p>The prefix to use for generated names.</p>"},{"location":"reference/kirin/idtable/#kirin.idtable.IdTable.table","title":"table  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>table: dict[T, str] = field(default_factory=dict)\n</code></pre> <p>The table that maps values to names.</p>"},{"location":"reference/kirin/idtable/#kirin.idtable.IdTable.add","title":"add","text":"<pre><code>add(value: T) -&gt; str\n</code></pre> <p>Add a value to the table and return the name.</p> Source code in <code>src/kirin/idtable.py</code> <pre><code>def add(self, value: T) -&gt; str:\n    \"\"\"Add a value to the table and return the name.\"\"\"\n    id = self.next_id\n    if (value_name := getattr(value, \"name\", None)) is not None:\n        curr_ind = self.name_count.get(value_name, 0)\n        suffix = f\"_{curr_ind}\" if curr_ind != 0 else \"\"\n        self.name_count[value_name] = curr_ind + 1\n        name = self.prefix + value_name + suffix\n        self.table[value] = name\n    else:\n        name = f\"{self.prefix}{id}\"\n        self.next_id += 1\n        self.table[value] = name\n    return name\n</code></pre>"},{"location":"reference/kirin/lattice/","title":"Lattice","text":""},{"location":"reference/kirin/lattice/#kirin.lattice.EmptyLattice","title":"EmptyLattice","text":"<p>               Bases: <code>Lattice['EmptyLattice']</code></p> <p>Empty lattice.</p>"},{"location":"reference/kirin/lattice/#kirin.lattice.Lattice","title":"Lattice","text":"<p>               Bases: <code>ABC</code>, <code>Generic[LatticeParent]</code></p> <p>Abstract base class for lattices.</p>"},{"location":"reference/kirin/lattice/#kirin.lattice.LatticeMeta","title":"LatticeMeta","text":"<p>               Bases: <code>ABCMeta</code></p> <p>Metaclass for lattices.</p>"},{"location":"reference/kirin/lattice/#kirin.lattice.SingletonMeta","title":"SingletonMeta","text":"<pre><code>SingletonMeta(name, bases, attrs)\n</code></pre> <p>               Bases: <code>LatticeMeta</code></p> <p>Singleton metaclass for lattices. It ensures that only one instance of a lattice is created.</p> <p>See https://stackoverflow.com/questions/674304/why-is-init-always-called-after-new/8665179#8665179</p> Source code in <code>src/kirin/lattice.py</code> <pre><code>def __init__(cls, name, bases, attrs):\n    super().__init__(name, bases, attrs)\n    cls._instance = None\n</code></pre>"},{"location":"reference/kirin/lattice/#kirin.lattice.UnionMeta","title":"UnionMeta","text":"<p>               Bases: <code>LatticeMeta</code></p> <p>Meta class for union types. It simplifies the union if possible.</p>"},{"location":"reference/kirin/prelude/","title":"Prelude","text":""},{"location":"reference/kirin/prelude/#kirin.prelude.basic","title":"basic","text":"<pre><code>basic(self)\n</code></pre> <p>The basic kernel.</p> <p>This eDSL includes the basic dialects and the basic optimization passes. Other eDSL can usually be built on top of this eDSL by utilizing the <code>basic.add</code> method to add more dialects and optimization passes.</p> <p>See also <code>basic_no_opt</code> for the basic kernel without optimization passes.</p>"},{"location":"reference/kirin/prelude/#kirin.prelude.basic--example","title":"Example","text":"<pre><code>from kirin.prelude import basic\n\n@basic(typeinfer=True)\ndef main(x: int) -&gt; int:\n    return x + 1 + 1\n\nmain.print() # main is a Method!\n</code></pre> Source code in <code>src/kirin/prelude.py</code> <pre><code>@dialect_group(basic_no_opt)\ndef basic(self):\n    \"\"\"The basic kernel.\n\n    This eDSL includes the basic dialects and the basic optimization passes.\n    Other eDSL can usually be built on top of this eDSL by utilizing the\n    `basic.add` method to add more dialects and optimization passes.\n\n    See also [`basic_no_opt`][kirin.prelude.basic_no_opt] for the basic kernel without optimization passes.\n\n    ## Example\n\n    ```python\n    from kirin.prelude import basic\n\n    @basic(typeinfer=True)\n    def main(x: int) -&gt; int:\n        return x + 1 + 1\n\n    main.print() # main is a Method!\n    ```\n    \"\"\"\n    fold_pass = Fold(self)\n    aggressive_fold_pass = aggressive.Fold(self)\n    typeinfer_pass = TypeInfer(self)\n\n    def run_pass(\n        mt: Annotated[Method, Doc(\"The method to run pass on.\")],\n        *,\n        verify: Annotated[\n            bool, Doc(\"run `verify` before running passes, default is `True`\")\n        ] = True,\n        typeinfer: Annotated[\n            bool,\n            Doc(\n                \"run type inference and apply the inferred type to IR, default `False`\"\n            ),\n        ] = False,\n        fold: Annotated[bool, Doc(\"run folding passes\")] = True,\n        aggressive: Annotated[\n            bool, Doc(\"run aggressive folding passes if `fold=True`\")\n        ] = False,\n    ) -&gt; None:\n        if verify:\n            mt.verify()\n\n        if fold:\n            if aggressive:\n                aggressive_fold_pass.fixpoint(mt)\n            else:\n                fold_pass(mt)\n\n        if typeinfer:\n            typeinfer_pass(mt)\n\n    return run_pass\n</code></pre>"},{"location":"reference/kirin/prelude/#kirin.prelude.basic_no_opt","title":"basic_no_opt","text":"<pre><code>basic_no_opt(self)\n</code></pre> <p>The basic kernel without optimization passes.</p> <p>This eDSL includes the basic dialects without any optimization passes. Other eDSL can usually be built on top of this eDSL by utilizing the <code>basic_no_opt.add</code> method to add more dialects and optimization passes.</p> <p>See also <code>basic</code> for the basic kernel with optimization passes.</p> Source code in <code>src/kirin/prelude.py</code> <pre><code>@dialect_group([cf, fcf, func, math, types, data, stmts])\ndef basic_no_opt(self):\n    \"\"\"The basic kernel without optimization passes.\n\n    This eDSL includes the basic dialects without any optimization passes.\n    Other eDSL can usually be built on top of this eDSL by utilizing the\n    `basic_no_opt.add` method to add more dialects and optimization passes.\n\n    See also [`basic`][kirin.prelude.basic] for the basic kernel with optimization passes.\n    \"\"\"\n\n    def run_pass(mt: Method) -&gt; None:\n        pass\n\n    return run_pass\n</code></pre>"},{"location":"reference/kirin/source/","title":"Source","text":""},{"location":"reference/kirin/worklist/","title":"WorkList","text":""},{"location":"reference/kirin/worklist/#kirin.worklist.WorkList","title":"WorkList  <code>dataclass</code>","text":"<pre><code>WorkList()\n</code></pre> <p>               Bases: <code>Generic[ElemType]</code></p> <p>The worklist data structure.</p> <p>The worklist is a stack that allows for O(1) removal of elements from the stack.</p>"},{"location":"reference/kirin/analysis/","title":"Index","text":""},{"location":"reference/kirin/analysis/cfg/","title":"CFG","text":""},{"location":"reference/kirin/analysis/cfg/#kirin.analysis.cfg.CFG","title":"CFG  <code>dataclass</code>","text":"<pre><code>CFG(parent: ir.Region, entry: ir.Block | None = None)\n</code></pre> <p>               Bases: <code>Printable</code></p> <p>Control Flow Graph of a given IR statement.</p>"},{"location":"reference/kirin/analysis/cfg/#kirin.analysis.cfg.CFG.entry","title":"entry  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>entry: Block | None = None\n</code></pre> <p>Entry block of the CFG.</p>"},{"location":"reference/kirin/analysis/cfg/#kirin.analysis.cfg.CFG.parent","title":"parent  <code>instance-attribute</code>","text":"<pre><code>parent: Region\n</code></pre> <p>Parent IR statement.</p>"},{"location":"reference/kirin/analysis/cfg/#kirin.analysis.cfg.CFG.predecessors","title":"predecessors  <code>cached</code> <code>property</code>","text":"<pre><code>predecessors\n</code></pre> <p>CFG data, mapping a block to its predecessors.</p>"},{"location":"reference/kirin/analysis/cfg/#kirin.analysis.cfg.CFG.successors","title":"successors  <code>cached</code> <code>property</code>","text":"<pre><code>successors\n</code></pre> <p>CFG data, mapping a block to its neighbors.</p>"},{"location":"reference/kirin/analysis/dataflow/","title":"Index","text":""},{"location":"reference/kirin/analysis/dataflow/constprop/","title":"Constprop","text":""},{"location":"reference/kirin/analysis/dataflow/constprop/#kirin.analysis.dataflow.constprop.ConstProp","title":"ConstProp","text":"<pre><code>ConstProp(\n    dialects: ir.DialectGroup | Iterable[ir.Dialect],\n    *,\n    fuel: int | None = None,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192\n)\n</code></pre> <p>               Bases: <code>ForwardExtra[ConstPropLattice, ConstPropFrameInfo]</code></p> Source code in <code>src/kirin/analysis/dataflow/constprop.py</code> <pre><code>def __init__(\n    self,\n    dialects: ir.DialectGroup | Iterable[ir.Dialect],\n    *,\n    fuel: int | None = None,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192,\n):\n    super().__init__(\n        dialects,\n        fuel=fuel,\n        max_depth=max_depth,\n        max_python_recursion_depth=max_python_recursion_depth,\n    )\n    self.interp = Interpreter(\n        dialects,\n        fuel=fuel,\n        max_depth=max_depth,\n        max_python_recursion_depth=max_python_recursion_depth,\n    )\n</code></pre>"},{"location":"reference/kirin/analysis/dataflow/constprop/#kirin.analysis.dataflow.constprop.ConstProp.keys","title":"keys  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>keys = ['constprop', 'empty']\n</code></pre> <p>The name of the interpreter to select from dialects by order.</p>"},{"location":"reference/kirin/analysis/dataflow/constprop/#kirin.analysis.dataflow.constprop.ConstProp.eval_stmt","title":"eval_stmt","text":"<pre><code>eval_stmt(\n    stmt: ir.Statement, args: tuple\n) -&gt; interp_value.Result[ConstPropLattice]\n</code></pre> <p>simply evaluate a statement</p> Source code in <code>src/kirin/analysis/dataflow/constprop.py</code> <pre><code>def eval_stmt(\n    self, stmt: ir.Statement, args: tuple\n) -&gt; interp_value.Result[ConstPropLattice]:\n    if stmt.has_trait(ir.ConstantLike) or (\n        stmt.has_trait(ir.Pure) and all(isinstance(x, Const) for x in args)\n    ):\n        return self.try_eval_const(stmt, args)\n\n    sig = self.build_signature(stmt, args)\n    if sig in self.registry:\n        return self.registry[sig](self, stmt, args)\n    elif stmt.__class__ in self.registry:\n        return self.registry[stmt.__class__](self, stmt, args)\n    elif not stmt.has_trait(ir.Pure):  # not specified and not pure\n        # NOTE: this will return so result value is not assigned\n        # assign manually here.\n        frame = self.state.current_frame()\n        for result in stmt.results:\n            frame.entries[result] = NotPure()\n\n        frame.extra = ConstPropFrameInfo(not_pure=True)\n        return interp_value.ResultValue(NotPure())\n    else:\n        # fallback to NotConst for other pure statements\n        return interp_value.ResultValue(NotConst())\n</code></pre>"},{"location":"reference/kirin/analysis/dataflow/forward/","title":"Forward","text":""},{"location":"reference/kirin/analysis/dataflow/forward/#kirin.analysis.dataflow.forward.ForwardExtra","title":"ForwardExtra","text":"<pre><code>ForwardExtra(\n    dialects: DialectGroup | Iterable[Dialect],\n    *,\n    fuel: int | None = None,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192\n)\n</code></pre> <p>               Bases: <code>AbstractInterpreter[ForwardFrame[LatticeElemType, ExtraType], LatticeElemType]</code>, <code>Generic[LatticeElemType, ExtraType]</code></p> <p>Abstract interpreter but record results for each SSA value.</p> Source code in <code>src/kirin/analysis/dataflow/forward.py</code> <pre><code>def __init__(\n    self,\n    dialects: DialectGroup | Iterable[Dialect],\n    *,\n    fuel: int | None = None,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192,\n):\n    super().__init__(\n        dialects,\n        fuel=fuel,\n        max_depth=max_depth,\n        max_python_recursion_depth=max_python_recursion_depth,\n    )\n    self.results = {}\n</code></pre>"},{"location":"reference/kirin/analysis/dataflow/forward/#kirin.analysis.dataflow.forward.ForwardExtra.new_method_frame","title":"new_method_frame","text":"<pre><code>new_method_frame(\n    mt: Method,\n) -&gt; ForwardFrame[LatticeElemType, ExtraType]\n</code></pre> <p>Create a new frame for the given method.</p> Source code in <code>src/kirin/analysis/dataflow/forward.py</code> <pre><code>def new_method_frame(self, mt: Method) -&gt; ForwardFrame[LatticeElemType, ExtraType]:\n    return ForwardFrame.from_method(mt)\n</code></pre>"},{"location":"reference/kirin/analysis/dataflow/forward/#kirin.analysis.dataflow.forward.ForwardExtra.postprocess_frame","title":"postprocess_frame","text":"<pre><code>postprocess_frame(\n    frame: ForwardFrame[LatticeElemType, ExtraType]\n) -&gt; None\n</code></pre> <p>Postprocess a frame after it is popped from the stack. This is called after a method is evaluated and the frame is popped. Default implementation does nothing.</p> Source code in <code>src/kirin/analysis/dataflow/forward.py</code> <pre><code>def postprocess_frame(\n    self, frame: ForwardFrame[LatticeElemType, ExtraType]\n) -&gt; None:\n    self.results = frame.entries\n</code></pre>"},{"location":"reference/kirin/analysis/dataflow/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/analysis/dataflow/typeinfer/#kirin.analysis.dataflow.typeinfer.TypeInference","title":"TypeInference","text":"<pre><code>TypeInference(\n    dialects: DialectGroup | Iterable[Dialect],\n    *,\n    fuel: int | None = None,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192\n)\n</code></pre> <p>               Bases: <code>Forward[TypeAttribute]</code></p> Source code in <code>src/kirin/analysis/dataflow/forward.py</code> <pre><code>def __init__(\n    self,\n    dialects: DialectGroup | Iterable[Dialect],\n    *,\n    fuel: int | None = None,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192,\n):\n    super().__init__(\n        dialects,\n        fuel=fuel,\n        max_depth=max_depth,\n        max_python_recursion_depth=max_python_recursion_depth,\n    )\n    self.results = {}\n</code></pre>"},{"location":"reference/kirin/analysis/dataflow/typeinfer/#kirin.analysis.dataflow.typeinfer.TypeInference.keys","title":"keys  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>keys = ['typeinfer', 'typeinfer.default']\n</code></pre> <p>The name of the interpreter to select from dialects by order.</p>"},{"location":"reference/kirin/analysis/dataflow/typeinfer/#kirin.analysis.dataflow.typeinfer.TypeInference.build_signature","title":"build_signature","text":"<pre><code>build_signature(stmt: Statement, args: tuple)\n</code></pre> <p>we use value here as signature as they will be types</p> Source code in <code>src/kirin/analysis/dataflow/typeinfer.py</code> <pre><code>def build_signature(self, stmt: Statement, args: tuple):\n    \"\"\"we use value here as signature as they will be types\"\"\"\n    _args = []\n    for x in args:\n        if isinstance(x, types.PyConst):\n            _args.append(x.typ)\n        elif isinstance(x, types.PyGeneric):\n            _args.append(x.body)\n        else:\n            _args.append(x)\n\n    return (\n        stmt.__class__,\n        tuple(_args),\n    )\n</code></pre>"},{"location":"reference/kirin/codegen/","title":"Index","text":""},{"location":"reference/kirin/codegen/base/","title":"Base","text":""},{"location":"reference/kirin/codegen/base/#kirin.codegen.base.CodeGen","title":"CodeGen  <code>dataclass</code>","text":"<pre><code>CodeGen(dialects: ir.DialectGroup | Iterable[ir.Dialect])\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[Target]</code></p> Source code in <code>src/kirin/codegen/base.py</code> <pre><code>def __init__(self, dialects: ir.DialectGroup | Iterable[ir.Dialect]):\n    if not isinstance(dialects, ir.DialectGroup):\n        dialects = ir.DialectGroup(dialects)\n    self.dialects = dialects\n    self.registry = dialects.registry.codegen(self.keys)\n</code></pre>"},{"location":"reference/kirin/codegen/base/#kirin.codegen.base.CodeGen.build_signature","title":"build_signature","text":"<pre><code>build_signature(stmt: ir.Statement) -&gt; Signature\n</code></pre> <p>build signature for querying the statement implementation.</p> Source code in <code>src/kirin/codegen/base.py</code> <pre><code>def build_signature(self, stmt: ir.Statement) -&gt; \"Signature\":\n    \"\"\"build signature for querying the statement implementation.\"\"\"\n    return (stmt.__class__, tuple(arg.type for arg in stmt.args))\n</code></pre>"},{"location":"reference/kirin/codegen/base/#kirin.codegen.base.CodeGen.emit","title":"emit","text":"<pre><code>emit(mt: ir.Method) -&gt; Target\n</code></pre> <p>top-level entry point for code generation.</p> Source code in <code>src/kirin/codegen/base.py</code> <pre><code>def emit(self, mt: ir.Method) -&gt; Target:\n    \"\"\"top-level entry point for code generation.\"\"\"\n    return self.emit_Method(mt)\n</code></pre>"},{"location":"reference/kirin/codegen/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/codegen/dict/","title":"Dict","text":""},{"location":"reference/kirin/codegen/dict/#kirin.codegen.dict.DictGen","title":"DictGen  <code>dataclass</code>","text":"<pre><code>DictGen(dialects: ir.DialectGroup | Iterable[ir.Dialect])\n</code></pre> <p>               Bases: <code>CodeGen[dict]</code></p> Source code in <code>src/kirin/codegen/dict.py</code> <pre><code>def __init__(self, dialects: ir.DialectGroup | Iterable[ir.Dialect]):\n    super().__init__(dialects)\n    self.ssa_id = IdTable()\n    self.block_id = IdTable()\n</code></pre>"},{"location":"reference/kirin/codegen/dict/#kirin.codegen.dict.DictGen.emit","title":"emit","text":"<pre><code>emit(mt: ir.Method)\n</code></pre> <p>top-level entry point for code generation.</p> Source code in <code>src/kirin/codegen/dict.py</code> <pre><code>def emit(self, mt: ir.Method):\n    self.root = {\n        \"globals\": {},\n        \"methods\": {},\n        \"entry\": mt.sym_name,\n    }\n    self.root[mt.sym_name] = self.emit_Method(mt)\n    return self.root\n</code></pre>"},{"location":"reference/kirin/codegen/impl/","title":"Impl","text":""},{"location":"reference/kirin/codegen/ssa/","title":"Ssa","text":""},{"location":"reference/kirin/decl/","title":"Index","text":""},{"location":"reference/kirin/decl/base/","title":"Base","text":""},{"location":"reference/kirin/decl/camel2snake/","title":"Camel2snake","text":""},{"location":"reference/kirin/decl/info/","title":"Info","text":""},{"location":"reference/kirin/decl/info/#kirin.decl.info.ArgumentField","title":"ArgumentField  <code>dataclass</code>","text":"<pre><code>ArgumentField(\n    kw_only: bool,\n    alias: Optional[str],\n    type: TypeAttribute,\n    print: bool = True,\n    group: bool = False,\n)\n</code></pre> <p>               Bases: <code>Field</code></p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.ArgumentField.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>group: bool = False\n</code></pre> <p>if <code>True</code>, this argument is annotated with Tuple[SSAValue, ...]</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.ArgumentField.print","title":"print  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>print: bool = True\n</code></pre> <p>if <code>True</code>, this argument name is printed in the signature.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.ArgumentField.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: TypeAttribute\n</code></pre> <p>type of the argument, will be used in validation.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.AttributeField","title":"AttributeField  <code>dataclass</code>","text":"<pre><code>AttributeField(\n    kw_only: bool,\n    alias: Optional[str],\n    default: Any,\n    init: bool,\n    repr: bool,\n    default_factory: Optional[Callable[[], Attribute]],\n    type: TypeAttribute,\n    property: bool,\n    pytype: bool = False,\n)\n</code></pre> <p>               Bases: <code>Field</code></p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.AttributeField.pytype","title":"pytype  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pytype: bool = False\n</code></pre> <p>if <code>True</code>, annotation is a python type hint instead of <code>TypeAttribute</code></p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields","title":"StatementFields  <code>dataclass</code>","text":"<pre><code>StatementFields(\n    std_args: dict[str, ArgumentField] = dict(),\n    kw_args: dict[str, ArgumentField] = dict(),\n    results: dict[str, ResultField] = dict(),\n    regions: dict[str, RegionField] = dict(),\n    blocks: dict[str, BlockField] = dict(),\n    attributes: dict[str, AttributeField] = dict(),\n    properties: dict[str, AttributeField] = dict(),\n)\n</code></pre>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.args","title":"args  <code>property</code>","text":"<pre><code>args\n</code></pre> <p>iterable of all argument fields.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.attributes","title":"attributes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>attributes: dict[str, AttributeField] = field(\n    default_factory=dict\n)\n</code></pre> <p>attributes of the statement.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.blocks","title":"blocks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>blocks: dict[str, BlockField] = field(default_factory=dict)\n</code></pre> <p>blocks of the statement.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.kw_args","title":"kw_args  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kw_args: dict[str, ArgumentField] = field(\n    default_factory=dict\n)\n</code></pre> <p>keyword-only arguments of the statement.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.properties","title":"properties  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>properties: dict[str, AttributeField] = field(\n    default_factory=dict\n)\n</code></pre> <p>properties of the statement.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.regions","title":"regions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>regions: dict[str, RegionField] = field(\n    default_factory=dict\n)\n</code></pre> <p>regions of the statement.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.required_names","title":"required_names  <code>cached</code> <code>property</code>","text":"<pre><code>required_names\n</code></pre> <p>set of all fields that do not have a default value.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.results","title":"results  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>results: dict[str, ResultField] = field(\n    default_factory=dict\n)\n</code></pre> <p>results of the statement.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.std_args","title":"std_args  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>std_args: dict[str, ArgumentField] = field(\n    default_factory=dict\n)\n</code></pre> <p>standard arguments of the statement.</p>"},{"location":"reference/kirin/decl/scan_fields/","title":"Scan fields","text":""},{"location":"reference/kirin/decl/scan_fields/#kirin.decl.scan_fields.ScanFields","title":"ScanFields","text":"<pre><code>ScanFields(cls: type, **kwargs: Unpack[StatementOptions])\n</code></pre> <p>               Bases: <code>BaseModifier</code></p> Source code in <code>src/kirin/decl/base.py</code> <pre><code>def __init__(self, cls: type, **kwargs: Unpack[StatementOptions]) -&gt; None:\n    self.cls = cls\n    self.cls_module = sys.modules.get(cls.__module__)\n\n    if \"dialect\" in kwargs:\n        self.dialect = kwargs[\"dialect\"]\n    else:\n        self.dialect = None\n    self.params = kwargs\n    setattr(cls, self._PARAMS, self.params)\n\n    if cls.__module__ in sys.modules:\n        self.globals = sys.modules[cls.__module__].__dict__\n    else:\n        # Theoretically this can happen if someone writes\n        # a custom string to cls.__module__.  In which case\n        # such dataclass won't be fully introspectable\n        # (w.r.t. typing.get_type_hints) but will still function\n        # correctly.\n        self.globals: dict[str, Any] = {}\n\n    # analysis state, used by scan_field, etc.\n    self.fields = StatementFields()\n    self.has_statement_bases = False\n    self.kw_only = self.params.get(\"kw_only\", False)\n    self.KW_ONLY_seen = False\n</code></pre>"},{"location":"reference/kirin/decl/verify/","title":"Verify","text":""},{"location":"reference/kirin/decl/emit/","title":"Index","text":""},{"location":"reference/kirin/decl/emit/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/decl/emit/from_python_call/","title":"From python call","text":""},{"location":"reference/kirin/decl/emit/init/","title":"Init","text":""},{"location":"reference/kirin/decl/emit/name/","title":"Name","text":""},{"location":"reference/kirin/decl/emit/property/","title":"Property","text":""},{"location":"reference/kirin/decl/emit/repr/","title":"Repr","text":""},{"location":"reference/kirin/decl/emit/traits/","title":"Traits","text":""},{"location":"reference/kirin/decl/emit/typecheck/","title":"Typecheck","text":""},{"location":"reference/kirin/decl/emit/verify/","title":"Verify","text":""},{"location":"reference/kirin/dialects/","title":"Index","text":""},{"location":"reference/kirin/dialects/cf/","title":"Index","text":""},{"location":"reference/kirin/dialects/cf/constprop/","title":"Constprop","text":""},{"location":"reference/kirin/dialects/cf/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/dialects/cf/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/cf/lower/","title":"Lower","text":""},{"location":"reference/kirin/dialects/cf/stmts/","title":"Stmts","text":""},{"location":"reference/kirin/dialects/cf/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/dialects/fcf/","title":"Index","text":""},{"location":"reference/kirin/dialects/fcf/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/dialects/fcf/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/fcf/stmts/","title":"Stmts","text":""},{"location":"reference/kirin/dialects/fcf/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/dialects/func/","title":"Index","text":"<p>A function dialect that is compatible with python semantics.</p>"},{"location":"reference/kirin/dialects/func/attrs/","title":"Attrs","text":""},{"location":"reference/kirin/dialects/func/attrs/#kirin.dialects.func.attrs.Signature","title":"Signature  <code>dataclass</code>","text":"<pre><code>Signature(\n    inputs: tuple[TypeLatticeElem, ...],\n    output: TypeLatticeElem,\n)\n</code></pre> <p>               Bases: <code>Generic[TypeLatticeElem]</code>, <code>Attribute</code></p> <p>function body signature.</p> <p>This is not a type attribute because it just stores the signature of a function at its definition site. We don't perform type inference on this directly.</p> <p>The type of a function is the type of <code>inputs[0]</code>, which typically is a <code>MethodType</code>.</p>"},{"location":"reference/kirin/dialects/func/constprop/","title":"Constprop","text":""},{"location":"reference/kirin/dialects/func/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/dialects/func/emit/","title":"Emit","text":""},{"location":"reference/kirin/dialects/func/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/func/lower/","title":"Lower","text":""},{"location":"reference/kirin/dialects/func/stmts/","title":"Stmts","text":""},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.FuncOpCallableInterface","title":"FuncOpCallableInterface  <code>dataclass</code>","text":"<pre><code>FuncOpCallableInterface()\n</code></pre> <p>               Bases: <code>CallableStmtInterface['Function']</code></p>"},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.FuncOpCallableInterface.get_callable_region","title":"get_callable_region  <code>classmethod</code>","text":"<pre><code>get_callable_region(stmt: Function) -&gt; Region\n</code></pre> <p>Returns the body of the callable region</p> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>@classmethod\ndef get_callable_region(cls, stmt: \"Function\") -&gt; Region:\n    return stmt.body\n</code></pre>"},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.Invoke","title":"Invoke  <code>dataclass</code>","text":"<pre><code>Invoke(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.Invoke.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>run mandatory validation checks. This is not same as typecheck, which may be optional.</p> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>def verify(self) -&gt; None:\n    if self.kwargs:\n        for name in self.kwargs:\n            if name not in self.callee.arg_names:\n                raise VerificationError(\n                    self,\n                    f\"method {self.callee.sym_name} does not have argument {name}\",\n                )\n    elif len(self.callee.arg_names) - 1 != len(self.args):\n        raise VerificationError(\n            self,\n            f\"expected {len(self.callee.arg_names)} arguments, got {len(self.args)}\",\n        )\n</code></pre>"},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.Lambda","title":"Lambda  <code>dataclass</code>","text":"<pre><code>Lambda(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.Lambda.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>run mandatory validation checks. This is not same as typecheck, which may be optional.</p> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>def verify(self) -&gt; None:\n    if self.body.blocks.isempty():\n        raise VerificationError(self, \"lambda body must not be empty\")\n</code></pre>"},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.Return","title":"Return","text":"<pre><code>Return(value_or_stmt: SSAValue | Statement | None = None)\n</code></pre> <p>               Bases: <code>Statement</code></p> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>def __init__(self, value_or_stmt: SSAValue | Statement | None = None) -&gt; None:\n    if isinstance(value_or_stmt, SSAValue):\n        args = [value_or_stmt]\n    elif isinstance(value_or_stmt, Statement):\n        if len(value_or_stmt._results) == 1:\n            args = [value_or_stmt._results[0]]\n        else:\n            raise ValueError(\n                f\"expected a single result, got {len(value_or_stmt._results)} results from {value_or_stmt.name}\"\n            )\n    elif value_or_stmt is None:\n        args = []\n    else:\n        raise ValueError(f\"expected SSAValue or Statement, got {value_or_stmt}\")\n\n    super().__init__(args=args, args_slice={\"value\": 0})\n</code></pre>"},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.Return.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>run mandatory validation checks. This is not same as typecheck, which may be optional.</p> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>def verify(self) -&gt; None:\n    if not self.args:\n        raise VerificationError(\n            self, \"return statement must have at least one value\"\n        )\n\n    if len(self.args) &gt; 1:\n        raise VerificationError(\n            self,\n            \"return statement must have at most one value\"\n            \", wrap multiple values in a tuple\",\n        )\n</code></pre>"},{"location":"reference/kirin/dialects/func/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/dialects/math/","title":"Index","text":"<p>math dialect, modeling functions in python's <code>math</code> stdlib</p>"},{"location":"reference/kirin/dialects/math/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/dialects/math/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/math/stmts/","title":"Stmts","text":""},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.acos","title":"acos  <code>dataclass</code>","text":"<pre><code>acos(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>acos statement, wrapping the math.acos function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.asin","title":"asin  <code>dataclass</code>","text":"<pre><code>asin(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>asin statement, wrapping the math.asin function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.asinh","title":"asinh  <code>dataclass</code>","text":"<pre><code>asinh(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>asinh statement, wrapping the math.asinh function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.atan","title":"atan  <code>dataclass</code>","text":"<pre><code>atan(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>atan statement, wrapping the math.atan function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.atan2","title":"atan2  <code>dataclass</code>","text":"<pre><code>atan2(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>atan2 statement, wrapping the math.atan2 function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.atanh","title":"atanh  <code>dataclass</code>","text":"<pre><code>atanh(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>atanh statement, wrapping the math.atanh function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.ceil","title":"ceil  <code>dataclass</code>","text":"<pre><code>ceil(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>ceil statement, wrapping the math.ceil function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.copysign","title":"copysign  <code>dataclass</code>","text":"<pre><code>copysign(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>copysign statement, wrapping the math.copysign function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.cos","title":"cos  <code>dataclass</code>","text":"<pre><code>cos(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>cos statement, wrapping the math.cos function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.cosh","title":"cosh  <code>dataclass</code>","text":"<pre><code>cosh(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>cosh statement, wrapping the math.cosh function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.degrees","title":"degrees  <code>dataclass</code>","text":"<pre><code>degrees(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>degrees statement, wrapping the math.degrees function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.erf","title":"erf  <code>dataclass</code>","text":"<pre><code>erf(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>erf statement, wrapping the math.erf function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.erfc","title":"erfc  <code>dataclass</code>","text":"<pre><code>erfc(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>erfc statement, wrapping the math.erfc function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.exp","title":"exp  <code>dataclass</code>","text":"<pre><code>exp(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>exp statement, wrapping the math.exp function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.expm1","title":"expm1  <code>dataclass</code>","text":"<pre><code>expm1(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>expm1 statement, wrapping the math.expm1 function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.fabs","title":"fabs  <code>dataclass</code>","text":"<pre><code>fabs(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>fabs statement, wrapping the math.fabs function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.floor","title":"floor  <code>dataclass</code>","text":"<pre><code>floor(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>floor statement, wrapping the math.floor function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.fmod","title":"fmod  <code>dataclass</code>","text":"<pre><code>fmod(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>fmod statement, wrapping the math.fmod function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.gamma","title":"gamma  <code>dataclass</code>","text":"<pre><code>gamma(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>gamma statement, wrapping the math.gamma function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.isfinite","title":"isfinite  <code>dataclass</code>","text":"<pre><code>isfinite(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>isfinite statement, wrapping the math.isfinite function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.isinf","title":"isinf  <code>dataclass</code>","text":"<pre><code>isinf(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>isinf statement, wrapping the math.isinf function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.isnan","title":"isnan  <code>dataclass</code>","text":"<pre><code>isnan(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>isnan statement, wrapping the math.isnan function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.lgamma","title":"lgamma  <code>dataclass</code>","text":"<pre><code>lgamma(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>lgamma statement, wrapping the math.lgamma function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.log10","title":"log10  <code>dataclass</code>","text":"<pre><code>log10(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>log10 statement, wrapping the math.log10 function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.log1p","title":"log1p  <code>dataclass</code>","text":"<pre><code>log1p(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>log1p statement, wrapping the math.log1p function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.log2","title":"log2  <code>dataclass</code>","text":"<pre><code>log2(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>log2 statement, wrapping the math.log2 function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.pow","title":"pow  <code>dataclass</code>","text":"<pre><code>pow(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>pow statement, wrapping the math.pow function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.radians","title":"radians  <code>dataclass</code>","text":"<pre><code>radians(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>radians statement, wrapping the math.radians function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.remainder","title":"remainder  <code>dataclass</code>","text":"<pre><code>remainder(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>remainder statement, wrapping the math.remainder function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.sin","title":"sin  <code>dataclass</code>","text":"<pre><code>sin(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>sin statement, wrapping the math.sin function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.sinh","title":"sinh  <code>dataclass</code>","text":"<pre><code>sinh(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>sinh statement, wrapping the math.sinh function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.sqrt","title":"sqrt  <code>dataclass</code>","text":"<pre><code>sqrt(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>sqrt statement, wrapping the math.sqrt function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.tan","title":"tan  <code>dataclass</code>","text":"<pre><code>tan(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>tan statement, wrapping the math.tan function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.tanh","title":"tanh  <code>dataclass</code>","text":"<pre><code>tanh(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>tanh statement, wrapping the math.tanh function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.trunc","title":"trunc  <code>dataclass</code>","text":"<pre><code>trunc(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>trunc statement, wrapping the math.trunc function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.ulp","title":"ulp  <code>dataclass</code>","text":"<pre><code>ulp(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>ulp statement, wrapping the math.ulp function</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/py/","title":"Index","text":""},{"location":"reference/kirin/dialects/py/data/","title":"Data","text":""},{"location":"reference/kirin/dialects/py/rules/","title":"Index","text":""},{"location":"reference/kirin/dialects/py/rules/getitem/","title":"Getitem","text":""},{"location":"reference/kirin/dialects/py/stmts/","title":"Index","text":""},{"location":"reference/kirin/dialects/py/stmts/#kirin.dialects.py.stmts.Constant","title":"Constant","text":"<pre><code>Constant(value: T | data.PyAttr[T])\n</code></pre> <p>               Bases: <code>Statement</code>, <code>Generic[T]</code></p> Source code in <code>src/kirin/dialects/py/stmts/_stmts/constant.py</code> <pre><code>def __init__(self, value: T | data.PyAttr[T]) -&gt; None:\n    if not isinstance(value, data.PyAttr):\n        value = data.PyAttr(value)\n    super().__init__(\n        properties={\"value\": value},\n        result_types=(types.PyConst(value.data, value.type),),\n    )\n</code></pre>"},{"location":"reference/kirin/dialects/py/stmts/#kirin.dialects.py.stmts.Constant.typecheck","title":"typecheck","text":"<pre><code>typecheck() -&gt; None\n</code></pre> <p>check the type of the statement.</p> Note <ol> <li>Statement should implement typecheck. this is done automatically via @statement, but in the case manualy implementation is needed, it should be implemented here.</li> <li>This API should be called after all the types are figured out (by typeinfer)</li> </ol> Source code in <code>src/kirin/dialects/py/stmts/_stmts/constant.py</code> <pre><code>def typecheck(self) -&gt; None:\n    if not isinstance(self.result.type, types.PyType):\n        raise VerificationError(\n            self, f\"Expected result type to be PyType, got {self.result.type}\"\n        )\n</code></pre>"},{"location":"reference/kirin/dialects/py/stmts/#kirin.dialects.py.stmts.Range","title":"Range  <code>dataclass</code>","text":"<pre><code>Range(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/py/stmts/#kirin.dialects.py.stmts.Range.from_python_call","title":"from_python_call  <code>classmethod</code>","text":"<pre><code>from_python_call(\n    state: LoweringState, node: ast.Call\n) -&gt; Result\n</code></pre> <p>Converts a Python call expression to a Kirin IR node.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>LoweringState</code> <p>The current state of the lowering process.</p> required <code>node</code> <code>Call</code> <p>The Python call expression to be converted.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion is not implemented for the given call expression.</p> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>The converted Kirin IR node.</p> Source code in <code>src/kirin/dialects/py/stmts/_stmts/range.py</code> <pre><code>@classmethod\ndef from_python_call(cls, state: LoweringState, node: ast.Call) -&gt; Result:\n    if len(node.args) == 1:\n        start = state.visit(ast.Constant(0)).expect_one()\n        stop = state.visit(node.args[0]).expect_one()\n        step = state.visit(ast.Constant(1)).expect_one()\n    elif len(node.args) == 2:\n        start = state.visit(node.args[0]).expect_one()\n        stop = state.visit(node.args[1]).expect_one()\n        step = state.visit(ast.Constant(1)).expect_one()\n    elif len(node.args) == 3:\n        start = state.visit(node.args[0]).expect_one()\n        stop = state.visit(node.args[1]).expect_one()\n        step = state.visit(node.args[2]).expect_one()\n    else:\n        raise DialectLoweringError(\"range() takes 1-3 arguments\")\n\n    return Result(state.append_stmt(cls(start, stop, step)))\n</code></pre>"},{"location":"reference/kirin/dialects/py/stmts/#kirin.dialects.py.stmts.Slice","title":"Slice","text":"<pre><code>Slice(start: SSAValue, stop: SSAValue, step: SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> Source code in <code>src/kirin/dialects/py/stmts/_stmts/slice.py</code> <pre><code>def __init__(self, start: SSAValue, stop: SSAValue, step: SSAValue) -&gt; None:\n    if not (\n        isinstance(stop.type, types.PyType) and isinstance(start.type, types.PyType)\n    ):\n        result_type = types.Bottom\n    elif start.type.is_subtype(types.NoneType):\n        if stop.type.is_subtype(types.NoneType):\n            result_type = types.Bottom\n        else:\n            result_type = types.Slice[types.widen_const(stop.type)]\n    else:\n        result_type = types.Slice[types.widen_const(start.type)]\n\n    super().__init__(\n        args=(start, stop, step),\n        result_types=[result_type],\n        args_slice={\"start\": 0, \"stop\": 1, \"step\": 2},\n    )\n</code></pre>"},{"location":"reference/kirin/dialects/py/stmts/#kirin.dialects.py.stmts.Slice.from_python_call","title":"from_python_call  <code>classmethod</code>","text":"<pre><code>from_python_call(\n    state: LoweringState, node: ast.Call\n) -&gt; Result\n</code></pre> <p>Converts a Python call expression to a Kirin IR node.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>LoweringState</code> <p>The current state of the lowering process.</p> required <code>node</code> <code>Call</code> <p>The Python call expression to be converted.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion is not implemented for the given call expression.</p> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>The converted Kirin IR node.</p> Source code in <code>src/kirin/dialects/py/stmts/_stmts/slice.py</code> <pre><code>@classmethod\ndef from_python_call(cls, state: LoweringState, node: ast.Call) -&gt; Result:\n    if len(node.args) == 1:\n        start = state.visit(ast.Constant(None)).expect_one()\n        stop = state.visit(node.args[0]).expect_one()\n        step = state.visit(ast.Constant(None)).expect_one()\n    elif len(node.args) == 2:\n        start = state.visit(node.args[0]).expect_one()\n        stop = state.visit(node.args[1]).expect_one()\n        step = state.visit(ast.Constant(None)).expect_one()\n    elif len(node.args) == 3:\n        start = state.visit(node.args[0]).expect_one()\n        stop = state.visit(node.args[1]).expect_one()\n        step = state.visit(node.args[2]).expect_one()\n    else:\n        raise DialectLoweringError(\"slice() takes 1-3 arguments\")\n\n    return Result(state.append_stmt(cls(start, stop, step)))\n</code></pre>"},{"location":"reference/kirin/dialects/py/stmts/constprop/","title":"Constprop","text":""},{"location":"reference/kirin/dialects/py/stmts/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/dialects/py/stmts/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/py/stmts/lowering/","title":"Lowering","text":""},{"location":"reference/kirin/dialects/py/stmts/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/","title":"Index","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/assign/","title":"Assign","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/binop/","title":"Binop","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/boolean/","title":"Boolean","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/builtin/","title":"Builtin","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/cmp/","title":"Cmp","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/constant/","title":"Constant","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/constant/#kirin.dialects.py.stmts._stmts.constant.Constant","title":"Constant","text":"<pre><code>Constant(value: T | data.PyAttr[T])\n</code></pre> <p>               Bases: <code>Statement</code>, <code>Generic[T]</code></p> Source code in <code>src/kirin/dialects/py/stmts/_stmts/constant.py</code> <pre><code>def __init__(self, value: T | data.PyAttr[T]) -&gt; None:\n    if not isinstance(value, data.PyAttr):\n        value = data.PyAttr(value)\n    super().__init__(\n        properties={\"value\": value},\n        result_types=(types.PyConst(value.data, value.type),),\n    )\n</code></pre>"},{"location":"reference/kirin/dialects/py/stmts/_stmts/constant/#kirin.dialects.py.stmts._stmts.constant.Constant.typecheck","title":"typecheck","text":"<pre><code>typecheck() -&gt; None\n</code></pre> <p>check the type of the statement.</p> Note <ol> <li>Statement should implement typecheck. this is done automatically via @statement, but in the case manualy implementation is needed, it should be implemented here.</li> <li>This API should be called after all the types are figured out (by typeinfer)</li> </ol> Source code in <code>src/kirin/dialects/py/stmts/_stmts/constant.py</code> <pre><code>def typecheck(self) -&gt; None:\n    if not isinstance(self.result.type, types.PyType):\n        raise VerificationError(\n            self, f\"Expected result type to be PyType, got {self.result.type}\"\n        )\n</code></pre>"},{"location":"reference/kirin/dialects/py/stmts/_stmts/getattr/","title":"Getattr","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/getitem/","title":"Getitem","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/list/","title":"List","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/range/","title":"Range","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/range/#kirin.dialects.py.stmts._stmts.range.Range","title":"Range  <code>dataclass</code>","text":"<pre><code>Range(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/dialects/py/stmts/_stmts/range/#kirin.dialects.py.stmts._stmts.range.Range.from_python_call","title":"from_python_call  <code>classmethod</code>","text":"<pre><code>from_python_call(\n    state: LoweringState, node: ast.Call\n) -&gt; Result\n</code></pre> <p>Converts a Python call expression to a Kirin IR node.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>LoweringState</code> <p>The current state of the lowering process.</p> required <code>node</code> <code>Call</code> <p>The Python call expression to be converted.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion is not implemented for the given call expression.</p> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>The converted Kirin IR node.</p> Source code in <code>src/kirin/dialects/py/stmts/_stmts/range.py</code> <pre><code>@classmethod\ndef from_python_call(cls, state: LoweringState, node: ast.Call) -&gt; Result:\n    if len(node.args) == 1:\n        start = state.visit(ast.Constant(0)).expect_one()\n        stop = state.visit(node.args[0]).expect_one()\n        step = state.visit(ast.Constant(1)).expect_one()\n    elif len(node.args) == 2:\n        start = state.visit(node.args[0]).expect_one()\n        stop = state.visit(node.args[1]).expect_one()\n        step = state.visit(ast.Constant(1)).expect_one()\n    elif len(node.args) == 3:\n        start = state.visit(node.args[0]).expect_one()\n        stop = state.visit(node.args[1]).expect_one()\n        step = state.visit(node.args[2]).expect_one()\n    else:\n        raise DialectLoweringError(\"range() takes 1-3 arguments\")\n\n    return Result(state.append_stmt(cls(start, stop, step)))\n</code></pre>"},{"location":"reference/kirin/dialects/py/stmts/_stmts/slice/","title":"Slice","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/slice/#kirin.dialects.py.stmts._stmts.slice.Slice","title":"Slice","text":"<pre><code>Slice(start: SSAValue, stop: SSAValue, step: SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> Source code in <code>src/kirin/dialects/py/stmts/_stmts/slice.py</code> <pre><code>def __init__(self, start: SSAValue, stop: SSAValue, step: SSAValue) -&gt; None:\n    if not (\n        isinstance(stop.type, types.PyType) and isinstance(start.type, types.PyType)\n    ):\n        result_type = types.Bottom\n    elif start.type.is_subtype(types.NoneType):\n        if stop.type.is_subtype(types.NoneType):\n            result_type = types.Bottom\n        else:\n            result_type = types.Slice[types.widen_const(stop.type)]\n    else:\n        result_type = types.Slice[types.widen_const(start.type)]\n\n    super().__init__(\n        args=(start, stop, step),\n        result_types=[result_type],\n        args_slice={\"start\": 0, \"stop\": 1, \"step\": 2},\n    )\n</code></pre>"},{"location":"reference/kirin/dialects/py/stmts/_stmts/slice/#kirin.dialects.py.stmts._stmts.slice.Slice.from_python_call","title":"from_python_call  <code>classmethod</code>","text":"<pre><code>from_python_call(\n    state: LoweringState, node: ast.Call\n) -&gt; Result\n</code></pre> <p>Converts a Python call expression to a Kirin IR node.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>LoweringState</code> <p>The current state of the lowering process.</p> required <code>node</code> <code>Call</code> <p>The Python call expression to be converted.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion is not implemented for the given call expression.</p> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>The converted Kirin IR node.</p> Source code in <code>src/kirin/dialects/py/stmts/_stmts/slice.py</code> <pre><code>@classmethod\ndef from_python_call(cls, state: LoweringState, node: ast.Call) -&gt; Result:\n    if len(node.args) == 1:\n        start = state.visit(ast.Constant(None)).expect_one()\n        stop = state.visit(node.args[0]).expect_one()\n        step = state.visit(ast.Constant(None)).expect_one()\n    elif len(node.args) == 2:\n        start = state.visit(node.args[0]).expect_one()\n        stop = state.visit(node.args[1]).expect_one()\n        step = state.visit(ast.Constant(None)).expect_one()\n    elif len(node.args) == 3:\n        start = state.visit(node.args[0]).expect_one()\n        stop = state.visit(node.args[1]).expect_one()\n        step = state.visit(node.args[2]).expect_one()\n    else:\n        raise DialectLoweringError(\"slice() takes 1-3 arguments\")\n\n    return Result(state.append_stmt(cls(start, stop, step)))\n</code></pre>"},{"location":"reference/kirin/dialects/py/stmts/_stmts/tuple/","title":"Tuple","text":""},{"location":"reference/kirin/dialects/py/stmts/_stmts/unary/","title":"Unary","text":""},{"location":"reference/kirin/dialects/py/types/","title":"Index","text":""},{"location":"reference/kirin/dialects/py/types/base/","title":"Base","text":""},{"location":"reference/kirin/dialects/py/types/base/#kirin.dialects.py.types.base.PyConst","title":"PyConst  <code>dataclass</code>","text":"<pre><code>PyConst(data: Type, typ: PyType | None = None)\n</code></pre> <p>               Bases: <code>PyType</code>, <code>Generic[Type]</code></p> <p>This will not appear in user-space. It is used to pass around constant values interprocedurally.</p> Source code in <code>src/kirin/dialects/py/types/elem.py</code> <pre><code>def __init__(self, data: Type, typ: PyType | None = None):\n    self.data = data\n    if isinstance(typ, PyConst):\n        typ = widen_const(typ)\n\n    if typ is not None:\n        self.typ = typ\n    else:\n        self.typ = PyClass(type(data))\n</code></pre>"},{"location":"reference/kirin/dialects/py/types/base/#kirin.dialects.py.types.base.PyGeneric","title":"PyGeneric  <code>dataclass</code>","text":"<pre><code>PyGeneric(\n    body: type[Type] | PyClass[Type],\n    *vars: PyType | PyVararg\n)\n</code></pre> <p>               Bases: <code>PyType</code>, <code>Generic[Type]</code></p> Source code in <code>src/kirin/dialects/py/types/elem.py</code> <pre><code>def __init__(self, body: type[Type] | PyClass[Type], *vars: PyType | PyVararg):\n    if isinstance(body, PyClass):\n        self.body = body\n    else:\n        self.body = PyClass(body)\n\n    self.vars, self.vararg = split_type_args(vars)\n</code></pre>"},{"location":"reference/kirin/dialects/py/types/base/#kirin.dialects.py.types.base.PyGeneric.vararg","title":"vararg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>vararg: PyVararg | None = None\n</code></pre> <p>unknown type variables</p>"},{"location":"reference/kirin/dialects/py/types/builtin/","title":"Builtin","text":"<p>some convenient singleton wrapper for python.</p> <p>They should be equivalent directly construct PyClass.</p>"},{"location":"reference/kirin/dialects/py/types/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/dialects/py/types/elem/","title":"Elem","text":""},{"location":"reference/kirin/dialects/py/types/elem/#kirin.dialects.py.types.elem.PyConst","title":"PyConst  <code>dataclass</code>","text":"<pre><code>PyConst(data: Type, typ: PyType | None = None)\n</code></pre> <p>               Bases: <code>PyType</code>, <code>Generic[Type]</code></p> <p>This will not appear in user-space. It is used to pass around constant values interprocedurally.</p> Source code in <code>src/kirin/dialects/py/types/elem.py</code> <pre><code>def __init__(self, data: Type, typ: PyType | None = None):\n    self.data = data\n    if isinstance(typ, PyConst):\n        typ = widen_const(typ)\n\n    if typ is not None:\n        self.typ = typ\n    else:\n        self.typ = PyClass(type(data))\n</code></pre>"},{"location":"reference/kirin/dialects/py/types/elem/#kirin.dialects.py.types.elem.PyGeneric","title":"PyGeneric  <code>dataclass</code>","text":"<pre><code>PyGeneric(\n    body: type[Type] | PyClass[Type],\n    *vars: PyType | PyVararg\n)\n</code></pre> <p>               Bases: <code>PyType</code>, <code>Generic[Type]</code></p> Source code in <code>src/kirin/dialects/py/types/elem.py</code> <pre><code>def __init__(self, body: type[Type] | PyClass[Type], *vars: PyType | PyVararg):\n    if isinstance(body, PyClass):\n        self.body = body\n    else:\n        self.body = PyClass(body)\n\n    self.vars, self.vararg = split_type_args(vars)\n</code></pre>"},{"location":"reference/kirin/dialects/py/types/elem/#kirin.dialects.py.types.elem.PyGeneric.vararg","title":"vararg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>vararg: PyVararg | None = None\n</code></pre> <p>unknown type variables</p>"},{"location":"reference/kirin/dialects/py/types/emit/","title":"Emit","text":""},{"location":"reference/kirin/interp/","title":"Index","text":""},{"location":"reference/kirin/interp/abstract/","title":"Abstract","text":""},{"location":"reference/kirin/interp/abstract/#kirin.interp.abstract.AbstractInterpreter","title":"AbstractInterpreter","text":"<pre><code>AbstractInterpreter(\n    dialects: DialectGroup | Iterable[Dialect],\n    *,\n    fuel: int | None = None,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192\n)\n</code></pre> <p>               Bases: <code>Generic[AbstractFrameType, ResultType]</code>, <code>BaseInterpreter[AbstractFrameType, ResultType]</code></p> Source code in <code>src/kirin/interp/abstract.py</code> <pre><code>def __init__(\n    self,\n    dialects: DialectGroup | Iterable[Dialect],\n    *,\n    fuel: int | None = None,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192,\n):\n    super().__init__(\n        dialects,\n        fuel=fuel,\n        max_depth=max_depth,\n        max_python_recursion_depth=max_python_recursion_depth,\n    )\n    self.bottom = self.bottom_value()\n</code></pre>"},{"location":"reference/kirin/interp/abstract/#kirin.interp.abstract.AbstractInterpreter.new_method_frame","title":"new_method_frame  <code>abstractmethod</code>","text":"<pre><code>new_method_frame(mt: Method) -&gt; AbstractFrameType\n</code></pre> <p>Create a new frame for the given method.</p> Source code in <code>src/kirin/interp/abstract.py</code> <pre><code>@abstractmethod\ndef new_method_frame(self, mt: Method) -&gt; AbstractFrameType: ...\n</code></pre>"},{"location":"reference/kirin/interp/base/","title":"Base","text":""},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter","title":"BaseInterpreter","text":"<pre><code>BaseInterpreter(\n    dialects: DialectGroup | Iterable[Dialect],\n    *,\n    fuel: int | None = None,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192\n)\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[FrameType, ValueType]</code></p> <p>A base class for interpreters.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def __init__(\n    self,\n    dialects: DialectGroup | Iterable[Dialect],\n    *,\n    fuel: int | None = None,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192,\n):\n    if not isinstance(dialects, DialectGroup):\n        dialects = DialectGroup(dialects)\n    self.dialects = dialects\n\n    self.registry, self.fallbacks = self.dialects.registry.interpreter(\n        keys=self.keys\n    )\n    self.state = InterpreterState()\n    self.fuel = fuel\n    self.max_depth = max_depth\n    self.max_python_recursion_depth = max_python_recursion_depth\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.dialects","title":"dialects  <code>instance-attribute</code>","text":"<pre><code>dialects: DialectGroup = dialects\n</code></pre> <p>The dialects to interpret.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.fuel","title":"fuel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fuel: int | None = fuel\n</code></pre> <p>The fuel limit.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.keys","title":"keys  <code>class-attribute</code>","text":"<pre><code>keys: list[str]\n</code></pre> <p>The name of the interpreter to select from dialects by order.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.registry","title":"registry  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>registry: dict[Signature, StatementImpl] = field(\n    init=False, repr=False\n)\n</code></pre> <p>A mapping of statement signature to their implementation.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.state","title":"state  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>state: InterpreterState[FrameType] = InterpreterState()\n</code></pre> <p>The interpreter state.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.build_signature","title":"build_signature","text":"<pre><code>build_signature(stmt: Statement, args: tuple) -&gt; Signature\n</code></pre> <p>build signature for querying the statement implementation.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def build_signature(self, stmt: Statement, args: tuple) -&gt; \"Signature\":\n    \"\"\"build signature for querying the statement implementation.\"\"\"\n    return (stmt.__class__, tuple(arg.type for arg in stmt.args))\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.eval","title":"eval","text":"<pre><code>eval(\n    mt: Method,\n    args: tuple[ValueType, ...],\n    kwargs: dict[str, ValueType] | None = None,\n) -&gt; InterpResult[ValueType]\n</code></pre> <p>Evaluate a method.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def eval(\n    self,\n    mt: Method,\n    args: tuple[ValueType, ...],\n    kwargs: dict[str, ValueType] | None = None,\n) -&gt; InterpResult[ValueType]:\n    \"\"\"Evaluate a method.\"\"\"\n    current_recursion_limit = sys.getrecursionlimit()\n    sys.setrecursionlimit(self.max_python_recursion_depth)\n    interface = mt.code.get_trait(traits.CallableStmtInterface)\n    if interface is None:\n        raise InterpreterError(f\"compiled method {mt} is not callable\")\n\n    if len(self.state.frames) &gt;= self.max_depth:\n        raise InterpreterError(\"maximum recursion depth exceeded\")\n\n    self.state.push_frame(self.new_method_frame(mt))\n    body = interface.get_callable_region(mt.code)\n    # NOTE: #self# is not user input so it is not\n    # in the args, +1 is for self\n    args = self.get_args(mt.arg_names[len(args) + 1 :], args, kwargs)\n    # NOTE: this should be checked via static validation, we just assume\n    # number of args is correct here\n    # NOTE: Method is used as if it is a singleton type, but it is not recognized by mypy\n    results = self.run_method_region(mt, body, args)\n    self.postprocess_frame(self.state.pop_frame())\n    sys.setrecursionlimit(current_recursion_limit)\n    return results\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.eval_stmt","title":"eval_stmt","text":"<pre><code>eval_stmt(\n    stmt: Statement, args: tuple\n) -&gt; Result[ValueType]\n</code></pre> <p>simply evaluate a statement</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def eval_stmt(self, stmt: Statement, args: tuple) -&gt; Result[ValueType]:\n    \"simply evaluate a statement\"\n    sig = self.build_signature(stmt, args)\n    if sig in self.registry:\n        return self.registry[sig](self, stmt, args)\n    elif stmt.__class__ in self.registry:\n        return self.registry[stmt.__class__](self, stmt, args)\n    elif stmt.dialect:\n        return self.fallbacks[stmt.dialect](self, stmt, args)\n    raise ValueError(f\"no dialect for stmt {stmt}\")\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.new_method_frame","title":"new_method_frame  <code>abstractmethod</code>","text":"<pre><code>new_method_frame(mt: Method) -&gt; FrameType\n</code></pre> <p>Create a new frame for the given method.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>@abstractmethod\ndef new_method_frame(self, mt: Method) -&gt; FrameType:\n    \"\"\"Create a new frame for the given method.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.permute_values","title":"permute_values  <code>staticmethod</code>","text":"<pre><code>permute_values(\n    arg_names: Sequence[str],\n    values: tuple[ValueType, ...],\n    kwarg_names: tuple[str, ...],\n) -&gt; tuple[ValueType, ...]\n</code></pre> <p>Permute the arguments according to the method signature and the given keyword arguments, where the keyword argument names refer to the last n arguments in the values tuple.</p> <p>Args</p> <p>mt: the method values: the values tuple (should not contain method itself) kwarg_names: the keyword argument names</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>@staticmethod\ndef permute_values(\n    arg_names: Sequence[str],\n    values: tuple[ValueType, ...],\n    kwarg_names: tuple[str, ...],\n) -&gt; tuple[ValueType, ...]:\n    \"\"\"Permute the arguments according to the method signature and\n    the given keyword arguments, where the keyword argument names\n    refer to the last n arguments in the values tuple.\n\n    Args\n\n    mt: the method\n    values: the values tuple (should not contain method itself)\n    kwarg_names: the keyword argument names\n    \"\"\"\n    n_total = len(values)\n    if kwarg_names:\n        kwargs = dict(zip(kwarg_names, values[n_total - len(kwarg_names) :]))\n    else:\n        kwargs = None\n\n    positionals = values[: n_total - len(kwarg_names)]\n    args = BaseInterpreter.get_args(\n        arg_names[len(positionals) + 1 :], positionals, kwargs\n    )\n    return args\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.postprocess_frame","title":"postprocess_frame","text":"<pre><code>postprocess_frame(frame: FrameType) -&gt; None\n</code></pre> <p>Postprocess a frame after it is popped from the stack. This is called after a method is evaluated and the frame is popped. Default implementation does nothing.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def postprocess_frame(self, frame: FrameType) -&gt; None:\n    \"\"\"Postprocess a frame after it is popped from the stack. This is\n    called after a method is evaluated and the frame is popped. Default\n    implementation does nothing.\n    \"\"\"\n    return\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.run_stmt","title":"run_stmt","text":"<pre><code>run_stmt(stmt: Statement, args: tuple) -&gt; Result[ValueType]\n</code></pre> <p>run a statement within the current frame</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def run_stmt(self, stmt: Statement, args: tuple) -&gt; Result[ValueType]:\n    \"run a statement within the current frame\"\n    if self.state.frames:\n        # NOTE: if run_stmt is called directly,\n        # there is no frame being pushed, we only\n        # push a frame when we call a method\n        self.state.current_frame().set_stmt(stmt)\n    return self.eval_stmt(stmt, args)\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.InterpResult","title":"InterpResult  <code>dataclass</code>","text":"<pre><code>InterpResult(result: ValueType | NoReturn | Err)\n</code></pre> <p>               Bases: <code>Generic[ValueType]</code></p> <p>This is used by the interpreter eval only.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def __init__(self, result: ValueType | NoReturn | Err):\n    if isinstance(result, Err):\n        self.err = result\n        self.value = NoReturn()\n    else:\n        self.value = result\n</code></pre>"},{"location":"reference/kirin/interp/concrete/","title":"Concrete","text":""},{"location":"reference/kirin/interp/concrete/#kirin.interp.concrete.Interpreter","title":"Interpreter","text":"<pre><code>Interpreter(\n    dialects: DialectGroup | Iterable[Dialect],\n    *,\n    fuel: int | None = None,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192\n)\n</code></pre> <p>               Bases: <code>BaseInterpreter[Frame[Any], Any]</code></p> Source code in <code>src/kirin/interp/concrete.py</code> <pre><code>def __init__(\n    self,\n    dialects: DialectGroup | Iterable[Dialect],\n    *,\n    fuel: int | None = None,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192,\n):\n    super().__init__(\n        dialects,\n        fuel=fuel,\n        max_depth=max_depth,\n        max_python_recursion_depth=max_python_recursion_depth,\n    )\n</code></pre>"},{"location":"reference/kirin/interp/concrete/#kirin.interp.concrete.Interpreter.keys","title":"keys  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>keys = ['main', 'empty']\n</code></pre> <p>The name of the interpreter to select from dialects by order.</p>"},{"location":"reference/kirin/interp/concrete/#kirin.interp.concrete.Interpreter.new_method_frame","title":"new_method_frame","text":"<pre><code>new_method_frame(mt: Method) -&gt; Frame[Any]\n</code></pre> <p>Create a new frame for the given method.</p> Source code in <code>src/kirin/interp/concrete.py</code> <pre><code>def new_method_frame(self, mt: Method) -&gt; Frame[Any]:\n    return Frame.from_method(mt)\n</code></pre>"},{"location":"reference/kirin/interp/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/interp/frame/","title":"Frame","text":""},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame","title":"Frame  <code>dataclass</code>","text":"<pre><code>Frame(\n    method: Method,\n    lino: int = 0,\n    stmt: Statement | None = None,\n    globals: dict[str, Any] = dict(),\n    entries: dict[SSAValue, ValueType] = dict(),\n)\n</code></pre> <p>               Bases: <code>FrameABC[ValueType]</code></p>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame.entries","title":"entries  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>entries: dict[SSAValue, ValueType] = field(\n    default_factory=dict\n)\n</code></pre> <p>SSA values and their corresponding values.</p>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame.globals","title":"globals  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>globals: dict[str, Any] = field(default_factory=dict)\n</code></pre> <p>Global variables this frame has access to.</p>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame.method","title":"method  <code>instance-attribute</code>","text":"<pre><code>method: Method\n</code></pre> <p>method being interpreted.</p>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame.stmt","title":"stmt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stmt: Statement | None = None\n</code></pre> <p>statement being interpreted.</p>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame.from_method","title":"from_method  <code>classmethod</code>","text":"<pre><code>from_method(method: Method) -&gt; Self\n</code></pre> <p>Create a new frame for the given method.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>@classmethod\ndef from_method(cls, method: Method) -&gt; Self:\n    return cls(method=method)\n</code></pre>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame.get_values","title":"get_values","text":"<pre><code>get_values(keys: Iterable[SSAValue]) -&gt; tuple\n</code></pre> <p>Get the values of the given <code>SSAValue</code> keys.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>def get_values(self, keys: Iterable[SSAValue]) -&gt; tuple:\n    return tuple(self.entries[key] for key in keys)\n</code></pre>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame.set_stmt","title":"set_stmt","text":"<pre><code>set_stmt(stmt: Statement) -&gt; Self\n</code></pre> <p>Set the current statement.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>def set_stmt(self, stmt: Statement) -&gt; Self:\n    self.stmt = stmt\n    return self\n</code></pre>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame.set_values","title":"set_values","text":"<pre><code>set_values(\n    keys: Iterable[SSAValue], values: Iterable[ValueType]\n) -&gt; None\n</code></pre> <p>Set the values of the given <code>SSAValue</code> keys.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>def set_values(self, keys: Iterable[SSAValue], values: Iterable[ValueType]) -&gt; None:\n    for key, value in zip(keys, values):\n        self.entries[key] = value\n</code></pre>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.FrameABC","title":"FrameABC  <code>dataclass</code>","text":"<pre><code>FrameABC()\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[ValueType]</code></p>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.FrameABC.from_method","title":"from_method  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>from_method(method: Method) -&gt; Self\n</code></pre> <p>Create a new frame for the given method.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>@classmethod\n@abstractmethod\ndef from_method(cls, method: Method) -&gt; Self:\n    \"\"\"Create a new frame for the given method.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.FrameABC.get_values","title":"get_values  <code>abstractmethod</code>","text":"<pre><code>get_values(keys: Iterable[SSAValue]) -&gt; tuple\n</code></pre> <p>Get the values of the given <code>SSAValue</code> keys.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>@abstractmethod\ndef get_values(self, keys: Iterable[SSAValue]) -&gt; tuple:\n    \"\"\"Get the values of the given `SSAValue` keys.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.FrameABC.set_stmt","title":"set_stmt  <code>abstractmethod</code>","text":"<pre><code>set_stmt(stmt: Statement) -&gt; Self\n</code></pre> <p>Set the current statement.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>@abstractmethod\ndef set_stmt(self, stmt: Statement) -&gt; Self:\n    \"\"\"Set the current statement.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.FrameABC.set_values","title":"set_values  <code>abstractmethod</code>","text":"<pre><code>set_values(\n    keys: Iterable[SSAValue], values: Iterable[ValueType]\n) -&gt; None\n</code></pre> <p>Set the values of the given <code>SSAValue</code> keys.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>@abstractmethod\ndef set_values(self, keys: Iterable[SSAValue], values: Iterable[ValueType]) -&gt; None:\n    \"\"\"Set the values of the given `SSAValue` keys.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/interp/impl/","title":"Impl","text":""},{"location":"reference/kirin/interp/state/","title":"State","text":""},{"location":"reference/kirin/interp/value/","title":"Value","text":""},{"location":"reference/kirin/ir/","title":"Index","text":"<p>IR module for kirin.</p> <p>This module contains the intermediate representation (IR) for kirin.</p>"},{"location":"reference/kirin/ir/attrs/","title":"Attributes","text":""},{"location":"reference/kirin/ir/attrs/#kirin.ir.attrs.AnyType","title":"AnyType  <code>dataclass</code>","text":"<pre><code>AnyType()\n</code></pre> <p>               Bases: <code>TypeAttribute</code></p> <p>Top of any type lattice.</p>"},{"location":"reference/kirin/ir/attrs/#kirin.ir.attrs.AttributeMeta","title":"AttributeMeta","text":"<p>               Bases: <code>ABCMeta</code></p> <p>Metaclass for attributes.</p>"},{"location":"reference/kirin/ir/attrs/#kirin.ir.attrs.BottomType","title":"BottomType  <code>dataclass</code>","text":"<pre><code>BottomType()\n</code></pre> <p>               Bases: <code>TypeAttribute</code></p> <p>Bottom of any type lattice.</p>"},{"location":"reference/kirin/ir/attrs/#kirin.ir.attrs.SingletonTypeMeta","title":"SingletonTypeMeta","text":"<pre><code>SingletonTypeMeta(name, bases, attrs)\n</code></pre> <p>               Bases: <code>TypeAttributeMeta</code>, <code>SingletonMeta</code></p> <p>Metaclass for singleton type attributes.</p> <p>Singleton type attributes are attributes that have only one instance.</p> <p>Examples: - <code>AnyType</code> - <code>BottomType</code></p> Source code in <code>src/kirin/lattice.py</code> <pre><code>def __init__(cls, name, bases, attrs):\n    super().__init__(name, bases, attrs)\n    cls._instance = None\n</code></pre>"},{"location":"reference/kirin/ir/attrs/#kirin.ir.attrs.TypeAttributeMeta","title":"TypeAttributeMeta","text":"<p>               Bases: <code>AttributeMeta</code>, <code>LatticeMeta</code></p> <p>Metaclass for type attributes.</p>"},{"location":"reference/kirin/ir/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/ir/dialect/#kirin.ir.dialect.Dialect","title":"Dialect  <code>dataclass</code>","text":"<pre><code>Dialect(\n    name: str,\n    stmts: list[type[Statement]] = list(),\n    attrs: list[type[Attribute]] = list(),\n    interps: dict[str, DialectInterpreter] = dict(),\n    lowering: dict[str, FromPythonAST] = dict(),\n    codegen: dict[str, DialectEmit] = dict(),\n)\n</code></pre> <p>Dialect is a collection of statements, attributes, interpreters, lowerings, and codegen.</p>"},{"location":"reference/kirin/ir/dialect/#kirin.ir.dialect.Dialect.register","title":"register","text":"<pre><code>register(node: type | None = None, key: str | None = None)\n</code></pre> <p>register is a decorator to register a node to the dialect.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>type | None</code> <p>The node to register. Defaults to None.</p> <code>None</code> <code>key</code> <code>str | None</code> <p>The key to register the node to. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the node is not a subclass of Statement, Attribute, DialectInterpreter, FromPythonAST, or DialectEmit.</p> Source code in <code>src/kirin/ir/dialect.py</code> <pre><code>@dataclass_transform()\ndef register(self, node: type | None = None, key: str | None = None):\n    \"\"\"register is a decorator to register a node to the dialect.\n\n    Args:\n        node (type | None): The node to register. Defaults to None.\n        key (str | None): The key to register the node to. Defaults to None.\n\n    Raises:\n        ValueError: If the node is not a subclass of Statement, Attribute, DialectInterpreter, FromPythonAST, or DialectEmit.\n    \"\"\"\n    from kirin.codegen.dialect import DialectEmit\n    from kirin.interp.dialect import DialectInterpreter\n    from kirin.lowering.dialect import FromPythonAST\n\n    if key is None:\n        key = \"main\"\n\n    def wrapper(node: type[T]) -&gt; type[T]:\n        if issubclass(node, Statement):\n            self.stmts.append(node)\n        elif issubclass(node, Attribute):\n            assert (\n                Attribute in node.__mro__\n            ), f\"{node} is not a subclass of Attribute\"\n            setattr(node, \"dialect\", self)\n            assert hasattr(node, \"name\"), f\"{node} does not have a name attribute\"\n            self.attrs.append(node)\n        elif issubclass(node, DialectInterpreter):\n            if key in self.interps:\n                raise ValueError(\n                    f\"Cannot register {node} to Dialect, key {key} exists\"\n                )\n            self.interps[key] = node()\n        elif issubclass(node, FromPythonAST):\n            if key in self.lowering:\n                raise ValueError(\n                    f\"Cannot register {node} to Dialect, key {key} exists\"\n                )\n            self.lowering[key] = node()\n        elif issubclass(node, DialectEmit):\n            if key in self.codegen:\n                raise ValueError(\n                    f\"Cannot register {node} to Dialect, key {key} exists\"\n                )\n            self.codegen[key] = node()\n        else:\n            raise ValueError(f\"Cannot register {node} to Dialect\")\n        return node\n\n    if node is None:\n        return wrapper\n\n    return wrapper(node)\n</code></pre>"},{"location":"reference/kirin/ir/group/","title":"Dialect Group","text":""},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup","title":"DialectGroup  <code>dataclass</code>","text":"<pre><code>DialectGroup(\n    dialects: Iterable[Union[Dialect, ModuleType]],\n    run_pass: RunPassGen[PassParams] | None = None,\n)\n</code></pre> <p>               Bases: <code>Generic[PassParams]</code></p> Source code in <code>src/kirin/ir/group.py</code> <pre><code>def __init__(\n    self,\n    dialects: Iterable[Union[\"Dialect\", ModuleType]],\n    run_pass: RunPassGen[PassParams] | None = None,\n):\n    def identity(code: Method):\n        pass\n\n    self.data = frozenset(self.map_module(dialect) for dialect in dialects)\n    if run_pass is None:\n        self.run_pass_gen = None\n        self.run_pass = None\n    else:\n        self.run_pass_gen = run_pass\n        self.run_pass = run_pass(self)\n</code></pre>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data: frozenset[Dialect] = frozenset(\n    map_module(dialect) for dialect in dialects\n)\n</code></pre> <p>The set of dialects in the group.</p>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup.registry","title":"registry  <code>property</code>","text":"<pre><code>registry: Registry\n</code></pre> <p>return the registry for the dialect group. This returns a proxy object that can be used to select the lowering interpreters, interpreters, and codegen for the dialects in the group.</p> <p>Returns:</p> Name Type Description <code>Registry</code> <code>Registry</code> <p>the registry object.</p>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup.run_pass","title":"run_pass  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>run_pass: RunPass[PassParams] | None = None\n</code></pre> <p>the function that runs the passes on the method.</p>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup.run_pass_gen","title":"run_pass_gen  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>run_pass_gen: RunPassGen[PassParams] | None = None\n</code></pre> <p>the function that generates the <code>run_pass</code> function.</p> <p>This is used to create new dialect groups from existing ones, while keeping the same <code>run_pass</code> function.</p>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup.__call__","title":"__call__","text":"<pre><code>__call__(\n    py_func: Callable[Param, RetType],\n    *args: PassParams.args,\n    **options: PassParams.kwargs\n) -&gt; Method[Param, RetType]\n</code></pre><pre><code>__call__(\n    py_func: None = None,\n    *args: PassParams.args,\n    **options: PassParams.kwargs\n) -&gt; MethodTransform[Param, RetType]\n</code></pre> <pre><code>__call__(\n    py_func: Callable[Param, RetType] | None = None,\n    *args: PassParams.args,\n    **options: PassParams.kwargs\n) -&gt; (\n    Method[Param, RetType] | MethodTransform[Param, RetType]\n)\n</code></pre> <p>create a method from the python function.</p> <p>Parameters:</p> Name Type Description Default <code>py_func</code> <code>Callable</code> <p>the python function to create the method from.</p> <code>None</code> <code>args</code> <code>args</code> <p>the arguments to pass to the run_pass function.</p> <code>()</code> <code>options</code> <code>kwargs</code> <p>the keyword arguments to pass to the run_pass function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Method</code> <code>Method[Param, RetType] | MethodTransform[Param, RetType]</code> <p>the method created from the python function.</p> Source code in <code>src/kirin/ir/group.py</code> <pre><code>def __call__(\n    self,\n    py_func: Callable[Param, RetType] | None = None,\n    *args: PassParams.args,\n    **options: PassParams.kwargs,\n) -&gt; Method[Param, RetType] | MethodTransform[Param, RetType]:\n    \"\"\"create a method from the python function.\n\n    Args:\n        py_func (Callable): the python function to create the method from.\n        args (PassParams.args): the arguments to pass to the run_pass function.\n        options (PassParams.kwargs): the keyword arguments to pass to the run_pass function.\n\n    Returns:\n        Method: the method created from the python function.\n    \"\"\"\n    from kirin.lowering import Lowering\n\n    emit_ir = Lowering(self)\n\n    def wrapper(py_func: Callable) -&gt; Method:\n        if py_func.__name__ == \"&lt;lambda&gt;\":\n            raise ValueError(\"Cannot compile lambda functions\")\n\n        lineno_offset, file = 0, \"\"\n        frame = inspect.currentframe()\n        if frame and frame.f_back is not None and frame.f_back.f_back is not None:\n            call_site_frame = frame.f_back.f_back\n            if py_func.__name__ in call_site_frame.f_locals:\n                raise CompilerError(\n                    f\"overwriting function definition of `{py_func.__name__}`\"\n                )\n\n            lineno_offset = call_site_frame.f_lineno - 1\n            file = call_site_frame.f_code.co_filename\n\n        code = emit_ir.run(py_func, lineno_offset=lineno_offset)\n        mt = Method(\n            mod=inspect.getmodule(py_func),\n            py_func=py_func,\n            sym_name=py_func.__name__,\n            arg_names=[\"#self#\"] + inspect.getfullargspec(py_func).args,\n            dialects=self,\n            code=code,\n            file=file,\n        )\n        if doc := inspect.getdoc(py_func):\n            mt.__doc__ = doc\n\n        if self.run_pass is not None:\n            self.run_pass(mt, *args, **options)\n        return mt\n\n    if py_func is not None:\n        return wrapper(py_func)\n    return wrapper\n</code></pre>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup.add","title":"add","text":"<pre><code>add(dialect: Union[Dialect, ModuleType]) -&gt; DialectGroup\n</code></pre> <p>add a dialect to the group.</p> <p>Parameters:</p> Name Type Description Default <code>dialect</code> <code>Union[Dialect, ModuleType]</code> <p>the dialect to add</p> required <p>Returns:</p> Name Type Description <code>DialectGroup</code> <code>DialectGroup</code> <p>the new dialect group with the added</p> Source code in <code>src/kirin/ir/group.py</code> <pre><code>def add(self, dialect: Union[\"Dialect\", ModuleType]) -&gt; \"DialectGroup\":\n    \"\"\"add a dialect to the group.\n\n    Args:\n        dialect (Union[Dialect, ModuleType]): the dialect to add\n\n    Returns:\n        DialectGroup: the new dialect group with the added\n    \"\"\"\n    return self.union([dialect])\n</code></pre>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup.map_module","title":"map_module  <code>staticmethod</code>","text":"<pre><code>map_module(dialect)\n</code></pre> <p>map the module to the dialect if it is a module. It assumes that the module has a <code>dialect</code> attribute that is an instance of <code>Dialect</code>.</p> Source code in <code>src/kirin/ir/group.py</code> <pre><code>@staticmethod\ndef map_module(dialect):\n    \"\"\"map the module to the dialect if it is a module.\n    It assumes that the module has a `dialect` attribute\n    that is an instance of [`Dialect`][kirin.ir.Dialect].\n    \"\"\"\n    if isinstance(dialect, ModuleType):\n        return getattr(dialect, \"dialect\")\n    return dialect\n</code></pre>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup.union","title":"union","text":"<pre><code>union(\n    dialect: Iterable[Union[Dialect, ModuleType]]\n) -&gt; DialectGroup\n</code></pre> <p>union a set of dialects to the group.</p> <p>Parameters:</p> Name Type Description Default <code>dialect</code> <code>Iterable[Union[Dialect, ModuleType]]</code> <p>the dialects to union</p> required <p>Returns:</p> Name Type Description <code>DialectGroup</code> <code>DialectGroup</code> <p>the new dialect group with the union.</p> Source code in <code>src/kirin/ir/group.py</code> <pre><code>def union(self, dialect: Iterable[Union[\"Dialect\", ModuleType]]) -&gt; \"DialectGroup\":\n    \"\"\"union a set of dialects to the group.\n\n    Args:\n        dialect (Iterable[Union[Dialect, ModuleType]]): the dialects to union\n\n    Returns:\n        DialectGroup: the new dialect group with the union.\n    \"\"\"\n    return DialectGroup(\n        dialects=self.data.union(frozenset(self.map_module(d) for d in dialect)),\n        run_pass=self.run_pass_gen,  # pass the run_pass_gen function\n    )\n</code></pre>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.Registry","title":"Registry  <code>dataclass</code>","text":"<pre><code>Registry(parent: DialectGroup)\n</code></pre> <p>Proxy class to build different registries from a dialect group.</p>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.Registry.parent","title":"parent  <code>instance-attribute</code>","text":"<pre><code>parent: DialectGroup\n</code></pre> <p>The parent dialect group.</p>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.Registry.codegen","title":"codegen","text":"<pre><code>codegen(\n    keys: Iterable[str],\n) -&gt; dict[CodegenSignature, CodegenImpl]\n</code></pre> <p>select the dialect codegen for the given key.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>Iterable[str]</code> <p>the keys to search for in the dialects</p> required <p>Returns:</p> Type Description <code>dict[Signature, StatementImpl]</code> <p>a map of dialects to their codegen.</p> Source code in <code>src/kirin/ir/group.py</code> <pre><code>def codegen(self, keys: Iterable[str]) -&gt; dict[\"CodegenSignature\", \"CodegenImpl\"]:\n    \"\"\"select the dialect codegen for the given key.\n\n    Args:\n        keys (Iterable[str]): the keys to search for in the dialects\n\n    Returns:\n        a map of dialects to their codegen.\n    \"\"\"\n    from kirin.codegen.impl import MethodImpl\n\n    ret: dict[\"CodegenSignature\", \"CodegenImpl\"] = {}\n    for dialect in self.parent.data:\n        dialect_codegen = None\n        for key in keys:\n            if key in dialect.codegen:\n                dialect_codegen = dialect.codegen[key]\n                break\n\n        # not found, just skip\n        if dialect_codegen is None:\n            continue\n\n        for key, func in dialect_codegen.table.items():\n            ret[key] = MethodImpl(dialect_codegen, func)\n    return ret\n</code></pre>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.Registry.interpreter","title":"interpreter","text":"<pre><code>interpreter(\n    keys: Iterable[str],\n) -&gt; tuple[\n    dict[Signature, InterpImpl], dict[Dialect, InterpImpl]\n]\n</code></pre> <p>select the dialect interpreter for the given key.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>Iterable[str]</code> <p>the keys to search for in the dialects</p> required <p>Returns:</p> Type Description <code>dict[Signature, StatementImpl]</code> <p>a map of statement signatures to their interpretation functions,</p> <code>dict[Dialect, StatementImpl]</code> <p>and a map of dialects to their fallback interpreters.</p> Source code in <code>src/kirin/ir/group.py</code> <pre><code>def interpreter(\n    self, keys: Iterable[str]\n) -&gt; tuple[dict[\"Signature\", \"InterpImpl\"], dict[\"Dialect\", \"InterpImpl\"]]:\n    \"\"\"select the dialect interpreter for the given key.\n\n    Args:\n        keys (Iterable[str]): the keys to search for in the dialects\n\n    Returns:\n        a map of statement signatures to their interpretation functions,\n        and a map of dialects to their fallback interpreters.\n    \"\"\"\n    from kirin.interp.impl import MethodImpl\n\n    ret: dict[\"Signature\", \"InterpImpl\"] = {}\n    fallback: dict[\"Dialect\", \"InterpImpl\"] = {}\n    for dialect in self.parent.data:\n        dialect_interp = None\n        for key in keys:\n            if key in dialect.interps:\n                dialect_interp = dialect.interps[key]\n                if dialect not in fallback:  # use the first fallback\n                    fallback[dialect] = dialect_interp.fallback\n\n                for sig, func in dialect_interp.table.items():\n                    if sig not in ret:\n                        ret[sig] = MethodImpl(dialect_interp, func)\n\n        if dialect not in fallback:\n            msg = \",\".join(keys)\n            raise KeyError(f\"Interpreter of {dialect.name} not found for {msg}\")\n    return ret, fallback\n</code></pre>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.Registry.lowering","title":"lowering","text":"<pre><code>lowering(keys: Iterable[str]) -&gt; dict[str, FromPythonAST]\n</code></pre> <p>select the dialect lowering interpreters for the given key.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>Iterable[str]</code> <p>the keys to search for in the dialects</p> required <p>Returns:</p> Type Description <code>dict[str, FromPythonAST]</code> <p>a map of dialects to their lowering interpreters</p> Source code in <code>src/kirin/ir/group.py</code> <pre><code>def lowering(self, keys: Iterable[str]) -&gt; dict[str, \"FromPythonAST\"]:\n    \"\"\"select the dialect lowering interpreters for the given key.\n\n    Args:\n        keys (Iterable[str]): the keys to search for in the dialects\n\n    Returns:\n        a map of dialects to their lowering interpreters\n    \"\"\"\n    ret: dict[str, \"FromPythonAST\"] = {}\n    from_ast = None\n    for dialect in self.parent.data:\n        for key in keys:\n            if key in dialect.lowering:\n                from_ast = dialect.lowering[key]\n                break\n\n        if from_ast is None:\n            msg = \",\".join(keys)\n            raise KeyError(f\"Lowering not found for {msg}\")\n\n        for name in from_ast.names:\n            if name in ret:\n                raise KeyError(f\"Lowering {name} already exists\")\n\n            ret[name] = from_ast\n    return ret\n</code></pre>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.dialect_group","title":"dialect_group","text":"<pre><code>dialect_group(\n    dialects: Iterable[Union[Dialect, ModuleType]]\n)\n</code></pre> <p>Create a dialect group from the given dialects based on the definition of <code>run_pass</code> function.</p> <p>Parameters:</p> Name Type Description Default <code>dialects</code> <code>Iterable[Union[Dialect, ModuleType]]</code> <p>the dialects to include in the group.</p> required <p>Returns:</p> Type Description <p>Callable[[RunPassGen[PassParams]], DialectGroup[PassParams]]: the dialect group.</p> <p>Example:</p> <pre><code>from kirin.dialects import cf, fcf, func, math\n\n@dialect_group([cf, fcf, func, math])\ndef basic_no_opt(self):\n    # initializations\n    def run_pass(mt: Method) -&gt; None:\n        # how passes are applied to the method\n        pass\n\n    return run_pass\n</code></pre> Source code in <code>src/kirin/ir/group.py</code> <pre><code>def dialect_group(dialects: Iterable[Union[\"Dialect\", ModuleType]]):\n    \"\"\"Create a dialect group from the given dialects based on the\n    definition of `run_pass` function.\n\n    Args:\n        dialects (Iterable[Union[Dialect, ModuleType]]): the dialects to include in the group.\n\n    Returns:\n        Callable[[RunPassGen[PassParams]], DialectGroup[PassParams]]: the dialect group.\n\n    Example:\n\n    ```python\n    from kirin.dialects import cf, fcf, func, math\n\n    @dialect_group([cf, fcf, func, math])\n    def basic_no_opt(self):\n        # initializations\n        def run_pass(mt: Method) -&gt; None:\n            # how passes are applied to the method\n            pass\n\n        return run_pass\n    ```\n    \"\"\"\n\n    # NOTE: do not alias the annotation below\n    def wrapper(\n        transform: RunPassGen[PassParams],\n    ) -&gt; DialectGroup[PassParams]:\n        ret = DialectGroup(dialects, run_pass=transform)\n        update_wrapper(ret, transform)\n        return ret\n\n    return wrapper\n</code></pre>"},{"location":"reference/kirin/ir/method/","title":"Method","text":""},{"location":"reference/kirin/ir/method/#kirin.ir.method.Method","title":"Method  <code>dataclass</code>","text":"<pre><code>Method(\n    mod: ModuleType | None,\n    py_func: Callable[Param, RetType] | None,\n    sym_name: str | None,\n    arg_names: list[str],\n    dialects: DialectGroup,\n    code: Statement,\n    fields: tuple = tuple(),\n    file: str = \"\",\n    lineno: list[tuple[int, int]] = list(),\n    backedges: list[Method] = list(),\n    return_type: TypeAttribute | None = None,\n    inferred: bool = False,\n    verified: bool = False,\n)\n</code></pre> <p>               Bases: <code>Printable</code>, <code>Generic[Param, RetType]</code></p>"},{"location":"reference/kirin/ir/method/#kirin.ir.method.Method.inferred","title":"inferred  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inferred: bool = False\n</code></pre> <p>if typeinfer has been run on this method</p>"},{"location":"reference/kirin/ir/method/#kirin.ir.method.Method.lineno","title":"lineno  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lineno: list[tuple[int, int]] = field(default_factory=list)\n</code></pre> <p>(, ) at the start of the statement call."},{"location":"reference/kirin/ir/method/#kirin.ir.method.Method.verified","title":"verified  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>verified: bool = False\n</code></pre> <p>if <code>code.verify</code> has been run on this method</p>"},{"location":"reference/kirin/ir/method/#kirin.ir.method.Method.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>verify the method body.</p> Source code in <code>src/kirin/ir/method.py</code> <pre><code>def verify(self) -&gt; None:\n    \"\"\"verify the method body.\"\"\"\n    try:\n        self.code.verify()\n    except VerificationError as e:\n        msg = f'File \"{self.file}\"'\n        if isinstance(e.node, Statement):\n            if e.node.source:\n                msg += f\", line {e.node.source.lineno}\"\n            msg += f\", in {e.node.name}\"\n\n        msg += f\":\\n    Verification failed for {self.sym_name}: {e.args[0]}\"\n        raise Exception(msg) from e\n    self.verified = True\n    return\n</code></pre>"},{"location":"reference/kirin/ir/ssa/","title":"SSA values","text":""},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.BlockArgument","title":"BlockArgument  <code>dataclass</code>","text":"<pre><code>BlockArgument(\n    block: Block,\n    index: int,\n    type: TypeAttribute = AnyType(),\n)\n</code></pre> <p>               Bases: <code>SSAValue</code></p> <p>SSAValue that is an argument to a <code>Block</code>.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def __init__(\n    self, block: Block, index: int, type: TypeAttribute = AnyType()\n) -&gt; None:\n    super().__init__()\n    self.type = type\n    self.block = block\n    self.index = index\n</code></pre>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.BlockArgument.block","title":"block  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>block: Block = block\n</code></pre> <p>The block that this argument belongs to.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.BlockArgument.index","title":"index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>index: int = index\n</code></pre> <p>The index of this argument in the block's argument list.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.BlockArgument.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type = type\n</code></pre> <p>The type of this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.DeletedSSAValue","title":"DeletedSSAValue  <code>dataclass</code>","text":"<pre><code>DeletedSSAValue(value: SSAValue)\n</code></pre> <p>               Bases: <code>SSAValue</code></p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def __init__(self, value: SSAValue) -&gt; None:\n    super().__init__()\n    self.value = value\n    self.type = value.type\n</code></pre>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.DeletedSSAValue.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type = type\n</code></pre> <p>The type of this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.ResultValue","title":"ResultValue  <code>dataclass</code>","text":"<pre><code>ResultValue(\n    stmt: Statement,\n    index: int,\n    type: TypeAttribute | None = None,\n)\n</code></pre> <p>               Bases: <code>SSAValue</code></p> <p>SSAValue that is a result of a <code>Statement</code>.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def __init__(\n    self, stmt: Statement, index: int, type: TypeAttribute | None = None\n) -&gt; None:\n    super().__init__()\n    self.type = type or AnyType()\n    self.stmt = stmt\n    self.index = index\n</code></pre>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.ResultValue.index","title":"index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>index: int = index\n</code></pre> <p>The index of this value in the statement's result list.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.ResultValue.stmt","title":"stmt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stmt: Statement = stmt\n</code></pre> <p>The statement that this value is a result of.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.ResultValue.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type = type or AnyType()\n</code></pre> <p>The type of this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue","title":"SSAValue  <code>dataclass</code>","text":"<pre><code>SSAValue()\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Printable</code></p> <p>Base class for all SSA values in the IR.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue.name","title":"name  <code>property</code> <code>writable</code>","text":"<pre><code>name: str | None\n</code></pre> <p>The name of this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue.name_pattern","title":"name_pattern  <code>class-attribute</code>","text":"<pre><code>name_pattern: Pattern[str] = compile(\n    \"([A-Za-z_$.-][\\\\w$.-]*)\"\n)\n</code></pre> <p>The pattern that the name of this SSA value must match.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type: TypeAttribute = field(\n    default_factory=AnyType, init=False, repr=True\n)\n</code></pre> <p>The type of this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue.uses","title":"uses  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>uses: set[Use] = field(\n    init=False, default_factory=set, repr=False\n)\n</code></pre> <p>The uses of this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue.add_use","title":"add_use","text":"<pre><code>add_use(use: Use) -&gt; Self\n</code></pre> <p>Add a use to this SSA value.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def add_use(self, use: Use) -&gt; Self:\n    \"\"\"Add a use to this SSA value.\"\"\"\n    self.uses.add(use)\n    return self\n</code></pre>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue.delete","title":"delete","text":"<pre><code>delete(safe: bool = True) -&gt; None\n</code></pre> <p>Delete this SSA value. If <code>safe</code> is <code>True</code>, raise an error if there are uses.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def delete(self, safe: bool = True) -&gt; None:\n    \"\"\"Delete this SSA value. If `safe` is `True`, raise an error if there are uses.\"\"\"\n    if safe and len(self.uses) &gt; 0:\n        raise ValueError(\"Cannot delete SSA value with uses\")\n    self.replace_by(DeletedSSAValue(self))\n</code></pre>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue.remove_use","title":"remove_use","text":"<pre><code>remove_use(use: Use) -&gt; Self\n</code></pre> <p>Remove a use from this SSA value.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def remove_use(self, use: Use) -&gt; Self:\n    \"\"\"Remove a use from this SSA value.\"\"\"\n    # print(use)\n    # assert use in self.uses, \"Use not found\"\n    if use in self.uses:\n        self.uses.remove(use)\n    return self\n</code></pre>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue.replace_by","title":"replace_by","text":"<pre><code>replace_by(other: SSAValue) -&gt; None\n</code></pre> <p>Replace this SSA value with another SSA value. Update all uses.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def replace_by(self, other: SSAValue) -&gt; None:\n    \"\"\"Replace this SSA value with another SSA value. Update all uses.\"\"\"\n    for use in self.uses.copy():\n        use.stmt.args[use.index] = other\n\n    if other.name is None and self.name is not None:\n        other.name = self.name\n\n    assert len(self.uses) == 0, \"Uses not empty\"\n</code></pre>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.TestValue","title":"TestValue  <code>dataclass</code>","text":"<pre><code>TestValue(type: TypeAttribute = AnyType())\n</code></pre> <p>               Bases: <code>SSAValue</code></p> <p>Test SSAValue for testing IR construction.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def __init__(self, type: TypeAttribute = AnyType()) -&gt; None:\n    super().__init__()\n    self.type = type\n</code></pre>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.TestValue.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type = type\n</code></pre> <p>The type of this SSA value.</p>"},{"location":"reference/kirin/ir/traits/","title":"Traits","text":""},{"location":"reference/kirin/ir/traits/#kirin.ir.traits.CallableStmtInterface","title":"CallableStmtInterface  <code>dataclass</code>","text":"<pre><code>CallableStmtInterface()\n</code></pre> <p>               Bases: <code>StmtTrait</code>, <code>Generic[StmtType]</code></p>"},{"location":"reference/kirin/ir/traits/#kirin.ir.traits.CallableStmtInterface.get_callable_region","title":"get_callable_region  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>get_callable_region(stmt: 'StmtType') -&gt; Region\n</code></pre> <p>Returns the body of the callable region</p> Source code in <code>src/kirin/ir/traits.py</code> <pre><code>@classmethod\n@abstractmethod\ndef get_callable_region(cls, stmt: \"StmtType\") -&gt; Region:\n    \"\"\"Returns the body of the callable region\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/ir/traits/#kirin.ir.traits.StmtTrait","title":"StmtTrait  <code>dataclass</code>","text":"<pre><code>StmtTrait()\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Base class for all statement traits.</p>"},{"location":"reference/kirin/ir/traits/#kirin.ir.traits.SymbolTable","title":"SymbolTable  <code>dataclass</code>","text":"<pre><code>SymbolTable()\n</code></pre> <p>               Bases: <code>StmtTrait</code></p> <p>Statement with SymbolTable trait can only have one region with one block.</p>"},{"location":"reference/kirin/ir/use/","title":"Use","text":""},{"location":"reference/kirin/ir/use/#kirin.ir.use.Use","title":"Use  <code>dataclass</code>","text":"<pre><code>Use(stmt: Statement, index: int)\n</code></pre> <p>A use of an SSA value in a statement.</p>"},{"location":"reference/kirin/ir/use/#kirin.ir.use.Use.index","title":"index  <code>instance-attribute</code>","text":"<pre><code>index: int\n</code></pre> <p>The index of the use in the statement.</p>"},{"location":"reference/kirin/ir/use/#kirin.ir.use.Use.stmt","title":"stmt  <code>instance-attribute</code>","text":"<pre><code>stmt: Statement\n</code></pre> <p>The statement that uses the SSA value.</p>"},{"location":"reference/kirin/ir/nodes/","title":"Index","text":""},{"location":"reference/kirin/ir/nodes/base/","title":"Base","text":""},{"location":"reference/kirin/ir/nodes/base/#kirin.ir.nodes.base.IRNode","title":"IRNode  <code>dataclass</code>","text":"<pre><code>IRNode()\n</code></pre> <p>               Bases: <code>Generic[ParentType]</code>, <code>ABC</code>, <code>Printable</code></p>"},{"location":"reference/kirin/ir/nodes/base/#kirin.ir.nodes.base.IRNode.typecheck","title":"typecheck  <code>abstractmethod</code>","text":"<pre><code>typecheck() -&gt; None\n</code></pre> <p>check if types are correct.</p> Source code in <code>src/kirin/ir/nodes/base.py</code> <pre><code>@abstractmethod\ndef typecheck(self) -&gt; None:\n    \"\"\"check if types are correct.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/ir/nodes/base/#kirin.ir.nodes.base.IRNode.verify","title":"verify  <code>abstractmethod</code>","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>run mandatory validation checks. This is not same as typecheck, which may be optional.</p> Source code in <code>src/kirin/ir/nodes/base.py</code> <pre><code>@abstractmethod\ndef verify(self) -&gt; None:\n    \"\"\"run mandatory validation checks. This is not same as typecheck, which may be optional.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/","title":"Block","text":""},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block","title":"Block  <code>dataclass</code>","text":"<pre><code>Block(\n    stmts: Sequence[Statement] = (),\n    argtypes: Iterable[TypeAttribute] = (),\n)\n</code></pre> <p>               Bases: <code>IRNode['Region']</code></p> <p>Block consist of a list of Statements and optionally input arguments.</p> <pre><code>argtypes (Iterable[TypeAttribute], optional): The type of the block arguments. Defaults to ().\n</code></pre> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def __init__(\n    self,\n    stmts: Sequence[Statement] = (),\n    argtypes: Iterable[TypeAttribute] = (),\n):\n    \"\"\"\n    Args:\n        stmts (Sequence[Statement], optional): A list of statements. Defaults to ().\n        argtypes (Iterable[TypeAttribute], optional): The type of the block arguments. Defaults to ().\n    \"\"\"\n    super().__init__()\n    self._args = tuple(\n        BlockArgument(self, i, argtype) for i, argtype in enumerate(argtypes)\n    )\n\n    self._first_stmt = None\n    self._last_stmt = None\n    self._first_branch = None\n    self._last_branch = None\n    self._stmt_len = 0\n    self.stmts.extend(stmts)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.args","title":"args  <code>property</code>","text":"<pre><code>args: BlockArguments\n</code></pre> <p>Get the  arguments of the Block.</p> <p>Returns:</p> Name Type Description <code>BlockArguments</code> <code>BlockArguments</code> <p>The arguments view of the Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.first_stmt","title":"first_stmt  <code>property</code>","text":"<pre><code>first_stmt: Statement | None\n</code></pre> <p>Get the first Statement of the Block.</p> <p>Returns:</p> Type Description <code>Statement | None</code> <p>Statement | None: The first Statement of the Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.last_stmt","title":"last_stmt  <code>property</code>","text":"<pre><code>last_stmt: Statement | None\n</code></pre> <p>Get the last Statement of the Block.</p> <p>Returns:</p> Type Description <code>Statement | None</code> <p>Statement | None: The last Statement of the Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.parent_node","title":"parent_node  <code>property</code> <code>writable</code>","text":"<pre><code>parent_node: Region | None\n</code></pre> <p>Get parent Region of the Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.parent_stmt","title":"parent_stmt  <code>property</code>","text":"<pre><code>parent_stmt: Statement | None\n</code></pre> <p>parent statement of the Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.stmts","title":"stmts  <code>property</code>","text":"<pre><code>stmts: BlockStmts\n</code></pre> <p>Get the list of Statements of the Block.</p> <p>Returns:</p> Name Type Description <code>BlockStmts</code> <code>BlockStmts</code> <p>The Statements of the Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.delete","title":"delete","text":"<pre><code>delete(safe: bool = True) -&gt; None\n</code></pre> <p>Delete the Block completely from the IR.</p> Note <p>This method will detach + remove references of the block.</p> <p>Parameters:</p> Name Type Description Default <code>safe</code> <code>bool</code> <p>If True, raise error if there is anything that still reference components in the block. Defaults to True.</p> <code>True</code> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def delete(self, safe: bool = True) -&gt; None:\n    \"\"\"Delete the Block completely from the IR.\n\n    Note:\n        This method will detach + remove references of the block.\n\n    Args:\n        safe (bool, optional): If True, raise error if there is anything that still reference components in the block. Defaults to True.\n    \"\"\"\n    self.detach()\n    self.drop_all_references()\n    for stmt in self.stmts:\n        stmt.delete(safe=safe)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.detach","title":"detach","text":"<pre><code>detach() -&gt; None\n</code></pre> <p>Detach this Block from the IR.</p> Note <p>Detach only detach the Block from the IR graph. It does not remove uses that reference the Block.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def detach(self) -&gt; None:\n    \"\"\"Detach this Block from the IR.\n\n    Note:\n        Detach only detach the Block from the IR graph. It does not remove uses that reference the Block.\n    \"\"\"\n    if self.parent is None:\n        return\n\n    idx = self.parent[self]\n    del self.parent._blocks[idx]\n    del self.parent._block_idx[self]\n    for block in self.parent._blocks[idx:]:\n        self.parent._block_idx[block] -= 1\n    self.parent = None\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.drop_all_references","title":"drop_all_references","text":"<pre><code>drop_all_references() -&gt; None\n</code></pre> <p>Remove all the dependency that reference/uses this Block.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def drop_all_references(self) -&gt; None:\n    \"\"\"Remove all the dependency that reference/uses this Block.\"\"\"\n    self.parent = None\n    for stmt in self.stmts:\n        stmt.drop_all_references()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.is_structurally_equal","title":"is_structurally_equal","text":"<pre><code>is_structurally_equal(\n    other: Self,\n    context: (\n        dict[IRNode | SSAValue, IRNode | SSAValue] | None\n    ) = None,\n) -&gt; bool\n</code></pre> <p>Check if the Block is structurally equal to another Block.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>The other Block to compare with.</p> required <code>context</code> <code>dict[IRNode | SSAValue, IRNode | SSAValue] | None</code> <p>A map of IRNode/SSAValue to hint that they are equivalent so the check will treat them as equivalent. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the Block is structurally equal to the other Block.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def is_structurally_equal(\n    self,\n    other: Self,\n    context: dict[IRNode | SSAValue, IRNode | SSAValue] | None = None,\n) -&gt; bool:\n    \"\"\"Check if the Block is structurally equal to another Block.\n\n    Args:\n        other (Self): The other Block to compare with.\n        context (dict[IRNode  |  SSAValue, IRNode  |  SSAValue] | None, optional): A map of IRNode/SSAValue to hint that they are equivalent so the check will treat them as equivalent. Defaults to None.\n\n    Returns:\n        bool: True if the Block is structurally equal to the other Block.\n    \"\"\"\n    if context is None:\n        context = {}\n\n    if len(self._args) != len(other._args) or len(self.stmts) != len(other.stmts):\n        return False\n\n    for arg, other_arg in zip(self._args, other._args):\n        if arg.type != other_arg.type:\n            return False\n        context[arg] = other_arg\n\n    context[self] = other\n    if not all(\n        stmt.is_structurally_equal(other_stmt, context)\n        for stmt, other_stmt in zip(self.stmts, other.stmts)\n    ):\n        return False\n\n    return True\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.typecheck","title":"typecheck","text":"<pre><code>typecheck() -&gt; None\n</code></pre> <p>Checking the types of the Statments in the Block.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def typecheck(self) -&gt; None:\n    \"\"\"Checking the types of the Statments in the Block.\"\"\"\n    for stmt in self.stmts:\n        stmt.typecheck()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>Verify the correctness of the Block.</p> <p>Raises:</p> Type Description <code>VerificationError</code> <p>If the Block is not correct.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def verify(self) -&gt; None:\n    \"\"\"Verify the correctness of the Block.\n\n    Raises:\n        VerificationError: If the Block is not correct.\n    \"\"\"\n    from kirin.ir.nodes.stmt import Region\n\n    if not isinstance(self.parent, Region):\n        raise VerificationError(self, \"Parent is not a region\")\n\n    for stmt in self.stmts:\n        stmt.verify()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.walk","title":"walk","text":"<pre><code>walk(\n    *, reverse: bool = False, region_first: bool = False\n) -&gt; Iterator[Statement]\n</code></pre> <p>Traversal the Statements in a Block.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>If walk in the reversed manner. Defaults to False.</p> <code>False</code> <code>region_first</code> <code>bool</code> <p>If the walk should go through the Statement first or the Region of a Statement first. Defaults to False.</p> <code>False</code> <p>Yields:</p> Type Description <code>Statement</code> <p>Iterator[Statement]: An iterator that yield Statements in the Block in the specified order.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def walk(\n    self, *, reverse: bool = False, region_first: bool = False\n) -&gt; Iterator[Statement]:\n    \"\"\"Traversal the Statements in a Block.\n\n    Args:\n        reverse (bool, optional): If walk in the reversed manner. Defaults to False.\n        region_first (bool, optional): If the walk should go through the Statement first or the Region of a Statement first. Defaults to False.\n\n    Yields:\n        Iterator[Statement]: An iterator that yield Statements in the Block in the specified order.\n    \"\"\"\n    for stmt in reversed(self.stmts) if reverse else self.stmts:\n        yield from stmt.walk(reverse=reverse, region_first=region_first)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockArguments","title":"BlockArguments  <code>dataclass</code>","text":"<pre><code>BlockArguments(node: NodeType, field: FieldType)\n</code></pre> <p>               Bases: <code>MutableSequenceView[tuple, 'Block', BlockArgument]</code></p> <p>A View object that contains a list of BlockArgument.</p> Description <p>This is a proxy object that provide safe API to manipulate the arguments of a Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockArguments.append_from","title":"append_from","text":"<pre><code>append_from(\n    typ: TypeAttribute, name: str | None = None\n) -&gt; BlockArgument\n</code></pre> <p>Append a new argument to the Block that this View reference to.</p> Description <p>This method will create a new <code>BlockArgument</code> and append it to the argument list of the reference <code>Block</code>.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>TypeAttribute</code> <p>The type of the argument.</p> required <code>name</code> <code>str | None</code> <p>name of the argument. Defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>BlockArgument</code> <code>BlockArgument</code> <p>The newly created <code>BlockArgument</code>.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def append_from(self, typ: TypeAttribute, name: str | None = None) -&gt; BlockArgument:\n    \"\"\"Append a new argument to the Block that this View reference to.\n\n    Description:\n        This method will create a new [`BlockArgument`][kirin.ir.BlockArgument] and append it to the argument list\n        of the reference `Block`.\n\n    Args:\n        typ (TypeAttribute): The type of the argument.\n        name (str | None, optional): name of the argument. Defaults to `None`.\n\n    Returns:\n        BlockArgument: The newly created [`BlockArgument`][kirin.ir.BlockArgument].\n\n    \"\"\"\n    new_arg = BlockArgument(self.node, len(self.node._args), typ)\n    if name:\n        new_arg.name = name\n\n    self.node._args += (new_arg,)\n    return new_arg\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockArguments.delete","title":"delete","text":"<pre><code>delete(arg: BlockArgument, safe: bool = True) -&gt; None\n</code></pre> <p>Delete a BlockArgument from the Block that this View reference to.</p> <p>Parameters:</p> Name Type Description Default <code>arg</code> <code>BlockArgument</code> <p>description</p> required <code>safe</code> <code>bool</code> <p>If True, error will be raised if the BlockArgument has any Use by others.  Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the argument does not belong to the reference block.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def delete(self, arg: BlockArgument, safe: bool = True) -&gt; None:\n    \"\"\"Delete a BlockArgument from the Block that this View reference to.\n\n\n    Args:\n        arg (BlockArgument): _description_\n        safe (bool, optional): If True, error will be raised if the BlockArgument has any Use by others.  Defaults to True.\n\n    Raises:\n        ValueError: If the argument does not belong to the reference block.\n    \"\"\"\n    if arg.block is not self.node:\n        raise ValueError(\"Attempt to delete an argument that is not in the block\")\n\n    for block_arg in self.field[arg.index + 1 :]:\n        block_arg.index -= 1\n    self.node._args = (*self.field[: arg.index], *self.field[arg.index + 1 :])\n    arg.delete(safe=safe)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockArguments.insert_from","title":"insert_from","text":"<pre><code>insert_from(\n    idx: int, typ: TypeAttribute, name: str | None = None\n) -&gt; BlockArgument\n</code></pre> <p>Insert a new argument to the Block that this View reference to.</p> Description <p>This method will create a new <code>BlockArgument</code> and insert it to the argument list of the reference Block at the specified index</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>Insert location index.</p> required <code>typ</code> <code>TypeAttribute</code> <p>The type of the argument.</p> required <code>name</code> <code>str | None</code> <p>Name of the argument. Defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>BlockArgument</code> <code>BlockArgument</code> <p>The newly created BlockArgument.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def insert_from(\n    self, idx: int, typ: TypeAttribute, name: str | None = None\n) -&gt; BlockArgument:\n    \"\"\"Insert a new argument to the Block that this View reference to.\n\n    Description:\n        This method will create a new `BlockArgument` and insert it to the argument list\n        of the reference Block at the specified index\n\n    Args:\n        idx (int): Insert location index.\n        typ (TypeAttribute): The type of the argument.\n        name (str | None, optional): Name of the argument. Defaults to `None`.\n\n    Returns:\n        BlockArgument: The newly created BlockArgument.\n    \"\"\"\n    if idx &lt; 0 or idx &gt; len(self.node._args):\n        raise ValueError(\"Invalid index\")\n\n    new_arg = BlockArgument(self.node, idx, typ)\n    if name:\n        new_arg.name = name\n\n    for arg in self.node._args[idx:]:\n        arg.index += 1\n    self.node._args = self.node._args[:idx] + (new_arg,) + self.node._args[idx:]\n    return new_arg\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockStmts","title":"BlockStmts  <code>dataclass</code>","text":"<pre><code>BlockStmts(node: NodeType)\n</code></pre> <p>               Bases: <code>View['Block', 'Statement']</code></p> <p>A View object that contains a list of Statements.</p> Description <p>This is a proxy object that provide safe API to manipulate the statements of a Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockStmts.append","title":"append","text":"<pre><code>append(value: Statement) -&gt; None\n</code></pre> <p>Append a Statement to the reference Block.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Statement</code> <p>A Statement to be appended.</p> required Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def append(self, value: Statement) -&gt; None:\n    \"\"\"Append a Statement to the reference Block.\n\n    Args:\n        value (Statement): A Statement to be appended.\n    \"\"\"\n    from kirin.ir.nodes.stmt import Statement\n\n    if not isinstance(value, Statement):\n        raise ValueError(f\"Expected Statement, got {type(value).__name__}\")\n\n    if self.node._stmt_len == 0:  # empty block\n        value.attach(self.node)\n        self.node._first_stmt = value\n        self.node._last_stmt = value\n        self.node._stmt_len += 1\n    elif self.node._last_stmt:\n        value.insert_after(self.node._last_stmt)\n    else:\n        raise ValueError(\"Invalid block, last_stmt is None\")\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockStmts.at","title":"at","text":"<pre><code>at(index: int) -&gt; Statement\n</code></pre> <p>This is similar to getitem but due to the nature of the linked list, it is less efficient than getitem.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def at(self, index: int) -&gt; Statement:\n    \"\"\"This is similar to __getitem__ but due to the nature of the linked list,\n    it is less efficient than __getitem__.\n    \"\"\"\n    if index &gt;= len(self):\n        raise IndexError(\"Index out of range\")\n\n    if index &lt; 0:\n        return self._at_reverse(-index - 1)\n\n    return self._at_forward(index)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/","title":"Region","text":""},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region","title":"Region  <code>dataclass</code>","text":"<pre><code>Region(\n    blocks: Block | Iterable[Block] = (),\n    parent: Statement | None = None,\n)\n</code></pre> <p>               Bases: <code>IRNode['Statement']</code></p> <p>Region consist of a list of Blocks</p> <p>Parameters:</p> Name Type Description Default <code>blocks</code> <code>Block | Iterable[Block]</code> <p>A single <code>Block</code> object or an iterable of Block objects. Defaults to ().</p> <code>()</code> <code>parent</code> <code>Statement | None</code> <p>The parent <code>Statement</code> object. Defaults to None.</p> <code>None</code> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def __init__(\n    self,\n    blocks: Block | Iterable[Block] = (),\n    parent: Statement | None = None,\n):\n    \"\"\"Initialize a Region object.\n\n    Args:\n        blocks (Block | Iterable[Block], optional): A single [`Block`](ir.Block) object or an iterable of Block objects. Defaults to ().\n        parent (Statement | None, optional): The parent [`Statement`](ir.Statement) object. Defaults to None.\n    \"\"\"\n    self._blocks = []\n    self._block_idx = {}\n    self.parent_node = parent\n    if isinstance(blocks, Block):\n        blocks = (blocks,)\n    for block in blocks:\n        self.blocks.append(block)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.blocks","title":"blocks  <code>property</code>","text":"<pre><code>blocks: RegionBlocks\n</code></pre> <p>Get the Blocks in the region.</p> <p>Returns:</p> Name Type Description <code>RegionBlocks</code> <code>RegionBlocks</code> <p>The blocks View object of the region.</p>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.parent_node","title":"parent_node  <code>property</code> <code>writable</code>","text":"<pre><code>parent_node: Statement | None\n</code></pre> <p>Get the parent statement of the region.</p>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.region_index","title":"region_index  <code>property</code>","text":"<pre><code>region_index: int\n</code></pre> <p>Get the index of the region within the parent scope.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The index of the region within the parent scope.</p>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(block: Block) -&gt; int\n</code></pre> <p>Get the index of a block within the region.</p> <p>Parameters:</p> Name Type Description Default <code>block</code> <code>Block</code> <p>The block to get the index of.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the block does not belong to the region.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The index of the block within the region.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def __getitem__(self, block: Block) -&gt; int:\n    \"\"\"Get the index of a block within the region.\n\n    Args:\n        block (Block): The block to get the index of.\n\n    Raises:\n        ValueError: If the block does not belong to the region.\n\n    Returns:\n        int: The index of the block within the region.\n    \"\"\"\n    if block.parent is not self:\n        raise ValueError(\"Block does not belong to the region\")\n    return self._block_idx[block]\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.clone","title":"clone","text":"<pre><code>clone(\n    ssamap: dict[SSAValue, SSAValue] | None = None\n) -&gt; Region\n</code></pre> <p>Clone a region. This will clone all blocks and statements in the region. <code>SSAValue</code> defined outside the region will not be cloned unless provided in <code>ssamap</code>.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def clone(self, ssamap: dict[SSAValue, SSAValue] | None = None) -&gt; Region:\n    \"\"\"Clone a region. This will clone all blocks and statements in the region.\n    `SSAValue` defined outside the region will not be cloned unless provided in `ssamap`.\n    \"\"\"\n    ret = Region()\n    successor_map: dict[Block, Block] = {}\n    _ssamap = ssamap or {}\n    for block in self.blocks:\n        new_block = Block()\n        ret.blocks.append(new_block)\n        successor_map[block] = new_block\n        for arg in block.args:\n            new_arg = new_block.args.append_from(arg.type, arg.name)\n            _ssamap[arg] = new_arg\n\n    # update statements\n    for block in self.blocks:\n        for stmt in block.stmts:\n            new_stmt = stmt.from_stmt(\n                stmt,\n                args=[_ssamap[arg] for arg in stmt.args],\n                regions=[region.clone(_ssamap) for region in stmt.regions],\n                successors=[\n                    successor_map[successor] for successor in stmt.successors\n                ],\n            )\n            successor_map[block].stmts.append(new_stmt)\n            for result, new_result in zip(stmt.results, new_stmt.results):\n                _ssamap[result] = new_result\n\n    return ret\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.delete","title":"delete","text":"<pre><code>delete(safe: bool = True) -&gt; None\n</code></pre> <p>Delete the Region completely from the IR graph.</p> Note <p>This method will detach + remove references of the Region.</p> <p>Parameters:</p> Name Type Description Default <code>safe</code> <code>bool</code> <p>If True, raise error if there is anything that still reference components in the Region. Defaults to True.</p> <code>True</code> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def delete(self, safe: bool = True) -&gt; None:\n    \"\"\"Delete the Region completely from the IR graph.\n\n    Note:\n        This method will detach + remove references of the Region.\n\n    Args:\n        safe (bool, optional): If True, raise error if there is anything that still reference components in the Region. Defaults to True.\n    \"\"\"\n    self.detach()\n    self.drop_all_references()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.detach","title":"detach","text":"<pre><code>detach(index: int | None = None) -&gt; None\n</code></pre> <p>Detach this Region from the IR tree graph.</p> Note <p>Detach only detach the Region from the IR graph. It does not remove uses that reference the Region.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def detach(self, index: int | None = None) -&gt; None:\n    \"\"\"Detach this Region from the IR tree graph.\n\n    Note:\n        Detach only detach the Region from the IR graph. It does not remove uses that reference the Region.\n    \"\"\"\n    # already detached\n    if self.parent_node is None:\n        return\n\n    if index is not None:\n        region_idx = index\n    else:\n        region_idx = self.region_index\n\n    del self.parent_node._regions[region_idx]\n    self.parent_node = None\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.drop_all_references","title":"drop_all_references","text":"<pre><code>drop_all_references() -&gt; None\n</code></pre> <p>Remove all the dependency that reference/uses this Region.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def drop_all_references(self) -&gt; None:\n    \"\"\"Remove all the dependency that reference/uses this Region.\"\"\"\n    self.parent_node = None\n    for block in self._blocks:\n        block.drop_all_references()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.is_structurally_equal","title":"is_structurally_equal","text":"<pre><code>is_structurally_equal(\n    other: Self,\n    context: (\n        dict[IRNode | SSAValue, IRNode | SSAValue] | None\n    ) = None,\n) -&gt; bool\n</code></pre> <p>Check if the Region is structurally equal to another Region.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>The other Region to compare with.</p> required <code>context</code> <code>dict[IRNode | SSAValue, IRNode | SSAValue] | None</code> <p>A map of IRNode/SSAValue to hint that they are equivalent so the check will treat them as equivalent. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the Region is structurally equal to the other Region.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def is_structurally_equal(\n    self,\n    other: Self,\n    context: dict[IRNode | SSAValue, IRNode | SSAValue] | None = None,\n) -&gt; bool:\n    \"\"\"Check if the Region is structurally equal to another Region.\n\n    Args:\n        other (Self): The other Region to compare with.\n        context (dict[IRNode  |  SSAValue, IRNode  |  SSAValue] | None, optional): A map of IRNode/SSAValue to hint that they are equivalent so the check will treat them as equivalent. Defaults to None.\n\n    Returns:\n        bool: True if the Region is structurally equal to the other Region.\n    \"\"\"\n    if context is None:\n        context = {}\n\n    if len(self.blocks) != len(other.blocks):\n        return False\n\n    for block, other_block in zip(self.blocks, other.blocks):\n        context[block] = other_block\n\n    if not all(\n        block.is_structurally_equal(other_block, context)\n        for block, other_block in zip(self.blocks, other.blocks)\n    ):\n        return False\n\n    return True\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.typecheck","title":"typecheck","text":"<pre><code>typecheck() -&gt; None\n</code></pre> <p>Checking the types of the Statments of Blocks in the Region.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def typecheck(self) -&gt; None:\n    \"\"\"Checking the types of the Statments of Blocks in the Region.\"\"\"\n    for block in self.blocks:\n        block.typecheck()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>Verify the correctness of the Region.</p> <p>Raises:</p> Type Description <code>VerificationError</code> <p>If the Region is not correct.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def verify(self) -&gt; None:\n    \"\"\"Verify the correctness of the Region.\n\n    Raises:\n        VerificationError: If the Region is not correct.\n    \"\"\"\n    from kirin.ir.nodes.stmt import Statement\n\n    if not isinstance(self.parent_node, Statement):\n        raise VerificationError(\n            self, \"expect Region to have a parent of type Statement\"\n        )\n\n    for block in self.blocks:\n        block.verify()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.walk","title":"walk","text":"<pre><code>walk(\n    *, reverse: bool = False, region_first: bool = False\n) -&gt; Iterator[Statement]\n</code></pre> <p>Traversal the Statements of Blocks in the Region.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>If walk in the reversed manner. Defaults to False.</p> <code>False</code> <code>region_first</code> <code>bool</code> <p>If the walk should go through the Statement first or the Region of a Statement first. Defaults to False.</p> <code>False</code> <p>Yields:</p> Type Description <code>Statement</code> <p>Iterator[Statement]: An iterator that yield Statements of Blocks in the Region, in the specified order.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def walk(\n    self, *, reverse: bool = False, region_first: bool = False\n) -&gt; Iterator[Statement]:\n    \"\"\"Traversal the Statements of Blocks in the Region.\n\n    Args:\n        reverse (bool, optional): If walk in the reversed manner. Defaults to False.\n        region_first (bool, optional): If the walk should go through the Statement first or the Region of a Statement first. Defaults to False.\n\n    Yields:\n        Iterator[Statement]: An iterator that yield Statements of Blocks in the Region, in the specified order.\n    \"\"\"\n    for block in reversed(self.blocks) if reverse else self.blocks:\n        yield from block.walk(reverse=reverse, region_first=region_first)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.RegionBlocks","title":"RegionBlocks  <code>dataclass</code>","text":"<pre><code>RegionBlocks(node: NodeType, field: FieldType)\n</code></pre> <p>               Bases: <code>MutableSequenceView[list[Block], 'Region', Block]</code></p> <p>A View object that contains a list of Blocks of a Region.</p> Description <p>This is a proxy object that provide safe API to manipulate the Blocks of a Region.</p>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.RegionBlocks.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(\n    idx: int | slice,\n    block_or_blocks: Block | Iterable[Block],\n) -&gt; None\n</code></pre> <p>Replace/Set the Blocks of the Region.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int | slice</code> <p>The index or slice to replace the <code>Blocks</code>.</p> required <code>block_or_blocks</code> <code>Block | Iterable[Block]</code> <p>The Block or Blocks to replace the Blocks.</p> required Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def __setitem__(\n    self, idx: int | slice, block_or_blocks: Block | Iterable[Block]\n) -&gt; None:\n    \"\"\"Replace/Set the Blocks of the Region.\n\n    Args:\n        idx (int | slice): The index or slice to replace the [`Blocks`](ir.Block).\n        block_or_blocks (Block | Iterable[Block]): The Block or Blocks to replace the Blocks.\n\n    \"\"\"\n    if isinstance(idx, int) and isinstance(block_or_blocks, Block):\n        self.field[idx].detach()\n        block_or_blocks.attach(self.node)\n        self.field[idx] = block_or_blocks\n        self.node._block_idx[block_or_blocks] = idx\n    elif isinstance(idx, slice) and isinstance(block_or_blocks, Iterable):\n        for block in block_or_blocks:\n            block.attach(self.node)\n        self.field[idx] = block_or_blocks\n        self.node._block_idx = {\n            block: i for i, block in enumerate(self.field)\n        }  # reindex\n    else:\n        raise ValueError(\"Invalid assignment\")\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.RegionBlocks.append","title":"append","text":"<pre><code>append(value: Block) -&gt; None\n</code></pre> <p>Append a Block to the Region.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Block</code> <p>The block to be appended.</p> required Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def append(self, value: Block) -&gt; None:\n    \"\"\"Append a Block to the Region.\n\n    Args:\n        value (Block): The block to be appended.\n    \"\"\"\n    value.attach(self.node)\n    self.node._block_idx[value] = len(self.field)\n    self.field.append(value)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.RegionBlocks.insert","title":"insert","text":"<pre><code>insert(idx: int, value: Block) -&gt; None\n</code></pre> <p>Inserts a Block at the specified index.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>The index at which to insert the block.</p> required <code>value</code> <code>Block</code> <p>The block to be inserted.</p> required Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def insert(self, idx: int, value: Block) -&gt; None:\n    \"\"\"Inserts a Block at the specified index.\n\n    Args:\n        idx (int): The index at which to insert the block.\n        value (Block): The block to be inserted.\n    \"\"\"\n    value.attach(self.node)\n    self.field.insert(idx, value)\n    for i, value in enumerate(self.field[idx:], idx):\n        self.node._block_idx[value] = i\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/","title":"Stmt","text":""},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.ArgumentList","title":"ArgumentList  <code>dataclass</code>","text":"<pre><code>ArgumentList(node: NodeType, field: FieldType)\n</code></pre> <p>               Bases: <code>MutableSequenceView[tuple, 'Statement', SSAValue]</code>, <code>Printable</code></p> <p>A View object that contains a list of Arguemnts of a Statement.</p> Description <p>This is a proxy object that provide safe API to manipulate the arguemnts of a statement.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.ArgumentList.insert","title":"insert","text":"<pre><code>insert(idx: int, value: SSAValue) -&gt; None\n</code></pre> <p>Insert the argument SSAValue at the specified index.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>The index to insert the value.</p> required <code>value</code> <code>SSAValue</code> <p>The value to insert.</p> required Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def insert(self, idx: int, value: SSAValue) -&gt; None:\n    \"\"\"Insert the argument SSAValue at the specified index.\n\n    Args:\n        idx (int): The index to insert the value.\n        value (SSAValue): The value to insert.\n    \"\"\"\n    args = self.field\n    value.add_use(Use(self.node, idx))\n    new_args = (*args[:idx], value, *args[idx:])\n    self.node._args = new_args\n    self.field = new_args\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.ArgumentList.set_item","title":"set_item","text":"<pre><code>set_item(idx: int, value: SSAValue) -&gt; None\n</code></pre> <p>Set the argument SSAVAlue at the specified index.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>The index of the item to set.</p> required <code>value</code> <code>SSAValue</code> <p>The value to set.</p> required Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def set_item(self, idx: int, value: SSAValue) -&gt; None:\n    \"\"\"Set the argument SSAVAlue at the specified index.\n\n    Args:\n        idx (int): The index of the item to set.\n        value (SSAValue): The value to set.\n    \"\"\"\n    args = self.field\n    args[idx].remove_use(Use(self.node, idx))\n    value.add_use(Use(self.node, idx))\n    new_args = (*args[:idx], value, *args[idx + 1 :])\n    self.node._args = new_args\n    self.field = new_args\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.ResultList","title":"ResultList  <code>dataclass</code>","text":"<pre><code>ResultList(node: NodeType, field: FieldType)\n</code></pre> <p>               Bases: <code>MutableSequenceView[list, 'Statement', ResultValue]</code></p> <p>A View object that contains a list of ResultValue of a Statement.</p> Description <p>This is a proxy object that provide safe API to manipulate the result values of a statement</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.ResultList.types","title":"types  <code>property</code>","text":"<pre><code>types: Sequence[TypeAttribute]\n</code></pre> <p>Get the result types of the Statement.</p> <p>Returns:</p> Type Description <code>Sequence[TypeAttribute]</code> <p>Sequence[TypeAttribute]: type of each result value.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement","title":"Statement  <code>dataclass</code>","text":"<pre><code>Statement(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>IRNode['Block']</code></p> <p>The Statment is an instruction in the IR</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.args","title":"args  <code>instance-attribute</code> <code>property</code> <code>writable</code>","text":"<pre><code>args: ArgumentList = args\n</code></pre> <p>Get the arguments of the Statement.</p> <p>Returns:</p> Name Type Description <code>ArgumentList</code> <code>ArgumentList</code> <p>The arguments View of the Statement.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.next_stmt","title":"next_stmt  <code>property</code> <code>writable</code>","text":"<pre><code>next_stmt: Statement | None\n</code></pre> <p>Get the next statement.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.parent_block","title":"parent_block  <code>property</code>","text":"<pre><code>parent_block: Block | None\n</code></pre> <p>Get the parent Block.</p> <p>Returns:</p> Type Description <code>Block | None</code> <p>Block | None: The parent Block.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.parent_node","title":"parent_node  <code>property</code> <code>writable</code>","text":"<pre><code>parent_node: Block | None\n</code></pre> <p>Get the parent node.</p> <p>Returns:</p> Type Description <code>Block | None</code> <p>Block | None: The parent node.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.parent_region","title":"parent_region  <code>property</code>","text":"<pre><code>parent_region: Region | None\n</code></pre> <p>Get the parent Region. Returns:     Region | None: The parent Region.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.parent_stmt","title":"parent_stmt  <code>property</code>","text":"<pre><code>parent_stmt: Statement | None\n</code></pre> <p>Get the parent statement.</p> <p>Returns:</p> Type Description <code>Statement | None</code> <p>Statement | None: The parent statement.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.prev_stmt","title":"prev_stmt  <code>property</code> <code>writable</code>","text":"<pre><code>prev_stmt: Statement | None\n</code></pre> <p>Get the previous statement.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.regions","title":"regions  <code>instance-attribute</code> <code>property</code> <code>writable</code>","text":"<pre><code>regions: list[Region] = list(regions)\n</code></pre> <p>Get a list of regions of the Statement.</p> <p>Returns:</p> Type Description <code>list[Region]</code> <p>list[Region]: The list of regions of the Statement.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.results","title":"results  <code>property</code>","text":"<pre><code>results: ResultList\n</code></pre> <p>Get the result values of the Statement.</p> <p>Returns:</p> Name Type Description <code>ResultList</code> <code>ResultList</code> <p>The result values View of the Statement.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.delete","title":"delete","text":"<pre><code>delete(safe: bool = True) -&gt; None\n</code></pre> <p>Delete the Statement completely from the IR graph.</p> Note <p>This method will detach + remove references of the Statement.</p> <p>Parameters:</p> Name Type Description Default <code>safe</code> <code>bool</code> <p>If True, raise error if there is anything that still reference components in the Statement. Defaults to True.</p> <code>True</code> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def delete(self, safe: bool = True) -&gt; None:\n    \"\"\"Delete the Statement completely from the IR graph.\n\n    Note:\n        This method will detach + remove references of the Statement.\n\n    Args:\n        safe (bool, optional): If True, raise error if there is anything that still reference components in the Statement. Defaults to True.\n    \"\"\"\n    self.detach()\n    self.drop_all_references()\n    for result in self._results:\n        result.delete(safe=safe)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.detach","title":"detach","text":"<pre><code>detach() -&gt; None\n</code></pre> <p>detach the statement from its parent block.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def detach(self) -&gt; None:\n    \"\"\"detach the statement from its parent block.\"\"\"\n    if self.parent is None:\n        return\n\n    parent: Block = self.parent\n    prev_stmt = self.prev_stmt\n    next_stmt = self.next_stmt\n\n    if prev_stmt is not None:\n        prev_stmt._next_stmt = next_stmt\n        self._prev_stmt = None\n    else:\n        assert (\n            parent._first_stmt is self\n        ), \"Invalid statement, has no prev_stmt but not first_stmt\"\n        parent._first_stmt = next_stmt\n\n    if next_stmt is not None:\n        next_stmt._prev_stmt = prev_stmt\n        self._next_stmt = None\n    else:\n        assert (\n            parent._last_stmt is self\n        ), \"Invalid statement, has no next_stmt but not last_stmt\"\n        parent._last_stmt = prev_stmt\n\n    self.parent = None\n    parent._stmt_len -= 1\n    return\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.drop_all_references","title":"drop_all_references","text":"<pre><code>drop_all_references() -&gt; None\n</code></pre> <p>Remove all the dependency that reference/uses this Statement.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def drop_all_references(self) -&gt; None:\n    \"\"\"Remove all the dependency that reference/uses this Statement.\"\"\"\n    self.parent = None\n    for idx, arg in enumerate(self._args):\n        arg.remove_use(Use(self, idx))\n    for region in self._regions:\n        region.drop_all_references()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.expect_one_result","title":"expect_one_result","text":"<pre><code>expect_one_result() -&gt; ResultValue\n</code></pre> <p>Check if the statement contain only one result, and return it</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def expect_one_result(self) -&gt; ResultValue:\n    \"\"\"Check if the statement contain only one result, and return it\"\"\"\n    if len(self._results) != 1:\n        raise ValueError(f\"expected one result, got {len(self._results)}\")\n    return self._results[0]\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.from_python_call","title":"from_python_call  <code>classmethod</code>","text":"<pre><code>from_python_call(\n    state: LoweringState, node: ast.Call\n) -&gt; Result\n</code></pre> <p>Converts a Python call expression to a Kirin IR node.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>LoweringState</code> <p>The current state of the lowering process.</p> required <code>node</code> <code>Call</code> <p>The Python call expression to be converted.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If the conversion is not implemented for the given call expression.</p> <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>The converted Kirin IR node.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>@classmethod\ndef from_python_call(cls, state: LoweringState, node: ast.Call) -&gt; Result:\n    \"\"\"Converts a Python call expression to a Kirin IR node.\n\n    Args:\n        state (LoweringState): The current state of the lowering process.\n        node (ast.Call): The Python call expression to be converted.\n\n    Raises:\n        NotImplementedError: If the conversion is not implemented for the given call expression.\n\n    Returns:\n        Result: The converted Kirin IR node.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.from_stmt","title":"from_stmt  <code>classmethod</code>","text":"<pre><code>from_stmt(\n    other: Statement,\n    args: Sequence[SSAValue] | None = None,\n    regions: list[Region] | None = None,\n    successors: list[Block] | None = None,\n    attributes: dict[str, Attribute] | None = None,\n) -&gt; Self\n</code></pre> <p>Create a similar Statement with new <code>ResultValue</code> and without attaching to any parent block. This still references to the old successor and regions.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>@classmethod\ndef from_stmt(\n    cls,\n    other: Statement,\n    args: Sequence[SSAValue] | None = None,\n    regions: list[Region] | None = None,\n    successors: list[Block] | None = None,\n    attributes: dict[str, Attribute] | None = None,\n) -&gt; Self:\n    \"\"\"Create a similar Statement with new `ResultValue` and without\n    attaching to any parent block. This still references to the old successor\n    and regions.\n    \"\"\"\n    obj = cls.__new__(cls)\n    Statement.__init__(\n        obj,\n        args=args or other._args,\n        regions=regions or other._regions,\n        successors=successors or other.successors,\n        attributes=attributes or other.attributes,\n        properties=other.properties,  # properties are immutable, thus no need to copy\n        result_types=[result.type for result in other._results],\n        args_slice=other._name_args_slice,\n    )\n    return obj\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.get_attr_or_prop","title":"get_attr_or_prop","text":"<pre><code>get_attr_or_prop(key: str) -&gt; Attribute | None\n</code></pre> <p>Get the attribute or property of the Statement.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the attribute or property.</p> required <p>Returns:</p> Type Description <code>Attribute | None</code> <p>Attribute | None: The attribute or property of the Statement.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def get_attr_or_prop(self, key: str) -&gt; Attribute | None:\n    \"\"\"Get the attribute or property of the Statement.\n\n    Args:\n        key (str): The key of the attribute or property.\n\n    Returns:\n        Attribute | None: The attribute or property of the Statement.\n    \"\"\"\n    return self.attributes.get(key, self.properties.get(key))\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.get_trait","title":"get_trait  <code>classmethod</code>","text":"<pre><code>get_trait(trait: type[TraitType]) -&gt; TraitType | None\n</code></pre> <p>Get the trait of the Statement.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>@classmethod\ndef get_trait(cls, trait: type[TraitType]) -&gt; TraitType | None:\n    \"\"\"Get the trait of the Statement.\"\"\"\n    for t in cls.traits:\n        if isinstance(t, trait):\n            return t\n    return None\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.has_trait","title":"has_trait  <code>classmethod</code>","text":"<pre><code>has_trait(trait_type: type[StmtTrait]) -&gt; bool\n</code></pre> <p>Check if the Statement has a specific trait.</p> <p>Parameters:</p> Name Type Description Default <code>trait_type</code> <code>type[StmtTrait]</code> <p>The type of trait to check for.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the class has the specified trait, False otherwise.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>@classmethod\ndef has_trait(cls, trait_type: type[StmtTrait]) -&gt; bool:\n    \"\"\"Check if the Statement has a specific trait.\n\n    Args:\n        trait_type (type[StmtTrait]): The type of trait to check for.\n\n    Returns:\n        bool: True if the class has the specified trait, False otherwise.\n    \"\"\"\n    for trait in cls.traits:\n        if isinstance(trait, trait_type):\n            return True\n    return False\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.insert_after","title":"insert_after","text":"<pre><code>insert_after(stmt: Statement) -&gt; None\n</code></pre> <p>Insert the current Statement after the input Statement.</p> <p>Parameters:</p> Name Type Description Default <code>stmt</code> <code>Statement</code> <p>Input Statement.</p> required Example <p>The following example demonstrates how to insert a Statement after another Statement. After <code>insert_after</code> is called, <code>stmt1</code> will be inserted after <code>stmt2</code>, which appears in IR in the order (stmt2 -&gt; stmt1) <pre><code>stmt1 = Statement()\nstmt2 = Statement()\nstmt1.insert_after(stmt2)\n</code></pre></p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def insert_after(self, stmt: Statement) -&gt; None:\n    \"\"\"Insert the current Statement after the input Statement.\n\n    Args:\n        stmt (Statement): Input Statement.\n\n    Example:\n        The following example demonstrates how to insert a Statement after another Statement.\n        After `insert_after` is called, `stmt1` will be inserted after `stmt2`, which appears in IR in the order (stmt2 -&gt; stmt1)\n        ```python\n        stmt1 = Statement()\n        stmt2 = Statement()\n        stmt1.insert_after(stmt2)\n        ```\n\n    \"\"\"\n    if self._next_stmt is not None and self._prev_stmt is not None:\n        raise ValueError(\n            f\"Cannot insert before a statement that is already in a block: {self.name}\"\n        )\n\n    if stmt._next_stmt is not None:\n        stmt._next_stmt._prev_stmt = self\n\n    self._prev_stmt = stmt\n    self._next_stmt = stmt._next_stmt\n\n    self.parent = stmt.parent\n    stmt._next_stmt = self\n\n    if self.parent:\n        self.parent._stmt_len += 1\n\n        if self._next_stmt is None:\n            self.parent._last_stmt = self\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.insert_before","title":"insert_before","text":"<pre><code>insert_before(stmt: Statement) -&gt; None\n</code></pre> <p>Insert the current Statement before the input Statement.</p> <p>Parameters:</p> Name Type Description Default <code>stmt</code> <code>Statement</code> <p>Input Statement.</p> required Example <p>The following example demonstrates how to insert a Statement before another Statement. After <code>insert_before</code> is called, <code>stmt1</code> will be inserted before <code>stmt2</code>, which appears in IR in the order (stmt1 -&gt; stmt2) <pre><code>stmt1 = Statement()\nstmt2 = Statement()\nstmt1.insert_before(stmt2)\n</code></pre></p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def insert_before(self, stmt: Statement) -&gt; None:\n    \"\"\"Insert the current Statement before the input Statement.\n\n    Args:\n        stmt (Statement): Input Statement.\n\n    Example:\n        The following example demonstrates how to insert a Statement before another Statement.\n        After `insert_before` is called, `stmt1` will be inserted before `stmt2`, which appears in IR in the order (stmt1 -&gt; stmt2)\n        ```python\n        stmt1 = Statement()\n        stmt2 = Statement()\n        stmt1.insert_before(stmt2)\n        ```\n\n    \"\"\"\n    if self._next_stmt is not None and self._prev_stmt is not None:\n        raise ValueError(\n            f\"Cannot insert before a statement that is already in a block: {self.name}\"\n        )\n\n    if stmt._prev_stmt is not None:\n        stmt._prev_stmt._next_stmt = self\n\n    self._next_stmt = stmt\n    self._prev_stmt = stmt._prev_stmt\n\n    self.parent = stmt.parent\n    stmt._prev_stmt = self\n\n    if self.parent:\n        self.parent._stmt_len += 1\n\n        if self._prev_stmt is None:\n            self.parent._first_stmt = self\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.is_structurally_equal","title":"is_structurally_equal","text":"<pre><code>is_structurally_equal(\n    other: Self,\n    context: (\n        dict[IRNode | SSAValue, IRNode | SSAValue] | None\n    ) = None,\n) -&gt; bool\n</code></pre> <p>Check if the Statement is structurally equal to another Statement.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>The other Statelemt to compare with.</p> required <code>context</code> <code>dict[IRNode | SSAValue, IRNode | SSAValue] | None</code> <p>A map of IRNode/SSAValue to hint that they are equivalent so the check will treat them as equivalent. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the IRNode is structurally equal to the other.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def is_structurally_equal(\n    self,\n    other: Self,\n    context: dict[IRNode | SSAValue, IRNode | SSAValue] | None = None,\n) -&gt; bool:\n    \"\"\"Check if the Statement is structurally equal to another Statement.\n\n    Args:\n        other (Self): The other Statelemt to compare with.\n        context (dict[IRNode  |  SSAValue, IRNode  |  SSAValue] | None, optional): A map of IRNode/SSAValue to hint that they are equivalent so the check will treat them as equivalent. Defaults to None.\n\n    Returns:\n        bool: True if the IRNode is structurally equal to the other.\n    \"\"\"\n    if context is None:\n        context = {}\n\n    if self.name != other.name:\n        return False\n\n    if (\n        len(self.args) != len(other.args)\n        or len(self.regions) != len(other.regions)\n        or len(self.successors) != len(other.successors)\n        or self.attributes != other.attributes\n        or self.properties != other.properties\n    ):\n        return False\n\n    if (\n        self.parent is not None\n        and other.parent is not None\n        and context.get(self.parent) != other.parent\n    ):\n        return False\n\n    if not all(\n        context.get(arg, arg) == other_arg\n        for arg, other_arg in zip(self.args, other.args)\n    ):\n        return False\n\n    if not all(\n        context.get(successor, successor) == other_successor\n        for successor, other_successor in zip(self.successors, other.successors)\n    ):\n        return False\n\n    if not all(\n        region.is_structurally_equal(other_region, context)\n        for region, other_region in zip(self.regions, other.regions)\n    ):\n        return False\n\n    for result, other_result in zip(self._results, other._results):\n        context[result] = other_result\n\n    return True\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.replace_by","title":"replace_by","text":"<pre><code>replace_by(stmt: Statement) -&gt; None\n</code></pre> <p>Replace the current Statement by the input Statement.</p> <p>Parameters:</p> Name Type Description Default <code>stmt</code> <code>Statement</code> <p>Input Statement.</p> required Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def replace_by(self, stmt: Statement) -&gt; None:\n    \"\"\"Replace the current Statement by the input Statement.\n\n    Args:\n        stmt (Statement): Input Statement.\n    \"\"\"\n    stmt.insert_before(self)\n    for result, old_result in zip(stmt._results, self._results):\n        old_result.replace_by(result)\n        if old_result.name:\n            result.name = old_result.name\n    self.delete()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.typecheck","title":"typecheck","text":"<pre><code>typecheck() -&gt; None\n</code></pre> <p>check the type of the statement.</p> Note <ol> <li>Statement should implement typecheck. this is done automatically via @statement, but in the case manualy implementation is needed, it should be implemented here.</li> <li>This API should be called after all the types are figured out (by typeinfer)</li> </ol> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def typecheck(self) -&gt; None:\n    \"\"\"check the type of the statement.\n\n    Note:\n        1. Statement should implement typecheck.\n        this is done automatically via @statement, but\n        in the case manualy implementation is needed,\n        it should be implemented here.\n        2. This API should be called after all the types are figured out (by typeinfer)\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>run mandatory validation checks. This is not same as typecheck, which may be optional.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def verify(self) -&gt; None:\n    return\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.walk","title":"walk","text":"<pre><code>walk(\n    *,\n    reverse: bool = False,\n    region_first: bool = False,\n    include_self: bool = True\n) -&gt; Iterator[Statement]\n</code></pre> <p>Traversal the Statements of Regions.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>If walk in the reversed manner. Defaults to False.</p> <code>False</code> <code>region_first</code> <code>bool</code> <p>If the walk should go through the Statement first or the Region of a Statement first. Defaults to False.</p> <code>False</code> <code>include_self</code> <code>bool</code> <p>If the walk should include the Statement itself. Defaults to True.</p> <code>True</code> <p>Yields:</p> Type Description <code>Statement</code> <p>Iterator[Statement]: An iterator that yield Statements of Blocks in the Region, in the specified order.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def walk(\n    self,\n    *,\n    reverse: bool = False,\n    region_first: bool = False,\n    include_self: bool = True,\n) -&gt; Iterator[Statement]:\n    \"\"\"Traversal the Statements of Regions.\n\n    Args:\n        reverse (bool, optional): If walk in the reversed manner. Defaults to False.\n        region_first (bool, optional): If the walk should go through the Statement first or the Region of a Statement first. Defaults to False.\n        include_self (bool, optional): If the walk should include the Statement itself. Defaults to True.\n\n    Yields:\n        Iterator[Statement]: An iterator that yield Statements of Blocks in the Region, in the specified order.\n    \"\"\"\n    if include_self and not region_first:\n        yield self\n\n    for region in reversed(self.regions) if reverse else self.regions:\n        yield from region.walk(reverse=reverse, region_first=region_first)\n\n    if include_self and region_first:\n        yield self\n</code></pre>"},{"location":"reference/kirin/ir/nodes/view/","title":"View","text":""},{"location":"reference/kirin/ir/nodes/view/#kirin.ir.nodes.view.MutableSequenceView","title":"MutableSequenceView  <code>dataclass</code>","text":"<pre><code>MutableSequenceView(node: NodeType, field: FieldType)\n</code></pre> <p>               Bases: <code>SequenceView[FieldType, NodeType, ElemType]</code></p>"},{"location":"reference/kirin/ir/nodes/view/#kirin.ir.nodes.view.MutableSequenceView.popfirst","title":"popfirst","text":"<pre><code>popfirst() -&gt; ElemType | None\n</code></pre> <p>Pop the first element from the view.</p> <p>Returns:</p> Type Description <code>ElemType | None</code> <p>The first element in the view.</p> Source code in <code>src/kirin/ir/nodes/view.py</code> <pre><code>def popfirst(self) -&gt; ElemType | None:\n    \"\"\"Pop the first element from the view.\n\n    Returns:\n        The first element in the view.\n    \"\"\"\n    if self:\n        return self.pop(0)\n    return None\n</code></pre>"},{"location":"reference/kirin/ir/nodes/view/#kirin.ir.nodes.view.MutableSequenceView.poplast","title":"poplast","text":"<pre><code>poplast() -&gt; ElemType | None\n</code></pre> <p>Pop the last element from the view.</p> <p>Returns:</p> Type Description <code>ElemType | None</code> <p>The last element in the view.</p> Source code in <code>src/kirin/ir/nodes/view.py</code> <pre><code>def poplast(self) -&gt; ElemType | None:\n    \"\"\"Pop the last element from the view.\n\n    Returns:\n        The last element in the view.\n    \"\"\"\n    if self:\n        return self.pop(-1)\n    return None\n</code></pre>"},{"location":"reference/kirin/lowering/","title":"Index","text":""},{"location":"reference/kirin/lowering/core/","title":"Core","text":""},{"location":"reference/kirin/lowering/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.FromPythonAST","title":"FromPythonAST","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.FromPythonAST.lower","title":"lower","text":"<pre><code>lower(state: LoweringState, node: ast.AST) -&gt; Result\n</code></pre> <p>Entry point of dialect specific lowering.</p> Source code in <code>src/kirin/lowering/dialect.py</code> <pre><code>def lower(self, state: LoweringState, node: ast.AST) -&gt; Result:\n    \"\"\"Entry point of dialect specific lowering.\"\"\"\n    return getattr(self, f\"lower_{node.__class__.__name__}\", self.unreachable)(\n        state, node\n    )\n</code></pre>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.Method","title":"Method  <code>dataclass</code>","text":"<pre><code>Method(\n    mod: ModuleType | None,\n    py_func: Callable[Param, RetType] | None,\n    sym_name: str | None,\n    arg_names: list[str],\n    dialects: DialectGroup,\n    code: Statement,\n    fields: tuple = tuple(),\n    file: str = \"\",\n    lineno: list[tuple[int, int]] = list(),\n    backedges: list[Method] = list(),\n    return_type: TypeAttribute | None = None,\n    inferred: bool = False,\n    verified: bool = False,\n)\n</code></pre> <p>               Bases: <code>Printable</code>, <code>Generic[Param, RetType]</code></p>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.Method.inferred","title":"inferred  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inferred: bool = False\n</code></pre> <p>if typeinfer has been run on this method</p>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.Method.lineno","title":"lineno  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lineno: list[tuple[int, int]] = field(default_factory=list)\n</code></pre> <p>(, ) at the start of the statement call."},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.Method.verified","title":"verified  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>verified: bool = False\n</code></pre> <p>if <code>code.verify</code> has been run on this method</p>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.Method.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>verify the method body.</p> Source code in <code>src/kirin/ir/method.py</code> <pre><code>def verify(self) -&gt; None:\n    \"\"\"verify the method body.\"\"\"\n    try:\n        self.code.verify()\n    except VerificationError as e:\n        msg = f'File \"{self.file}\"'\n        if isinstance(e.node, Statement):\n            if e.node.source:\n                msg += f\", line {e.node.source.lineno}\"\n            msg += f\", in {e.node.name}\"\n\n        msg += f\":\\n    Verification failed for {self.sym_name}: {e.args[0]}\"\n        raise Exception(msg) from e\n    self.verified = True\n    return\n</code></pre>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.SSAValue","title":"SSAValue  <code>dataclass</code>","text":"<pre><code>SSAValue()\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Printable</code></p> <p>Base class for all SSA values in the IR.</p>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.SSAValue.name","title":"name  <code>property</code> <code>writable</code>","text":"<pre><code>name: str | None\n</code></pre> <p>The name of this SSA value.</p>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.SSAValue.name_pattern","title":"name_pattern  <code>class-attribute</code>","text":"<pre><code>name_pattern: Pattern[str] = compile(\n    \"([A-Za-z_$.-][\\\\w$.-]*)\"\n)\n</code></pre> <p>The pattern that the name of this SSA value must match.</p>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.SSAValue.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type: TypeAttribute = field(\n    default_factory=AnyType, init=False, repr=True\n)\n</code></pre> <p>The type of this SSA value.</p>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.SSAValue.uses","title":"uses  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>uses: set[Use] = field(\n    init=False, default_factory=set, repr=False\n)\n</code></pre> <p>The uses of this SSA value.</p>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.SSAValue.add_use","title":"add_use","text":"<pre><code>add_use(use: Use) -&gt; Self\n</code></pre> <p>Add a use to this SSA value.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def add_use(self, use: Use) -&gt; Self:\n    \"\"\"Add a use to this SSA value.\"\"\"\n    self.uses.add(use)\n    return self\n</code></pre>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.SSAValue.delete","title":"delete","text":"<pre><code>delete(safe: bool = True) -&gt; None\n</code></pre> <p>Delete this SSA value. If <code>safe</code> is <code>True</code>, raise an error if there are uses.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def delete(self, safe: bool = True) -&gt; None:\n    \"\"\"Delete this SSA value. If `safe` is `True`, raise an error if there are uses.\"\"\"\n    if safe and len(self.uses) &gt; 0:\n        raise ValueError(\"Cannot delete SSA value with uses\")\n    self.replace_by(DeletedSSAValue(self))\n</code></pre>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.SSAValue.remove_use","title":"remove_use","text":"<pre><code>remove_use(use: Use) -&gt; Self\n</code></pre> <p>Remove a use from this SSA value.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def remove_use(self, use: Use) -&gt; Self:\n    \"\"\"Remove a use from this SSA value.\"\"\"\n    # print(use)\n    # assert use in self.uses, \"Use not found\"\n    if use in self.uses:\n        self.uses.remove(use)\n    return self\n</code></pre>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.SSAValue.replace_by","title":"replace_by","text":"<pre><code>replace_by(other: SSAValue) -&gt; None\n</code></pre> <p>Replace this SSA value with another SSA value. Update all uses.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def replace_by(self, other: SSAValue) -&gt; None:\n    \"\"\"Replace this SSA value with another SSA value. Update all uses.\"\"\"\n    for use in self.uses.copy():\n        use.stmt.args[use.index] = other\n\n    if other.name is None and self.name is not None:\n        other.name = self.name\n\n    assert len(self.uses) == 0, \"Uses not empty\"\n</code></pre>"},{"location":"reference/kirin/lowering/frame/","title":"Frame","text":""},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame","title":"Frame  <code>dataclass</code>","text":"<pre><code>Frame(\n    state: LoweringState,\n    parent: Optional[Frame],\n    stream: StmtStream[ast.stmt],\n    current_region: Region,\n    entry_block: Block,\n    current_block: Block,\n    next_block: Block | None = None,\n    defs: dict[str, SSAValue | set[SSAValue]] = dict(),\n    globals: dict[str, Any] = dict(),\n    captures: dict[str, SSAValue] = dict(),\n    capture_callback: Optional[CallbackFn] = None,\n)\n</code></pre>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.capture_callback","title":"capture_callback  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>capture_callback: Optional[CallbackFn] = None\n</code></pre> <p>callback function that creates a local SSAValue value when an captured value was used.</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.captures","title":"captures  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>captures: dict[str, SSAValue] = field(default_factory=dict)\n</code></pre> <p>values accessed from the parent frame</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.current_block","title":"current_block  <code>instance-attribute</code>","text":"<pre><code>current_block: Block\n</code></pre> <p>current block being lowered</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.current_region","title":"current_region  <code>instance-attribute</code>","text":"<pre><code>current_region: Region\n</code></pre> <p>current region being lowered</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.defs","title":"defs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>defs: dict[str, SSAValue | set[SSAValue]] = field(\n    default_factory=dict\n)\n</code></pre> <p>values defined in the current frame</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.entry_block","title":"entry_block  <code>instance-attribute</code>","text":"<pre><code>entry_block: Block\n</code></pre> <p>entry block of the frame</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.globals","title":"globals  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>globals: dict[str, Any] = field(default_factory=dict)\n</code></pre> <p>global values known to the current frame</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.next_block","title":"next_block  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_block: Block | None = None\n</code></pre> <p>next block, if any</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.from_stmts","title":"from_stmts  <code>classmethod</code>","text":"<pre><code>from_stmts(\n    stmts: Sequence[ast.stmt] | StmtStream[ast.stmt],\n    state: LoweringState,\n    parent: Optional[Frame] = None,\n    region: Optional[Region] = None,\n    block: Optional[Block] = None,\n    globals: dict[str, Any] | None = None,\n    capture_callback: Optional[CallbackFn] = None,\n)\n</code></pre> <p>Create a new frame from a list of statements or a new <code>StmtStream</code>.</p> <ul> <li><code>stmts</code>: list of statements or a <code>StmtStream</code> to be lowered.</li> <li><code>region</code>: <code>Region</code> to append the new block to, <code>None</code> to create a new one, default <code>None</code>.</li> <li><code>block</code>: <code>Block</code> to append the new statements to, <code>None</code> to create a new one, default <code>None</code>.</li> <li><code>globals</code>: global variables, default <code>None</code>.</li> </ul> Source code in <code>src/kirin/lowering/frame.py</code> <pre><code>@classmethod\ndef from_stmts(\n    cls,\n    stmts: Sequence[ast.stmt] | StmtStream[ast.stmt],\n    state: \"LoweringState\",\n    parent: Optional[\"Frame\"] = None,\n    region: Optional[Region] = None,\n    block: Optional[Block] = None,\n    globals: dict[str, Any] | None = None,\n    capture_callback: Optional[CallbackFn] = None,\n):\n    \"\"\"Create a new frame from a list of statements or a new `StmtStream`.\n\n    - `stmts`: list of statements or a `StmtStream` to be lowered.\n    - `region`: `Region` to append the new block to, `None` to create a new one, default `None`.\n    - `block`: `Block` to append the new statements to, `None` to create a new one, default `None`.\n    - `globals`: global variables, default `None`.\n    \"\"\"\n    if not isinstance(stmts, StmtStream):\n        stmts = StmtStream(stmts)\n\n    block = block or Block()\n    if region:\n        region.blocks.append(block)\n\n    return cls(\n        state=state,\n        parent=parent,\n        stream=stmts,\n        current_region=region or Region(block),\n        entry_block=block,\n        current_block=block,\n        globals=globals or {},\n        capture_callback=capture_callback,\n    )\n</code></pre>"},{"location":"reference/kirin/lowering/result/","title":"Result","text":""},{"location":"reference/kirin/lowering/state/","title":"State","text":""},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.LoweringState","title":"LoweringState  <code>dataclass</code>","text":"<pre><code>LoweringState(\n    dialects: DialectGroup,\n    registry: dict[str, FromPythonAST],\n    lines: list[str],\n    lineno_offset: int,\n    col_offset: int,\n    source: SourceInfo,\n    max_lines: int = 3,\n    _current_frame: Frame | None = None,\n)\n</code></pre> <p>               Bases: <code>NodeVisitor</code></p>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.LoweringState.col_offset","title":"col_offset  <code>instance-attribute</code>","text":"<pre><code>col_offset: int\n</code></pre> <p>column offset at the beginning of the source</p>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.LoweringState.lineno_offset","title":"lineno_offset  <code>instance-attribute</code>","text":"<pre><code>lineno_offset: int\n</code></pre> <p>lineno offset at the beginning of the source</p>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.LoweringState.source","title":"source  <code>instance-attribute</code>","text":"<pre><code>source: SourceInfo\n</code></pre> <p>source info of the current node</p>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.LoweringState.append_stmt","title":"append_stmt","text":"<pre><code>append_stmt(stmt: StmtType) -&gt; StmtType\n</code></pre> <p>Shorthand for appending a statement to the current block of current frame.</p> Source code in <code>src/kirin/lowering/state.py</code> <pre><code>def append_stmt(self, stmt: StmtType) -&gt; StmtType:\n    \"\"\"Shorthand for appending a statement to the current block of current frame.\"\"\"\n    return self.current_frame.append_stmt(stmt)\n</code></pre>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.LoweringState.exhaust","title":"exhaust","text":"<pre><code>exhaust(frame: Frame | None = None) -&gt; Frame\n</code></pre> <p>Exhaust given frame's stream. If not given, exhaust current frame's stream.</p> Source code in <code>src/kirin/lowering/state.py</code> <pre><code>def exhaust(self, frame: Frame | None = None) -&gt; Frame:\n    \"\"\"Exhaust given frame's stream. If not given, exhaust current frame's stream.\"\"\"\n    if not frame:\n        current_frame = self.current_frame\n    else:\n        current_frame = frame\n\n    stream = current_frame.stream\n    while stream.has_next():\n        stmt = stream.pop()\n        self.visit(stmt)\n    return current_frame\n</code></pre>"},{"location":"reference/kirin/lowering/stream/","title":"Stream","text":""},{"location":"reference/kirin/passes/","title":"Index","text":""},{"location":"reference/kirin/passes/abc/","title":"Abc","text":""},{"location":"reference/kirin/passes/abc/#kirin.passes.abc.Pass","title":"Pass  <code>dataclass</code>","text":"<pre><code>Pass(dialects: DialectGroup)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>A pass is a transformation that is applied to a method. It wraps the analysis and rewrites needed to transform the method as an independent unit.</p> <p>Unlike LLVM/MLIR passes, a pass in Kirin does not apply to a module, this is because we focus on individual methods defined within python modules. This is a design choice to allow seamless integration within the Python interpreter.</p> <p>A Kirin compile unit is a <code>ir.Method</code> object, which is always equivalent to a LLVM/MLIR module if it were lowered to LLVM/MLIR just like other JIT compilers.</p>"},{"location":"reference/kirin/passes/fold/","title":"Fold","text":""},{"location":"reference/kirin/passes/inline/","title":"Inline","text":""},{"location":"reference/kirin/passes/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/passes/aggressive/","title":"Index","text":""},{"location":"reference/kirin/passes/aggressive/fold/","title":"Fold","text":""},{"location":"reference/kirin/print/","title":"Index","text":""},{"location":"reference/kirin/print/printable/","title":"Printable","text":""},{"location":"reference/kirin/print/printable/#kirin.print.printable.Printable","title":"Printable","text":""},{"location":"reference/kirin/print/printable/#kirin.print.printable.Printable.print","title":"print","text":"<pre><code>print(\n    printer: Printer | None = None,\n    analysis: dict[ir.SSAValue, Any] | None = None,\n) -&gt; None\n</code></pre> <p>Entry point of the printing process.</p> <p>Parameters:</p> Name Type Description Default <code>printer</code> <code>Printer</code> <p><code>Printer</code> object to use for printing. If None, a new <code>Printer</code> object will be created.</p> <code>None</code> <code>analysis</code> <code>dict[SSAValue, Printable]</code> <p>Analysis results to use for printing. If <code>None</code>, no analysis results</p> <code>None</code> Source code in <code>src/kirin/print/printable.py</code> <pre><code>def print(\n    self,\n    printer: Printer | None = None,\n    analysis: dict[ir.SSAValue, Any] | None = None,\n) -&gt; None:\n    \"\"\"\n    Entry point of the printing process.\n\n    Args:\n        printer (Printer):\n            `Printer` object to use for printing.\n            If None, a new `Printer` object will be created.\n        analysis (dict[ir.SSAValue, Printable]):\n            Analysis results to use for printing. If `None`, no analysis results\n    \"\"\"\n    printer = self.__get_printer(printer, analysis)\n    self.print_impl(printer)\n    printer.plain_print(\"\\n\")  # add a new line in the end\n</code></pre>"},{"location":"reference/kirin/print/printer/","title":"Printer","text":""},{"location":"reference/kirin/print/printer/#kirin.print.printer.PrintState","title":"PrintState  <code>dataclass</code>","text":"<pre><code>PrintState(\n    ssa_id: IdTable[ir.SSAValue] = IdTable[\"ir.SSAValue\"](),\n    block_id: IdTable[ir.Block] = lambda: IdTable[\n        \"ir.Block\"\n    ](prefix=\"^\")(),\n    indent: int = 0,\n    result_width: int = 0,\n    indent_marks: list[int] = list(),\n    rich_style: str | None = None,\n    rich_highlight: bool | None = False,\n    messages: list[str] = list(),\n)\n</code></pre>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.PrintState.result_width","title":"result_width  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result_width: int = 0\n</code></pre> <p>SSA-value column width in printing</p>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer","title":"Printer  <code>dataclass</code>","text":"<pre><code>Printer(\n    stream: IOType | None = None,\n    analysis: dict[ir.SSAValue, Printable] | None = None,\n    show_indent_mark: bool = True,\n)\n</code></pre> <p>               Bases: <code>Generic[IOType]</code></p> Source code in <code>src/kirin/print/printer.py</code> <pre><code>def __init__(\n    self,\n    stream: IOType | None = None,\n    analysis: dict[\"ir.SSAValue\", Printable] | None = None,\n    show_indent_mark: bool = True,\n):\n    self.stream = stream\n    self.analysis = analysis\n    self.console = Console(file=self.stream, highlight=False)\n    self.state = PrintState()\n    self.color = ColorScheme()\n    self.show_indent_mark = show_indent_mark\n</code></pre>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.show_indent_mark","title":"show_indent_mark  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>show_indent_mark: bool = show_indent_mark\n</code></pre> <p>Whether to show indent marks, e.g \u2502</p>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.print","title":"print","text":"<pre><code>print(object)\n</code></pre> <p>entry point for printing an object</p> Source code in <code>src/kirin/print/printer.py</code> <pre><code>def print(self, object):\n    \"\"\"entry point for printing an object\"\"\"\n    if isinstance(object, Printable):\n        object.print_impl(self)\n    else:\n        fn = getattr(self, f\"print_{object.__class__.__name__}\", None)\n        if fn is None:\n            raise NotImplementedError(\n                f\"Printer for {object.__class__.__name__} not found\"\n            )\n        fn(object)\n</code></pre>"},{"location":"reference/kirin/rewrite/","title":"Index","text":""},{"location":"reference/kirin/rewrite/abc/","title":"Abc","text":""},{"location":"reference/kirin/rewrite/abc/#kirin.rewrite.abc.RewriteRule","title":"RewriteRule  <code>dataclass</code>","text":"<pre><code>RewriteRule()\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>A rewrite rule that matches and rewrites IR nodes.</p> <p>The rewrite rule is applied to an IR node by calling the instance with the node as an argument. The rewrite rule should mutate the node instead of returning a new node. A <code>RewriteResult</code> should be returned to indicate whether the rewrite rule has done something, whether the rewrite rule should terminate, and whether the rewrite rule has exceeded the maximum number of iterations.</p>"},{"location":"reference/kirin/rewrite/chain/","title":"Chain","text":""},{"location":"reference/kirin/rewrite/chain/#kirin.rewrite.chain.Chain","title":"Chain  <code>dataclass</code>","text":"<pre><code>Chain(rules: List[RewriteRule])\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <p>Chain multiple rewrites together.</p> <p>The chain will apply each rewrite in order until one of the rewrites terminates.</p>"},{"location":"reference/kirin/rewrite/fixpoint/","title":"Fixpoint","text":""},{"location":"reference/kirin/rewrite/fixpoint/#kirin.rewrite.fixpoint.Fixpoint","title":"Fixpoint  <code>dataclass</code>","text":"<pre><code>Fixpoint(rule: RewriteRule, max_iter: int = 32)\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <p>Apply a rewrite rule until a fixpoint is reached.</p> <p>The rewrite rule is applied to the node until the rewrite rule does not do anything.</p>"},{"location":"reference/kirin/rewrite/fixpoint/#kirin.rewrite.fixpoint.Fixpoint--parameters","title":"Parameters","text":"<ul> <li><code>map</code>: The rewrite rule to apply.</li> <li><code>max_iter</code>: The maximum number of iterations to apply the rewrite rule. Default is 32.</li> </ul>"},{"location":"reference/kirin/rewrite/result/","title":"Result","text":""},{"location":"reference/kirin/rewrite/walk/","title":"Walk","text":""},{"location":"reference/kirin/rewrite/walk/#kirin.rewrite.walk.Walk","title":"Walk  <code>dataclass</code>","text":"<pre><code>Walk(\n    rule: RewriteRule,\n    worklist: WorkList[IRNode] = WorkList(),\n    reverse: bool = False,\n    region_first: bool = False,\n)\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <p>Walk through the IR nodes and apply a rewrite rule.</p> <p>The walk will apply the rewrite rule to each node in the IR tree in a depth-first order.</p>"},{"location":"reference/kirin/rewrite/walk/#kirin.rewrite.walk.Walk--parameters","title":"Parameters","text":"<ul> <li><code>map</code>: The rewrite rule to apply.</li> <li><code>reverse</code>: Whether to traverse the IR tree in reverse order. Default is <code>False</code>.</li> <li><code>region_first</code>: Whether to traverse the regions before the blocks. Default is <code>False</code>.</li> </ul>"},{"location":"reference/kirin/rules/","title":"Index","text":""},{"location":"reference/kirin/rules/alias/","title":"Alias","text":""},{"location":"reference/kirin/rules/apply_type/","title":"Apply type","text":""},{"location":"reference/kirin/rules/call2invoke/","title":"Call2invoke","text":""},{"location":"reference/kirin/rules/call2invoke/#kirin.rules.call2invoke.Call2Invoke","title":"Call2Invoke  <code>dataclass</code>","text":"<pre><code>Call2Invoke(results: dict[ir.SSAValue, ConstPropLattice])\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <p>Rewrite a <code>Call</code> statement to an <code>Invoke</code> statement.</p>"},{"location":"reference/kirin/rules/cfg_compactify/","title":"Cfg compactify","text":""},{"location":"reference/kirin/rules/cse/","title":"Cse","text":""},{"location":"reference/kirin/rules/dce/","title":"Dce","text":""},{"location":"reference/kirin/rules/fold/","title":"Fold","text":""},{"location":"reference/kirin/rules/getfield/","title":"Getfield","text":""},{"location":"reference/kirin/rules/getitem/","title":"Getitem","text":""},{"location":"reference/kirin/rules/inline/","title":"Inline","text":""},{"location":"reference/kirin/rules/inline/#kirin.rules.inline.Inline","title":"Inline  <code>dataclass</code>","text":"<pre><code>Inline(heuristic: Callable[[ir.IRNode], bool])\n</code></pre> <p>               Bases: <code>RewriteRule</code></p>"},{"location":"reference/kirin/rules/inline/#kirin.rules.inline.Inline.heuristic","title":"heuristic  <code>instance-attribute</code>","text":"<pre><code>heuristic: Callable[[IRNode], bool]\n</code></pre> <p>inline heuristic that determines whether a function should be inlined</p>"},{"location":"reference/kirin/rules/inline/#kirin.rules.inline.Inline.inline_call_like","title":"inline_call_like","text":"<pre><code>inline_call_like(\n    call_like: ir.Statement,\n    args: tuple[ir.SSAValue, ...],\n    region: ir.Region,\n)\n</code></pre> <p>Inline a function call-like statement</p> <p>Parameters:</p> Name Type Description Default <code>call_like</code> <code>Statement</code> <p>the call-like statement</p> required <code>args</code> <code>tuple[SSAValue, ...]</code> <p>the arguments of the call (first one is the callee)</p> required <code>region</code> <code>Region</code> <p>the region of the callee</p> required Source code in <code>src/kirin/rules/inline.py</code> <pre><code>def inline_call_like(\n    self,\n    call_like: ir.Statement,\n    args: tuple[ir.SSAValue, ...],\n    region: ir.Region,\n):\n    \"\"\"\n    Inline a function call-like statement\n\n    Args:\n        call_like (ir.Statement): the call-like statement\n        args (tuple[ir.SSAValue, ...]): the arguments of the call (first one is the callee)\n        region (ir.Region): the region of the callee\n    \"\"\"\n    # &lt;stmt&gt;\n    # &lt;stmt&gt;\n    # &lt;br (a, b, c)&gt;\n\n    # &lt;block (a, b,c)&gt;:\n    # &lt;block&gt;:\n    # &lt;block&gt;:\n    # &lt;br&gt;\n\n    # ^&lt;block&gt;:\n    # &lt;stmt&gt;\n    # &lt;stmt&gt;\n\n    # 1. we insert the entry block of the callee function\n    # 2. we insert the rest of the blocks into the parent region\n    # 3.1 if the return is in the entry block, means no control flow,\n    #     replace the call results with the return values\n    # 3.2 if the return is some of the blocks, means control flow,\n    #     split the current block into two, and replace the return with\n    #     the branch instruction\n    # 4. remove the call\n    if not call_like.parent_block:\n        return\n\n    if not call_like.parent_region:\n        return\n\n    # NOTE: we cannot change region because it may be used elsewhere\n    inline_region: ir.Region = region.clone()\n    parent_block: ir.Block = call_like.parent_block\n    parent_region: ir.Region = call_like.parent_region\n\n    # wrap what's after invoke into a block\n    after_block = ir.Block()\n    stmt = call_like.next_stmt\n    while stmt is not None:\n        stmt.detach()\n        after_block.stmts.append(stmt)\n        stmt = call_like.next_stmt\n\n    for result in call_like.results:\n        block_arg = after_block.args.append_from(result.type, result.name)\n        result.replace_by(block_arg)\n\n    parent_block_idx = parent_region._block_idx[parent_block]\n    entry_block = inline_region.blocks.popfirst()\n    idx, block = 0, entry_block\n    while block is not None:\n        idx += 1\n\n        if block.last_stmt and isinstance(block.last_stmt, func.Return):\n            block.last_stmt.replace_by(\n                cf.Branch(\n                    arguments=(block.last_stmt.value,),\n                    successor=after_block,\n                )\n            )\n\n        parent_region.blocks.insert(parent_block_idx + idx, block)\n        block = inline_region.blocks.popfirst()\n\n    parent_region.blocks.append(after_block)\n\n    # NOTE: we expect always to have an entry block\n    # but we still check for it cuz we are not gonna\n    # error for empty regions here.\n    if entry_block:\n        cf.Branch(\n            arguments=args,\n            successor=entry_block,\n        ).insert_before(call_like)\n    call_like.delete()\n    return\n</code></pre>"},{"location":"reference/kirin/rules/aggressive/","title":"Index","text":""},{"location":"reference/kirin/rules/aggressive/fold/","title":"Fold","text":""}]}