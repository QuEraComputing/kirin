{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\: )\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":"Kernel Intermediate Representation Infrastructure <p>Kirin is the Kernel Intermediate Representation Infrastructure developed. It is a compiler infrastructure for building compilers for embedded domain-specific languages (eDSLs) that target scientific computing kernels especially for quantum computing use cases where domain-knowledge in quantum computation is critical in the implementation of a compiler.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install kirin-toolchain\n</code></pre> <p>See Installation for more details.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>MLIR-like dialects as composable python packages</li> <li>Generated Python frontend for your DSLs</li> <li>Pythonic API for building compiler passes</li> <li>Julia-like abstract interpretation framework</li> <li>Builtin support for interpretation</li> <li>Builtin support Python type system and type inference</li> <li>Type hinted via modern Python type hints</li> </ul>"},{"location":"#kirins-mission","title":"Kirin's mission","text":"<p>Kirin empowers scientists to build tailored embedded domain-specific languages (eDSLs) by adhering to three core principles:</p> <ol> <li> <p>Scientists First Kirin prioritizes enabling researchers to create compilers for scientific challenges. The toolchain is designed\u00a0by\u00a0and\u00a0for\u00a0domain experts, ensuring practicality and alignment with real-world research needs.</p> </li> <li> <p>Focused Scope Unlike generic compiler frameworks, Kirin deliberately narrows its focus to scientific applications. It specializes in high-level, structurally oriented eDSLs\u2014optimized for concise, kernel-style functions that form the backbone of computational workflows.</p> </li> <li> <p>Composability as a Foundation Science thrives on interdisciplinary collaboration. Kirin treats composability \u2014 the modular integration of systems and components\u2014as a first-class design principle. This ensures eDSLs and their compilers can seamlessly interact, mirroring the interconnected nature of scientific domains.</p> </li> </ol> <p>For the interested, please read the Kirin blog post blog post for more details.</p>"},{"location":"#acknowledgement","title":"Acknowledgement","text":"<p>While the mission and audience may be very different, Kirin has been deeply inspired by a few projects:</p> <ul> <li>MLIR, the concept of dialects and the way it is designed.</li> <li>xDSL, about how IR data structure &amp; interpreter should be designed in Python.</li> <li>Julia, abstract interpretation, and certain design choices for scientific community.</li> <li>JAX and numba, the frontend syntax and the way it is designed.</li> <li>Symbolics.jl and its predecessors, the design of rule-based rewriter.</li> </ul> <p>Part of the work is also inspired in previous collaboration in YaoCompiler, thus we would like to thank Valentin Churavy and William Moses for early discussions around the compiler plugin topic. We thank early support of the YaoCompiler project from Unitary Foundation.</p>"},{"location":"#kirin-and-friends","title":"Kirin and friends","text":"<p>While at the moment only us at QuEra Computing Inc are actively developing Kirin and using it in our projects, we are open to collaboration and encourage contributions from the community! If you are using Kirin in your project, please let us know so we can add you to the list of projects using Kirin.</p>"},{"location":"#quantum-computing","title":"Quantum Computing","text":"<p>Kirin has been used for building several eDSLs within QuEra Computing, including:</p> <ul> <li>bloqade.qasm2 - uses Kirin to define an eDSL for the Quantum Assembly Language (QASM) 2.0. It demonstrates how to create multiple dialects, run custom analysis and rewrites, and generate code from the dialects (back to QASM 2.0 in this case).</li> <li>bloqade.stim - uses Kirin to define an eDSL for the Stim language. It demonstrates how to create multiple dialects, run custom analysis and rewrites, and generate code from the dialects (back to Stim in this case).</li> <li>bloqade.qBraid - An example demonstrating how to lower from an existing representation into Kirin IR by using the visitor pattern.</li> </ul> <p>We are in the process of open-sourcing more eDSLs built on top of Kirin and encourage you to keep an eye out for them!</p>"},{"location":"#quick-example-the-food-language","title":"Quick Example: the <code>food</code> language","text":"<p>For the impatient, we prepare an example that requires no background knowledge in any specific domain. In this example, we will mutate python's semantics to support a small eDSL called <code>food</code>. It describes the process of cooking, eating food, and taking food naps after.</p> <p>Before we start, let's take a look at what would our <code>food</code> language look like:</p> <pre><code>@food\ndef main(x: int):\n    food = NewFood(type=\"burger\")  # (1)!\n    serving = Cook(food, x)  # (2)!\n    Eat(serving)  # (3)!\n    Nap()  # (4)!\n\n    return x + 1  # (5)!\n</code></pre> <ol> <li>The <code>NewFood</code> statement creates a new food object with a given type.</li> <li>The <code>Cook</code> statement makes that food for <code>x</code> portions into a servings object.</li> <li>The <code>Eat</code> statement means you eat a serving object.</li> <li>The <code>Nap</code> statement means you nap. Eating food makes you sleepy!!</li> <li>Doing some math to get a result.</li> </ol> <p>The food language is wrapped with a decorator <code>@food</code> to indicate that the function is written in the <code>food</code> language instead of normal Python. (think about how would you program GPU kernels in Python, or how would you use <code>jax.jit</code> and <code>numba.jit</code> decorators).</p> <p>You can run the <code>main</code> function as if it is a normal Python function.</p> <pre><code>main(1)\n</code></pre> <p>or you can inspect the compiled result via</p> <pre><code>main.print()\n</code></pre> <p></p>"},{"location":"#defining-the-dialect","title":"Defining the dialect","text":"<p>First, let's define the dialect object, which is a registry for all the objects modeling the semantics.</p> <pre><code>from kirin import ir\n\ndialect = ir.Dialect(\"food\")\n</code></pre>"},{"location":"#defining-the-statements","title":"Defining the statements","text":"<p>Next, we want to define a runtime value <code>Food</code>, as well as the runtime value of <code>Servings</code> for the <code>food</code> language so that we may use later in our interpreter. These are just a standard Python <code>dataclass</code>.</p> <pre><code>from dataclasses import dataclass\n\n@dataclass\nclass Food:\n    type: str\n\n\n@dataclass\nclass Serving:\n    kind: Food\n    amount: int\n</code></pre> <p>Now, we can define the <code>food</code> language's statements.</p> <pre><code>from kirin.decl import statement, info\nfrom kirin import ir, types\n\n@statement(dialect=dialect)\nclass NewFood(ir.Statement):\n    name = \"new_food\"\n    traits = frozenset({ir.Pure(), ir.FromPythonCall()})\n    type: str = info.attribute(types.String)\n    result: ir.ResultValue = info.result(types.PyClass(Food))\n</code></pre> <ol> <li>The <code>name</code> field specifies the name of the statement in the IR text format (e.g printing).</li> <li>The <code>traits</code> field specifies the statement's traits, in this case, it is a    pure function because each brand name uniquely identifies a    food object. We also add a trait of <code>FromPythonCall()</code> to allow lowering from a Python call in the Python AST.</li> <li>The <code>type</code> field specifies the argument of the statement. It is an Attribute of string value. See <code>PyAttr</code> for further details.</li> <li>The <code>result</code> field specifies the result of the statement. Usually a statement only has one result    value. The type of the result must be <code>ir.ResultValue</code> with a field specifier     <code>info.result</code> that optionally specifies the type of the result.</li> </ol> <p>the <code>NewFood</code> statement creates a new food object with a given brand. Thus it takes a string as an attribute and returns a <code>Food</code> object. Click the plus sign above to see the corresponding explanation.</p> <pre><code>@statement(dialect=dialect)\nclass Cook(ir.Statement):\n    traits = frozenset({ir.FromPythonCall()})\n    target: ir.SSAValue = info.argument(types.PyClass(Food)) # (1)!\n    amount: ir.SSAValue = info.argument(types.Int)\n    result: ir.ResultValue = info.result(types.PyClass(Serving))\n</code></pre> <ol> <li>The arguments of a <code>Statement</code> must be <code>ir.SSAValue</code> objects with a    field specifier <code>info.argument</code> that optionally specifies the type of the argument.</li> </ol> <p>Next, we define <code>Cook</code> statement that takes a <code>Food</code> object as an argument, and the result value is a <code>Serving</code> object. The <code>types.PyClass</code> type understands Python classes and can take a Python class as an argument to create a type attribute <code>TypeAttribute</code>.</p> <pre><code>@statement(dialect=dialect)\nclass Eat(ir.Statement):\n    traits = frozenset({ir.FromPythonCall()})\n    target: ir.SSAValue = info.argument(types.PyClass(Serving))\n</code></pre> <p>Similarly, we define <code>Eat</code> statement that takes a <code>Serving</code> object as an argument. As the same previously, the <code>types.PyClass</code> type understands Python classes (in this case the <code>Serving</code> class) and can take a Python class as an argument to create a type attribute. Notice that <code>Eat</code> does not have any return value.</p> <p>Finally, we define the <code>Nap</code> statement that describes the nap action, which does not have any arguments and has no return value.</p> <pre><code>@statement(dialect=dialect)\nclass Nap(ir.Statement):\n    traits = frozenset({ir.FromPythonCall()})\n</code></pre>"},{"location":"#defining-the-method-table-for-concrete-interpreter","title":"Defining the method table for concrete interpreter","text":"<p>Now with the statements defined, we can define how to interpret them by defining the method table associate with each statement.</p> <pre><code>from kirin.interp import Frame, Interpreter, MethodTable, impl\n\n@dialect.register\nclass FoodMethods(MethodTable):\n    ...\n</code></pre> <p>The <code>FoodMethods</code> class is a subclass of <code>MethodTable</code>. Together with the decorator from the dialect group <code>@dialect.register</code>, they register the implementation of the method table to interpreter. The implementation is a method decorated with <code>@impl</code> that executes the statement.</p> <pre><code>    @impl(NewFood)\n    def new_food(self, interp: Interpreter, frame: Frame, stmt: NewFood):\n        return (Food(stmt.type),) # (1)!\n\n    @impl(Eat)\n    def eat(self, interp: Interpreter, frame: Frame, stmt: Eat):\n        serving: Serving = frame.get(stmt.target)\n        print(f\"Eating {serving.amount} servings of {serving.kind.type}\")\n        return ()\n\n    @impl(Cook)\n    def cook(self, interp: Interpreter, frame: Frame, stmt: Cook): # (2)!\n        food: Food = frame.get(stmt.target)\n        amount: int = frame.get(stmt.amount)\n        print(f\"Cooking {food.type} {amount}\")\n\n        return (Serving(food, amount),)\n\n    @impl(Nap)\n    def nap(self, interp: Interpreter, frame: Frame, stmt: Nap):\n        print(\"Napping!!!\")\n        return () # (3)!\n</code></pre> <ol> <li>The statement has return value which is a <code>Food</code> runtime object.</li> <li>Sometimes, the execution of a statement will have side-effect and return value. For example, here the execution <code>Cook</code> statement print strings (side-effect) as well as return a <code>Serving</code> runtime object.</li> <li>In the case where the statement does not have any return value but simply have side-effect only, the return value is simply an empty tuple.</li> </ol> <p>The return value is just a normal tuple that contains interpretation runtime values. Click the plus sign above to see the corresponding explanation.</p>"},{"location":"#rewrite-eat-statement","title":"Rewrite <code>Eat</code> statement","text":"<p>Sometimes when we are hungry, we will do something that is not expected. Here, we introduce how to do a rewrite on the program. What we want to do is simple:</p> <p>Every time we eat, we will to buy another piece of food, then take a nap. Someone has the munchies, eh?</p> <p>More specifically, we want to rewrite the program such that, every time we encounter a <code>Eat</code> statement, we insert a <code>NewFood</code> statement, and <code>Nap</code> after <code>Eat</code>. Let's define a rewrite pass that rewrites our <code>Eat</code> statement. This is done by defining a subclass of <code>RewriteRule</code> and implementing the <code>rewrite_Statement</code> method. The <code>RewriteRule</code> class is a standard Python visitor on Kirin's IR.</p> <pre><code>from kirin.rewrite.abc import RewriteRule # (1)!\nfrom kirin.rewrite.result import RewriteResult\nfrom kirin import ir\n\n@dataclass\nclass NewFoodAndNap(RewriteRule):\n    # sometimes someone is hungry and needs a nap\n    def rewrite_Statement(self, node: ir.Statement) -&gt; RewriteResult: # (2)!\n        if not isinstance(node, Eat): # (3)!\n            return RewriteResult()\n\n        # 1. create new stmts:\n        new_food_stmt = NewFood(type=\"burger\") # (4)!\n        nap_stmt = Nap() # (5)!\n\n        # 2. put them in the ir\n        new_food_stmt.insert_after(node) # (6)!\n        nap_stmt.insert_after(new_food_stmt)\n\n        return RewriteResult(has_done_something=True) # (7)!\n</code></pre> <ol> <li>Import the <code>RewriteRule</code> class from the <code>rewrite</code> module.</li> <li>This is the signature of the <code>rewrite_Statement</code> method. Your IDE should hint the type signature so you can auto-complete it.</li> <li>Check if the statement is a <code>Eat</code> statement. If it is not, return an empty <code>RewriteResult</code>.</li> <li>Create new <code>NewFood</code> statement.</li> <li>Create new <code>Nap</code> statement.</li> <li>insert the new created statements into the IR. Each of the ir.Statement provides an API such as <code>insert_after</code>, <code>insert_before</code> and <code>replace_by</code> that allows you to insert a new statement either after or before, or replace the current statement with another one.</li> <li>Return a <code>RewriteResult</code> that indicates the rewrite has been done.</li> </ol>"},{"location":"#putting-everything-together","title":"Putting everything together","text":"<p>Now we can put everything together and finally create the <code>food</code> decorator, and you do not need to figure out the complicated type hinting and decorator implementation because Kirin will do it for you!</p> <pre><code>from kirin.ir import dialect_group\nfrom kirin.prelude import basic_no_opt\nfrom kirin.rewrite import Walk\nfrom kirin.passes import Fold\n\n\n@dialect_group(basic_no_opt.add(dialect)) # (1)!\ndef food(self): # (2)!\n\n    fold_pass = Fold(self)\n\n    def run_pass(mt, *, fold:bool=True, hungry:bool=True):  # (3)!\n\n        if fold:\n            fold_pass(mt)\n\n        if hungry:\n            Walk(NewFoodAndNap()).rewrite(mt.code) # (4)!\n\n    return run_pass # (5)!\n</code></pre> <ol> <li>The <code>dialect_group</code> decorator specifies the dialect group that the <code>food</code> dialect belongs to. In this case, instead of rebuilding the whole dialect group, we just add our <code>dialect</code> object to the <code>basic_no_opt</code> dialect group which provides all the basic Python semantics, such as math, function, closure, control flows, etc.</li> <li>The <code>food</code> function is the decorator that will be used to decorate the <code>main</code> function.</li> <li>The <code>run_pass</code> function wraps all the passes that need to run on the input method. It optionally can take some arguments or keyword arguments that will be passed to the <code>food</code> decorator.</li> <li>Inside the <code>run_pass</code> function, we will traverse the entire IR and use the rule <code>NewFoodAndNap</code> to rewrite all the <code>Eat</code> statements.</li> <li>Remember to return the <code>run_pass</code> function at the end of the <code>food</code> function.</li> </ol> <p>This is it!</p> <p>For further advanced use case see <code>CookBook/Food</code></p>"},{"location":"#contributors","title":"Contributors","text":"<ul> <li>QuEra Computing Inc</li> </ul>"},{"location":"#license","title":"License","text":"<p>Apache License 2.0 with LLVM Exceptions</p>"},{"location":"101/","title":"Compiler 101","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"101/#compiler-101-for-scientists","title":"Compiler 101 for scientists","text":"<p>In this section, we cover some common compiler concepts that are useful to know when working with Kirin.</p>"},{"location":"101/#computational-graph","title":"Computational Graph","text":"<p>For those familiar with automatic differentiation and neutral networks. Many may be also familiar with the concept of computational graph. In the context of automatic differentiation, a computational graph is a directed async graph (DAG) that represents the computation of a function. Each node in the graph represents an operation, and each edge represents the flow of data between operations. The graph is constructed by tracing the operations performed on the input data.</p> <p>Due to the fact that every edge in computational graph represents a data dependency, the \"variables\" (a.k.a the edges) are assigned a value only once. This is also known as the Static Single Assignment (SSA) form.</p> <p>Further readings:</p> <ul> <li>PyTorch Computational Graph</li> <li>A Gentle Introduction to Tensors and Computational Graphs</li> </ul>"},{"location":"101/#static-single-assignment-ssa-form","title":"Static Single Assignment (SSA) Form","text":"<p>Kirin IR is in Static Single Assignment (SSA) form. This means that each variable is assigned only once. This makes it easier to reason about the program and allows for more optimizations such as dead code elimination, control flow graph (CFG) simplification and constant propagation. More specifically when you see variables starting with <code>%</code>, you are looking at the SSA form of the program.</p> <p>Further readings:</p> <ul> <li>Understanding static single assignment forms</li> <li>CS6120 Lecture 6: Static Single Assignment</li> </ul>"},{"location":"101/#what-is-purity","title":"What is purity?","text":"<p>A function is said to be pure if it has no side effects. In other word, a pure function is a function that only depends on its input arguments and produces a result. This means that the function does not modify any state outside of its scope. This is useful because it allows the compiler to optimize the function more aggressively.</p>"},{"location":"analysis/","title":"Analysis","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"analysis/#analysis","title":"Analysis","text":"<p>Kirin provides a set of analysis tools for common analysis tasks and for building new analysis tools.</p>"},{"location":"analysis/#forward-dataflow-analysis","title":"Forward Dataflow Analysis","text":"<p>The forward dataflow analysis is a common analysis technique that computes the dataflow information of a program by propagating the information forward through the control flow graph. The forward dataflow analysis is implemented in the <code>kirin.analysis.Forward</code> class.</p> <p>The build a forward dataflow analysis, you need to define a lattice. The lattice represents the set of values that can be computed by the analysis.</p>"},{"location":"analysis/#lattice","title":"Lattice","text":"<p>A lattice is a set of values that are partially ordered. In Kirin IR, a lattice is a subclass of the <code>Lattice</code> ABC class. A lattice can be used to represent the result of a statement that has multiple possible results.</p> <p>The <code>kirin.lattice</code> module provides a set of base and mixin classes that can be used to build some common lattices.</p> <p>Most of the lattices are bounded lattices, which can be implemented by using the <code>BoundedLattice</code> abstract class.</p> <p>Some lattice elements are singleton, which means the lattice class represents a single instance. A metaclass <code>SingletonMeta</code> is provided to create singleton lattice class that guarantees only one instance will be created, e.g the following is a trivial lattice named <code>EmptyLattice</code>:</p> <pre><code>class EmptyLattice(BoundedLattice[\"EmptyLattice\"], metaclass=SingletonMeta):\n    \"\"\"Empty lattice.\"\"\"\n\n    def join(self, other: \"EmptyLattice\") -&gt; \"EmptyLattice\":\n        return self\n\n    def meet(self, other: \"EmptyLattice\") -&gt; \"EmptyLattice\":\n        return self\n\n    @classmethod\n    def bottom(cls):\n        return cls()\n\n    @classmethod\n    def top(cls):\n        return cls()\n\n    def __hash__(self) -&gt; int:\n        return id(self)\n\n    def is_subseteq(self, other: \"EmptyLattice\") -&gt; bool:\n        return True\n</code></pre> <p>where the lattice is a <code>BoundedLattice</code> and it is also a singleton class, which means the class will only have one instance.</p>"},{"location":"analysis/#putting-things-together","title":"Putting things together","text":"<p>To build a forward dataflow analysis, you need to define a lattice and subclass the <code>Forward</code> class. The following is the type inference analysis (simplified) that infers the type of each variable in the program:</p> <pre><code>class TypeInference(Forward[types.TypeAttribute]):\n    keys = [\"typeinfer\"]\n    lattice = types.TypeAttribute\n</code></pre> <p>where the class <code>TypeInference</code> is actually the same as the interpreter we introduced before, but instead of running on concrete values, it runs on the lattice values and walks through all the control flow branches. The field <code>keys</code> is a list of keys that tells the interpreter which method registry to use to run the analysis (similar to the key <code>\"main\"</code> for concrete interpretation).</p>"},{"location":"analysis/#control-flow-graph","title":"Control Flow Graph","text":"<p>The control flow graph (CFG) can be constructed by calling the <code>CFG</code> class constructor. The CFG is a directed graph that represents the control flow of the program. Each node in the graph represents a basic block, and each edge represents a control flow transfer between two basic blocks.</p> <p>An example of using the CFG class to construct a CFG is shown below:</p> <pre><code>from kirin.analysis import CFG\nfrom kirin.prelude import basic\n\n@basic\ndef main(x):\n    if x &gt; 0:\n        y = 1\n    else:\n        y = 2\n    return y\n\n\ncfg = CFG(main.callable_region)\ncfg.print()\n</code></pre> <p>prints the following directed acyclic graph:</p> <pre><code>Successors:\n^0 -&gt; [^1, ^2]\n^2 -&gt; [^3]\n^3 -&gt; []\n^1 -&gt; [^3]\n\nPredecessors:\n^1 &lt;- [^0]\n^2 &lt;- [^0]\n^3 &lt;- [^2, ^1]\n</code></pre>"},{"location":"analysis/#api-references","title":"API References","text":"<p>               Bases: <code>ForwardExtra[ForwardFrame[LatticeElemType], LatticeElemType]</code>, <code>ABC</code></p> <p>Forward dataflow analysis.</p> <p>This is the base class for forward dataflow analysis. If your analysis requires extra information per frame, you should subclass <code>ForwardExtra</code> instead.</p> <p>               Bases: <code>Printable</code></p> <p>Control Flow Graph of a given IR statement.</p> <p>This class implements the <code>kirin.graph.Graph</code> protocol.</p> <p>Pretty Printing</p> <p>This object is pretty printable via <code>.print()</code> method.</p>"},{"location":"analysis/#kirin.analysis.Forward.initialize_frame","title":"initialize_frame","text":"<pre><code>initialize_frame(\n    code: ir.Statement, *, has_parent_access: bool = False\n) -&gt; ForwardFrame[LatticeElemType]\n</code></pre> <p>Create a new frame for the given method.</p> Source code in <code>src/kirin/analysis/forward.py</code> <pre><code>def initialize_frame(\n    self, code: ir.Statement, *, has_parent_access: bool = False\n) -&gt; ForwardFrame[LatticeElemType]:\n    return ForwardFrame(code, has_parent_access=has_parent_access)\n</code></pre>"},{"location":"analysis/#kirin.analysis.cfg.CFG.entry","title":"entry  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>entry: Block | None = None\n</code></pre> <p>Entry block of the CFG.</p>"},{"location":"analysis/#kirin.analysis.cfg.CFG.parent","title":"parent  <code>instance-attribute</code>","text":"<pre><code>parent: Region\n</code></pre> <p>Parent IR statement.</p>"},{"location":"analysis/#kirin.analysis.cfg.CFG.predecessors","title":"predecessors  <code>cached</code> <code>property</code>","text":"<pre><code>predecessors\n</code></pre> <p>CFG data, mapping a block to its predecessors.</p>"},{"location":"analysis/#kirin.analysis.cfg.CFG.successors","title":"successors  <code>cached</code> <code>property</code>","text":"<pre><code>successors\n</code></pre> <p>CFG data, mapping a block to its neighbors.</p>"},{"location":"codegen/","title":"Codegen","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"comparison/","title":"Comparison","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"contrib/","title":"Contributing","text":"<p>Please see Installation for instructions on how to set up your development environment.</p>"},{"location":"contrib/#pre-commit-hooks","title":"Pre-commit hooks","text":"<p>We use <code>pre-commit</code> to run the linter checks before you commit your changes. The pre-commit hooks are installed as part of the development dependencies. You can setup <code>pre-commit</code> using the following command:</p> <pre><code>pre-commit install\n</code></pre> <p>This will run the linter checks before you commit your changes. If the checks fail, the commit will be rejected. Most of the following sections can be checked by the pre-commit hooks.</p>"},{"location":"contrib/#running-the-tests","title":"Running the tests","text":"<p>We use <code>pytest</code> for testing. To run the tests, simply run:</p> <pre><code>pytest\n</code></pre> <p>or for a specific test file with the <code>-s</code> flag to show the output of the program:</p> <pre><code>pytest -s tests/test_program.py\n</code></pre> <p>lots of tests contains pretty printing of the IR themselves, so it's useful to see the output.</p>"},{"location":"contrib/#code-style","title":"Code style","text":"<p>We use <code>black</code> for code formatting. Besides the linter requirements, we also require the following good-to-have practices:</p>"},{"location":"contrib/#naming","title":"Naming","text":"<ul> <li>try not to use abbreviation as names, unless it's a common abbreviation like <code>idx</code> for <code>index</code></li> <li>try not create a lot of duplicated name prefix unless the extra information is necessary when accessing the class object.</li> <li>try to use <code>snake_case</code> for naming variables and functions, and <code>CamelCase</code> for classes.</li> </ul>"},{"location":"contrib/#comments","title":"Comments","text":"<ul> <li>try not to write comments, unless it's really necessary. The code should be self-explanatory.</li> <li>if you have to write comments, try to use <code>NOTE:</code>, <code>TODO:</code> <code>FIXME:</code> tags to make it easier to search for them.</li> </ul>"},{"location":"contrib/#documentation","title":"Documentation","text":"<p>We use <code>just</code> for mangaging command line tools and scripts. It should be installed when you run <code>uv sync</code>. To build the documentation, simply run:</p> <pre><code>just doc\n</code></pre> <p>This will launch a local server to preview the documentation. You can also run <code>just doc-build</code> to build the documentation without launching the server.</p>"},{"location":"contrib/#license","title":"License","text":"<p>By contributing to this project, you agree to license your contributions under the Apache License 2.0 with LLVM Exceptions.</p>"},{"location":"def/","title":"Declarations","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"def/#understanding-kirin-ir-declarations","title":"Understanding Kirin IR Declarations","text":"<p>In this section, we will learn about the terminology used in Kirin IR. This will help you understand the structure of the IR and how to write your own compiler using Kirin.</p> <p>Note</p> <p>The examples in this section will also contain the equivalent MLIR and xDSL code to help you understand the differences between them if you are already familiar with MLIR or xDSL.</p>"},{"location":"def/#dialect","title":"Dialect","text":"<p>The <code>Dialect</code> object is the main registry of all the statements and attributes that are available in the IR. You can create a dialect by just following:</p> <pre><code>from kirin import ir\ndialect = ir.Dialect(\"my_dialect\") # (1)!\n</code></pre> <ol> <li>The <code>Dialect</code> object is created with the name <code>my_dialect</code>.</li> </ol>"},{"location":"def/#dialect-groups","title":"Dialect Groups","text":"<p>A dialect group is a collection of dialects that can be used as a decorator for Python frontend. It is used to group multiple dialects together and define the passes, compiler options, and other configurations for the dialects.</p> <pre><code>from kirin.ir import Method, dialect_group\n\n@dialect_group(\n    [\n        base,\n        binop,\n        cmp,\n        unary,\n        assign,\n        attr,\n        boolop,\n        constant,\n        indexing,\n        func,\n    ]\n) # (1)!\ndef python_basic(self): # (2)!\n    def run_pass(mt: Method) -&gt; None: # (3)!\n        pass # (4)!\n    return run_pass\n</code></pre> <ol> <li>The <code>dialect_group</code> decorator is used to create a dialect group with the specified dialects. In this case, we construct a basic Python dialect that allows some basic operations.</li> <li>The <code>python_basic</code> function is the entry point of the dialect group. It takes a <code>self</code> argument, which is the <code>DialectGroup</code> object. This argument is used to access the definition of the dialect group and optionally update the dialect group.</li> <li>The <code>run_pass</code> function is the function that will be called when the dialect group is applied to a given Python function. This is where you can define the passes that will be applied to the method. See the next example.</li> </ol> <p>Note</p> <p>Unlike MLIR/LLVM, because Kirin focuses on kernel functions, the minimal unit of compilation is a function. Therefore, the compiler pass always passes a <code>ir.Method</code> object which contains a function-like statement (a statement has <code>ir.traits.CallableStmtInterface</code>).</p> <p>The above dialect group <code>python_basic</code> allows you to use it as following:</p> <pre><code>@python_basic\ndef my_function():\n    pass\n</code></pre> <p>However, if we want to run some compilation passes on the function, we need to define some passes in the <code>run_pass</code> function.</p> <pre><code>from kirin.passes.fold import Fold\n\n@dialect_group(python_basic) # (1)!\ndef python(self):\n    fold_pass = Fold(self) # (2)!\n\n    def run_pass(mt: Method, *, verify: bool = True, fold: bool = True) -&gt; None: # (3)!\n        if verify: # (4)!\n            mt.verify()\n\n        if fold: # (5)!\n            fold_pass(mt)\n    return run_pass\n</code></pre> <ol> <li>The <code>dialect_group</code> decorator can also take a dialect group as an argument. This will use the dialects defined in the given dialect group with different passes.</li> <li>The <code>Fold</code> pass is created when initializing the dialect group. This pass is used later when running the <code>run_pass</code> function.</li> <li>The <code>run_pass</code> function is the function that will be called when the dialect group is applied to a given Python function. This function takes a <code>mt</code> argument, which is the <code>ir.Method</code> object, and optional arguments <code>verify</code>, <code>fold</code>, and <code>aggressive</code>.</li> <li>If the <code>verify</code> argument is <code>True</code>, the method will be verified.</li> <li>If the <code>fold</code> argument is <code>True</code>, the <code>Fold</code> pass will be applied to the method.</li> </ol> <p>The above dialect group <code>python</code> allows you to use it as following:</p> <pre><code>@python(fold=True) # (1)!\ndef my_function():\n    pass\n</code></pre> <ol> <li>The <code>fold</code> argument here is passed to the <code>run_pass</code> function defined in the dialect group. Looks complicated? Don't worry, the <code>@dialect_group</code> decorator will handle everything including the type hints!</li> </ol>"},{"location":"def/#statement","title":"Statement","text":"<p>In Kirin IR, a statement describes an operation that can be executed. Statements are the building blocks that contain the semantics of the program.</p>"},{"location":"def/#defining-a-statement","title":"Defining a Statement","text":"<p>While a statement can be hand-written by inheriting <code>ir.Statement</code>, we provide a python-<code>dataclass</code>-like decorator <code>statement</code> and in combine with the <code>info.argument</code>,<code>info.result</code>,<code>info.region</code>, <code>info.block</code> field specifier to make it easier to define a statement.</p> KirinMLIRxDSL <pre><code>from kirin import ir\nfrom kirin.decl import statement, info\n\n@statement # (1)!\nclass MyStatement(ir.Statement): # (2)!\n    name = \"awesome\" # (3)!\n    traits = frozenset({ir.Pure()}) # (4)!\n    # blabla, we will talk about this later\n</code></pre> <ol> <li>the decorator <code>@statement</code> is used to generate implementations for the <code>MyStatement</code> class based on the fields defined in the class.</li> <li>The <code>MyStatement</code> class inherits from <code>ir.Statement</code>.</li> <li>The <code>name</code> field is the name of the statement, if your desired name is just <code>my_statement</code>, you can omit this field, <code>@statement</code> will automatically generate the name by converting the class name to snake case. The name is what will be used in text/pretty printing.</li> <li>The <code>traits</code> field is used to specify the traits of the statement. In this case, the statement is pure.</li> </ol> <pre><code>class MyOp&lt;string mnemonic, list&lt;Trait&gt; traits = []&gt; :\n    Op&lt;MyDialect, mnemonic, traits&gt;;\n\ndef dialect_MyOp : MyOp&lt;\"awesome\"&gt; {\n    let summary = \"my awesome statement\";\n\n    let description = [{my awesome statement}];\n\n    let arguments = (\n        // some inputs, e.g ins F64ElementsAttr:$value from the MLIR Toy example\n    );\n\n    let results = (\n        // some outputs, e.g outs F64Tensor from the MLIR Toy example\n    );\n  }\n</code></pre> <pre><code>from xdsl.irdl import IRDLOperation, irdl_op_definition, traits_def\n\n@irdl_op_definition\nclass MyStatement(IRDLOperation):\n    name = \"awesome\"\n    traits = traits_def(Pure())\n</code></pre> <p>Like a function, a statement can have multiple inputs and outputs.</p> KirinMLIRxDSL <pre><code>@statement # (1)!\nclass Add(ir.Statement):\n    traits = frozenset({ir.Pure()}) # (2)!\n    lhs: ir.SSAValue = info.argument(ir.types.Int) # (3)!\n    rhs: ir.SSAValue = info.argument(ir.types.Int) # (4)!\n    output: ir.ResultValue = info.result(ir.types.Int) # (5)!\n</code></pre> <ol> <li>the decorator <code>@statement</code> is used to generate implementations for the <code>MyStatement</code> class based on the fields defined in the class.</li> <li>The <code>traits</code> field is used to specify the traits of the statement. In this case, the statement is pure.</li> <li>The <code>lhs</code> field is the left-hand side input value of the statement. The field descriptor <code>info.argument</code> is used to specify the type of the input value.</li> <li>The <code>rhs</code> field is the right-hand side input value of the statement. The field descriptor <code>info.argument</code> is used to specify the type of the input value.</li> <li>The <code>output</code> field is the output value of the statement. The field descriptor <code>info.result</code> is used to specify the type of the output value.</li> </ol> <pre><code>def dialect_Add : MyOp&lt;\"add\"&gt; {\n    let summary = \"my add statement\";\n\n    let description = [{my add statement}];\n\n    let arguments = (\n        AnySignlessInteger:$lhs,\n        AnySignlessInteger:$rhs\n    );\n\n    let results = (outs I64:$output);\n}\n</code></pre> <pre><code>from xdsl.irdl import IRDLOperation, irdl_op_definition, traits_def\n\n@irdl_op_definition\nclass Add(IRDLOperation):\n    T: ClassVar = VarConstraint(\"T\", signlessIntegerLike)\n    lhs = operand_def(T)\n    rhs = operand_def(T)\n    result = result_def(T)\n    assembly_format = \"$lhs `,` $rhs attr-dict `:` type($result)\"\n</code></pre> <p>A statement can have blocks as successors, which describe the control flow of the program.</p> <p>Note</p> <p>For Kirin, because <code>Statement</code>s are just dataclass, the <code>__init__</code> method is generated in the same convention as Python <code>dataclass</code>. The field descriptor <code>info.xxx</code> are also using standard <code>dataclass</code> field descriptor convention. Most of the time, one can just use the default dataclass <code>__init__</code>. For comparison, in MLIR, the <code>BranchOp</code> will need a custom builder to add the operands and successors. Similarly, in xDSL, the <code>BranchOp</code> will need a <code>__init__</code> method to add the operands and successors.</p> KirinMLIRxDSL <pre><code>@statement\nclass Branch(Statement):\n   name = \"br\"\n   traits = frozenset({IsTerminator()}) # (1)!\n\n   arguments: tuple[SSAValue, ...] # (2)!\n   successor: Block = info.block() # (3)!\n</code></pre> <ol> <li>The <code>traits</code> field is used to specify the traits of the statement. In this case, the statement is a terminator.</li> <li>The <code>arguments</code> field is the input values of the statement. Branch can take multiple arguments, <code>tuple[SSAValue, ...]</code> is used to specify that the field is a tuple of <code>SSAValue</code>. Note that only <code>...</code> is supported because if the number of arguments is known, we recommend specifying them explicitly.</li> <li>The <code>successor</code> field is the block that the statement will go to after execution. The field descriptor <code>info.block</code> is used to specify the type of the field.</li> </ol> <pre><code>def BranchOp : CF_Op&lt;\"br\", [\n   DeclareOpInterfaceMethods&lt;BranchOpInterface, [\"getSuccessorForOperands\"]&gt;,\n   Pure, Terminator\n ]&gt; {\n    let arguments = (ins Variadic&lt;AnyType&gt;:$destOperands);\n    let successors = (successor AnySuccessor:$dest);\n\n    let builders = [\n        OpBuilder&lt;(ins \"Block *\":$dest,\n            CArg&lt;\"ValueRange\", \"{}\"&gt;:$destOperands), [{\n        $_state.addSuccessors(dest);\n        $_state.addOperands(destOperands);\n        }]&gt;];\n}\n</code></pre> <pre><code>from xdsl.irdl import IRDLOperation, irdl_op_definition, traits_def\n\n@irdl_op_definition\nclass BranchOp(IRDLOperation):\n    \"\"\"Branch operation\"\"\"\n\n    name = \"cf.br\"\n\n    arguments = var_operand_def()\n    successor = successor_def()\n\n    traits = traits_def(IsTerminator(), BranchOpHasCanonicalizationPatterns())\n\n    def __init__(self, dest: Block, *ops: Operation | SSAValue):\n       super().__init__(operands=[[op for op in ops]], successors=[dest])\n</code></pre> <p>It can also have a region that contains other statements, for example, a function statement (simplified).</p> KirinMLIRxDSL <pre><code>@statement\nclass Function(ir.Statement):\n   name = \"func\"\n   traits = frozenset({SSACFGRegion()}) # (1)!\n   sym_name: str = info.attribute() # (2)!\n   body: Region = info.region(multi=True) # (3)!\n</code></pre> <ol> <li>The <code>traits</code> field contains the <code>SSACFGRegion</code> trait, which indicates that the region in the statement is a standard control-flow graph.</li> <li>The <code>sym_name</code> field is the name of the function. In the <code>@statement</code> decorator, if a field annotated with normal Python types (not an IR node, e.g <code>ir.SSAValue</code>, <code>ir.Block</code>, <code>ir.Region</code>), it will be treated as a <code>PyAttr</code> attribute.</li> <li>The <code>body</code> field is the region that contains the statements of the function. The field descriptor <code>info.region</code> is used to specify this region can contain multiple blocks.</li> </ol> <pre><code>def FuncOp : Func_Op&lt;\"func\", [\n    AffineScope, AutomaticAllocationScope,\n    FunctionOpInterface, IsolatedFromAbove, OpAsmOpInterface\n]&gt; {\n    let arguments = (ins SymbolNameAttr:$sym_name);\n    let regions = (region AnyRegion:$body);\n\n    let builders = [OpBuilder&lt;(ins\n       \"StringRef\":$name, \"FunctionType\":$type,\n       CArg&lt;\"ArrayRef&lt;NamedAttribute&gt;\", \"{}\"&gt;:$attrs,\n       CArg&lt;\"ArrayRef&lt;DictionaryAttr&gt;\", \"{}\"&gt;:$argAttrs)\n    &gt;];\n    let hasCustomAssemblyFormat = 1;\n}\n</code></pre> <pre><code>@irdl_op_definition\nclass FuncOp(IRDLOperation):\n    name = \"func.func\"\n    traits = traits_def(\n        IsolatedFromAbove(), SymbolOpInterface(), FuncOpCallableInterface()\n    )\n    body = region_def()\n    sym_name = prop_def(StringAttr)\n\n    def __init__(\n        self,\n        name: str,\n        region: Region | type[Region.DEFAULT] = Region.DEFAULT,\n    ):\n        properties: dict[str, Attribute | None] = {\"sym_name\": StringAttr(name)}\n        super().__init__(properties=properties, regions=[region])\n</code></pre>"},{"location":"def/#constructing-a-statement","title":"Constructing a Statement","text":"<p>Statements can be constructed in similar ways to constructing a normal Python <code>dataclass</code>. Taking the previous definitions as an example:</p> <pre><code>from kirin.dialects.py.constant import Constant\n\nlhs, rhs = Constant(1), Constant(2) # (1)!\nadd = Add(lhs.result, rhs=rhs.result) # (2)!\n</code></pre> <ol> <li>Two <code>Constant</code> statements are created with the value <code>1</code> and <code>2</code>.</li> <li>An <code>Add</code> statement is created with the <code>lhs</code> and <code>rhs</code> fields set to the results of the <code>lhs</code> and <code>rhs</code> statements. Like <code>@dataclass</code> unless specified by <code>kw_only=True</code>, the fields are positional.</li> </ol>"},{"location":"def/#block","title":"Block","text":"<p>A block is a sequence of statements that are executed in order. Optionally, a block can have arguments that are passed from the predecessor block and terminates with a terminator statement. Unlike <code>ir.Statement</code>, the <code>ir.Block</code> class is final and cannot be extended.</p>"},{"location":"def/#constructing-a-block","title":"Constructing a Block","text":"<p><code>Block</code> takes a <code>Sequence</code> of statements as an argument, e.g a list of statements.</p> <pre><code>from kirin import ir\nir.Block() # Block(_args=())\nir.Block([stmt_a, stmt_b])\n</code></pre> <p>continue the example from Constructing a Statement, we can construct a block like following:</p> <pre><code>block = ir.Block()\narg_x = block.args.append_from(ir.types.Any)\narg_y = block.args.append_from(ir.types.Any)\nblock.stmts.append(Add(arg_x, arg_y))\n</code></pre> <p>Note</p> <p>Every IR node in Kirin has a pretty printer that can be used to print the node in a human-readable format. Just call <code>.print</code> method. In the above example, we have</p> <p><pre><code>^0(%0, %1):\n    %2 = add(lhs=%0, rhs=%1) : !py.int\n</code></pre> which is the pretty-printed version of the block. You may notice this is similar to MLIR text format, which is intentional.</p>"},{"location":"def/#region","title":"Region","text":"<p>A region is a sequence of blocks that are connected by control flow. A region can contain multiple blocks and can be nested within another region via statements that contain a region field. Unlike <code>ir.Statement</code>, the <code>ir.Region</code> class is final and cannot be extended.</p>"},{"location":"def/#constructing-a-region","title":"Constructing a Region","text":"<p>Continuing the example from Constructing a Block, we can construct a region like following:</p> <pre><code>region = ir.Region([block])\n</code></pre> <p>pretty printing the region will give you</p> <pre><code>{\n  ^0(%1, %2):\n  \u2502 %0 = add(lhs=%1, rhs=%2) : !py.int\n}\n</code></pre>"},{"location":"def/#ssa-value","title":"SSA Value","text":"<p>An SSA value is a value that is assigned only once in the program. In Kirin IR, an SSA value is represented by the <code>ir.SSAValue</code> class. Most of the time, one does not need to construct the SSA value directly, as it is automatically created when constructing a statement.</p> <p>There are 3 types of SSA values:</p> <ul> <li><code>ir.SSAValue</code>: the base class of SSA values.</li> <li><code>ir.ResultValue</code>: SSA values that are the result of a statement, this object allows you to access the parent statement via <code>result.owner</code> property.</li> <li><code>ir.BlockArgument</code>: SSA values that are the arguments of a block.</li> </ul>"},{"location":"install/","title":"Installation","text":"<p>Kirin is available in PyPI and thus can be installed via <code>pip</code>. Install Kirin using the following command:</p> <pre><code>pip install kirin-toolchain\n</code></pre> <p>Kirin supports Python 3.9 or later. We recommend using Python 3.10+ for the best experience.</p> <p>We strongly recommend developing your compiler project using <code>uv</code>, which is the official development environment for Kirin. You can install <code>uv</code> using the following command:</p> Linux and macOSWindows <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <p>then</p> <pre><code>uv add kirin-toolchain\n</code></pre> <pre><code>powershell -ExecutionPolicy ByPass -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n</code></pre> <p>then</p> <pre><code>uv add kirin-toolchain\n</code></pre>"},{"location":"install/#kirin-and-its-friends","title":"Kirin and its friends","text":"<p>Kirin also comes with a few friends that you might find useful:</p> <ul> <li><code>bloqade-qasm</code>: (link missing) A quantum assembly language (QASM 2.0) dialect for Kirin with a builtin QASM 2.0 text format parser.</li> <li><code>bloqade</code>: (available soon) QuEra's SDK for next-gen error-corrected neutral-atom quantum computers.</li> </ul>"},{"location":"install/#development","title":"Development","text":"<p>If you want to contribute to Kirin, you can clone the repository from GitHub:</p> <pre><code>git clone https://github.com/QuEraComputing/kirin.git\n</code></pre> <p>We use <code>uv</code> to manage the development environment, after you install <code>uv</code>, you can install the development dependencies using the following command:</p> <pre><code>uv sync\n</code></pre> <p>Our code review requires that you pass the tests and the linting checks. We recommend you to install <code>pre-commit</code> to run the checks before you commit your changes, the command line tool <code>pre-commit</code> has been installed as part of the development dependencies. You can setup <code>pre-commit</code> using the following command:</p> <pre><code>pre-commit install\n</code></pre>"},{"location":"install/#requirements","title":"Requirements","text":"<p>Kirin requires the following dependencies:</p> <ul> <li><code>rich</code>: for pretty-printing</li> <li><code>type-extensions</code>: for type hints</li> <li><code>beartype</code>: for runtime type checking and analysis of type hints in the python dialect</li> </ul>"},{"location":"interp/","title":"Interpretation","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"interp/#interpretation","title":"Interpretation","text":"<p>Kirin provides a framework for interpreting the IR. There are multiple ways to interpret the IR:</p> <ol> <li>concrete interpretation, which evaluates the IR using concrete values like CPython.</li> <li>abstract interpretation, which evaluates the IR on lattice values. (See also Analysis)</li> <li>tree walking, which walks the IR tree and performs actions on each node. (See also Code Generation)</li> </ol> <p>this page will focus on concrete interpretation.</p>"},{"location":"interp/#concrete-interpretation","title":"Concrete Interpretation","text":""},{"location":"interp/#function-call-like-interpretation","title":"Function-call like interpretation","text":"<p>The concrete interpreter is essentially a dispatcher of implementations for each statement in the IR. For dialect developers, the main task is to implement a method table, taking the <code>py.binop</code> dialect as an example:</p> <pre><code>from kirin import interp # (1)!\n\nfrom . import stmts # (2)!\nfrom ._dialect import dialect # (3)!\n\n@dialect.register # (4)!\nclass PyMethodTable(interp.MethodTable): # (4)!\n\n    @interp.impl(stmts.Add) # (5)!\n    def add(self, interp, frame: interp.Frame, stmt: stmts.Add): # (6)!\n        return (frame.get(stmt.lhs) + frame.get(stmt.rhs),) # (7)!\n</code></pre> <ol> <li>Import the <code>interp</code> module.</li> <li>Import the statements module. This is defined similarly as Declaring Statements.</li> <li>Import the dialect object. This is defined in a similar way as Declaring Dialect.</li> <li>Register the method table with the dialect. This will push the method table to the dialect's registry. By default this will be registered under the key <code>\"main\"</code>, equivalent to <code>@dialect.register(key=\"main\")</code>.</li> <li>Mark the method as an implementation of the <code>Add</code> statement. This can be dispatched on the type of the statement, e.g to only mark the implementation for <code>Add(Int, Int)</code>, you can write <code>@interp.impl(stmts.Add, types.Int, types.Int)</code>, where <code>types</code> can be imported by <code>from kirin import types</code>.</li> <li>While this is enforced, it is recommended to type hint the frame and the statement so you can get the hinting from the IDE. The <code>@interp.impl</code> decorator will also type check if the method signature is correct.</li> <li>In the actual implementation, <code>frame.get</code> is used to get the value of the operands. This will return the value of the operand if it is defined in the frame, otherwise it will raise an <code>InterpreterError</code>. Most of the case, the return value should be a <code>tuple</code> of the results of the statement. In this case, there is only one result, so it is returned as a single-element tuple.</li> </ol> <p>What is a frame?</p> <p>A frame is a mapping of <code>SSAValue</code> to their actual values. It represents the state of a function-like statement that cuts the scope of the variables. The frame is passed to the method table so that the interpreter can get the values of the operands from current frame.</p>"},{"location":"interp/#control-flow-statements","title":"Control flow statements","text":"<p>Except these \"normal\" statements that act more like a function call, there are also control flow statements. For example, the <code>Branch</code> statement from <code>cf</code> dialect, defined as follows (see also Declaring Statements):</p> <pre><code>@statement(dialect=dialect)\nclass Branch(Statement):\n    name = \"br\"\n    traits = frozenset({IsTerminator()})\n\n    arguments: tuple[SSAValue, ...]\n    successor: Block = info.block()\n</code></pre> <p>When interpreting a <code>Branch</code> statement, instead of actually executing something, we would like to instruct the interpreter to jump to a successor block. This is done by returning a special value <code>interp.Successor</code>:</p> <pre><code>@dialect.register\nclass CfMethods(MethodTable):\n\n    @impl(Branch)\n    def branch(self, interp: Interpreter, frame: Frame, stmt: Branch):\n        return Successor(stmt.successor, *frame.get_values(stmt.arguments))\n</code></pre> <p>Similar to <code>frame.get</code>, <code>frame.get_values</code> is a convenience method to get the values of multiple operands at once.</p> <p>What is a successor?</p> <p>A successor is a tuple of a block and the values to be passed to the block. The interpreter will use this information to jump to the block and pass the values to the block.</p> <p>Another special control flow statement is <code>ReturnValue</code>, unlike <code>interp.Successor</code> that jumps to another block, <code>ReturnValue</code> will let interpreter pop the current frame and return the values to the caller or finish the execution:</p> <pre><code>@dialect.register\nclass FuncMethods(MethodTable):\n\n    @impl(Return)\n    def return_(self, interp: Interpreter, frame: Frame, stmt: Return):\n        return interp.ReturnValue(*frame.get_values(stmt.values))\n</code></pre>"},{"location":"interp/#error-handling","title":"Error handling","text":"<p>Some statements will throw a runtime error, such as <code>cf.Assert</code> from the <code>cf</code> dialect, defined as follows:</p> <pre><code>@statement(dialect=dialect)\nclass Assert(Statement):\n    name = \"assert\"\n    condition: SSAValue\n    message: SSAValue = info.argument(String)\n</code></pre> <p>When interpreting an <code>Assert</code> statement, we need to check the condition and raise an error if it is false:</p> <pre><code>@dialect.register\nclass CfMethods(MethodTable):\n\n    @impl(Assert)\n    def assert_stmt(self, interp: Interpreter, frame: Frame, stmt: Assert):\n        if frame.get(stmt.condition) is True:\n            return ()\n\n        if stmt.message:\n            raise interp.WrapException(AssertionError(frame.get(stmt.message)))\n        else:\n            raise interp.WrapException(AssertionError(\"Assertion failed\"))\n</code></pre> <p>or raising an <code>InterpreterError</code>:</p> <pre><code>@dialect.register\nclass CfMethods(MethodTable):\n\n    @impl(Assert)\n    def assert_stmt(self, interp: Interpreter, frame: Frame, stmt: Assert):\n        if frame.get(stmt.condition) is True:\n            return ()\n\n        if stmt.message:\n            raise InterpreterError(frame.get(stmt.message))\n        else:\n            raise InterpreterError(\"assertion failed\")\n</code></pre>"},{"location":"interp/#running-the-interpreter","title":"Running the interpreter","text":"<p>To run the interpreter, you just need to pass the method to <code>eval</code>:</p> <pre><code>from kirin.interp import Interpreter\nfrom kirin.prelude import basic\ninterp = Interpreter(basic)\n\n@basic\ndef main(a: int, b: int) -&gt; int:\n    return a + b\n\ninterp.eval(main, 1, 2)\n</code></pre>"},{"location":"interp/#overlaying","title":"Overlaying","text":"<p>One of the most powerful features of the interpreter is overlaying. This allows you to override the implementation of a statement in a dialect by picking different order of method table lookup or even customize the method lookup. This is done by inheriting <code>Interpreter</code> and define the class variable <code>keys</code>:</p> <pre><code>class MyInterpreter(Interpreter):\n    keys = [\"my_overlay\", \"main\"]\n</code></pre> <p>When using this new <code>MyInterpreter</code>, the method lookup will first look for the methods registered in the <code>my_overlay</code> key. If the method is not found, it will fall back to the <code>main</code> key. This allows you to override the implementation of a statement in a dialect without modifying the dialect itself.</p> <p>We will talk about overlaying in abstract interpretation and analysis section which has more use cases.</p>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/2025/02/28/introducing-kirin-a-new-open-source-software-development-tool-for-fault-tolerant-quantum-computing/","title":"Introducing Kirin, a new open-source software development tool for fault-tolerant quantum computing","text":"<p>Today, we are excited to introduce Kirin (Kernel Intermediate Representation INfrastructure), a new Python-based compiler infrastructure designed to simplify how scientists and engineers create embedded domain-specific languages (eDSLs)\u2014especially in the space of quantum computing. We are introducing this alongside the next generation of the\u00a0Bloqade SDK (v0.16) \u2014 the neutral atom quantum computing software development kit.</p> <p>Note</p> <p>if you are unfamiliar with eDSLs, see the appendix for a more detailed description of the motivation and use of eDSLs.</p> <p>Bloqade will serve as a hub for eDSLs targeting neutral-atom quantum computers. Kirin introduces a powerful system of dialects and a robust Intermediate Representation (IR) that together address the unique challenges in quantum programming, scientific simulation, and hardware control. In this inaugural release (v0.21), we introduce\u00a0a QASM2\u00a0eDSL and its neutral-atom extensions, powered by Kirin.</p> <p>Together, these open-source tools are designed to empower scientists and developers to push the boundaries of quantum computing and scientific research.</p>"},{"location":"blog/2025/02/28/introducing-kirin-a-new-open-source-software-development-tool-for-fault-tolerant-quantum-computing/#what-is-kirin","title":"What is Kirin?","text":"<p>Kirin is a new compiler infrastructure designed to simplify the development of embedded domain-specific languages (eDSLs), particularly for quantum computing and other scientific domains. In quantum computing, fragmented representations of quantum objects\u2014such as circuits, pulses, noise models, control flows, and tensor networks\u2014create significant challenges in integrating them into a cohesive framework. Kirin addresses these challenges by providing tools to\u00a0unify and compose\u00a0these diverse representations and their corresponding compilation processes.</p>"},{"location":"blog/2025/02/28/introducing-kirin-a-new-open-source-software-development-tool-for-fault-tolerant-quantum-computing/#kirins-mission","title":"Kirin\u2019s mission","text":"<p>Kirin empowers scientists to build tailored embedded domain-specific languages (eDSLs) by adhering to three core principles:</p> <ol> <li> <p>Scientists First</p> <p>Kirin prioritizes enabling researchers to create compilers for scientific challenges. The toolchain is designed\u00a0by\u00a0and\u00a0for\u00a0domain experts, ensuring practicality and alignment with real-world research needs.</p> </li> <li> <p>Focused Scope</p> <p>Unlike generic compiler frameworks, Kirin deliberately narrows its focus to scientific applications. It specializes in high-level, structurally oriented eDSLs\u2014optimized for concise, kernel-style functions that form the backbone of computational workflows.</p> </li> <li> <p>Composability as a Foundation</p> <p>Science thrives on interdisciplinary collaboration. Kirin treats composability\u2014the modular integration of systems and components\u2014as a first-class design principle. This ensures eDSLs and their compilers can seamlessly interact, mirroring the interconnected nature of scientific domains.</p> </li> </ol>"},{"location":"blog/2025/02/28/introducing-kirin-a-new-open-source-software-development-tool-for-fault-tolerant-quantum-computing/#what-are-kernel-functions","title":"What are Kernel Functions?","text":"<p>A kernel function is a piece of code that runs on specialized hardware\u2014like a GPU, a cluster, or a quantum computer\u2014instead of going through normal Python interpretation. While this concept may be unfamiliar in the field of quantum computing, it's common in machine learning frameworks like JAX (jax jit, pallas), PyTorch or CUDA.jl, where the <code>@jit</code> decorator marks Python functions as kernels for compilation and optimization.</p>"},{"location":"blog/2025/02/28/introducing-kirin-a-new-open-source-software-development-tool-for-fault-tolerant-quantum-computing/#example-extending-qasm2-with-kirin","title":"Example: Extending QASM2 with Kirin","text":"<p>Suppose you have an existing quantum circuit language (like OpenQASM 2) and you would like to add recursion and loops \u2014 a concept that your original circuit language doesn\u2019t have. Let\u2019s see how this works.</p> <p>The baseline\u00a0<code>qasm2.main</code>\u00a0decorator adheres strictly to QASM2 specifications:</p> <pre><code>from bloqade import qasm2\n\n@qasm2.main\ndef main():\n    qreg = qasm2.qreg(2) # quantum register\n    creg = qasm2.creg(2) # classical register\n    qasm2.h(qreg[0]) # Hadamard gate\n    qasm2.measure(qreg[0], creg[0]) # measure\n    if creg[0] == 0: # simple conditional gate\n       qasm2.x(qreg[0])\n</code></pre> <p>You may quickly find it restrictive when writing more complicated examples due to the lack of some common Python language features such as recursions and loops. To address this, we provide a <code>qasm2.extended</code> decorator that introduces some common Python language features as well as some special gates for the neutral atom platform. For instance, see the following Quantum Fourier Transform (QFT) example written with recursion:</p> <pre><code>import math\nfrom bloqade import qasm2\n\n@qasm2.extended\ndef qft(qreg: qasm2.QReg, n: int, k: int):\n    if k == n:\n        return qreg\n\n    qasm2.h(qreg[k])\n    for i in range(k + 1, n):\n        qasm2.cu1(qreg[i], qreg[k], 2 * math.pi / 2**i)\n    qft(qreg, n, k + 1)  # recursion\n    return qreg\n</code></pre> <p>Below, you can see what this immediately compiles to. While we aren\u2019t going to dive too deeply into what the output means, the interested readers can learn more about it in Kirin\u2019s documentation.</p> Compilation result of Bloqade\u2019s extended qasm2 kernel of a QFT program. <p>At a high-level, this is an Intermediate Representation (IR) that the compiler emits. By representing a human-readable program in a machine-friendly IR, it allows us to further compile the program into other lower-level representations such as atom moves and pulses for neutral atom quantum computers.</p>"},{"location":"blog/2025/02/28/introducing-kirin-a-new-open-source-software-development-tool-for-fault-tolerant-quantum-computing/#dialects-multiple-edsl-made-simple","title":"Dialects - multiple eDSL made simple","text":"<p>At QuEra, we can design and compile many different eDSLs to enable fast iterations on our machine architecture. This begs the question: how do we easily compose and maintain them?</p> <p>The answer to the problem in Kirin is dialects \u2014 smaller, highly composable units of languages. While the actual implementation of the <code>@qasm2.extended</code> eDSL involves several dialects, in general, it introduces the QASM2 unitary operator into Python, so equivalently you can just write</p> <pre><code>from kirin.prelude import basic\nfrom bloqade import qasm2\n\n@basic.add(qasm2.uop)\ndef qft(qreg: qasm2.QReg, n: int): ... # same as previous\n</code></pre> <p>where the <code>basic</code> dialect provides the basic Python language support (e.g., functions, control flows) and the <code>qasm2.uop</code> dialect provides the QASM2 gates. Thus, creating a new eDSL on top of an existing one is very simple:</p> <ul> <li>step 1: Define the semantics you want to add on top of an existing eDSL as dialects</li> <li>step 2: Add them to the existing eDSL via <code>.add</code> method</li> </ul> <p>Kirin, the compiler infrastructure, helps you define the compilers for different dialects and easily compose multiple compiler components made for different dialects.</p>"},{"location":"blog/2025/02/28/introducing-kirin-a-new-open-source-software-development-tool-for-fault-tolerant-quantum-computing/#example-extending-an-edsl-to-support-parallel-gates-with-kirin","title":"Example: Extending an eDSL to support parallel gates with Kirin","text":"<p>Suppose you have an existing quantum circuit language (in OpenQASM 2) and would like to add parallel gates\u2014a concept that your hardware supports but the original language doesn\u2019t. The neutral-atom quantum computers at QuEra are capable of a high degree of parallelism, which calls for a parallel dialect that provides the semantics of parallel gates. For example, you can write a GHZ state preparation circuit using parallel gates with a shorter circuit depth compared to a typical serial execution. This parallelism is also what makes our device powerful in implementing certain transversal gates that are desirable for quantum error correction (QEC).</p> <p>To support parallel gates with Kirin, you would:</p> <p>To support parallel gates with Kirin, you would:</p> <ol> <li>Define a dialect that expresses parallel operations (for example, <code>parallel.u</code> or <code>parallel.cz</code>).</li> <li>Compose that dialect with your base language dialect(s).</li> <li>Decorate your Python function with Kirin\u2019s compiler directive, so it compiles to the new IR.</li> </ol> <pre><code># a simplified version of single layer circuit in log-depth\n# GHZ state preparation with parallel gates\nimport math\nfrom bloqade import qasm2\nfrom kirin.prelude import basic\nfrom kirin.dialects import ilist\n\nn = 4\nn_qubits = int(2**n)\n\n@basic.add(qasm2.dialects.parallel)\ndef ghz_layer(i_layer: int, qreg: qasm2.QReg):\n    step = n_qubits // (2**i_layer)\n    def get_qubit(x: int):\n        return qreg[x]\n\n    ctrl_qubits = ilist.map(fn=get_qubit, collection=range(0, n_qubits, step))\n    targ_qubits = ilist.map(\n        fn=get_qubit, collection=range(step // 2, n_qubits, step)\n    )\n    # Ry(-pi/2)\n    qasm2.parallel.u(qargs=targ_qubits, theta=-math.pi / 2, phi=0.0, lam=0.0)\n    # CZ gates\n    qasm2.parallel.cz(ctrls=ctrl_qubits, qargs=targ_qubits)\n    # Ry(pi/2)\n    qasm2.parallel.u(qargs=targ_qubits, theta=math.pi / 2, phi=0.0, lam=0.0)\n</code></pre> <p>Under the hood, Kirin translates this code into its IR, combining Python semantics such as closure (from <code>basic</code>) with the parallel gate semantics (from <code>qasm2.dialects.parallel</code>). You can then run optimization passes or map the IR to specific device instructions\u2014all without rewriting your entire stack. For convenience, we wrap the above extension with some modification in a dialect group  <code>@qasm2.extended</code>  demonstrated previously in the Bloqade SDK.</p>"},{"location":"blog/2025/02/28/introducing-kirin-a-new-open-source-software-development-tool-for-fault-tolerant-quantum-computing/#outlook-and-future-plans","title":"Outlook and Future Plans","text":"<p>This initial release of Kirin centers on the infrastructure \u2014 the IR, dialect system, and Python integration \u2014 so you can:</p> <ol> <li>Prototype New eDSLs: Start defining your own dialects or try out the built-in ones (for quantum gates, parallel operations, etc.).</li> <li>Optimize with Custom Passes: Take advantage of IR transformations to optimize your kernel for speed, resource usage, or hardware constraints.</li> <li>Contribute: Share your domain expertise by creating new dialects or compiler transforms \u2014be it for advanced noise modeling, novel quantum error correction strategies, or new compilation algorithms.</li> </ol> <p>Looking ahead, we plan to release additional dialects and compiler tools that will enable:</p> <ol> <li>Programming with lower-level neutral atom machine concepts, including atom movement</li> <li>Hardware-specific optimizations to improve execution fidelity and performance on the neutral-atom platform</li> <li>A fully functional pipeline to access our state-of-the-art neutral-atom hardware</li> </ol> <p>By open-sourcing both our quantum eDSLs (Bloqade) and infrastructure (Kirin), we invite the entire community to join us in advancing quantum computing. Together, we can push the boundaries of what's possible.</p>"},{"location":"blog/2025/02/28/introducing-kirin-a-new-open-source-software-development-tool-for-fault-tolerant-quantum-computing/#try-it-out","title":"Try it out","text":"<ul> <li>Download and Install: Check out Kirin\u2019s repository on GitHub and install via <code>pip</code>:</li> </ul> <p><pre><code>pip install kirin-toolchain\n</code></pre> - Documentation and Examples: Visit our docs site for a getting-started guide and examples.</p>"},{"location":"blog/2025/02/28/introducing-kirin-a-new-open-source-software-development-tool-for-fault-tolerant-quantum-computing/#community","title":"Community","text":"<p>We encourage everyone join the effort to build this infrastructure together</p> <ul> <li>Slack join via this link to meet and share your ideas about Kirin with the community!</li> <li>GitHub Discussion: ****Have trouble using Kirin but not sure if it should be a bug report? Or want to announce your package built using Kirin? Or more public discussion or announcement in the community? Try Kirin\u2019s GitHub Discussion.</li> <li>Star Kirin on GitHub: If you like what you see, please give us a star on GitHub!</li> </ul> <p>Whether you\u2019re a quantum researcher, a compiler engineer, or just passionate about building next-generation compiler tools, Kirin is here to help you design, optimize, and compose advanced computational workflows with ease. We can\u2019t wait to see what you\u2019ll create!</p>"},{"location":"blog/2025/02/28/introducing-kirin-a-new-open-source-software-development-tool-for-fault-tolerant-quantum-computing/#appendix-the-growing-need-for-edsls-in-quantum-science","title":"Appendix: The Growing Need for eDSLs in Quantum Science","text":"<p>Over the past decade, the fields of quantum computing and scientific research have seen remarkable progress, both in\u00a0software\u00a0and\u00a0hardware. Scientists have developed increasingly sophisticated simulators\u2014such as quantum circuit simulators, differential equation solvers, and differentiable solvers\u2014as well as a variety of highly controllable quantum systems, including neutral atoms, trapped ions, superconducting qubits, and atoms in optical lattices. These systems are now being used for a wide range of applications.</p> <p>This rapid progress underscores the need for more advanced tools to effectively interact with these simulators and physical systems. To address this, scientists have created numerous\u00a0domain-specific languages (DSLs)\u00a0and their corresponding compilers. Examples include:</p> <ul> <li>Quantum Circuit Languages: Quipper, ProjectQ, Q#, Cirq, OpenQASM 2 &amp; 3, PennyLane, Stim</li> <li>Tensor Network Libraries: ITensor, OMEinsum, QUIMB, Tenet</li> </ul> <p>At its core, computations translate problem descriptions into signals controlling physical systems, making every computation fundamentally a compilation challenge. Building domain-specific languages (DSLs) and compilers is complex, typically beyond most scientists' expertise. Specialized domains like circuit simplification, hardware engineering, atomic physics, and quantum error correction require deep integration into software. Relying on a small compiler engineering team to develop these DSLs is inherently impractical at the current stage of quantum.</p> <p>We are scientists, just like you, striving for scientific breakthroughs. But we\u2019ve found ourselves stuck trying to build complex compilers to program our own machines and simulators. Existing tools are either too complex for scientists to use effectively or not flexible enough to adapt to our specific needs. These challenges are not unique to the neutral-atom community\u2014they exist across the broader quantum computing community.</p>"},{"location":"blog/2025/02/28/introducing-kirin-a-new-open-source-software-development-tool-for-fault-tolerant-quantum-computing/#how-kirin-fits-into-the-bigger-picture","title":"How Kirin Fits Into the Bigger Picture","text":"<p>Kirin isn\u2019t just another compiler \u2014 it\u2019s a framework for building compilers. If you\u2019re working with:</p> <ul> <li>Quantum Hardware like neutral-atom arrays, trapped ions, or superconducting qubits</li> <li>Classical HPC kernels for domain-specific simulation workflows</li> <li>Hybrid Quantum-Classical blend quantum and classical workflows treating both as first-class citizens</li> </ul> <p>Kirin\u2019s modular design gives you a foundation to express your domain logic, refine it through compiler passes, and ultimately generate efficient, hardware-friendly instructions. Because Kirin is built by scientists for scientists, it emphasizes approachable abstractions and leaves the door open for community-driven innovation.</p> <p></p>"},{"location":"blog/2025/02/28/introducing-kirin-a-new-open-source-software-development-tool-for-fault-tolerant-quantum-computing/#acknowledgement","title":"Acknowledgement","text":"<p>While the mission and audience may be very different, Kirin has been deeply inspired by a few projects:</p> <ul> <li>MLIR, the concept of dialects and the way it is designed.</li> <li>xDSL, about how IR data structure &amp; interpreter should be designed in Python.</li> <li>Julia, abstract interpretation, and certain design choices for scientific community.</li> <li>JAX\u00a0and\u00a0numba, the frontend syntax and the way it is designed.</li> <li>Symbolics.jl\u00a0and its predecessors, the design of rule-based rewriter.</li> </ul> <p>Part of the work is also inspired in previous collaboration in YaoCompiler, thus we would like to thank Valentin Churavy and William Moses for early discussions around the compiler plugin topic. We thank early support of the YaoCompiler project from Unitary Foundation.</p>"},{"location":"cookbook/","title":"Index","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"cookbook/#cookbook","title":"Cookbook","text":"<p>This cookbook provides a collection of quick examples to help you get started with Kirin. Each example is a self-contained page that demonstrates a specific feature or use case. You can copy and paste the code snippets into your own project and modify them as needed.</p>"},{"location":"cookbook/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Continuation of FoodLang</li> </ul>"},{"location":"cookbook/foodlang/analysis/","title":"Food Pricing Analysis Pass","text":""},{"location":"cookbook/foodlang/analysis/#food-cost-and-nap-analysis","title":"Food cost and Nap analysis","text":"<p>In this section we will discuss on how to perform analysis of a Kirin program. We will again use our <code>food</code> dialect example.</p>"},{"location":"cookbook/foodlang/analysis/#goal","title":"Goal","text":"<p>Let's consider the following program</p> <pre><code>@food\ndef main2(x: int):\n\n    burger = NewFood(type=\"burger\")\n    salad = NewFood(type=\"salad\")\n\n    burger_serving = Cook(burger, 12 + x)\n    salad_serving = Cook(salad, 10 + x)\n\n    Eat(burger_serving)\n    Eat(salad_serving)\n    Nap()\n\n    Eat(burger_serving)\n    Nap()\n\n    Eat(burger_serving)\n    Nap()\n\n    return x\n</code></pre> <p>We would like to implement an forward dataflow analysis that walks through the program and collects the pricing information for each of the statements as well as how many times one has napped.</p>"},{"location":"cookbook/foodlang/analysis/#defining-a-lattice","title":"Defining a Lattice","text":"<p>One of the important concepts related to doing static analysis is the Lattice (See Wiki:Lattice and Lecture Notes On Static Analysis for further details) A Lattice defines the partial order of the lattice element. An simple example is the type lattice.</p> <p>Let's now defines our <code>Item</code> lattice for the price analysis.</p> <p>First, a lattice always has <code>top</code> and <code>bottom</code> elements. In type lattice, the top element is <code>Any</code> and bottom element is <code>None</code>.</p> <p>Here, we define <code>AnyItem</code> as <code>top</code> and <code>NoItem</code> as <code>bottom</code>. In Kirin, we can simply inherit the <code>BoundedLattice</code> from <code>kirin.lattice</code>. Kirin also provides some simple mixins with default implementations of the API such as <code>is_subseteq</code>, <code>join</code> and <code>meet</code> so you don't have to re-implement them.</p> <pre><code>from kirin.lattice import (\n    SingletonMeta,\n    BoundedLattice,\n    IsSubsetEqMixin,\n    SimpleJoinMixin,\n    SimpleMeetMixin,\n)\nfrom typing import final\nfrom dataclasses import dataclass\n\n@dataclass\nclass Item(\n    IsSubsetEqMixin[\"Item\"],\n    SimpleJoinMixin[\"Item\"],\n    SimpleMeetMixin[\"Item\"],\n    BoundedLattice[\"Item\"],\n):\n\n    @classmethod\n    def top(cls) -&gt; \"Item\":\n        return AnyItem()\n\n    @classmethod\n    def bottom(cls) -&gt; \"Item\":\n        return NotItem()\n\n\n@final\n@dataclass\nclass NotItem(Item, metaclass=SingletonMeta): # (1)!\n    \"\"\"The bottom of the lattice.\n\n    Since the element is the same without any field,\n    we can use the SingletonMeta to make it a singleton by inheriting from the metaclass\n\n    \"\"\"\n\n    def is_subseteq(self, other: Item) -&gt; bool:\n        return True\n\n\n@final\n@dataclass\nclass AnyItem(Item, metaclass=SingletonMeta):\n    \"\"\"The top of the lattice.\n\n    Since the element is the same without any field,\n    we can use the SingletonMeta to make it a singleton by inheriting from the metaclass\n\n    \"\"\"\n\n    def is_subseteq(self, other: Item) -&gt; bool:\n        return isinstance(other, AnyItem)\n</code></pre> <ol> <li>Notice that since <code>NotItem</code> and <code>AnyItem</code> do not have any properties, we can mark them as singletons to prohibit duplicate copies of instances by inheriting from the <code>SingletonMeta</code> metaclass.</li> </ol> <p>Next there are a few more lattice elements we want to define:</p> <pre><code>@final\n@dataclass\nclass ItemServing(Item): # (1)!\n    count: Item\n    type: str\n\n    def is_subseteq(self, other: Item) -&gt; bool:\n        return (\n            isinstance(other, ItemServing)\n            and self.count == other.count\n            and self.type == other.type\n        )\n\n\n@final\n@dataclass\nclass AtLeastXItem(Item): # (2)!\n    data: int\n\n    def is_subseteq(self, other: Item) -&gt; bool:\n        return isinstance(other, AtLeastXItem) and self.data == other.data\n\n\n@final\n@dataclass\nclass ConstIntItem(Item): # (3)!\n    data: int\n\n    def is_subseteq(self, other: Item) -&gt; bool:\n        return isinstance(other, ConstIntItem) and self.data == other.data\n\n\n@final\n@dataclass\nclass ItemFood(Item): # (4)!\n    type: str\n\n    def is_subseteq(self, other: Item) -&gt; bool:\n        return isinstance(other, ItemFood) and self.type == other.type\n</code></pre> <ol> <li><code>ItemServing</code> which contains information of the kind of food of the <code>Serving</code>, as well as the count</li> <li><code>AtLeastXItem</code> which contains information of a constant type result value is a number that is least <code>x</code>. The <code>data</code> contain the lower-bound</li> <li><code>ConstIntItem</code> which contains a concrete number.</li> <li><code>ItemFood</code> which contains information of <code>Food</code>.</li> </ol>"},{"location":"cookbook/foodlang/analysis/#custom-forward-data-flow-analysis","title":"Custom Forward Data Flow Analysis","text":"<p>Now we have defined our lattice. Let's move on to see how we can write an analysis pass, and get the analysis results.</p> <p>In Kirin, the analysis pass is implemented with <code>AbstractInterpreter</code> (inspired by the Julia programming language). Kirin provides an simple forward dataflow analysis <code>Forward</code>. So we will use that.</p> <p>Here our analysis will do two things.</p> <ol> <li>Get all the analysis results as a dictionary of SSAValue to lattice elements.</li> <li>Count how many times one naps.</li> </ol> <pre><code>from kirin.analysis import Forward, ForwardFrame\nfrom kirin.interp import SpecialValue\nfrom kirin.ir import Method\n\nfrom dataclasses import field\n\n@dataclass\nclass FeeAnalysis(Forward[Item]): # (1)!\n    keys = [\"food.fee\"] # (2)!\n    lattice = Item\n    nap_count: int = field(init=False)\n\n    def initialize(self): # (3)!\n        \"\"\"Initialize the analysis pass.\n\n        The method is called before the analysis pass starts.\n\n        Note:\n            1. Here one is *required* to call the super().initialize() to initialize the analysis pass,\n            which clears all the previous analysis results and symbol tables.\n            2. Any additional initialization that belongs to the analysis should also be done here.\n            For example, in this case, we initialize the `nap_count` to 0.\n\n        \"\"\"\n        super().initialize()\n        self.nap_count = 0\n        return self\n\n    def eval_stmt_fallback( # (4)!\n        self, frame: ForwardFrame[Item], stmt: ir.Statement\n    ) -&gt; tuple[Item, ...] | SpecialValue[Item]:\n        return ()\n\n    def run_method(self, method: Method, args: tuple[Item, ...]) -&gt; Item: # (5)!\n        return self.run_callable(method.code, (self.lattice.bottom(),) + args)\n</code></pre> <ol> <li>Inherit from <code>Forward</code> with our custom lattice element <code>Item</code>.</li> <li>The keys for the MethodTable. Remember that in Kirin all the implementation methods of an interpreter are implemented and registered to a <code>MethodTable</code>.</li> <li><code>AbstractInterpreter</code> has an abstract method <code>initialize</code> which will be called every time <code>run()</code> is called. We can overload this to reset the variable, so we can re-use this class instance.</li> <li>This method implements a fallback for when a statement is encountered that has no corresponding method for it in the <code>MethodTable</code>. Here, we just return an empty tuple because we know all the statements that have a return value will be implemented, so only statements without return values will have to fall back.</li> <li>This method defines and customizes how to run the <code>ir.Method</code>.</li> </ol> <p>Click the + logo to see more details.</p> <p>Now we want to implement how the statement gets run. This is the same as what we described when we mentioned the concrete interpreter.</p> <p>Note that each dialect can have multiple registered <code>MethodTable</code>s, distinguished by a <code>key</code>. The interpreter uses the <code>key</code> to find the corresponding <code>MethodTable</code>s for each dialect in a dialect group.</p> <p>Here, we use <code>key=\"food.fee\"</code></p> <p>First we need to implement for <code>Constant</code> statement in <code>py.constant</code> dialect. If its <code>int</code>, we return <code>ConstIntItem</code> lattice element. If its <code>Food</code>, we return <code>ItemFood</code>.</p> <pre><code>from kirin.dialects import py\nfrom kirin.interp import MethodTable\nfrom kirin.exceptions import InterpreterExit\n\n@py.constant.dialect.register(key=\"food.fee\")\nclass PyConstMethodTable(MethodTable):\n\n    @interp.impl(py.constant.Constant)\n    def const(\n        self,\n        interp: FeeAnalysis,\n        frame: interp.Frame[Item],\n        stmt: py.constant.Constant,\n    ):\n        if isinstance(stmt.value, int):\n            return (ConstIntItem(data=stmt.value),)\n        elif isinstance(stmt.value, Food):\n            return (ItemFood(type=stmt.value.type),)\n\n        else:\n            raise InterpreterExit(\n                f\"illegal constant type {type(stmt.value)}\"\n            )\n</code></pre> <p>Next, since we allow the <code>add</code> operation in the program (Note the <code>12 + x</code> and <code>10 + x</code> operations in used in instantiating <code>Cook</code>), we also need to let abstract interpreter know how to interpret the <code>binop.Add</code> statement, which is in the <code>py.binop</code> dialect.</p> <pre><code>@binop.dialect.register(key=\"food.fee\")\nclass PyBinOpMethodTable(MethodTable):\n\n    @interp.impl(binop.Add)\n    def add(\n        self,\n        interp: FeeAnalysis,\n        frame: Frame[Item],\n        stmt: binop.Add,\n    ):\n        left = frame.get(stmt.lhs)\n        right = frame.get(stmt.rhs)\n\n        if isinstance(left, AtLeastXItem) or isinstance(right, AtLeastXItem):\n            out = AtLeastXItem(data=left.data + right.data)\n        else:\n            out = ConstIntItem(data=left.data + right.data)\n\n        return (out,)\n</code></pre> <p>Finally, we need an implementation for our food dialect statements.</p> <pre><code>@dialect.register(key=\"food.fee\")\nclass FoodMethodTable(MethodTable):\n\n    @impl(NewFood)\n    def new_food(\n        self,\n        interp: FeeAnalysis,\n        frame: Frame[Item],\n        stmt: NewFood,\n    ):\n        return (ItemFood(type=stmt.type),)\n\n    @impl(Cook)\n    def cook(\n        self,\n        interp: FeeAnalysis,\n        frame: Frame[Item],\n        stmt: Cook,\n    ):\n        # food depends on the food type to have different charge:\n\n        food = frame.get_typed(stmt.target, ItemFood)\n        serving_count: AtLeastXItem | ConstIntItem = frame.get(stmt.amount)\n\n        out = ItemServing(count=serving_count, type=food.type)\n\n        return (out,)\n\n    @impl(Nap)\n    def nap(\n        self,\n        interp: FeeAnalysis,\n        frame: interp.Frame[Item],\n        stmt: Nap,\n    ):\n        interp.nap_count += 1\n        return ()\n</code></pre>"},{"location":"cookbook/foodlang/analysis/#putting-everything-together","title":"Putting Everything Together","text":"<pre><code>fee_analysis = FeeAnalysis(main2.dialects)\nresults, expect = fee_analysis.run_analysis(main2, args=(AtLeastXItem(data=10),))\nprint(results)\nprint(fee_analysis.nap_count)\n</code></pre>"},{"location":"cookbook/foodlang/cf_rewrite/","title":"Advanced Rewriting","text":""},{"location":"cookbook/foodlang/cf_rewrite/#rewrite-if-else-control-flow","title":"Rewrite if-else control flow","text":"<p>In the main page, we introduce a simple <code>food</code> dialect example, and described how to use Kirin to define a simple compiler. In this section, we want to continue with this example, and consider a more complex rewrite pass that involves the built-in Python dialect <code>if-else</code> control flow.</p>"},{"location":"cookbook/foodlang/cf_rewrite/#goal","title":"Goal","text":"<p>When one gets really really full, not only does one want to take a nap, but sometimes one makes random decisions too. Here specifically, We want to rewrite the existing <code>IfElse</code> statement defined in the <code>py</code> dialect into a custom <code>RandomBranch</code> statement we will define in our food dialect.</p> <p>The execution of <code>RandomBranch</code>, as stated in its name, randomly executes a branch each time we run it.</p>"},{"location":"cookbook/foodlang/cf_rewrite/#define-custom-randombranch-statement","title":"Define Custom RandomBranch statement","text":"<p>Lets start by defining our <code>RandomBranch</code> Statement:</p> <pre><code>from kirin.decl import statement, info\nfrom kirin import ir, types\n\n@statement(dialect=dialect)\nclass RandomBranch(ir.Statement):\n    name = \"random_br\"\n    traits = frozenset({ir.IsTerminator()}) # (1)!\n    cond: ir.SSAValue = info.argument(types.Bool) # (2)!\n    then_arguments: tuple[ir.SSAValue, ...] = info.argument() # (3)!\n    else_arguments: tuple[ir.SSAValue, ...] = info.argument() # (4)!\n    then_successor: ir.Block = info.block() # (5)!\n    else_successor: ir.Block = info.block() # (6)!\n</code></pre> <ol> <li>The <code>traits</code> field specifies that this statement is a terminator. A terminator is a statement that    ends a block. In this case, the <code>RandomBranch</code> statement is a terminator because it decides which    block to go next.</li> <li>The <code>cond</code> field specifies the condition of the branch. It is a boolean value.</li> <li>The <code>then_arguments</code> field specifies the arguments that are passed to the <code>then_successor</code> block. Unlike    previous examples, the <code>then_arguments</code> field is annotated with <code>tuple[ir.SSAValue, ...]</code>, which means    it takes a tuple of <code>ir.SSAValue</code> objects (like what it means in a <code>dataclass</code>).</li> <li>The <code>else_arguments</code> field specifies the arguments that are passed to the <code>else_successor</code> block.</li> <li>The <code>then_successor</code> field specifies the block that the control flow goes to if the condition is true.</li> <li>The <code>else_successor</code> field specifies the block that the control flow goes to if the condition is false.</li> </ol> <p>The <code>RandomBranch</code> statement is a terminator that takes a boolean condition and two tuples of arguments. However, unlike a normal <code>if else</code> branching statement, it does not execute the branches based on the condition. Instead, it randomly chooses one of the branches to execute. We will implement the execution behavior of this statement in the following.</p>"},{"location":"cookbook/foodlang/cf_rewrite/#implementation-and-methodtable","title":"Implementation and MethodTable","text":"<p>Recall in the introduction of food dialect we introduced the <code>MethodTable</code>. Now that we have defined the <code>RandomBranch</code> statement, we will need to tell interpreter how to interpret it.</p> <p>Let's find the <code>FoodMethods</code> MethodTable that we defined and registered to the <code>food</code> dialect previously. Note that as part of the previous imports we now pull in a <code>Successor</code> whose purpose will be explained below, as well as importing <code>randint</code> from Python's <code>random</code> module to introduce the random behavior we want:</p> <pre><code>from kirin.interp import Frame, Successor, Interpreter, MethodTable, impl\nfrom math import randint\n\n@dialect.register\nclass FoodMethods(MethodTable):\n    ...\n</code></pre> <p>Now we want to also implement the execution method and then register it to this method table:</p> <pre><code>    @impl(RandomBranch)\n    def random_branch(self, interp: Interpreter, stmt: RandomBranch, values: tuple):\n        frame = interp.state.current_frame()\n        if randint(0, 1):\n            return Successor(\n                stmt.then_successor, *frame.get_values(stmt.then_arguments)\n            )\n        else:\n            return Successor(\n                stmt.else_successor, *frame.get_values(stmt.then_arguments)\n            )\n</code></pre> <p>The <code>random_branch</code> implementation randomly chooses one of the branches to execute. The return value is a <code>Successor</code> object that specifies the next block to execute and the arguments to pass to the block.</p>"},{"location":"cookbook/foodlang/cf_rewrite/#rewrite-python-if-else-statement-to-randombranch","title":"Rewrite Python <code>if else</code> statement to <code>RandomBranch</code>","text":"<p>Now we can define a rewrite pass that rewrites Python <code>if else</code> statement to <code>RandomBranch</code> statement. This is done by defining a subclass of <code>RewriteRule</code> and implementing the <code>rewrite_Statement</code> method. The <code>RewriteRule</code> class is a standard Python visitor on Kirin's IR.</p> <p>Here, we only need to implement the <code>rewrite_Statement</code> method to rewrite the <code>if else</code> statement to <code>RandomBranch</code>.</p> <pre><code>from kirin.dialects import cf # (1)!\nfrom kirin.rewrite import RewriteResult, RewriteRule # (2)!\n\n@dataclass\nclass RewriteToRandomBranch(RewriteRule):\n\n    def rewrite_Statement(self, node: ir.Statement) -&gt; RewriteResult: # (3)!\n        if not isinstance(node, cf.ConditionalBranch): # (4)!\n            return RewriteResult()\n        node.replace_by(\n            RandomBranch(\n                cond=node.cond,\n                then_arguments=node.then_arguments,\n                then_successor=node.then_successor,\n                else_arguments=node.else_arguments,\n                else_successor=node.else_successor,\n            )\n        )\n        return RewriteResult(has_done_something=True) # (5)!\n</code></pre> <ol> <li>Import the control flow dialect <code>cf</code> which is what Python's <code>if else</code> statement compiles to by default in the <code>basic</code> dialect group.</li> <li>Import the <code>RewriteRule</code> class from the <code>rewrite</code> module.</li> <li>This is the signature of <code>rewrite_Statement</code> method. Your IDE should hint the type signature so you can auto-complete it.</li> <li>Check if the statement is a <code>ConditionalBranch</code> statement. If it is not, return an empty <code>RewriteResult</code>.</li> <li>Replace the <code>ConditionalBranch</code> statement with a <code>RandomBranch</code> statement and return a <code>RewriteResult</code> that indicates the rewrite has been done. Every statement has a <code>replace_by</code> method that replaces the statement with another statement.</li> </ol>"},{"location":"cookbook/foodlang/cf_rewrite/#adding-to-the-decorator","title":"Adding to the decorator","text":"<p>Now we can incorporate our new rewrite rule as part of the function that defines the <code>@food</code> decorator!</p> <pre><code>from kirin.ir import dialect_group\nfrom kirin.prelude import basic_no_opt\nfrom kirin.rewrite import Walk, Fixpoint\n\n@dialect_group(basic_no_opt.add(dialect))\ndef food(self):\n\n    fold_pass = Fold(self)\n\n    def run_pass(mt, *, fold:bool = True, hungry:bool=False, got_lost: bool=True): # (1)!\n\n        if fold:\n            fold_pass(mt)\n\n        if hungry:\n            Walk(NewFoodAndNap()).rewrite(mt.code)\n\n        if got_lost:\n            Fixpoint(Walk(RandomWalkBranch())).rewrite(mt.code) # (2)!\n\n    return run_pass\n</code></pre> <ol> <li>Lets add an extra <code>got_lost</code> option to toggle this <code>RandomWalkBranch()</code> rewrite rule.</li> <li>The <code>Walk</code> will walk through the IR and apply the rule. The <code>Fixpoint</code> then repeatedly walks through the IR until there is nothing to rewrite.</li> </ol>"},{"location":"cookbook/foodlang/codegen/","title":"Receipt Codegen","text":""},{"location":"cookbook/foodlang/codegen/#codegen-food-receipt","title":"Codegen Food receipt","text":"<p>At the end of the day, we enjoy the food and take a nap, but still need to pay the bill. In this section we will use the previous food language analysis result, and discuss how to use Kirin's codegen framework to generate a receipt.</p>"},{"location":"cookbook/foodlang/codegen/#goal","title":"Goal","text":"<p>Lets again continue with the same program, using the previously created <code>FeeAnalysis</code> pass to get an analysis result. <pre><code>@food\ndef main2(x: int):\n\n    burger = NewFood(type=\"burger\")\n    salad = NewFood(type=\"salad\")\n\n    burger_serving = Cook(burger, 12 + x)\n    salad_serving = Cook(salad, 10 + x)\n\n    Eat(burger_serving)\n    Eat(salad_serving)\n    Nap()\n\n    Eat(burger_serving)\n    Nap()\n\n    Eat(burger_serving)\n    Nap()\n\n    return x\n</code></pre></p> <p>We want to generate a receipt of bill that listed the type of food cooked, and the amount of servings that were cooked.</p>"},{"location":"cookbook/foodlang/codegen/#codegen-using-kirin-emitstr","title":"Codegen using kirin EmitStr","text":"<p>Kirin also provides a Codegen framework (we call it <code>Emit</code>), which is also a kind of <code>Interpreter</code>! (These days, what isn't an interpreter? :P)</p> <p>Here, since we want to codegen a receipt in text format, our target is <code>Str</code>. We will use the <code>EmitStr</code> class Kirin provides which does a lot of the heavy lifting for us. In general, one can also customize the Codegen by subclassing from <code>EmitABC</code>, but here we will just directly using <code>EmitStr</code> provided by kirin.</p> <pre><code>def default_menu_price():\n    return {\n        \"burger\": 3.0,\n        \"salad\": 4.0,\n        \"chicken\": 2.0,\n    }\n\n\n\n@dataclass\nclass EmitReceiptMain(EmitStr):\n    keys = [\"emit.receipt\"]\n    dialects: ir.DialectGroup = field(default=food)\n    file: StringIO = field(default_factory=StringIO)\n    menu_price: dict[str, float] = field(default_factory=default_menu_price)\n    receipt_analysis_result: dict[ir.SSAValue, Item] = field(default_factory=dict)\n\n    def initialize(self):\n        super().initialize()\n        self.file.truncate(0)\n        self.file.seek(0)\n        return self\n\n    def eval_stmt_fallback(\n        self, frame: EmitStrFrame, stmt: ir.Statement\n    ) -&gt; tuple[str, ...]:\n        return (stmt.name,)\n\n    def emit_block(self, frame: EmitStrFrame, block: ir.Block) -&gt; str | None:\n        for stmt in block.stmts:\n            result = self.eval_stmt(frame, stmt)\n            if isinstance(result, tuple):\n                frame.set_values(stmt.results, result)\n        return None\n\n    def get_output(self) -&gt; str:\n        self.file.seek(0)\n        return \"\\n\".join(\n            [\n                \"item    \\tamount \\t  price\",\n                \"-----------------------------------\",\n                self.file.read(),\n            ]\n        )\n</code></pre> <p>As with all other Kirin interpreters, we need to implement a <code>MethodTable</code> for our emit interpreter. Here, we register method tables to the key <code>emit.receipt</code>.</p> <pre><code>@func.dialect.register(key=\"emit.receipt\")\nclass FuncEmit(interp.MethodTable):\n\n    @interp.impl(func.Function)\n    def emit_func(self, emit: EmitReceiptMain, frame: EmitStrFrame, stmt: func.Function):\n        _ = emit.run_ssacfg_region(frame, stmt.body)\n        return ()\n</code></pre> <p>For our <code>Cook</code> Statement, we want to generate a transaction each time we cook. We will get the previous analysis result from the corresponding SSAValue. If the lattice element is a <code>AtLeastXItem</code>, we generate a line with the food type, and <code>&gt;= x</code>. If its a <code>ConstIntItem</code> we just directly generate the amount.</p> <pre><code>@dialect.register(key=\"emit.receipt\")\nclass FoodEmit(interp.MethodTable):\n\n    @interp.impl(stmts.Cook)\n    def emit_cook(self, emit: EmitReceiptMain, frame: EmitStrFrame, stmt: stmts.Cook):\n        serving_item = cast(ItemServing, emit.receipt_analysis_result[stmt.result])\n\n        amount_str = \"\"\n        price_str = \"\"\n        if isinstance(serving_item.count, AtLeastXItem):\n            amount_str = f\"&gt;={serving_item.count.data}\"\n            price_str = (\n                f\"  &gt;=${emit.menu_price[serving_item.type] * serving_item.count.data}\"\n            )\n        elif isinstance(serving_item.count, ConstIntItem):\n            amount_str = f\"  {serving_item.count.data}\"\n            price_str = (\n                f\"  ${emit.menu_price[serving_item.type] * serving_item.count.data}\"\n            )\n        else:\n            raise EmitError(\"invalid analysis result.\")\n\n        emit.writeln(frame, f\"{serving_item.type}\\t{amount_str}\\t{price_str}\")\n\n        return ()\n</code></pre>"},{"location":"cookbook/foodlang/codegen/#put-together","title":"Put together:","text":"<pre><code>emitter = EmitReceiptMain()\nemitter.receipt_analysis_result = results\n\nemitter.run(main2, (\"\",))\nprint(emitter.get_output())\n</code></pre>"},{"location":"cookbook/paulilang/pauli/","title":"Pauli Matrix Algebra","text":"<p>In this example, we'll implement a simple dialect that allows you to write mathematical expressions using the Pauli matrices \\(\\sigma_x, \\sigma_y\\) and \\(\\sigma_z\\). We'll add some basic rewriting routines so that the IR is symbolically rewritten using the basic relations</p> \\[ \\sigma_i \\sigma_j = \\epsilon_{ijk} \\sigma_k, \\] <p>and</p> \\[ \\sigma_i^2 = \\mathbb{I_2} \\] <p>Given these relations, you can rewrite longer expressions at compile time, such that the resulting code that is executed becomes much simpler and the number of matrix operations that need to be performed is reduced.</p> <p>We'll start out with the basic definitions and then add more features to it as we go along.</p>"},{"location":"cookbook/paulilang/pauli/#defining-the-dialect","title":"Defining the dialect","text":"<p>First off, we'll define the dialect statements. Each statement defining a Pauli operator will be returning a numpy array. We can keep things concise by defining the properties in one class and then inheriting from that class for each statement.</p> <p>Each statement that you want to use in your dialect needs to be registered to it. That's done by providing your dialect as an argument to the <code>statement</code>.</p> <pre><code>from numbers import Number\nimport numpy as np\n\nfrom kirin import ir, lowering\nfrom kirin.types import PyClass\nfrom kirin.decl import statement, info\n\n\ndialect = ir.Dialect(\"pauli\")  # (1)!\n\n\n@statement  # (2)!\nclass PauliOperator(ir.Statement):\n    traits = frozenset({ir.Pure(), lowering.FromPythonCall()})  # (3)!\n    pre_factor: Number = info.attribute(default=1)  # (4)!\n    result: ir.ResultValue = info.result(PyClass(np.matrix))\n\n\n@statement(dialect=dialect)  # (5)!\nclass X(PauliOperator):\n    pass\n\n@statement(dialect=dialect)\nclass Y(PauliOperator):\n    pass\n\n@statement(dialect=dialect)\nclass Z(PauliOperator):\n    pass\n\n\n@statement(dialect=dialect)\nclass Id(PauliOperator):\n    pass\n</code></pre> <ol> <li>Define the actual dialect to which we want to register our statements.</li> <li>Notice how we are not registering the <code>PauliOperator</code>. That's because we don't actually want users to create an instant of it since it serves just as a base type. This is similar to how a user cannot create a number of base type <code>Number</code>, it's always a type such as <code>float</code> or <code>int</code>.</li> <li>All Pauli operator statements are pure, since they have no side-effects and their output is fully determined by the input. They are also created by a simple call.</li> <li>In addition to the actual matrix, our Pauli operator statements will also have a pre-factor that's just a number. This makes rewriting easier later, read on for more details.</li> <li>Concrete statements have to be registered to our dialect.</li> </ol> <p>With these few simple statements defined, we can already create a basic decorator that does no rewrites or optimizations, but at least knows about our statements. Note that we are adding our dialect to the <code>basic_no_opt</code> dialect group. This defines some basic semantics such as multiplication. In practice, you'd very rarely ever want to start from scratch. There are a number of different dialect groups pre-defined in kirin, from which to start.</p> <pre><code>from kirin.prelude import basic_no_opt\n\n\n@ir.dialect_group(basic_no_opt.add(dialect=dialect))\ndef pauli_basic_no_opt(self):\n    def run_pass(mt):\n        pass  # (1)!\n\n    return run_pass\n</code></pre> <ol> <li>As a start, our dialect will do nothing with the IR.</li> </ol> <p>With that, we can use our DSL within a function that is decorated accordingly.</p> <pre><code>@pauli_basic_no_opt\ndef basic_example():\n    x = X()\n    y = Y()\n    z = x * y\n    return z\n\nbasic_example.print()\n</code></pre> <p>The printed IR shows that the statements are executed fine, but nothing more is happening.</p> <pre><code>func.func basic_example() -&gt; !Any {\n  ^0(%basic_example_self):\n  \u2502 %x = pauli.x(){pre_factor=1 : !py.Number} : !py.matrix\n  \u2502 %y = pauli.y(){pre_factor=1 : !py.Number} : !py.matrix\n  \u2502 %z = py.binop.mult(%x, %y) : ~T\n  \u2502      func.return %z\n} // func.func basic_example\n</code></pre> <p>Ideally, we'd like the IR to be rewritten, such that the result will just be</p> \\[ \\sigma_x \\sigma_y = i \\sigma_z \\] <p>In the following, we'll add a corresponding rewrite pass to our Pauli DSL.</p>"},{"location":"cookbook/paulilang/pauli/#rewriting-multiplications","title":"Rewriting multiplications","text":"<p>In order to rewrite the IR of our DSL, we'll need to define a <code>RewriteRule</code> that does what we want and then add it to the DSL as a pass. A <code>RewriteRule</code> takes node of our IR expression as an argument and then rewrites it (in-place) according to any rule that you specify.</p> <p>Since we want to rewrite statements of our dialect, the entry point we define in our rule will be the <code>rewrite_Statement</code> method.</p> <pre><code>from dataclasses import dataclass\n\nfrom kirin.rewrite import abc, result\nfrom kirin.dialects import py\n\n\n@dataclass\nclass RewritePauliMult(abc.RewriteRule):\n    def rewrite_Statement(self, node: ir.Statement) -&gt; result.RewriteResult:\n        if not isinstance(node, py.binop.Mult):  # (1)!\n            return result.RewriteResult()\n\n        if not isinstance(node.lhs.owner, PauliOperator) and not isinstance(node.rhs.owner, PauliOperator):  # (2)!\n            return result.RewriteResult()\n\n        if isinstance(node.lhs.owner, py.Constant): # (3)!\n            new_op = self.number_pauli_mult(node.lhs.owner, node.rhs.owner)\n            node.replace_by(new_op)\n            return result.RewriteResult(has_done_something=True)\n        elif isinstance(node.rhs.owner, py.Constant): # (4)!\n            new_op = self.number_pauli_mult(node.rhs.owner, node.lhs.owner)\n            node.replace_by(new_op)\n            return result.RewriteResult(has_done_something=True)\n\n\n        if not isinstance(node.lhs.owner, PauliOperator) or not isinstance(node.rhs.owner, PauliOperator):  # (5)!\n                return result.RewriteResult()\n\n        new_op = self.pauli_pauli_mult(node.lhs.owner, node.rhs.owner)  #(6)!\n        node.replace_by(new_op)\n        return result.RewriteResult(has_done_something=True)\n\n    ...\n</code></pre> <ol> <li>Make sure we're looking at a multiplication.</li> <li>If not at least one of the constituents of the is a subtype of <code>PauliOperator</code> we don't want to do anything. This also makes sure the <code>Statement</code>s in our multiplication are owned by a <code>Statement</code> (see below for more details).</li> <li>This is a multiplcation with a number on the left-hand-side.</li> <li>This is a multiplcation with a number on the right-hand-side. We can just call the same method to rewrite this, but swap the sides. That's fine as things commute.</li> <li>None of the consituents is a number, one of them is a Pauli matrix. With this check we make sure that both of them are Pauli matrices, otherwise we bail (we could also be looking at a multiplication of e.g. additions).</li> <li>Now, we know for sure we have two Pauli matrices that need to be rewritten according to their commutation relation.</li> </ol> <p>Note how we're always checking the type by looking at the <code>.owner</code> of the <code>lhs</code> and <code>rhs</code> of the multiplcation. This achieves two things: first, it allows to actually determine the type of each of the nodes for basic checks (such as making sure that at least one of the arguments to the multiplication is a Pauli matrix). We decide how to rewrite the expression based on this. Secondly, this also makes sure that the owner is a <code>Statement</code> rather than a <code>Block</code>. That means we're actually looking at a statement rather than an argument to a block (think, a function argument) and we're fine doing a rewrite. If the check is <code>False</code>, i.e. if we are looking at a <code>Block</code>-owned Pauli matrix or a multiplication that doesn't contain any Pauli matrices, we simply bail and don't do a rewrite.</p> <p>So, the above <code>rewrite_Statement</code> method just runs a few basic checks and forwards to an appropriate rewriting method depending on the argument types of the multiplication.</p> <p>Now, let's have a look at the actual rewriting methods.</p> <pre><code>    @staticmethod\n    def number_pauli_mult(lhs: py.Constant, rhs: PauliOperator) -&gt; PauliOperator:\n        num = lhs.value.unwrap() * rhs.pre_factor\n        return type(rhs)(pre_factor=num)  # (1)!\n\n    @staticmethod\n    def pauli_pauli_mult(lhs: PauliOperator, rhs: PauliOperator) -&gt; PauliOperator:\n        num = rhs.pre_factor * lhs.pre_factor\n\n        if isinstance(lhs, type(rhs)):  # (2)!\n            return Id(pre_factor=num)\n\n        if isinstance(lhs, type(rhs)):\n            return Id(pre_factor=num)\n\n        if isinstance(lhs, Id):  # (3)!\n            return type(rhs)(pre_factor=num)\n\n        if isinstance(rhs, Id):\n            return type(lhs)(pre_factor=num)\n\n        if isinstance(lhs, X):  # (4)\n            if isinstance(rhs, Y):\n                return Z(pre_factor=1j * num)\n            elif isinstance(rhs, Z):\n                return Y(pre_factor=-1j * num)\n\n        if isinstance(lhs, Y):\n            if isinstance(rhs, X):\n                return Z(pre_factor=-1j * num)\n            elif isinstance(rhs, Z):\n                return X(pre_factor=1j * num)\n\n        if isinstance(lhs, Z):\n            if isinstance(rhs, Y):\n                return X(pre_factor=-1j * num)\n            elif isinstance(rhs, X):\n                return Y(pre_factor=1j * num)\n\n        raise RuntimeError(\"How on earth did we end up here?\")  # (5)!\n</code></pre> <ol> <li>When rewriting a multiplication with a number, we just construct the same Pauli matrix with an updated pre-factor.</li> <li>If both Pauli matrices are of the same type, the result will be an identity matrix.</li> <li>If either one is an identity, we just return the other argument with an updated pre-factor.</li> <li>For all other cases, we have to explicitly check both types and return the third one according to the relation shown at the beginning of this example.</li> <li>The cases above should be exhaustive, so if we reach this point, there's a bug in our logic.</li> </ol> <p>The method rewriting a multiplication with a number is rather straightforward. We simply return the same Pauli matrix, but with an updated pre-factor. To obtain the constructor from the expression we simply use e.g. <code>type(rhs)</code>.</p> <p>The second method, which rewrites products of Pauli matrices, is a bit more interesting. We have to cover a number of cases for the different types we can encounter and rewrite things accordingly.</p> <p>Finally, let's put our rewriter to the test. We create another decorator for our dialect, adding in a rewrite pass that walks through our expression tree and rewrites according to the rule defined above.</p> <pre><code>from kirin.rewrite import Walk\n\n\n@ir.dialect_group(basic_no_opt.add(dialect=dialect))\ndef pauli_mul_opt(self):\n    def run_pass(mt):\n        Walk(RewritePauliMult()).rewrite(mt.code)\n\n    return run_pass\n\n\n@pauli_mul_opt\ndef advanced_example():\n    x = 2*X()\n    y = Y()\n    z = x * y\n    return z\n\n\nadvanced_example.print()\n</code></pre> <p>Success! Looking at the IR that is printed out by the last line,</p> <pre><code>func.func advanced_example() -&gt; !Any {\n  ^0(%advanced_example_self):\n  \u2502 %0 = py.constant.constant 2 : !py.int\n  \u2502 %1 = pauli.x(){pre_factor=1 : !py.Number} : !py.matrix\n  \u2502 %x = pauli.x(){pre_factor=2 : !py.Number} : !py.matrix\n  \u2502 %y = pauli.y(){pre_factor=1 : !py.Number} : !py.matrix\n  \u2502 %z = pauli.z(){pre_factor=2j : !py.Number} : !py.matrix\n  \u2502      func.return %z\n} // func.func advanced_example\n</code></pre> <p>we see that the return value assigned in the second-to-last line, <code>%z</code>, is rewritten as an instance of a <code>Z</code> operator statement of our dialect. Actually, since the rewriting pass is now smart enough to figure out how to rewrite the expressions, the rest of SSA values that are assigned are no longer needed.</p> <p>We can use a <code>Fold</code> in order to get rid of those.</p> <pre><code>from kirin.passes import Fold\n\n\n@ir.dialect_group(basic_no_opt.add(dialect=dialect))\ndef pauli_mul_opt_fold(self):\n    fold_pass = Fold(self)\n\n    def run_pass(mt):\n        Walk(RewritePauliMult()).rewrite(mt.code)\n        fold_pass(mt)  # (1)!\n\n    return run_pass\n\n\n@pauli_mul_opt_fold\ndef advanced_example_fold():\n    x = 2*X()\n    y = Y()\n    z = x * y\n    return z\n\n\nadvanced_example_fold.print()\n</code></pre> <ol> <li>Make sure to run the folding pass after the rewrite.</li> </ol> <p>The resulting IR is</p> <pre><code>func.func advanced_example_fold() -&gt; !Any {\n  ^0(%advanced_example_fold_self):\n  \u2502 %z = pauli.z(){pre_factor=2j : !py.Number} : !py.matrix\n  \u2502      func.return %z\n} // func.func advanced_example_fold\n</code></pre> <p>Fantastic! Our entire function now got rewritten to a single statement. Just adding the pre-defined <code>Fold</code> pass gave us constant folding for free. This nicely illustrates how powerful the composability of passes is in kirin.</p> <p>Even better, since the IR is first written in SSA form and all multiplications are only binary operators, our rewriter already works for arbitrarily long chains of multiplications.</p> <pre><code>@pauli_mul_opt_fold\ndef nested_multiplication_example():\n    return 7 * X() * Y() * Y() * Z() * X() * Z()\n\n\nnested_multiplication_example.print()\n</code></pre> <p>The resulting IR is again a function that simply instantiates a single Pauli matrix:</p> <pre><code>func.func nested_multiplication_example() -&gt; !Any {\n  ^0(%nested_multiplication_example_self):\n  \u2502 %0 = pauli.id(){pre_factor=(-7+0j) : !py.Number} : !py.matrix\n  \u2502      func.return %0\n} // func.func nested_multiplication_example\n</code></pre> <p>To see how the IR is first written in SSA form, assigning values line-by-line for intermediary steps, turn off folding by using the <code>@pauli_mul_opt</code> decorator for the function instead.</p> <p>Okay, so this is pretty cool, but the code we used so far isn't very involved. Now, let's see what happens if use an addition inside a multiplcation.</p> <pre><code>@pauli_mul_opt_fold\ndef addition_example():\n    z = (X() + Y()) * Y()\n    return z\n\naddition_example.print()\n</code></pre> <p>Here's the resulting IR:</p> <pre><code>func.func addition_example() -&gt; !Any {\n  ^0(%addition_example_self):\n  \u2502 %0 = pauli.x(){pre_factor=1 : !py.Number} : !py.matrix\n  \u2502 %1 = pauli.y(){pre_factor=1 : !py.Number} : !py.matrix\n  \u2502 %2 = py.binop.add(%0, %1) : ~T\n  \u2502 %3 = pauli.y(){pre_factor=1 : !py.Number} : !py.matrix\n  \u2502 %z = py.binop.mult(%2, %3) : ~T\n  \u2502      func.return %z\n} // func.func addition_example\n</code></pre> <p>Oh no! It seems our rewriting rule did nothing here. That's because it doesn't know how to deal with a multiplication containing an addition, which is the value assigned to <code>%z</code> in the IR. Subsequently, there are also no constants to be folded in the end. We'll see how to extend our Pauli DSL in order to deal with this.</p>"},{"location":"cookbook/paulilang/pauli/#chaining-rewriters","title":"Chaining rewriters","text":"<p>We could deal with the issue we're facing by adding another <code>if</code> branch in our <code>RewritePauliMult.rewrite_Statement</code> method above. However, we might later want to enhance it further and at some point the implementation will get quite messy.</p> <p>Also, we can take a step back and think about what we actually want to have here: Basically, all we'd need is to rewrite the addition using distribution, i.e. \\((a + b) c = ac + bc\\). Then, the multiplication rewriter we already have could work it's magic on the multiplication instances. This rewriting of a multiplication containing additions has nothing to do with Pauli matrices, though. It's something more general, so it makes sense to separate this rewriting logic.</p> <p>In this section, we'll implement another rewriting rule that distributes multiplications containing additions and then add this to our dialect such that both rewriting rules are applied.</p> <p>We start out by defining the rewriter. The basic principle is the same as before.</p> <pre><code>@dataclass\nclass RewriteDistributeMult(abc.RewriteRule):\n    def rewrite_Statement(self, node: ir.Statement) -&gt; result.RewriteResult:\n        if not isinstance(node, py.binop.Mult):  # (1)!\n            return result.RewriteResult()\n\n        if isinstance(node.lhs.owner, py.binop.Add):  # (2)!\n            m1 = py.binop.Mult(node.lhs.owner.lhs, node.rhs)  # (3)!\n            m2 = py.binop.Mult(node.lhs.owner.rhs, node.rhs)\n\n            m1.insert_before(node)  # (4)!\n            m2.insert_before(node)\n\n            a = py.binop.Add(m1.result, m2.result)  # (5)!\n            node.replace_by(a)  # (6)!\n            return result.RewriteResult(has_done_something=True)\n\n        if isinstance(node.rhs.owner, py.binop.Add):\n            m1 = py.binop.Mult(node.lhs, node.rhs.owner.lhs)\n            m2 = py.binop.Mult(node.lhs, node.rhs.owner.rhs)\n\n            m1.insert_before(node)\n            m2.insert_before(node)\n\n            a = py.binop.Add(m1.result, m2.result)\n            node.replace_by(a)\n            return result.RewriteResult(has_done_something=True)\n\n        return result.RewriteResult()\n</code></pre> <ol> <li>Again, we want to make sure we're looking at a multiplication.</li> <li>The left-hand-side argument of the multiplication is an addition in this case. Let's rewrite it.</li> <li>The addition is binary, so we define to multiplication instances that consist of the appropriate arguments. Note that the order here matters, since e.g. Pauli matrices don't commute.</li> <li>In order to replace our node by an addition of multiplications, we need to make sure the newly created multiplication statements are actually part of the current block. Also, they need to be injected before the node.</li> <li>Define the addition containing the multiplications.</li> <li>Replace the current node by the addition defined above.</li> </ol> <p>The rewriter just looks at two cases, where either one of the arguments to the multiplication is an addition. Now, let's define a DSL that uses both rewriting passes. To compose them, we'll use a <code>Chain</code> to create a rewriter that runs both rewrite passes.</p> <pre><code>from kirin.rewrite import Chain\n\n\n@ir.dialect_group(basic_no_opt.add(dialect=dialect))\ndef pauli_add(self):\n    fold_pass = Fold(self)\n\n    def run_pass(mt):\n        Walk(\n            Chain(RewriteDistributeMult(), RewritePauliMult())\n            ).rewrite(mt.code)\n        fold_pass(mt)\n\n    return run_pass\n</code></pre> <p>Great, let's try it out!</p> <pre><code>@pauli_add\ndef addition_that_kinda_works():\n    z = (X() + Y()) * Y()\n    return z\n\n\naddition_that_kinda_works.print()\n</code></pre> <p>From the resulting IR, we see that this kind of works:</p> <pre><code>func.func addition_that_kinda_works() -&gt; !Any {\n  ^0(%addition_that_kinda_works_self):\n  \u2502 %0 = pauli.x(){pre_factor=1 : !py.Number} : !py.matrix\n  \u2502 %1 = pauli.y(){pre_factor=1 : !py.Number} : !py.matrix\n  \u2502 %2 = pauli.y(){pre_factor=1 : !py.Number} : !py.matrix\n  \u2502 %3 = py.binop.mult(%0, %2) : ~T\n  \u2502 %4 = py.binop.mult(%1, %2) : ~T\n  \u2502 %z = py.binop.add(%3, %4) : ~T\n  \u2502      func.return %z\n} // func.func addition_that_kinda_works\n</code></pre> <p>The return value <code>%z</code> now is an addition containing the multiplication. So at least the rewriter we just implemented seems to work. However, the multiplication instances of Pauli matrices are not rewritten.</p> <p>The reason for this is that the rewrite pass tries to rewrite the multiplications first, which still contains the addition at the time. What we really want, however, is to run both passes over and over until no further simplifications are possible. This can be achieved by using a <code>Fixpoint</code>, which does exactly that.</p> <p>With that, let's finally define our complete <code>pauli</code> DSL.</p> <pre><code>from kirin.rewrite import Fixpoint\n\n\n@ir.dialect_group(basic_no_opt.add(dialect=dialect))\ndef pauli(self):\n    fold_pass = Fold(self)\n\n    def run_pass(mt):\n        Fixpoint(Walk(\n            Chain(RewriteDistributeMult(), RewritePauliMult())\n            )).rewrite(mt.code)\n        fold_pass(mt)\n\n    return run_pass\n</code></pre> <p>Note, that we need to make sure to wrap the <code>Walk</code> by the <code>Fixpoint</code>, since we are changing the structure of the IR and thus need to walk through the whole thing over and over.</p> <p>Now, let's try this out.</p> <pre><code>@pauli\ndef addition_that_works():\n    z = (X() + Y()) * Y()\n    return z\n\n\naddition_that_works.print()\n</code></pre> <p>And here's the result:</p> <pre><code>func.func addition_that_works() -&gt; !Any {\n  ^0(%addition_that_works_self):\n  \u2502 %0 = pauli.z(){pre_factor=1j : !py.Number} : !py.matrix\n  \u2502 %1 = pauli.id(){pre_factor=1 : !py.Number} : !py.matrix\n  \u2502 %z = py.binop.add(%0, %1) : ~T\n  \u2502      func.return %z\n} // func.func addition_that_works\n</code></pre> <p>Great, both rewriters now do their job as we'd expect. The resulting return value is an addition of just two Pauli matrices, each of which is the result of a rewritten multiplication.</p> <p>Using this, we can be sure that the actual number of matrix multiplications we need to perform in the end will be minimal, since they are rewritten at compile time.</p> <pre><code>@pauli\ndef cool_example():\n    x = X()\n    y = Y()\n    z = Z()\n    ex = 2*(x + y) * (z + y)\n    return ex\n\n\ncool_example.print()\n</code></pre> <p>As you can see from the IR,</p> <pre><code>func.func cool_example() -&gt; !Any {\n  ^0(%cool_example_self):\n  \u2502  %0 = pauli.y(){pre_factor=-2j : !py.Number} : !py.matrix\n  \u2502  %1 = pauli.z(){pre_factor=2j : !py.Number} : !py.matrix\n  \u2502  %2 = py.binop.add(%0, %1) : ~T\n  \u2502  %3 = pauli.x(){pre_factor=2j : !py.Number} : !py.matrix\n  \u2502  %4 = pauli.id(){pre_factor=2 : !py.Number} : !py.matrix\n  \u2502  %5 = py.binop.add(%3, %4) : ~T\n  \u2502 %ex = py.binop.add(%2, %5) : ~T\n  \u2502       func.return %ex\n} // func.func cool_example\n</code></pre> <p>the result here is just a number of additions containing other additions and Pauli matrices. That's it! Next, we'll see how we can actually run the code we're writing with our DSL.</p>"},{"location":"cookbook/paulilang/pauli/#method-implementation","title":"Method implementation","text":"<p>Before we can execute the code that is represented by the IR, we'll need to register methods for each statement to our dialect. This is done by defining a <code>MethodTable</code> and registering it to the dialect. Then, the interpreter knows how to deal with statements such as <code>X()</code>.</p> <p>As the typing of the <code>result</code> field suggests, we want each statement to return a <code>np.matrix</code>.</p> <pre><code>import numpy as np\n\nfrom kirin.interp import MethodTable, impl\n\n\n@dialect.register\nclass PauliMethods(MethodTable):\n    X_mat = np.array([[0, 1], [1, 0]])\n    Y_mat = np.array([[0, -1j], [1j, 0]])\n    Z_mat = np.array([[1, 0], [0, -1]])\n    Id_mat = np.array([[1, 0], [0, 1]])\n\n    @impl(X)  # (1)!\n    def x(self, interp, frame, stmt: X):\n        return (stmt.pre_factor * self.X_mat, )\n\n    @impl(Y)\n    def y(self, interp, frame, stmt: Y):\n        return (self.Y_mat * stmt.pre_factor, )\n\n    @impl(Z)\n    def z(self, interp, frame, stmt: Z):\n        return (self.Z_mat * stmt.pre_factor, )\n\n    @impl(Id)\n    def id(self, interp, frame, stmt: Id):\n        return (self.Id_mat * stmt.pre_factor, )\n\n\n\nprint(cool_example())  # (2)!\n</code></pre> <ol> <li>Register an implementation for the statement <code>X()</code>.</li> <li>Notice that we are actually calling the function this time.</li> </ol> <p>And, sure enough, when running the code, we now obtain a \\(2x2\\) matrix:</p> <pre><code>[[ 2.+2.j -2.+2.j]\n [ 2.+2.j  2.-2.j]]\n</code></pre> <p>Also, now that the method table is registered to the dialect, constant folding can really work its magic. To see that, let's define another function and look at its IR. Note, that it wouldn't work the same for any function defined so far, since they were defined before the methods were registered to the dialect.</p> <pre><code>@pauli\ndef the_coolest_example():\n    ex = (X() + 2*Y()) * Z()\n    return ex\n\nthe_coolest_example.print()\n</code></pre> <p>And now, check out the IR:</p> <pre><code>func.func the_coolest_example() -&gt; !Any {\n  ^0(%the_coolest_example_self):\n  \u2502 %ex = py.constant.constant array([[ 0.+0.j, -1.+2.j],\n       [ 1.+2.j,  0.+0.j]]) : !py.ndarray\n  \u2502       func.return %ex\n} // func.func the_coolest_example\n</code></pre> <p>Well, look at this. No additions or multiplications left, the function is just returning a single matrix. This is because the constant folding pass uses the fact that all of the statements are pure. Then, it invokes the actual methods and resolves additions of matrices. So everything is evaluated at compile time. That's neat! And we got all of that basically for free, just by providing methods. Amazing.</p> <p>But, wait: if constant folding can evaluate additions, couldn't it also evaluate multiplications? Wouldn't the make our multiplication rewrite pass obsolete? Sort of: this would mean that you still evaluate a whole bunch of matrix products, just at compile time rather than at runtime. Our rewriting pass, instead uses a symbolic approach to rewrite multiplications without the need to actually evaluate a matrix multiplication. Of course, since we are talking about 2x2 matrices only, the difference won't be very large. However, this is just an example to illustrate how to do something like this.</p>"},{"location":"dialects/cf/","title":"Control Flow","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"dialects/cf/#the-control-flow-dialect","title":"The Control Flow Dialect","text":"<p>The control flow dialect provides the most generic control flow semantics via <code>cf.Branch</code> and <code>cf.ConditionalBranch</code>.</p>"},{"location":"dialects/cf/#cfbranch","title":"<code>cf.Branch</code>","text":"<p>the <code>cf.Branch</code> statement is used to mark how basic block branches to another basic block without condition. This represents an edge on the control flow graph (CFG).</p> <pre><code>^1(%2):\n  \u2502   %y = py.constant.constant 1 : !py.int\n  \u2502        cf.br ^3(%y)\n  ^2(%3):\n  \u2502 %y_1 = py.constant.constant 2 : !py.int\n  \u2502        cf.br ^3(%y_1)\n  ^3(%y_2):\n  \u2502        func.return %y_2\n</code></pre> <p>Definition the <code>cf.Branch</code> statement takes a successor block and its argument. The <code>cf.Branch</code> is a terminator thus it should always be the last statement of a block.</p> <p>Note</p> <p><code>ir.Statement</code> does not own any <code>ir.Block</code>, the <code>ir.Region</code> owns blocks. The <code>ir.Statement</code> will only own <code>ir.Region</code>. In Kirin, we use similar design as LLVM/MLIR where the phi nodes in SSA form are replaced by block arguments.</p>"},{"location":"dialects/cf/#cfconditionalbranch","title":"<code>cf.ConditionalBranch</code>","text":"<p>The <code>cf.ConditionalBranch</code> statement represents a conditional branching statement that looks like following (the <code>cf.cond_br</code> statement):</p> <pre><code>^0(%main_self, %x):\n\u2502   %0 = py.constant.constant 1 : !py.int\n\u2502   %1 = py.cmp.gt(lhs=%x, rhs=%0) : !py.bool\n\u2502        cf.cond_br %1 goto ^1(%1) else ^2(%1)\n</code></pre> <p>Definition, <code>cf.ConditionalBranch</code> takes a boolean condition <code>cond</code> of type <code>ir.SSAValue</code> and:</p> <ul> <li>then successor and its argument</li> <li>else successor and its argument</li> </ul> <p>this statement is also a terminator, which means it must be the last statement of a block.</p>"},{"location":"dialects/cf/#combining-together-lowering-from-python","title":"Combining together - lowering from Python","text":"<p>Now combining these two statemente together, we can represent most of the Python control flows, e.g <code>if-else</code> and <code>for</code>-loops. These two statement basically just provides a basic way describing the edges on a control flow graph (CFG) by assuming the node only has one or two outgoing edges.</p> <p>As an example, the following Python program:</p> <pre><code>from kirin.prelude import basic_no_opt\n\n@basic_no_opt\ndef main(x):\n    if x &gt; 1:\n        y = 1\n    else:\n        y = 2\n    return y\n</code></pre> <p>will be lowered to the following SSA form in <code>cf</code> dialect:</p> <pre><code>func.func main(!Any) -&gt; !Any {\n  ^0(%main_self, %x):\n  \u2502   %0 = py.constant.constant 1 : !py.int\n  \u2502   %1 = py.cmp.gt(lhs=%x, rhs=%0) : !py.bool\n  \u2502        cf.cond_br %1 goto ^1(%1) else ^2(%1)\n  ^1(%2):\n  \u2502   %y = py.constant.constant 1 : !py.int\n  \u2502        cf.br ^3(%y)\n  ^2(%3):\n  \u2502 %y_1 = py.constant.constant 2 : !py.int\n  \u2502        cf.br ^3(%y_1)\n  ^3(%y_2):\n  \u2502        func.return %y_2\n} // func.func main\n</code></pre> <p>And similarly, we can lower a <code>for</code>-loop into the <code>cf</code> dialect:</p> <pre><code>@basic_no_opt\ndef main(x):\n    for i in range(5):\n        x = x + i\n    return x\n</code></pre> <p>will be lowered into the following SSA form:</p> <pre><code>func.func main(!Any) -&gt; !Any {\n  ^0(%main_self, %x_1):\n  \u2502 %0 = py.constant.constant 0 : !py.int\n  \u2502 %1 = py.constant.constant 5 : !py.int\n  \u2502 %2 = py.constant.constant 1 : !py.int\n  \u2502 %3 = py.range.range(start=%0, stop=%1, step=%2) : !py.range\n  \u2502 %4 = py.iterable.iter(value=%3) : !Any\n  \u2502 %5 = py.constant.constant None : !py.NoneType\n  \u2502 %6 = py.iterable.next(iter=%4) : !Any\n  \u2502 %7 = py.cmp.is(lhs=%6, rhs=%5) : !py.bool\n  \u2502      cf.cond_br %7 goto ^2(%x_1) else ^1(%6, %x_1)\n  ^1(%i, %x_2):\n  \u2502 %x = py.binop.add(%x_2, %i) : ~T\n  \u2502 %8 = py.iterable.next(iter=%4) : !Any\n  \u2502 %9 = py.cmp.is(lhs=%8, rhs=%5) : !py.bool\n  \u2502      cf.cond_br %9 goto ^2(%x) else ^1(%8, %x)\n  ^2(%x_3):\n  \u2502      func.return %x_3\n} // func.func main\n</code></pre> <p>However, as you may already notice, lowering from Python directly to <code>cf</code> dialect will lose some of the high-level information such as the control flow is actually a for-loop. This information can be useful when one wants to perform some optimization. This is why we are taking the same route as MLIR with a structural IR (via <code>ir.Region</code>s). For the interested readers, please proceed to Structural Control Flow for further reading.</p>"},{"location":"dialects/cf/#api-reference","title":"API Reference","text":""},{"location":"dialects/cf/#kirin.dialects.cf.stmts.Branch","title":"Branch  <code>kirin-statement</code>","text":"<pre><code>Branch(*, successor: ir.Block)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/cf/#kirin.dialects.cf.stmts.Branch.arguments","title":"arguments  <code>instance-attribute</code>","text":"<pre><code>arguments: tuple[SSAValue, ...]\n</code></pre>"},{"location":"dialects/cf/#kirin.dialects.cf.stmts.Branch.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'br'\n</code></pre>"},{"location":"dialects/cf/#kirin.dialects.cf.stmts.Branch.successor","title":"successor  <code>kirin-block</code> <code>kw-only</code>","text":"<pre><code>successor: Block = block()\n</code></pre>"},{"location":"dialects/cf/#kirin.dialects.cf.stmts.Branch.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({IsTerminator()})\n</code></pre>"},{"location":"dialects/cf/#kirin.dialects.cf.stmts.Branch.print_impl","title":"print_impl","text":"<pre><code>print_impl(printer: Printer) -&gt; None\n</code></pre> Source code in <code>src/kirin/dialects/cf/stmts.py</code> <pre><code>def print_impl(self, printer: Printer) -&gt; None:\n    with printer.rich(style=\"keyword\"):\n        printer.print_name(self)\n\n    printer.plain_print(\" \")\n    printer.plain_print(printer.state.block_id[self.successor])\n    printer.print_seq(\n        self.arguments,\n        delim=\", \",\n        prefix=\"(\",\n        suffix=\")\",\n    )\n</code></pre>"},{"location":"dialects/cf/#kirin.dialects.cf.stmts.Branch.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>run mandatory validation checks. This is not same as verify_type, which may be optional.</p> Source code in <code>src/kirin/dialects/cf/stmts.py</code> <pre><code>def verify(self) -&gt; None:\n    return\n</code></pre>"},{"location":"dialects/cf/#kirin.dialects.cf.stmts.ConditionalBranch","title":"ConditionalBranch  <code>kirin-statement</code>","text":"<pre><code>ConditionalBranch(\n    cond: ir.SSAValue,\n    *,\n    then_successor: ir.Block,\n    else_successor: ir.Block\n)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/cf/#kirin.dialects.cf.stmts.ConditionalBranch.cond","title":"cond  <code>kirin-argument</code>","text":"<pre><code>cond: SSAValue = argument(Bool)\n</code></pre>"},{"location":"dialects/cf/#kirin.dialects.cf.stmts.ConditionalBranch.else_arguments","title":"else_arguments  <code>instance-attribute</code>","text":"<pre><code>else_arguments: tuple[SSAValue, ...]\n</code></pre>"},{"location":"dialects/cf/#kirin.dialects.cf.stmts.ConditionalBranch.else_successor","title":"else_successor  <code>kirin-block</code> <code>kw-only</code>","text":"<pre><code>else_successor: Block = block()\n</code></pre>"},{"location":"dialects/cf/#kirin.dialects.cf.stmts.ConditionalBranch.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'cond_br'\n</code></pre>"},{"location":"dialects/cf/#kirin.dialects.cf.stmts.ConditionalBranch.then_arguments","title":"then_arguments  <code>instance-attribute</code>","text":"<pre><code>then_arguments: tuple[SSAValue, ...]\n</code></pre>"},{"location":"dialects/cf/#kirin.dialects.cf.stmts.ConditionalBranch.then_successor","title":"then_successor  <code>kirin-block</code> <code>kw-only</code>","text":"<pre><code>then_successor: Block = block()\n</code></pre>"},{"location":"dialects/cf/#kirin.dialects.cf.stmts.ConditionalBranch.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({IsTerminator()})\n</code></pre>"},{"location":"dialects/cf/#kirin.dialects.cf.stmts.ConditionalBranch.print_impl","title":"print_impl","text":"<pre><code>print_impl(printer: Printer) -&gt; None\n</code></pre> Source code in <code>src/kirin/dialects/cf/stmts.py</code> <pre><code>def print_impl(self, printer: Printer) -&gt; None:\n    with printer.rich(style=\"keyword\"):\n        printer.print_name(self)\n\n    printer.plain_print(\" \")\n    printer.print(self.cond)\n\n    with printer.rich(style=\"keyword\"):\n        printer.plain_print(\" goto \")\n\n    printer.plain_print(printer.state.block_id[self.then_successor])\n    printer.plain_print(\"(\")\n    printer.print_seq(self.then_arguments, delim=\", \")\n    printer.plain_print(\")\")\n\n    with printer.rich(style=\"keyword\"):\n        printer.plain_print(\" else \")\n\n    printer.plain_print(printer.state.block_id[self.else_successor])\n    printer.plain_print(\"(\")\n    printer.print_seq(self.else_arguments, delim=\", \")\n    printer.plain_print(\")\")\n</code></pre>"},{"location":"dialects/cf/#kirin.dialects.cf.stmts.ConditionalBranch.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>run mandatory validation checks. This is not same as verify_type, which may be optional.</p> Source code in <code>src/kirin/dialects/cf/stmts.py</code> <pre><code>def verify(self) -&gt; None:\n    return\n</code></pre>"},{"location":"dialects/func/","title":"Function","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"dialects/func/#the-function-dialect","title":"The Function Dialect","text":"<p>The function dialect provides a set of statements to model semantics of Python-like functions, that means:</p> <ul> <li><code>def &lt;name&gt;(&lt;args&gt;*, &lt;kwargs&gt;*)</code> like function declarations</li> <li>nested functions (namely closures)</li> <li>high-order functions (functions can be used as arguments)</li> <li>dynamically/statically calling a function or closure</li> </ul>"},{"location":"dialects/func/#funcreturn","title":"<code>func.Return</code>","text":"<p>This is a simple statement that models the <code>return</code> statement in a function declaration. While this is a very simple statement, it is worth noting that this statement only accepts one argument of type ir.SSAValue because in Python (and most of other languages) functions always have a single return value, and multiple return values are represented by returning a <code>tuple</code>.</p>"},{"location":"dialects/func/#funcfunction","title":"<code>func.Function</code>","text":"<p>This is the most fundamental statement that models a Python function.</p> <p>Definition The <code>func.Function</code> takes no arguments, but contains a special <code>str</code> attribute (thus stored as <code>PyAttr</code>) that can be used as a symbolic reference within a symbol table. The <code>func.Function</code> also takes a <code>func.Signature</code> attribute to store the signature of corresponding function declaration. Last, it contains a <code>ir.Region</code> that represents the function body. The <code>ir.Region</code> follows the SSACFG convention where the blocks in the region forms a control flow graph.</p> <p>Differences with MLIR</p> <p>As Kirin's priority is writing eDSL as kernel functions in Python. To support high-order functions the entry block arguments always have their first argument <code>self</code> of type <code>types.MethodType</code>. This is a design inspired by Julia's IR design.</p> <p>As an example, the following Python function</p> <pre><code>from kirin.prelude import basic_no_opt\n\n@basic_no_opt\ndef main(x):\n    return x\n</code></pre> <p>will be lowered into the following IR, where <code>main_self</code> referencing the function itself.</p> <pre><code>func.func main(!Any) -&gt; !Any {\n  ^0(%main_self, %x):\n  \u2502 func.return %x\n} // func.func main\n</code></pre> <p>the function can be terminated by a <code>func.Return</code> statement. All blocks in the function region must have terminators. In the lowering process, if the block is not terminated, a <code>func.Return</code> will be attached to return <code>None</code> in the function body. Thus <code>func.Function</code> can only have a single return value.</p>"},{"location":"dialects/func/#funccall-and-funcinvoke","title":"<code>func.Call</code> and <code>func.Invoke</code>","text":"<p>These two statements models the most common call convention in Python with consideration of compilation:</p> <ul> <li><code>func.Call</code> models dynamic calls where the callee is unknown at compile time, thus of type <code>ir.SSAValue</code></li> <li><code>func.Invoke</code> models static calls where the callee is known at compile time, thus of type <code>ir.Method</code></li> </ul> <p>they both take <code>inputs</code> which is a tuple of <code>ir.SSAValue</code> as argument. Because we assume all functions will only return a single value, <code>func.Call</code> and <code>func.Invoke</code> only have a single result.</p>"},{"location":"dialects/func/#funclambda","title":"<code>func.Lambda</code>","text":"<p>This statement models nested functions (a.k.a closures). While most definitions are similar to <code>func.Function</code> the key difference is <code>func.Lambda</code> takes a tuple of <code>ir.SSAValue</code> arguments as <code>captured</code>. This models the captured variables for a nested function, e.g</p> <p>the following Python function containing a closure inside with variable <code>x</code> being captured:</p> <pre><code>from kirin import basic_no_opt\n\n@basic_no_opt\ndef main(x):\n    def closure():\n        return x\n    return closure\n</code></pre> <p>will be lowered into</p> <pre><code>func.func main(!Any) -&gt; !Any {\n  ^0(%main_self, %x):\n  \u2502 %closure = func.lambda closure(%x) -&gt; !Any {\n  \u2502            \u2502 ^1(%closure_self):\n  \u2502            \u2502 \u2502 %x_1 = func.getfield(%closure_self, 0) : !Any\n  \u2502            \u2502 \u2502        func.return %x_1\n  \u2502            } // func.lambda closure\n  \u2502            func.return %closure\n} // func.func main\n</code></pre> <p>Unlike <code>func.Function</code> this statement also has a result value which points to the closure itself. Inside the closure body, we insert <code>func.GetField</code> to unpack captured variables into the closure body.</p>"},{"location":"dialects/func/#api-reference","title":"API Reference","text":""},{"location":"dialects/func/#kirin.dialects.func.stmts.Call","title":"Call  <code>kirin-statement</code>","text":"<pre><code>Call(\n    callee: ir.SSAValue,\n    inputs: tuple[ir.SSAValue, ...],\n    *,\n    kwargs: tuple[str, ...] = (),\n    purity: bool\n)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Call.callee","title":"callee  <code>kirin-argument</code>","text":"<pre><code>callee: SSAValue = argument()\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Call.inputs","title":"inputs  <code>kirin-argument</code>","text":"<pre><code>inputs: tuple[SSAValue, ...] = argument()\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Call.kwargs","title":"kwargs  <code>kirin-attribute</code> <code>kw-only</code>","text":"<pre><code>kwargs: tuple[str, ...] = attribute(\n    default_factory=lambda: ()\n)\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Call.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'call'\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Call.purity","title":"purity  <code>kirin-attribute</code> <code>kw-only</code>","text":"<pre><code>purity: bool = attribute(default=False)\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Call.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result()\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Call.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({MaybePure()})\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Call.check_type","title":"check_type","text":"<pre><code>check_type() -&gt; None\n</code></pre> <p>Check the types of the Block. Raises <code>Exception</code> if the types are not correct. This method is called by the <code>verify_type</code> method, which will detect the source of the error in the IR. One should always call the <code>verify_type</code> method to verify the types of the IR.</p> Note <p>This method is generated by the <code>@statement</code> decorator. But can be overridden if needed.</p> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>def check_type(self) -&gt; None:\n    if not self.callee.type.is_subseteq(types.MethodType):\n        if self.callee.type.is_subseteq(types.PyClass(FunctionType)):\n            raise ir.TypeCheckError(\n                self,\n                f\"callee must be a method type, got {self.callee.type}\",\n                help=\"did you call a Python function directly? \"\n                \"consider decorating it with kernel decorator\",\n            )\n\n        if self.callee.type.is_subseteq(types.PyClass(ClassMethodType)):\n            raise ir.TypeCheckError(\n                self,\n                \"callee must be a method type, got class method\",\n                help=\"did you try to call a Python class method within a kernel? \"\n                \"consider rewriting it with a captured variable instead of calling it inside the kernel\",\n            )\n\n        if self.callee.type is types.Any:\n            return\n        raise ir.TypeCheckError(\n            self,\n            f\"callee must be a method type, got {self.callee.type}\",\n            help=\"did you forget to decorate the function with kernel decorator?\",\n        )\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Call.print_impl","title":"print_impl","text":"<pre><code>print_impl(printer: Printer) -&gt; None\n</code></pre> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>def print_impl(self, printer: Printer) -&gt; None:\n    pprint_calllike(self, printer.state.ssa_id[self.callee], printer)\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.ConstantNone","title":"ConstantNone  <code>kirin-statement</code>","text":"<pre><code>ConstantNone()\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>A constant None value.</p> <p>This is mainly used to represent the None return value of a function to match Python semantics.</p>"},{"location":"dialects/func/#kirin.dialects.func.stmts.ConstantNone.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'const.none'\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.ConstantNone.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(NoneType)\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.ConstantNone.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({Pure(), ConstantLike()})\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.FuncOpCallableInterface","title":"FuncOpCallableInterface  <code>dataclass</code>","text":"<pre><code>FuncOpCallableInterface()\n</code></pre> <p>               Bases: <code>CallableStmtInterface['Function']</code></p>"},{"location":"dialects/func/#kirin.dialects.func.stmts.FuncOpCallableInterface.get_callable_region","title":"get_callable_region  <code>classmethod</code>","text":"<pre><code>get_callable_region(stmt: Function) -&gt; ir.Region\n</code></pre> <p>Returns the body of the callable region</p> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>@classmethod\ndef get_callable_region(cls, stmt: \"Function\") -&gt; ir.Region:\n    return stmt.body\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Function","title":"Function  <code>kirin-statement</code>","text":"<pre><code>Function(\n    *, sym_name: str, signature: Signature, body: ir.Region\n)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Function.body","title":"body  <code>kirin-region</code> <code>kw-only</code>","text":"<pre><code>body: Region = region(multi=True)\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Function.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'func'\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Function.signature","title":"signature  <code>kirin-attribute</code> <code>kw-only</code>","text":"<pre><code>signature: Signature = attribute()\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Function.sym_name","title":"sym_name  <code>kirin-attribute</code> <code>kw-only</code>","text":"<pre><code>sym_name: str = attribute()\n</code></pre> <p>The symbol name of the function.</p>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Function.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset(\n    {\n        IsolatedFromAbove(),\n        SymbolOpInterface(),\n        HasSignature(),\n        FuncOpCallableInterface(),\n        SSACFGRegion(),\n    }\n)\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Function.print_impl","title":"print_impl","text":"<pre><code>print_impl(printer: Printer) -&gt; None\n</code></pre> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>def print_impl(self, printer: Printer) -&gt; None:\n    with printer.rich(style=\"keyword\"):\n        printer.print_name(self)\n        printer.plain_print(\" \")\n\n    with printer.rich(style=\"symbol\"):\n        printer.plain_print(self.sym_name)\n\n    printer.print_seq(self.signature.inputs, prefix=\"(\", suffix=\")\", delim=\", \")\n\n    with printer.rich(style=\"comment\"):\n        printer.plain_print(\" -&gt; \")\n        printer.print(self.signature.output)\n        printer.plain_print(\" \")\n\n    printer.print(self.body)\n\n    with printer.rich(style=\"comment\"):\n        printer.plain_print(f\" // func.func {self.sym_name}\")\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.GetField","title":"GetField  <code>kirin-statement</code>","text":"<pre><code>GetField(obj: ir.SSAValue, *, field: int)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/func/#kirin.dialects.func.stmts.GetField.field","title":"field  <code>kirin-attribute</code> <code>kw-only</code>","text":"<pre><code>field: int = attribute()\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.GetField.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'getfield'\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.GetField.obj","title":"obj  <code>kirin-argument</code>","text":"<pre><code>obj: SSAValue = argument(MethodType)\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.GetField.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(init=False)\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.GetField.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({Pure()})\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.GetField.print_impl","title":"print_impl","text":"<pre><code>print_impl(printer: Printer) -&gt; None\n</code></pre> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>def print_impl(self, printer: Printer) -&gt; None:\n    printer.print_name(self)\n    printer.plain_print(\n        \"(\", printer.state.ssa_id[self.obj], \", \", str(self.field), \")\"\n    )\n    with printer.rich(style=\"black\"):\n        printer.plain_print(\" : \")\n        printer.print(self.result.type)\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Invoke","title":"Invoke  <code>kirin-statement</code>","text":"<pre><code>Invoke(\n    inputs: tuple[ir.SSAValue, ...],\n    *,\n    callee: ir.Method,\n    kwargs: tuple[str, ...],\n    purity: bool\n)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Invoke.callee","title":"callee  <code>kirin-attribute</code> <code>kw-only</code>","text":"<pre><code>callee: Method = attribute()\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Invoke.inputs","title":"inputs  <code>kirin-argument</code>","text":"<pre><code>inputs: tuple[SSAValue, ...] = argument()\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Invoke.kwargs","title":"kwargs  <code>kirin-attribute</code> <code>kw-only</code>","text":"<pre><code>kwargs: tuple[str, ...] = attribute()\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Invoke.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'invoke'\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Invoke.purity","title":"purity  <code>kirin-attribute</code> <code>kw-only</code>","text":"<pre><code>purity: bool = attribute(default=False)\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Invoke.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result()\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Invoke.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({MaybePure()})\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Invoke.check","title":"check","text":"<pre><code>check() -&gt; None\n</code></pre> <p>Check the statement. Raises <code>Exception</code> if the statement is not correct. This method is called by the <code>verify</code> method, which will detect the source of the error in the IR. One should always call the <code>verify</code> method to verify the IR.</p> <p>The difference between <code>check</code> and <code>check_type</code> is that <code>check</code> is called at any time to check the structure of the IR by <code>verify</code>, while <code>check_type</code> is called after the type inference to check the types of the IR.</p> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>def check(self) -&gt; None:\n    if self.kwargs:\n        for name in self.kwargs:\n            assert (\n                name in self.callee.arg_names\n            ), f\"method {self.callee.sym_name} does not have argument {name}\"\n    elif len(self.callee.arg_names) - 1 != len(self.args):\n        raise ValueError(\n            f\"expected {len(self.callee.arg_names)} arguments, got {len(self.args)}\"\n        )\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Invoke.print_impl","title":"print_impl","text":"<pre><code>print_impl(printer: Printer) -&gt; None\n</code></pre> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>def print_impl(self, printer: Printer) -&gt; None:\n    pprint_calllike(self, self.callee.sym_name, printer)\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Lambda","title":"Lambda  <code>kirin-statement</code>","text":"<pre><code>Lambda(\n    captured: tuple[ir.SSAValue, ...],\n    *,\n    sym_name: str,\n    signature: Signature,\n    body: ir.Region\n)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Lambda.body","title":"body  <code>kirin-region</code> <code>kw-only</code>","text":"<pre><code>body: Region = region(multi=True)\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Lambda.captured","title":"captured  <code>kirin-argument</code>","text":"<pre><code>captured: tuple[SSAValue, ...] = argument()\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Lambda.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'lambda'\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Lambda.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(MethodType)\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Lambda.signature","title":"signature  <code>kirin-attribute</code> <code>kw-only</code>","text":"<pre><code>signature: Signature = attribute()\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Lambda.sym_name","title":"sym_name  <code>kirin-attribute</code> <code>kw-only</code>","text":"<pre><code>sym_name: str = attribute()\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Lambda.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset(\n    {\n        Pure(),\n        HasSignature(),\n        SymbolOpInterface(),\n        FuncOpCallableInterface(),\n        SSACFGRegion(),\n    }\n)\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Lambda.check","title":"check","text":"<pre><code>check() -&gt; None\n</code></pre> <p>Check the statement. Raises <code>Exception</code> if the statement is not correct. This method is called by the <code>verify</code> method, which will detect the source of the error in the IR. One should always call the <code>verify</code> method to verify the IR.</p> <p>The difference between <code>check</code> and <code>check_type</code> is that <code>check</code> is called at any time to check the structure of the IR by <code>verify</code>, while <code>check_type</code> is called after the type inference to check the types of the IR.</p> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>def check(self) -&gt; None:\n    assert self.body.blocks, \"lambda body must not be empty\"\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Lambda.print_impl","title":"print_impl","text":"<pre><code>print_impl(printer: Printer) -&gt; None\n</code></pre> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>def print_impl(self, printer: Printer) -&gt; None:\n    with printer.rich(style=\"keyword\"):\n        printer.print_name(self)\n    printer.plain_print(\" \")\n\n    with printer.rich(style=\"symbol\"):\n        printer.plain_print(self.sym_name)\n\n    printer.print_seq(self.captured, prefix=\"(\", suffix=\")\", delim=\", \")\n\n    with printer.rich(style=\"bright_black\"):\n        printer.plain_print(\" -&gt; \")\n        printer.print(self.signature.output)\n\n    printer.plain_print(\" \")\n    printer.print(self.body)\n\n    with printer.rich(style=\"black\"):\n        printer.plain_print(f\" // func.lambda {self.sym_name}\")\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Return","title":"Return  <code>kirin-statement</code>","text":"<pre><code>Return(\n    value_or_stmt: ir.SSAValue | ir.Statement | None = None,\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>def __init__(self, value_or_stmt: ir.SSAValue | ir.Statement | None = None) -&gt; None:\n    if isinstance(value_or_stmt, ir.SSAValue):\n        args = [value_or_stmt]\n    elif isinstance(value_or_stmt, ir.Statement):\n        if len(value_or_stmt._results) == 1:\n            args = [value_or_stmt._results[0]]\n        else:\n            raise ValueError(\n                f\"expected a single result, got {len(value_or_stmt._results)} results from {value_or_stmt.name}\"\n            )\n    elif value_or_stmt is None:\n        args = []\n    else:\n        raise ValueError(f\"expected SSAValue or Statement, got {value_or_stmt}\")\n\n    super().__init__(args=args, args_slice={\"value\": 0})\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Return.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'return'\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Return.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({IsTerminator(), HasParent((Function,))})\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Return.value","title":"value  <code>kirin-argument</code>","text":"<pre><code>value: SSAValue = argument()\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Return.check","title":"check","text":"<pre><code>check() -&gt; None\n</code></pre> <p>Check the statement. Raises <code>Exception</code> if the statement is not correct. This method is called by the <code>verify</code> method, which will detect the source of the error in the IR. One should always call the <code>verify</code> method to verify the IR.</p> <p>The difference between <code>check</code> and <code>check_type</code> is that <code>check</code> is called at any time to check the structure of the IR by <code>verify</code>, while <code>check_type</code> is called after the type inference to check the types of the IR.</p> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>def check(self) -&gt; None:\n    assert self.args, \"return statement must have at least one value\"\n    assert len(self.args) &lt;= 1, (\n        \"return statement must have at most one value\"\n        \", wrap multiple values in a tuple\"\n    )\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Return.print_impl","title":"print_impl","text":"<pre><code>print_impl(printer: Printer) -&gt; None\n</code></pre> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>def print_impl(self, printer: Printer) -&gt; None:\n    with printer.rich(style=\"keyword\"):\n        printer.print_name(self)\n\n    if self.args:\n        printer.plain_print(\" \")\n        printer.print_seq(self.args, delim=\", \")\n</code></pre>"},{"location":"dialects/ilist/","title":"Immutable List","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"dialects/ilist/#the-immutable-list-dialect","title":"The Immutable List Dialect","text":"<p>The immutable list dialect models a Python-like <code>list</code> but is immutable. There are many good reasons to have an immutable list for compilation, especially when a list is immutable, we can assume a lot of statements to be pure and foldable (and thus can be inlined or simplified without extra analysis/rewrites).</p> <p>JAX</p> <p>This is also the reason why JAX picks an immutable array semantic.</p> <p>Why not use tuple?</p> <p>Tuple can take multiple items of different types, but list can only take items of the same type. Thus they have different trade-offs when doing analysis such as type inference of iterating through a tuple/list.</p>"},{"location":"dialects/ilist/#runtime","title":"Runtime","text":"<p>This dialect provides a runtime object <code>IList</code> which is a simple Python class wraps a Python list. This object can be used as a compile-time value by providing an implementation of <code>__hash__</code> that returns the object id. This means common simplifications like Common Subexpression Elimination (CSE) will not detect duplicated <code>IList</code> unless the <code>ir.SSAValue</code> points to identical <code>IList</code> object.</p> <p>Implementation Details</p> <p>this is an implementation detail of <code>IList</code>, we can switch to a more efficient runtime in the future where the memory layout is optimized based on the assumption of items in same type and immutabiility.</p> <p>The <code>IList</code> runtime object implements most of the Python <code>Sequence</code> interface, such as <code>__getitem__</code>, <code>__iter__</code>, <code>__len__</code> etc.</p>"},{"location":"dialects/ilist/#new","title":"<code>New</code>","text":"<p>This statements take a tuple of <code>ir.SSAValue</code> and creates an <code>IList</code> as result.</p> <p>Syntax Sugar in Lowering</p> <p>The syntax <code>[a, b, c]</code> will be lowered into <code>New</code> statement as a syntax sugar when <code>ilist</code> dialect is used (thus in conflict with mutable Python list). This may change in the future to give developers more freedom to choose what to lower from.</p>"},{"location":"dialects/ilist/#map","title":"<code>Map</code>","text":"<p>This statements take a high-order function (a function object) of signature <code>[[ElemT], OutT]</code> and apply it on a given <code>IList[ElemT, Len]</code> object then return a new <code>IList[OutT, Len]</code>.</p> <p>For example:</p> <pre><code>@basic_no_opt\ndef main(x: ilist.IList[float, Literal[5]]):\n    def closure(a):\n        return a + 1\n    return ilist.map(closure, x)\n</code></pre> <p>will be lowerd into the following</p> <pre><code>func.func main(!py.IList[!py.float, 5]) -&gt; !Any {\n  ^0(%main_self, %x):\n  \u2502 %closure = func.lambda closure() -&gt; !Any {\n  \u2502            \u2502 ^1(%closure_self, %a):\n  \u2502            \u2502 \u2502 %1 = py.constant.constant 1 : !py.int\n  \u2502            \u2502 \u2502 %2 = py.binop.add(%a, %1) : ~T\n  \u2502            \u2502 \u2502      func.return %2\n  \u2502            } // func.lambda closure\n  \u2502       %0 = py.ilist.map(fn=%closure, collection=%x : !py.IList[!py.float, 5]) : !py.IList[~OutElemT, ~ListLen]\n  \u2502            func.return %0\n} // func.func main\n</code></pre>"},{"location":"dialects/ilist/#foldl-and-foldr","title":"<code>Foldl</code> and <code>Foldr</code>","text":"<p>These two statements represents applying a binary operator <code>+</code> (any binary operator) on an <code>IList</code> with a different reduction order, e.g given <code>[a, b, c]</code>, <code>Foldl</code> represents <code>((a + b) + c)</code> and <code>Foldr</code> represents <code>(a + (b + c))</code>.</p>"},{"location":"dialects/ilist/#scan","title":"<code>Scan</code>","text":"<p>While the actual implementation is not the same, this statement represents the same semantics as the following function:</p> <pre><code>def scan(fn, xs, init):\n    carry = init\n    ys = []\n    for elem in xs:\n        carry, y = fn(carry, elem)\n        ys.append(y)\n    return carry, ys\n</code></pre>"},{"location":"dialects/ilist/#foreach","title":"<code>ForEach</code>","text":"<p>this represents a <code>for</code>-loop without any loop variables (variables pass through each loop iteration).</p>"},{"location":"dialects/ilist/#api-reference","title":"API Reference","text":""},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.CarryT","title":"CarryT  <code>module-attribute</code>","text":"<pre><code>CarryT = TypeVar('CarryT')\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.ElemT","title":"ElemT  <code>module-attribute</code>","text":"<pre><code>ElemT = TypeVar('ElemT')\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.IListType","title":"IListType  <code>module-attribute</code>","text":"<pre><code>IListType = Generic(IList, ElemT, ListLen)\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.ListLen","title":"ListLen  <code>module-attribute</code>","text":"<pre><code>ListLen = TypeVar('ListLen')\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.OutElemT","title":"OutElemT  <code>module-attribute</code>","text":"<pre><code>OutElemT = TypeVar('OutElemT')\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.ResultT","title":"ResultT  <code>module-attribute</code>","text":"<pre><code>ResultT = TypeVar('ResultT')\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Foldl","title":"Foldl  <code>kirin-statement</code>","text":"<pre><code>Foldl(\n    fn: ir.SSAValue,\n    collection: ir.SSAValue,\n    init: ir.SSAValue,\n    *,\n    purity: bool\n)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Foldl.collection","title":"collection  <code>kirin-argument</code>","text":"<pre><code>collection: SSAValue = argument(IListType[ElemT])\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Foldl.fn","title":"fn  <code>kirin-argument</code>","text":"<pre><code>fn: SSAValue = argument(\n    Generic(Method, [OutElemT, ElemT], OutElemT)\n)\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Foldl.init","title":"init  <code>kirin-argument</code>","text":"<pre><code>init: SSAValue = argument(OutElemT)\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Foldl.purity","title":"purity  <code>kirin-attribute</code> <code>kw-only</code>","text":"<pre><code>purity: bool = attribute(default=False)\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Foldl.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(OutElemT)\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Foldl.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({MaybePure(), FromPythonCall()})\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Foldr","title":"Foldr  <code>kirin-statement</code>","text":"<pre><code>Foldr(\n    fn: ir.SSAValue,\n    collection: ir.SSAValue,\n    init: ir.SSAValue,\n    *,\n    purity: bool\n)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Foldr.collection","title":"collection  <code>kirin-argument</code>","text":"<pre><code>collection: SSAValue = argument(IListType[ElemT])\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Foldr.fn","title":"fn  <code>kirin-argument</code>","text":"<pre><code>fn: SSAValue = argument(\n    Generic(Method, [ElemT, OutElemT], OutElemT)\n)\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Foldr.init","title":"init  <code>kirin-argument</code>","text":"<pre><code>init: SSAValue = argument(OutElemT)\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Foldr.purity","title":"purity  <code>kirin-attribute</code> <code>kw-only</code>","text":"<pre><code>purity: bool = attribute(default=False)\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Foldr.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(OutElemT)\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Foldr.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({MaybePure(), FromPythonCall()})\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.ForEach","title":"ForEach  <code>kirin-statement</code>","text":"<pre><code>ForEach(\n    fn: ir.SSAValue,\n    collection: ir.SSAValue,\n    *,\n    purity: bool\n)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.ForEach.collection","title":"collection  <code>kirin-argument</code>","text":"<pre><code>collection: SSAValue = argument(IListType[ElemT])\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.ForEach.fn","title":"fn  <code>kirin-argument</code>","text":"<pre><code>fn: SSAValue = argument(Generic(Method, [ElemT], NoneType))\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.ForEach.purity","title":"purity  <code>kirin-attribute</code> <code>kw-only</code>","text":"<pre><code>purity: bool = attribute(default=False)\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.ForEach.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({MaybePure(), FromPythonCall()})\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Map","title":"Map  <code>kirin-statement</code>","text":"<pre><code>Map(\n    fn: ir.SSAValue,\n    collection: ir.SSAValue,\n    *,\n    purity: bool\n)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Map.collection","title":"collection  <code>kirin-argument</code>","text":"<pre><code>collection: SSAValue = argument(IListType[ElemT, ListLen])\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Map.fn","title":"fn  <code>kirin-argument</code>","text":"<pre><code>fn: SSAValue = argument(MethodType[[ElemT], OutElemT])\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Map.purity","title":"purity  <code>kirin-attribute</code> <code>kw-only</code>","text":"<pre><code>purity: bool = attribute(default=False)\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Map.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(IListType[OutElemT, ListLen])\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Map.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({MaybePure(), FromPythonCall()})\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.New","title":"New  <code>kirin-statement</code>","text":"<pre><code>New(\n    values: Sequence[ir.SSAValue],\n    elem_type: types.TypeAttribute | None = None,\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> Source code in <code>src/kirin/dialects/ilist/stmts.py</code> <pre><code>def __init__(\n    self,\n    values: Sequence[ir.SSAValue],\n    elem_type: types.TypeAttribute | None = None,\n) -&gt; None:\n    if not elem_type:\n        elem_type = types.Any\n    result_type = IListType[elem_type, types.Literal(len(values))]\n    super().__init__(\n        args=values,\n        result_types=(result_type,),\n        args_slice={\"values\": slice(0, len(values))},\n        attributes={\"elem_type\": elem_type},\n    )\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.New.elem_type","title":"elem_type  <code>kirin-attribute</code> <code>kw-only</code>","text":"<pre><code>elem_type: TypeAttribute = attribute()\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.New.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(IListType[ElemT])\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.New.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({Pure(), FromPythonCall()})\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.New.values","title":"values  <code>kirin-argument</code>","text":"<pre><code>values: tuple[SSAValue, ...] = argument(ElemT)\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Push","title":"Push  <code>kirin-statement</code>","text":"<pre><code>Push(lst: ir.SSAValue, value: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Push.lst","title":"lst  <code>kirin-argument</code>","text":"<pre><code>lst: SSAValue = argument(IListType[ElemT])\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Push.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(IListType[ElemT])\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Push.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({Pure(), FromPythonCall()})\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Push.value","title":"value  <code>kirin-argument</code>","text":"<pre><code>value: SSAValue = argument(IListType[ElemT])\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Range","title":"Range  <code>kirin-statement</code>","text":"<pre><code>Range(\n    start: ir.SSAValue, stop: ir.SSAValue, step: ir.SSAValue\n)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Range.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'range'\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Range.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(IListType[Int, Any])\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Range.start","title":"start  <code>kirin-argument</code>","text":"<pre><code>start: SSAValue = argument(Int)\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Range.step","title":"step  <code>kirin-argument</code>","text":"<pre><code>step: SSAValue = argument(Int)\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Range.stop","title":"stop  <code>kirin-argument</code>","text":"<pre><code>stop: SSAValue = argument(Int)\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Range.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({Pure(), FromPythonRangeLike()})\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Scan","title":"Scan  <code>kirin-statement</code>","text":"<pre><code>Scan(\n    fn: ir.SSAValue,\n    collection: ir.SSAValue,\n    init: ir.SSAValue,\n    *,\n    purity: bool\n)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Scan.collection","title":"collection  <code>kirin-argument</code>","text":"<pre><code>collection: SSAValue = argument(IListType[ElemT, ListLen])\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Scan.fn","title":"fn  <code>kirin-argument</code>","text":"<pre><code>fn: SSAValue = argument(\n    Generic(\n        Method, [OutElemT, ElemT], Tuple[OutElemT, ResultT]\n    )\n)\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Scan.init","title":"init  <code>kirin-argument</code>","text":"<pre><code>init: SSAValue = argument(OutElemT)\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Scan.purity","title":"purity  <code>kirin-attribute</code> <code>kw-only</code>","text":"<pre><code>purity: bool = attribute(default=False)\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Scan.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(\n    Tuple[OutElemT, IListType[ResultT, ListLen]]\n)\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Scan.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({MaybePure(), FromPythonCall()})\n</code></pre>"},{"location":"dialects/scf/","title":"Structural Control Flow","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"dialects/scf/#scf-dialects","title":"SCF Dialects","text":"<p>The structured control flow (SCF) dialect is a dialect we adopt from the MLIR project with modifications to better fit the semantics of Python. This page will explain the SCF dialects semantics and how they are used.</p>"},{"location":"dialects/scf/#scfyield","title":"<code>scf.Yield</code>","text":"<p>The <code>scf.Yield</code> statement is used to mark the end of a block and yield to the region parent. It is used in the following way, for example with <code>scf.if</code> statement:</p> <pre><code>%value_1 = scf.if %cond {\n    // body\n    scf.yield %value\n} else {\n    // body\n    scf.yield %value\n}\n</code></pre> <p><code>scf.Yield</code> marks that the <code>%value</code> will be returned to the parent statement as its result. Unlike MLIR, most of the Kirin scf dialect can also terminate with <code>func.Return</code> statement to make things easier to lower from Python.</p>"},{"location":"dialects/scf/#scfif","title":"<code>scf.If</code>","text":"<p>The <code>scf.If</code> statement is used to conditionally execute a block of code. It is used in the following way:</p> <pre><code>scf.if %cond {\n    // body\n} else {\n    // body\n}\n</code></pre> <p>Definition The <code>scf.If</code> statement can have a <code>cond</code> argument, a <code>then_body</code> region with single block, and optionally a <code>else_body</code> with single block. The <code>then_body</code> block is executed if the condition is true, and the <code>else_body</code> block is executed if the condition is false.</p> <p>Termination <code>then_body</code> must terminate with <code>scf.Yield</code> or <code>func.Return</code> statement. <code>else_body</code> is optional and can be omitted. If one of the body terminates with <code>scf.Yield</code> the other body must terminate explicitly with <code>scf.Yield</code> or <code>func.Return</code>.</p>"},{"location":"dialects/scf/#scffor","title":"<code>scf.For</code>","text":"<p>The <code>scf.For</code> statement is used to iterate over a range of values. It is used in the following way:</p> <pre><code>def simple_loop():\n    j = 0.0\n    for i in range(10):\n        j = j + i\n    return j\n</code></pre> <p>lowered to the following IR:</p> <pre><code>func.func simple_loop() -&gt; !Any {\n  ^0(%simple_loop_self):\n  \u2502   %j = py.constant.constant 0.0\n  \u2502   %0 = py.constant.constant IList(range(0, 10))\n  \u2502 %j_1 = py.constant.constant 45.0\n  \u2502 %j_2 = scf.for %i in %0\n  \u2502        \u2502 iter_args(%j_3 = %j) {\n  \u2502        \u2502 %j_4 = py.binop.add(%j_3, %i)\n  \u2502        \u2502        scf.yield %j_4\n  \u2502        }\n  \u2502        func.return %j_1\n} // func.func simple_loop\n</code></pre> <p>Definition The <code>scf.For</code> statement takes an <code>iterable</code> as an argument.</p> <p>Note</p> <p>Unlike MLIR where the loop iterable is restricted to a step range, Kirin allows any Python iterable object to be used as a loop iterable by marking this iterable argument as <code>ir.types.Any</code>. While it can be any Python iterable object, the actual loop compilation can only happen if the iterable type is known and supported by the compiler implementation.</p> <p><code>scf.For</code> can also take an optional <code>initializers</code> tuple of values that are used to initialize the loop variables (printed as right-hand side of the <code>iter_args</code> field).</p> <p>Termination The loop body must terminate with <code>scf.Yield</code> or <code>func.Return</code> statement.</p> <p>Scoping The loop body creates a new scope. As a result of this, any variables defined inside the loop body are not accessible outside the loop body unless they are explicitly yielded.</p> <p>Known difference with Python <code>for</code> loop</p> <p>The <code>scf.For</code> statement does not follow exactly the same semantics as Python <code>for</code> loop. This difference is due to the context difference of compilation vs. interpretation. Like many other compiled languages, the loop body introduces a new scope and the loop variable is not accessible outside the loop body, e.g the following code will error in Julia:</p> <p><pre><code>function simple_loop()\n    for i in 1:10\n        j = j + i\n        if j &gt; 5\n            return j\n        end\n    end\n    return j\nend\n</code></pre> will error with <code>UndefVarError</code>:</p> <pre><code>julia&gt; simple_loop()\n    ERROR: UndefVarError: `j` not defined in local scope\n    Suggestion: check for an assignment to a local variable that shadows a global of the same name.\n    Stacktrace:\n        [1] simple_loop()\n        @ Main ./REPL[1]:3\n        [2] top-level scope\n        @ REPL[2]:1\n</code></pre> <p>However, in Python this code will work due to the fact that interpreter will not actually create a new scope for the loop body:</p> <pre><code>def simple_loop():\n    for i in range(10):\n        j = j + i\n        if j == 5:\n            return j\n    return j # will refer to the j defined in the loop body\n</code></pre>"},{"location":"dialects/scf/#reference","title":"Reference","text":""},{"location":"dialects/scf/#kirin.dialects.scf.stmts.For","title":"For  <code>kirin-statement</code>","text":"<pre><code>For(\n    iterable: ir.SSAValue,\n    body: ir.Region,\n    *initializers: ir.SSAValue\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> Source code in <code>src/kirin/dialects/scf/stmts.py</code> <pre><code>def __init__(\n    self,\n    iterable: ir.SSAValue,\n    body: ir.Region,\n    *initializers: ir.SSAValue,\n):\n    stmt = body.blocks[0].last_stmt\n    if isinstance(stmt, Yield):\n        result_types = tuple(value.type for value in stmt.values)\n    else:\n        result_types = ()\n    super().__init__(\n        args=(iterable, *initializers),\n        regions=(body,),\n        result_types=result_types,\n        args_slice={\"iterable\": 0, \"initializers\": slice(1, None)},\n        attributes={\"purity\": ir.PyAttr(False)},\n    )\n</code></pre>"},{"location":"dialects/scf/#kirin.dialects.scf.stmts.For.body","title":"body  <code>kirin-region</code> <code>kw-only</code>","text":"<pre><code>body: Region = region(multi=False)\n</code></pre>"},{"location":"dialects/scf/#kirin.dialects.scf.stmts.For.initializers","title":"initializers  <code>kirin-argument</code>","text":"<pre><code>initializers: tuple[SSAValue, ...] = argument(Any)\n</code></pre>"},{"location":"dialects/scf/#kirin.dialects.scf.stmts.For.iterable","title":"iterable  <code>kirin-argument</code>","text":"<pre><code>iterable: SSAValue = argument(Any)\n</code></pre>"},{"location":"dialects/scf/#kirin.dialects.scf.stmts.For.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'for'\n</code></pre>"},{"location":"dialects/scf/#kirin.dialects.scf.stmts.For.purity","title":"purity  <code>kirin-attribute</code> <code>kw-only</code>","text":"<pre><code>purity: bool = attribute(default=False)\n</code></pre>"},{"location":"dialects/scf/#kirin.dialects.scf.stmts.For.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({MaybePure(), SSACFGRegion()})\n</code></pre>"},{"location":"dialects/scf/#kirin.dialects.scf.stmts.For.print_impl","title":"print_impl","text":"<pre><code>print_impl(printer: Printer) -&gt; None\n</code></pre> Source code in <code>src/kirin/dialects/scf/stmts.py</code> <pre><code>def print_impl(self, printer: Printer) -&gt; None:\n    printer.print_name(self)\n    printer.plain_print(\" \")\n    block = self.body.blocks[0]\n    printer.print(block.args[0])\n    printer.plain_print(\" in \", style=\"keyword\")\n    printer.print(self.iterable)\n    if self.results:\n        with printer.rich(style=\"comment\"):\n            printer.plain_print(\" -&gt; \")\n            printer.print_seq(\n                tuple(result.type for result in self.results),\n                delim=\", \",\n                style=\"comment\",\n            )\n\n    with printer.indent():\n        if self.initializers:\n            printer.print_newline()\n            printer.plain_print(\"iter_args(\")\n            for idx, (arg, val) in enumerate(\n                zip(block.args[1:], self.initializers)\n            ):\n                printer.print(arg)\n                printer.plain_print(\" = \")\n                printer.print(val)\n                if idx &lt; len(self.initializers) - 1:\n                    printer.plain_print(\", \")\n            printer.plain_print(\")\")\n\n        printer.plain_print(\" {\")\n        if printer.analysis is not None:\n            with printer.rich(style=\"warning\"):\n                for arg in block.args:\n                    printer.print_newline()\n                    printer.print_analysis(\n                        arg, prefix=f\"{printer.state.ssa_id[arg]} --&gt; \"\n                    )\n        with printer.align(printer.result_width(block.stmts)):\n            for stmt in block.stmts:\n                printer.print_newline()\n                printer.print_stmt(stmt)\n    printer.print_newline()\n    printer.plain_print(\"}\")\n    with printer.rich(style=\"comment\"):\n        printer.plain_print(f\" -&gt; purity={self.purity}\")\n</code></pre>"},{"location":"dialects/scf/#kirin.dialects.scf.stmts.For.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>run mandatory validation checks. This is not same as verify_type, which may be optional.</p> Source code in <code>src/kirin/dialects/scf/stmts.py</code> <pre><code>def verify(self) -&gt; None:\n    from kirin.dialects.func import Return\n\n    if len(self.body.blocks) != 1:\n        raise ir.ValidationError(self, \"for loop body must have a single block\")\n\n    if len(self.body.blocks[0].args) != len(self.initializers) + 1:\n        raise ir.ValidationError(\n            self,\n            \"for loop body must have arguments for all initializers and the loop variable\",\n        )\n\n    stmt = self.body.blocks[0].last_stmt\n    if stmt is None or not isinstance(stmt, (Yield, Return)):\n        raise ir.ValidationError(\n            self, \"for loop body must terminate with a yield or return\"\n        )\n\n    if isinstance(stmt, Return):\n        return\n\n    if len(stmt.values) != len(self.initializers):\n        raise ir.ValidationError(\n            self,\n            \"for loop body must have the same number of results as initializers\",\n        )\n    if len(self.results) != len(stmt.values):\n        raise ir.ValidationError(\n            self,\n            \"for loop must have the same number of results as the yield in the body\",\n        )\n</code></pre>"},{"location":"dialects/scf/#kirin.dialects.scf.stmts.IfElse","title":"IfElse  <code>kirin-statement</code>","text":"<pre><code>IfElse(\n    cond: ir.SSAValue,\n    then_body: ir.Region | ir.Block,\n    else_body: ir.Region | ir.Block | None = None,\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>Python-like if-else statement.</p> <p>This statement has a condition, then body, and else body.</p> <p>Then body either terminates with a yield statement or <code>scf.return</code>.</p> Source code in <code>src/kirin/dialects/scf/stmts.py</code> <pre><code>def __init__(\n    self,\n    cond: ir.SSAValue,\n    then_body: ir.Region | ir.Block,\n    else_body: ir.Region | ir.Block | None = None,\n):\n    if isinstance(then_body, ir.Region):\n        then_body_region = then_body\n        if then_body_region.blocks:\n            then_body_block = then_body_region.blocks[-1]\n        else:\n            then_body_block = None\n    elif isinstance(then_body, ir.Block):\n        then_body_block = then_body\n        then_body_region = ir.Region(then_body)\n\n    if isinstance(else_body, ir.Region):\n        if not else_body.blocks:  # empty region\n            else_body_region = else_body\n            else_body_block = None\n        elif len(else_body.blocks) == 0:\n            else_body_region = else_body\n            else_body_block = None\n        else:\n            else_body_region = else_body\n            else_body_block = else_body_region.blocks[0]\n    elif isinstance(else_body, ir.Block):\n        else_body_region = ir.Region(else_body)\n        else_body_block = else_body\n    else:\n        else_body_region = ir.Region()\n        else_body_block = None\n\n    # if either then or else body has yield, we generate results\n    # we assume if both have yields, they have the same number of results\n    results = ()\n    if then_body_block is not None:\n        then_yield = then_body_block.last_stmt\n        else_yield = (\n            else_body_block.last_stmt if else_body_block is not None else None\n        )\n        if then_yield is not None and isinstance(then_yield, Yield):\n            results = then_yield.values\n        elif else_yield is not None and isinstance(else_yield, Yield):\n            results = else_yield.values\n\n    result_types = tuple(value.type for value in results)\n    super().__init__(\n        args=(cond,),\n        regions=(then_body_region, else_body_region),\n        result_types=result_types,\n        args_slice={\"cond\": 0},\n        attributes={\"purity\": ir.PyAttr(False)},\n    )\n</code></pre>"},{"location":"dialects/scf/#kirin.dialects.scf.stmts.IfElse.cond","title":"cond  <code>kirin-argument</code>","text":"<pre><code>cond: SSAValue = argument(Any)\n</code></pre>"},{"location":"dialects/scf/#kirin.dialects.scf.stmts.IfElse.else_body","title":"else_body  <code>kirin-region</code> <code>kw-only</code>","text":"<pre><code>else_body: Region = region(\n    multi=False, default_factory=Region\n)\n</code></pre>"},{"location":"dialects/scf/#kirin.dialects.scf.stmts.IfElse.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'if'\n</code></pre>"},{"location":"dialects/scf/#kirin.dialects.scf.stmts.IfElse.purity","title":"purity  <code>kirin-attribute</code> <code>kw-only</code>","text":"<pre><code>purity: bool = attribute(default=False)\n</code></pre>"},{"location":"dialects/scf/#kirin.dialects.scf.stmts.IfElse.then_body","title":"then_body  <code>kirin-region</code> <code>kw-only</code>","text":"<pre><code>then_body: Region = region(multi=False)\n</code></pre>"},{"location":"dialects/scf/#kirin.dialects.scf.stmts.IfElse.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({MaybePure(), SSACFGRegion()})\n</code></pre>"},{"location":"dialects/scf/#kirin.dialects.scf.stmts.IfElse.print_impl","title":"print_impl","text":"<pre><code>print_impl(printer: Printer) -&gt; None\n</code></pre> Source code in <code>src/kirin/dialects/scf/stmts.py</code> <pre><code>def print_impl(self, printer: Printer) -&gt; None:\n    printer.print_name(self)\n    printer.plain_print(\" \")\n    printer.print(self.cond)\n    printer.plain_print(\" \")\n    printer.print(self.then_body)\n    if self.else_body.blocks and not (\n        len(self.else_body.blocks[0].stmts) == 1\n        and isinstance(else_term := self.else_body.blocks[0].last_stmt, Yield)\n        and not else_term.values  # empty yield\n    ):\n        printer.plain_print(\" else \", style=\"keyword\")\n        printer.print(self.else_body)\n\n    with printer.rich(style=\"comment\"):\n        printer.plain_print(f\" -&gt; purity={self.purity}\")\n</code></pre>"},{"location":"dialects/scf/#kirin.dialects.scf.stmts.IfElse.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>run mandatory validation checks. This is not same as verify_type, which may be optional.</p> Source code in <code>src/kirin/dialects/scf/stmts.py</code> <pre><code>def verify(self) -&gt; None:\n    from kirin.dialects.func import Return\n\n    if len(self.then_body.blocks) != 1:\n        raise ir.ValidationError(self, \"then region must have a single block\")\n\n    if len(self.else_body.blocks) != 1:\n        raise ir.ValidationError(self, \"else region must have a single block\")\n\n    then_block = self.then_body.blocks[0]\n    else_block = self.else_body.blocks[0]\n    if len(then_block.args) != 1:\n        raise ir.ValidationError(\n            self, \"then block must have a single argument for condition\"\n        )\n\n    if len(else_block.args) != 1:\n        raise ir.ValidationError(\n            self, \"else block must have a single argument for condition\"\n        )\n\n    then_stmt = then_block.last_stmt\n    else_stmt = else_block.last_stmt\n    if then_stmt is None or not isinstance(then_stmt, (Yield, Return)):\n        raise ir.ValidationError(\n            self, \"then block must terminate with a yield or return\"\n        )\n\n    if else_stmt is None or not isinstance(else_stmt, (Yield, Return)):\n        raise ir.ValidationError(\n            self, \"else block must terminate with a yield or return\"\n        )\n</code></pre>"},{"location":"dialects/scf/#kirin.dialects.scf.stmts.Yield","title":"Yield  <code>kirin-statement</code>","text":"<pre><code>Yield(*values: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> Source code in <code>src/kirin/dialects/scf/stmts.py</code> <pre><code>def __init__(self, *values: ir.SSAValue):\n    super().__init__(args=values, args_slice={\"values\": slice(None)})\n</code></pre>"},{"location":"dialects/scf/#kirin.dialects.scf.stmts.Yield.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'yield'\n</code></pre>"},{"location":"dialects/scf/#kirin.dialects.scf.stmts.Yield.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({IsTerminator()})\n</code></pre>"},{"location":"dialects/scf/#kirin.dialects.scf.stmts.Yield.values","title":"values  <code>kirin-argument</code>","text":"<pre><code>values: tuple[SSAValue, ...] = argument(Any)\n</code></pre>"},{"location":"dialects/scf/#kirin.dialects.scf.stmts.Yield.print_impl","title":"print_impl","text":"<pre><code>print_impl(printer: Printer) -&gt; None\n</code></pre> Source code in <code>src/kirin/dialects/scf/stmts.py</code> <pre><code>def print_impl(self, printer: Printer) -&gt; None:\n    printer.print_name(self)\n    printer.print_seq(self.values, prefix=\" \", delim=\", \")\n</code></pre>"},{"location":"dialects/python/","title":"Index","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"dialects/python/#python-dialects","title":"Python Dialects","text":"<p>Kirin provides a set of dialects that represents fractions of Python semantics. We will describe each dialect in this page. The general design principle of these dialects is to provide a composable set of Python semantics that can be used to build different embedded DSLs inside Python.</p>"},{"location":"dialects/python/core/","title":"Core","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"dialects/python/core/#core-python-dialects","title":"Core Python Dialects","text":"<p>This page contains the core Python dialects that are used most frequently when designing an embedded DSL in Python.</p>"},{"location":"dialects/python/core/#reference","title":"Reference","text":""},{"location":"dialects/python/core/#base","title":"Base","text":""},{"location":"dialects/python/core/#kirin.dialects.py.base","title":"kirin.dialects.py.base","text":"<p>Base dialect for Python.</p> <p>This dialect does not contain statements. It only contains lowering rules for <code>ast.Name</code> and <code>ast.Expr</code>.</p>"},{"location":"dialects/python/core/#kirin.dialects.py.base.dialect","title":"dialect  <code>module-attribute</code>","text":"<pre><code>dialect = Dialect('py.base')\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.base.PythonLowering","title":"PythonLowering  <code>dataclass</code>","text":"<pre><code>PythonLowering()\n</code></pre> <p>               Bases: <code>FromPythonAST</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.base.PythonLowering.lower_Expr","title":"lower_Expr","text":"<pre><code>lower_Expr(\n    state: lowering.State, node: ast.Expr\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/base.py</code> <pre><code>def lower_Expr(self, state: lowering.State, node: ast.Expr) -&gt; lowering.Result:\n    return state.parent.visit(state, node.value)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.base.PythonLowering.lower_Name","title":"lower_Name","text":"<pre><code>lower_Name(\n    state: lowering.State, node: ast.Name\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/base.py</code> <pre><code>def lower_Name(self, state: lowering.State, node: ast.Name) -&gt; lowering.Result:\n    name = node.id\n    if isinstance(node.ctx, ast.Load):\n        value = state.current_frame.get(name)\n        if value is None:\n            raise lowering.BuildError(f\"{name} is not defined\")\n        return value\n    elif isinstance(node.ctx, ast.Store):\n        raise lowering.BuildError(\"unhandled store operation\")\n    else:  # Del\n        raise lowering.BuildError(\"unhandled del operation\")\n</code></pre>"},{"location":"dialects/python/core/#constant","title":"Constant","text":""},{"location":"dialects/python/core/#kirin.dialects.py.constant","title":"kirin.dialects.py.constant","text":"<p>Constant statement for Python dialect.</p> <p>This module contains the dialect for the Python <code>constant</code> statement, including:</p> <ul> <li>The <code>Constant</code> statement class.</li> <li>The lowering pass for the <code>constant</code> statement.</li> <li>The concrete implementation of the <code>constant</code> statement.</li> <li>The Julia emitter for the <code>constant</code> statement.</li> </ul> <p>This dialect maps <code>ast.Constant</code> nodes to the <code>Constant</code> statement.</p>"},{"location":"dialects/python/core/#kirin.dialects.py.constant.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T', covariant=True)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.constant.dialect","title":"dialect  <code>module-attribute</code>","text":"<pre><code>dialect = Dialect('py.constant')\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.constant.Concrete","title":"Concrete  <code>dataclass</code>","text":"<pre><code>Concrete()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.constant.Concrete.constant","title":"constant","text":"<pre><code>constant(interp, frame: interp.Frame, stmt: Constant)\n</code></pre> Source code in <code>src/kirin/dialects/py/constant.py</code> <pre><code>@interp.impl(Constant)\ndef constant(self, interp, frame: interp.Frame, stmt: Constant):\n    return (stmt.value.unwrap(),)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.constant.Constant","title":"Constant  <code>kirin-statement</code>","text":"<pre><code>Constant(value: T | ir.Data[T])\n</code></pre> <p>               Bases: <code>Statement</code>, <code>Generic[T]</code></p> Source code in <code>src/kirin/dialects/py/constant.py</code> <pre><code>def __init__(self, value: T | ir.Data[T]) -&gt; None:\n    if not isinstance(value, ir.Data):\n        value = ir.PyAttr(value)\n    super().__init__(\n        attributes={\"value\": value},\n        result_types=(value.type,),\n    )\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.constant.Constant.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'constant'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.constant.Constant.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result()\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.constant.Constant.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset(\n    {Pure(), ConstantLike(), FromPythonCall()}\n)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.constant.Constant.value","title":"value  <code>kirin-attribute</code> <code>kw-only</code>","text":"<pre><code>value: Data[T] = attribute()\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.constant.Constant.check_type","title":"check_type","text":"<pre><code>check_type() -&gt; None\n</code></pre> <p>Check the types of the Block. Raises <code>Exception</code> if the types are not correct. This method is called by the <code>verify_type</code> method, which will detect the source of the error in the IR. One should always call the <code>verify_type</code> method to verify the types of the IR.</p> Note <p>This method is generated by the <code>@statement</code> decorator. But can be overridden if needed.</p> Source code in <code>src/kirin/dialects/py/constant.py</code> <pre><code>def check_type(self) -&gt; None:\n    if not isinstance(self.result.type, types.TypeAttribute):\n        raise TypeError(\n            f\"Expected result type to be PyType, got {self.result.type}\"\n        )\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.constant.Constant.print_impl","title":"print_impl","text":"<pre><code>print_impl(printer: Printer) -&gt; None\n</code></pre> Source code in <code>src/kirin/dialects/py/constant.py</code> <pre><code>def print_impl(self, printer: Printer) -&gt; None:\n    printer.print_name(self)\n    printer.plain_print(\" \")\n    if isinstance(self.value, ir.PyAttr):\n        printer.plain_print(repr(self.value.data))\n    else:  # other attributes\n        printer.plain_print(repr(self.value))\n    with printer.rich(style=\"comment\"):\n        printer.plain_print(\" : \")\n        printer.print(self.result.type)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.constant.JuliaTable","title":"JuliaTable  <code>dataclass</code>","text":"<pre><code>JuliaTable()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.constant.JuliaTable.emit_Constant","title":"emit_Constant","text":"<pre><code>emit_Constant(\n    emit: EmitJulia, frame: EmitStrFrame, stmt: Constant\n)\n</code></pre> Source code in <code>src/kirin/dialects/py/constant.py</code> <pre><code>@interp.impl(Constant)\ndef emit_Constant(self, emit: EmitJulia, frame: EmitStrFrame, stmt: Constant):\n    return (emit.emit_attribute(stmt.value),)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.constant.Lowering","title":"Lowering  <code>dataclass</code>","text":"<pre><code>Lowering()\n</code></pre> <p>               Bases: <code>FromPythonAST</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.constant.Lowering.lower_Constant","title":"lower_Constant","text":"<pre><code>lower_Constant(\n    state: lowering.State, node: ast.Constant\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/constant.py</code> <pre><code>def lower_Constant(\n    self, state: lowering.State, node: ast.Constant\n) -&gt; lowering.Result:\n    return state.current_frame.push(\n        Constant(node.value),\n    )\n</code></pre>"},{"location":"dialects/python/core/#unaryop","title":"UnaryOp","text":""},{"location":"dialects/python/core/#kirin.dialects.py.unary.stmts","title":"kirin.dialects.py.unary.stmts","text":""},{"location":"dialects/python/core/#kirin.dialects.py.unary.stmts.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T')\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.unary.stmts.Invert","title":"Invert  <code>kirin-statement</code>","text":"<pre><code>Invert(value: ir.SSAValue)\n</code></pre> <p>               Bases: <code>UnaryOp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.unary.stmts.Invert.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'invert'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.unary.stmts.Not","title":"Not  <code>kirin-statement</code>","text":"<pre><code>Not(value: ir.SSAValue)\n</code></pre> <p>               Bases: <code>UnaryOp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.unary.stmts.Not.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'not'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.unary.stmts.UAdd","title":"UAdd  <code>kirin-statement</code>","text":"<pre><code>UAdd(value: ir.SSAValue)\n</code></pre> <p>               Bases: <code>UnaryOp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.unary.stmts.UAdd.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'uadd'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.unary.stmts.USub","title":"USub  <code>kirin-statement</code>","text":"<pre><code>USub(value: ir.SSAValue)\n</code></pre> <p>               Bases: <code>UnaryOp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.unary.stmts.USub.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'usub'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.unary.stmts.UnaryOp","title":"UnaryOp  <code>kirin-statement</code>","text":"<pre><code>UnaryOp(value: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.unary.stmts.UnaryOp.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(T)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.unary.stmts.UnaryOp.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({Pure(), FromPythonCall()})\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.unary.stmts.UnaryOp.value","title":"value  <code>kirin-argument</code>","text":"<pre><code>value: SSAValue = argument(T, print=False)\n</code></pre>"},{"location":"dialects/python/core/#binop","title":"BinOp","text":""},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts","title":"kirin.dialects.py.binop.stmts","text":""},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T')\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.Add","title":"Add  <code>kirin-statement</code>","text":"<pre><code>Add(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>BinOp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.Add.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'add'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.BinOp","title":"BinOp  <code>kirin-statement</code>","text":"<pre><code>BinOp(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.BinOp.lhs","title":"lhs  <code>kirin-argument</code>","text":"<pre><code>lhs: SSAValue = argument(T, print=False)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.BinOp.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(T)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.BinOp.rhs","title":"rhs  <code>kirin-argument</code>","text":"<pre><code>rhs: SSAValue = argument(T, print=False)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.BinOp.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({Pure(), FromPythonCall()})\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.BitAnd","title":"BitAnd  <code>kirin-statement</code>","text":"<pre><code>BitAnd(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>BinOp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.BitAnd.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'bitand'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.BitOr","title":"BitOr  <code>kirin-statement</code>","text":"<pre><code>BitOr(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>BinOp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.BitOr.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'bitor'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.BitXor","title":"BitXor  <code>kirin-statement</code>","text":"<pre><code>BitXor(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>BinOp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.BitXor.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'bitxor'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.Div","title":"Div  <code>kirin-statement</code>","text":"<pre><code>Div(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>BinOp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.Div.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'div'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.FloorDiv","title":"FloorDiv  <code>kirin-statement</code>","text":"<pre><code>FloorDiv(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>BinOp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.FloorDiv.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'floordiv'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.LShift","title":"LShift  <code>kirin-statement</code>","text":"<pre><code>LShift(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>BinOp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.LShift.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'lshift'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.MatMult","title":"MatMult  <code>kirin-statement</code>","text":"<pre><code>MatMult(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>BinOp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.MatMult.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'matmult'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.Mod","title":"Mod  <code>kirin-statement</code>","text":"<pre><code>Mod(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>BinOp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.Mod.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'mod'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.Mult","title":"Mult  <code>kirin-statement</code>","text":"<pre><code>Mult(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>BinOp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.Mult.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'mult'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.Pow","title":"Pow  <code>kirin-statement</code>","text":"<pre><code>Pow(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>BinOp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.Pow.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'pow'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.RShift","title":"RShift  <code>kirin-statement</code>","text":"<pre><code>RShift(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>BinOp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.RShift.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'rshift'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.Sub","title":"Sub  <code>kirin-statement</code>","text":"<pre><code>Sub(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>BinOp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.Sub.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'sub'\n</code></pre>"},{"location":"dialects/python/core/#assertion","title":"Assertion","text":""},{"location":"dialects/python/core/#kirin.dialects.py.assertion","title":"kirin.dialects.py.assertion","text":"<p>Assertion dialect for Python.</p> <p>This module contains the dialect for the Python <code>assert</code> statement, including:</p> <ul> <li>The <code>Assert</code> statement class.</li> <li>The lowering pass for the <code>assert</code> statement.</li> <li>The concrete implementation of the <code>assert</code> statement.</li> <li>The type inference implementation of the <code>assert</code> statement.</li> <li>The Julia emitter for the <code>assert</code> statement.</li> </ul> <p>This dialect maps <code>ast.Assert</code> nodes to the <code>Assert</code> statement.</p>"},{"location":"dialects/python/core/#kirin.dialects.py.assertion.dialect","title":"dialect  <code>module-attribute</code>","text":"<pre><code>dialect = Dialect('py.assert')\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assertion.Assert","title":"Assert  <code>kirin-statement</code>","text":"<pre><code>Assert(message: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.assertion.Assert.condition","title":"condition  <code>instance-attribute</code>","text":"<pre><code>condition: SSAValue\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assertion.Assert.message","title":"message  <code>kirin-argument</code>","text":"<pre><code>message: SSAValue = argument(String)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assertion.Assert.print_impl","title":"print_impl","text":"<pre><code>print_impl(printer: Printer) -&gt; None\n</code></pre> Source code in <code>src/kirin/dialects/py/assertion.py</code> <pre><code>def print_impl(self, printer: Printer) -&gt; None:\n    with printer.rich(style=\"keyword\"):\n        printer.print_name(self)\n\n    printer.plain_print(\" \")\n    printer.print(self.condition)\n\n    if self.message:\n        printer.plain_print(\", \")\n        printer.print(self.message)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assertion.Concrete","title":"Concrete  <code>dataclass</code>","text":"<pre><code>Concrete()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.assertion.Concrete.assert_stmt","title":"assert_stmt","text":"<pre><code>assert_stmt(\n    interp_: interp.Interpreter,\n    frame: interp.Frame,\n    stmt: Assert,\n)\n</code></pre> Source code in <code>src/kirin/dialects/py/assertion.py</code> <pre><code>@interp.impl(Assert)\ndef assert_stmt(\n    self, interp_: interp.Interpreter, frame: interp.Frame, stmt: Assert\n):\n    if frame.get(stmt.condition) is True:\n        return ()\n\n    if stmt.message:\n        raise interp.WrapException(AssertionError(frame.get(stmt.message)))\n    else:\n        raise interp.WrapException(AssertionError(\"Assertion failed\"))\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assertion.EmitJulia","title":"EmitJulia  <code>dataclass</code>","text":"<pre><code>EmitJulia()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.assertion.EmitJulia.emit_assert","title":"emit_assert","text":"<pre><code>emit_assert(\n    interp: julia.EmitJulia,\n    frame: EmitStrFrame,\n    stmt: Assert,\n)\n</code></pre> Source code in <code>src/kirin/dialects/py/assertion.py</code> <pre><code>@interp.impl(Assert)\ndef emit_assert(self, interp: julia.EmitJulia, frame: EmitStrFrame, stmt: Assert):\n    interp.writeln(\n        frame, f\"@assert {frame.get(stmt.condition)} {frame.get(stmt.message)}\"\n    )\n    return ()\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assertion.Lowering","title":"Lowering  <code>dataclass</code>","text":"<pre><code>Lowering()\n</code></pre> <p>               Bases: <code>FromPythonAST</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.assertion.Lowering.lower_Assert","title":"lower_Assert","text":"<pre><code>lower_Assert(\n    state: lowering.State, node: ast.Assert\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/assertion.py</code> <pre><code>def lower_Assert(self, state: lowering.State, node: ast.Assert) -&gt; lowering.Result:\n    from kirin.dialects.py.constant import Constant\n\n    cond = state.lower(node.test).expect_one()\n    if node.msg:\n        message = state.lower(node.msg).expect_one()\n        state.current_frame.push(Assert(condition=cond, message=message))\n    else:\n        message_stmt = state.current_frame.push(Constant(\"\"))\n        state.current_frame.push(\n            Assert(condition=cond, message=message_stmt.result)\n        )\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assertion.TypeInfer","title":"TypeInfer  <code>dataclass</code>","text":"<pre><code>TypeInfer()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.assertion.TypeInfer.assert_stmt","title":"assert_stmt","text":"<pre><code>assert_stmt(interp, frame, stmt: Assert)\n</code></pre> Source code in <code>src/kirin/dialects/py/assertion.py</code> <pre><code>@interp.impl(Assert)\ndef assert_stmt(self, interp, frame, stmt: Assert):\n    return (types.Bottom,)\n</code></pre>"},{"location":"dialects/python/core/#assignment","title":"Assignment","text":""},{"location":"dialects/python/core/#kirin.dialects.py.assign","title":"kirin.dialects.py.assign","text":"<p>Assignment dialect for Python.</p> <p>This module contains the dialect for the Python assignment statement, including:</p> <ul> <li>Statements: <code>Alias</code>, <code>SetItem</code>.</li> <li>The lowering pass for the assignments.</li> <li>The concrete implementation of the assignment statements.</li> </ul> <p>This dialects maps Python assignment syntax.</p>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T')\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.dialect","title":"dialect  <code>module-attribute</code>","text":"<pre><code>dialect = Dialect('py.assign')\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.Alias","title":"Alias  <code>kirin-statement</code>","text":"<pre><code>Alias(value: ir.SSAValue, *, target: ir.PyAttr[str])\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.Alias.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'alias'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.Alias.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(T)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.Alias.target","title":"target  <code>kirin-attribute</code> <code>kw-only</code>","text":"<pre><code>target: PyAttr[str] = attribute()\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.Alias.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({Pure(), FromPythonCall()})\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.Alias.value","title":"value  <code>kirin-argument</code>","text":"<pre><code>value: SSAValue = argument(T)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.Alias.print_impl","title":"print_impl","text":"<pre><code>print_impl(printer: Printer) -&gt; None\n</code></pre> Source code in <code>src/kirin/dialects/py/assign.py</code> <pre><code>def print_impl(self, printer: Printer) -&gt; None:\n    printer.print_name(self)\n    printer.plain_print(\" \")\n    with printer.rich(style=\"symbol\"):\n        printer.plain_print(self.target.data)\n\n    with printer.rich(style=\"keyword\"):\n        printer.plain_print(\" = \")\n\n    printer.print(self.value)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.Concrete","title":"Concrete  <code>dataclass</code>","text":"<pre><code>Concrete()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.Concrete.alias","title":"alias","text":"<pre><code>alias(interp, frame: interp.Frame, stmt: Alias)\n</code></pre> Source code in <code>src/kirin/dialects/py/assign.py</code> <pre><code>@interp.impl(Alias)\ndef alias(self, interp, frame: interp.Frame, stmt: Alias):\n    return (frame.get(stmt.value),)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.Concrete.set_attribute","title":"set_attribute","text":"<pre><code>set_attribute(\n    interp, frame: interp.Frame, stmt: SetAttribute\n)\n</code></pre> Source code in <code>src/kirin/dialects/py/assign.py</code> <pre><code>@interp.impl(SetAttribute)\ndef set_attribute(self, interp, frame: interp.Frame, stmt: SetAttribute):\n    obj = frame.get(stmt.obj)\n    value = frame.get(stmt.value)\n    setattr(obj, stmt.attr, value)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.Concrete.setindex","title":"setindex","text":"<pre><code>setindex(interp, frame: interp.Frame, stmt: SetItem)\n</code></pre> Source code in <code>src/kirin/dialects/py/assign.py</code> <pre><code>@interp.impl(SetItem)\ndef setindex(self, interp, frame: interp.Frame, stmt: SetItem):\n    frame.get(stmt.obj)[frame.get(stmt.index)] = frame.get(stmt.value)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.Concrete.type_assert","title":"type_assert","text":"<pre><code>type_assert(interp_, frame: interp.Frame, stmt: TypeAssert)\n</code></pre> Source code in <code>src/kirin/dialects/py/assign.py</code> <pre><code>@interp.impl(TypeAssert)\ndef type_assert(self, interp_, frame: interp.Frame, stmt: TypeAssert):\n    got = frame.get(stmt.got)\n    got_type = types.PyClass(type(got))\n    if not got_type.is_subseteq(stmt.expected):\n        raise interp.WrapException(\n            TypeError(f\"Expected {stmt.expected}, got {got_type}\")\n        )\n    return (frame.get(stmt.got),)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.Lowering","title":"Lowering  <code>dataclass</code>","text":"<pre><code>Lowering()\n</code></pre> <p>               Bases: <code>FromPythonAST</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.Lowering.assign_item","title":"assign_item  <code>classmethod</code>","text":"<pre><code>assign_item(\n    state: lowering.State,\n    target,\n    result: lowering.State.Result,\n)\n</code></pre> Source code in <code>src/kirin/dialects/py/assign.py</code> <pre><code>@classmethod\ndef assign_item(cls, state: lowering.State, target, result: lowering.State.Result):\n    match target:\n        case ast.Tuple(elts, ast.Store()):\n            if len(elts) != len(result.data):\n                raise lowering.BuildError(\n                    f\"tuple assignment length mismatch: {len(elts)} != {len(result.data)}\"\n                )\n            for target, value in zip(elts, result.data):\n                cls.assign_item_value(state, target, value)\n        case _:\n            cls.assign_item_value(state, target, result.expect_one())\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.Lowering.assign_item_value","title":"assign_item_value  <code>classmethod</code>","text":"<pre><code>assign_item_value(\n    state: lowering.State, target, value: ir.SSAValue\n)\n</code></pre> Source code in <code>src/kirin/dialects/py/assign.py</code> <pre><code>@classmethod\ndef assign_item_value(cls, state: lowering.State, target, value: ir.SSAValue):\n    current_frame = state.current_frame\n    match target:\n        case ast.Name(name, ast.Store()):\n            value.name = name\n            current_frame.defs[name] = value\n        case ast.Attribute(obj, attr, ast.Store()):\n            obj = state.lower(obj).expect_one()\n            stmt = SetAttribute(obj, value, attr=attr)\n            current_frame.push(stmt)\n        case ast.Subscript(obj, slice, ast.Store()):\n            obj = state.lower(obj).expect_one()\n            slice = state.lower(slice).expect_one()\n            stmt = SetItem(obj=obj, index=slice, value=value)\n            current_frame.push(stmt)\n        case _:\n            raise lowering.BuildError(f\"unsupported target {target}\")\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.Lowering.lower_AnnAssign","title":"lower_AnnAssign","text":"<pre><code>lower_AnnAssign(\n    state: lowering.State, node: ast.AnnAssign\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/assign.py</code> <pre><code>def lower_AnnAssign(\n    self, state: lowering.State, node: ast.AnnAssign\n) -&gt; lowering.Result:\n    type_hint = self.get_hint(state, node.annotation)\n    value = state.lower(node.value).expect_one()\n    stmt = state.current_frame.push(TypeAssert(got=value, expected=type_hint))\n    self.assign_item_value(state, node.target, stmt.result)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.Lowering.lower_Assign","title":"lower_Assign","text":"<pre><code>lower_Assign(\n    state: lowering.State, node: ast.Assign\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/assign.py</code> <pre><code>def lower_Assign(self, state: lowering.State, node: ast.Assign) -&gt; lowering.Result:\n    result = state.lower(node.value)\n    current_frame = state.current_frame\n    match node:\n        case ast.Assign(\n            targets=[ast.Name(lhs_name, ast.Store())], value=ast.Name(_, ast.Load())\n        ):\n            stmt = Alias(\n                value=result.data[0], target=ir.PyAttr(lhs_name)\n            )  # NOTE: this is guaranteed to be one result\n            stmt.result.name = lhs_name\n            current_frame.defs[lhs_name] = current_frame.push(stmt).result\n        case _:\n            for target in node.targets:\n                self.assign_item(state, target, result)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.Lowering.lower_AugAssign","title":"lower_AugAssign","text":"<pre><code>lower_AugAssign(\n    state: lowering.State, node: ast.AugAssign\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/assign.py</code> <pre><code>def lower_AugAssign(\n    self, state: lowering.State, node: ast.AugAssign\n) -&gt; lowering.Result:\n    match node.target:\n        case ast.Name(name, ast.Store()):\n            rhs = ast.Name(name, ast.Load())\n        case ast.Attribute(obj, attr, ast.Store()):\n            rhs = ast.Attribute(obj, attr, ast.Load())\n        case ast.Subscript(obj, slice, ast.Store()):\n            rhs = ast.Subscript(obj, slice, ast.Load())\n        case _:\n            raise lowering.BuildError(f\"unsupported target {node.target}\")\n    self.assign_item_value(\n        state,\n        node.target,\n        state.lower(ast.BinOp(rhs, node.op, node.value)).expect_one(),\n    )\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.Lowering.lower_NamedExpr","title":"lower_NamedExpr","text":"<pre><code>lower_NamedExpr(\n    state: lowering.State, node: ast.NamedExpr\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/assign.py</code> <pre><code>def lower_NamedExpr(\n    self, state: lowering.State, node: ast.NamedExpr\n) -&gt; lowering.Result:\n    value = state.lower(node.value).expect_one()\n    self.assign_item_value(state, node.target, value)\n    return value\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.SetAttribute","title":"SetAttribute  <code>kirin-statement</code>","text":"<pre><code>SetAttribute(\n    obj: ir.SSAValue, value: ir.SSAValue, *, attr: str\n)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.SetAttribute.attr","title":"attr  <code>kirin-attribute</code> <code>kw-only</code>","text":"<pre><code>attr: str = attribute()\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.SetAttribute.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'setattr'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.SetAttribute.obj","title":"obj  <code>kirin-argument</code>","text":"<pre><code>obj: SSAValue = argument(print=False)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.SetAttribute.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({FromPythonCall()})\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.SetAttribute.value","title":"value  <code>kirin-argument</code>","text":"<pre><code>value: SSAValue = argument(print=False)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.SetItem","title":"SetItem  <code>kirin-statement</code>","text":"<pre><code>SetItem(\n    obj: ir.SSAValue, value: ir.SSAValue, index: ir.SSAValue\n)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.SetItem.index","title":"index  <code>kirin-argument</code>","text":"<pre><code>index: SSAValue = argument(print=False)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.SetItem.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'setitem'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.SetItem.obj","title":"obj  <code>kirin-argument</code>","text":"<pre><code>obj: SSAValue = argument(print=False)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.SetItem.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({FromPythonCall()})\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.SetItem.value","title":"value  <code>kirin-argument</code>","text":"<pre><code>value: SSAValue = argument(print=False)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.TypeAssert","title":"TypeAssert  <code>kirin-statement</code>","text":"<pre><code>TypeAssert(\n    got: ir.SSAValue, *, expected: types.TypeAttribute\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> Source code in <code>src/kirin/dialects/py/assign.py</code> <pre><code>def __init__(self, got: ir.SSAValue, *, expected: types.TypeAttribute):\n    super().__init__(\n        args=(got,),\n        attributes={\"expected\": expected},\n        result_types=(expected,),\n        args_slice={\"got\": 0},\n    )\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.TypeAssert.expected","title":"expected  <code>kirin-attribute</code> <code>kw-only</code>","text":"<pre><code>expected: TypeAttribute = attribute()\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.TypeAssert.got","title":"got  <code>kirin-argument</code>","text":"<pre><code>got: SSAValue = argument(print=False)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.TypeAssert.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result()\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.TypeAssert.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({FromPythonCall()})\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.TypeInfer","title":"TypeInfer  <code>dataclass</code>","text":"<pre><code>TypeInfer()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.TypeInfer.type_assert","title":"type_assert","text":"<pre><code>type_assert(\n    interp_,\n    frame: interp.Frame[types.TypeAttribute],\n    stmt: TypeAssert,\n)\n</code></pre> Source code in <code>src/kirin/dialects/py/assign.py</code> <pre><code>@interp.impl(TypeAssert)\ndef type_assert(\n    self, interp_, frame: interp.Frame[types.TypeAttribute], stmt: TypeAssert\n):\n    got = frame.get(stmt.got)\n    if got.is_subseteq(stmt.expected):\n        return (got.meet(stmt.expected),)\n    return (types.Bottom,)\n</code></pre>"},{"location":"dialects/python/core/#unpack","title":"Unpack","text":""},{"location":"dialects/python/core/#kirin.dialects.py.unpack","title":"kirin.dialects.py.unpack","text":"<p>The unpack dialect for Python.</p> <p>This module contains the dialect for the Python unpack semantics, including:</p> <ul> <li>The <code>Unpack</code> statement class.</li> <li>The lowering pass for the unpack statement.</li> <li>The concrete implementation of the unpack statement.</li> <li>The type inference implementation of the unpack statement.</li> <li>A helper function <code>unpacking</code> for unpacking Python AST nodes during lowering.</li> </ul>"},{"location":"dialects/python/core/#kirin.dialects.py.unpack.dialect","title":"dialect  <code>module-attribute</code>","text":"<pre><code>dialect = Dialect('py.unpack')\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.unpack.Concrete","title":"Concrete  <code>dataclass</code>","text":"<pre><code>Concrete()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.unpack.Concrete.unpack","title":"unpack","text":"<pre><code>unpack(\n    interp: interp.Interpreter,\n    frame: interp.Frame,\n    stmt: Unpack,\n)\n</code></pre> Source code in <code>src/kirin/dialects/py/unpack.py</code> <pre><code>@interp.impl(Unpack)\ndef unpack(self, interp: interp.Interpreter, frame: interp.Frame, stmt: Unpack):\n    return tuple(frame.get(stmt.value))\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.unpack.TypeInfer","title":"TypeInfer  <code>dataclass</code>","text":"<pre><code>TypeInfer()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.unpack.TypeInfer.unpack","title":"unpack","text":"<pre><code>unpack(\n    interp,\n    frame: interp.Frame[types.TypeAttribute],\n    stmt: Unpack,\n)\n</code></pre> Source code in <code>src/kirin/dialects/py/unpack.py</code> <pre><code>@interp.impl(Unpack)\ndef unpack(self, interp, frame: interp.Frame[types.TypeAttribute], stmt: Unpack):\n    value = frame.get(stmt.value)\n    if isinstance(value, types.Generic) and value.is_subseteq(types.Tuple):\n        if value.vararg:\n            rest = tuple(value.vararg.typ for _ in stmt.names[len(value.vars) :])\n            return tuple(value.vars) + rest\n        else:\n            return value.vars\n    # TODO: support unpacking other types\n    return tuple(types.Any for _ in stmt.names)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.unpack.Unpack","title":"Unpack  <code>kirin-statement</code>","text":"<pre><code>Unpack(value: ir.SSAValue, names: tuple[str | None, ...])\n</code></pre> <p>               Bases: <code>Statement</code></p> Source code in <code>src/kirin/dialects/py/unpack.py</code> <pre><code>def __init__(self, value: ir.SSAValue, names: tuple[str | None, ...]):\n    result_types = [types.Any] * len(names)\n    super().__init__(\n        args=(value,),\n        result_types=result_types,\n        args_slice={\"value\": 0},\n        attributes={\"names\": ir.PyAttr(names)},\n    )\n    for result, name in zip(self.results, names):\n        result.name = name\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.unpack.Unpack.names","title":"names  <code>kirin-attribute</code> <code>kw-only</code>","text":"<pre><code>names: tuple[str | None, ...] = attribute()\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.unpack.Unpack.value","title":"value  <code>kirin-argument</code>","text":"<pre><code>value: SSAValue = argument(Any)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.unpack.Unpack.print_impl","title":"print_impl","text":"<pre><code>print_impl(printer: Printer) -&gt; None\n</code></pre> Source code in <code>src/kirin/dialects/py/unpack.py</code> <pre><code>def print_impl(self, printer: Printer) -&gt; None:\n    printer.print_name(self)\n    printer.plain_print(\" \")\n    printer.print(self.value)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.unpack.unpacking","title":"unpacking","text":"<pre><code>unpacking(\n    state: lowering.State,\n    node: ast.expr,\n    value: ir.SSAValue,\n)\n</code></pre> Source code in <code>src/kirin/dialects/py/unpack.py</code> <pre><code>def unpacking(state: lowering.State, node: ast.expr, value: ir.SSAValue):\n    if isinstance(node, ast.Name):\n        state.current_frame.defs[node.id] = value\n        value.name = node.id\n        return\n    elif not isinstance(node, ast.Tuple):\n        raise lowering.BuildError(f\"unsupported unpack node {node}\")\n\n    names: list[str | None] = []\n    continue_unpack: list[int] = []\n    for idx, item in enumerate(node.elts):\n        if isinstance(item, ast.Name):\n            names.append(item.id)\n        else:\n            names.append(None)\n            continue_unpack.append(idx)\n    stmt = state.current_frame.push(Unpack(value, tuple(names)))\n    for name, result in zip(names, stmt.results):\n        if name is not None:\n            state.current_frame.defs[name] = result\n\n    for idx in continue_unpack:\n        unpacking(state, node.elts[idx], stmt.results[idx])\n</code></pre>"},{"location":"dialects/python/core/#boolean-operation","title":"Boolean Operation","text":""},{"location":"dialects/python/core/#kirin.dialects.py.boolop","title":"kirin.dialects.py.boolop","text":"<p>Boolean operators for Python dialect.</p> <p>This module contains the dialect for the Python boolean operators, including:</p> <ul> <li>The <code>And</code> and <code>Or</code> statement classes.</li> <li>The lowering pass for the boolean operators.</li> <li>The concrete implementation of the boolean operators.</li> <li>The Julia emitter for the boolean operators.</li> </ul> <p>This dialect maps <code>ast.BoolOp</code> nodes to the <code>And</code> and <code>Or</code> statements.</p>"},{"location":"dialects/python/core/#kirin.dialects.py.boolop.dialect","title":"dialect  <code>module-attribute</code>","text":"<pre><code>dialect = Dialect('py.boolop')\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.boolop.And","title":"And  <code>kirin-statement</code>","text":"<pre><code>And(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>BoolOp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.boolop.And.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'and'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.boolop.BoolOp","title":"BoolOp  <code>kirin-statement</code>","text":"<pre><code>BoolOp(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.boolop.BoolOp.lhs","title":"lhs  <code>kirin-argument</code>","text":"<pre><code>lhs: SSAValue = argument(print=False)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.boolop.BoolOp.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(Bool)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.boolop.BoolOp.rhs","title":"rhs  <code>kirin-argument</code>","text":"<pre><code>rhs: SSAValue = argument(print=False)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.boolop.BoolOp.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({Pure(), FromPythonCall()})\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.boolop.BoolOpMethod","title":"BoolOpMethod  <code>dataclass</code>","text":"<pre><code>BoolOpMethod()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.boolop.BoolOpMethod.and_","title":"and_","text":"<pre><code>and_(interp, frame: interp.Frame, stmt: And)\n</code></pre> Source code in <code>src/kirin/dialects/py/boolop.py</code> <pre><code>@interp.impl(And)\ndef and_(self, interp, frame: interp.Frame, stmt: And):\n    return (frame.get(stmt.lhs) and frame.get(stmt.rhs),)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.boolop.BoolOpMethod.or_","title":"or_","text":"<pre><code>or_(interp, frame: interp.Frame, stmt: Or)\n</code></pre> Source code in <code>src/kirin/dialects/py/boolop.py</code> <pre><code>@interp.impl(Or)\ndef or_(self, interp, frame: interp.Frame, stmt: Or):\n    return (frame.get(stmt.lhs) or frame.get(stmt.rhs),)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.boolop.JuliaTable","title":"JuliaTable  <code>dataclass</code>","text":"<pre><code>JuliaTable()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.boolop.JuliaTable.emit_And","title":"emit_And","text":"<pre><code>emit_And(emit: EmitJulia, frame: EmitStrFrame, stmt: And)\n</code></pre> Source code in <code>src/kirin/dialects/py/boolop.py</code> <pre><code>@interp.impl(And)\ndef emit_And(self, emit: EmitJulia, frame: EmitStrFrame, stmt: And):\n    return emit.emit_binaryop(frame, \"&amp;&amp;\", stmt.lhs, stmt.rhs, stmt.result)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.boolop.JuliaTable.emit_Or","title":"emit_Or","text":"<pre><code>emit_Or(emit: EmitJulia, frame: EmitStrFrame, stmt: Or)\n</code></pre> Source code in <code>src/kirin/dialects/py/boolop.py</code> <pre><code>@interp.impl(Or)\ndef emit_Or(self, emit: EmitJulia, frame: EmitStrFrame, stmt: Or):\n    return emit.emit_binaryop(frame, \"||\", stmt.lhs, stmt.rhs, stmt.result)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.boolop.Or","title":"Or  <code>kirin-statement</code>","text":"<pre><code>Or(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>BoolOp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.boolop.Or.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'or'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.boolop.PythonLowering","title":"PythonLowering  <code>dataclass</code>","text":"<pre><code>PythonLowering()\n</code></pre> <p>               Bases: <code>FromPythonAST</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.boolop.PythonLowering.lower_BoolOp","title":"lower_BoolOp","text":"<pre><code>lower_BoolOp(\n    state: lowering.State, node: ast.BoolOp\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/boolop.py</code> <pre><code>def lower_BoolOp(self, state: lowering.State, node: ast.BoolOp) -&gt; lowering.Result:\n    lhs = state.lower(node.values[0]).expect_one()\n    match node.op:\n        case ast.And():\n            boolop = And\n        case ast.Or():\n            boolop = Or\n        case _:\n            raise lowering.BuildError(f\"unsupported boolop {node.op}\")\n\n    for value in node.values[1:]:\n        lhs = state.current_frame.push(\n            boolop(lhs=lhs, rhs=state.lower(value).expect_one())\n        ).result\n    return lhs\n</code></pre>"},{"location":"dialects/python/core/#comparison","title":"Comparison","text":""},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts","title":"kirin.dialects.py.cmp.stmts","text":""},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.Cmp","title":"Cmp  <code>kirin-statement</code>","text":"<pre><code>Cmp(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.Cmp.lhs","title":"lhs  <code>kirin-argument</code>","text":"<pre><code>lhs: SSAValue = argument()\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.Cmp.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(Bool)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.Cmp.rhs","title":"rhs  <code>kirin-argument</code>","text":"<pre><code>rhs: SSAValue = argument()\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.Cmp.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({Pure(), FromPythonCall()})\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.Eq","title":"Eq  <code>kirin-statement</code>","text":"<pre><code>Eq(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Cmp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.Eq.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'eq'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.Gt","title":"Gt  <code>kirin-statement</code>","text":"<pre><code>Gt(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Cmp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.Gt.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'gt'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.GtE","title":"GtE  <code>kirin-statement</code>","text":"<pre><code>GtE(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Cmp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.GtE.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'gte'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.In","title":"In  <code>kirin-statement</code>","text":"<pre><code>In(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Cmp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.In.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'in'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.Is","title":"Is  <code>kirin-statement</code>","text":"<pre><code>Is(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Cmp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.Is.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'is'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.IsNot","title":"IsNot  <code>kirin-statement</code>","text":"<pre><code>IsNot(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Cmp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.IsNot.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'is_not'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.Lt","title":"Lt  <code>kirin-statement</code>","text":"<pre><code>Lt(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Cmp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.Lt.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'lt'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.LtE","title":"LtE  <code>kirin-statement</code>","text":"<pre><code>LtE(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Cmp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.LtE.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'lte'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.NotEq","title":"NotEq  <code>kirin-statement</code>","text":"<pre><code>NotEq(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Cmp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.NotEq.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'ne'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.NotIn","title":"NotIn  <code>kirin-statement</code>","text":"<pre><code>NotIn(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Cmp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.NotIn.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'not_in'\n</code></pre>"},{"location":"dialects/python/data/","title":"Data","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"dialects/python/data/#dialects-that-brings-in-common-python-data-types","title":"Dialects that brings in common Python data types","text":"<p>This page provides a reference for dialects that bring in semantics for common Python data types.</p> <p>Note</p> <p>While it is worth noting that using Python semantics can be very convenient, it is also important to remember that the Python semantics are not designed for compilation. Therefore, it is important to be aware of the limitations of using Python semantics in a compilation context especially when it comes to data types. An example of this is the <code>list</code> data type in Python which is a dynamic mutable array. When the low-level code is not expecting a dynamic mutable array, it can lead to extra complexity for compilation. An immutable array or a fixed-size array can be a better choice in such cases (see <code>ilist</code> dialect).</p>"},{"location":"dialects/python/data/#references","title":"References","text":""},{"location":"dialects/python/data/#tuple","title":"Tuple","text":""},{"location":"dialects/python/data/#kirin.dialects.py.tuple","title":"kirin.dialects.py.tuple","text":"<p>The tuple dialect for Python.</p> <p>This dialect provides a way to work with Python tuples in the IR, including:</p> <ul> <li>The <code>New</code> statement class.</li> <li>The lowering pass for the tuple statement.</li> <li>The concrete implementation of the tuple statement.</li> <li>The type inference implementation of the tuple addition with <code>py.binop.Add</code>.</li> <li>The constant propagation implementation of the tuple statement.</li> <li>The Julia emitter for the tuple statement.</li> </ul> <p>This dialect maps <code>ast.Tuple</code> nodes to the <code>New</code> statement.</p>"},{"location":"dialects/python/data/#kirin.dialects.py.tuple.dialect","title":"dialect  <code>module-attribute</code>","text":"<pre><code>dialect = Dialect('py.tuple')\n</code></pre>"},{"location":"dialects/python/data/#kirin.dialects.py.tuple.Concrete","title":"Concrete  <code>dataclass</code>","text":"<pre><code>Concrete()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/data/#kirin.dialects.py.tuple.Concrete.new","title":"new","text":"<pre><code>new(\n    interp: interp.Interpreter,\n    frame: interp.Frame,\n    stmt: New,\n)\n</code></pre> Source code in <code>src/kirin/dialects/py/tuple.py</code> <pre><code>@interp.impl(New)\ndef new(self, interp: interp.Interpreter, frame: interp.Frame, stmt: New):\n    return (frame.get_values(stmt.args),)\n</code></pre>"},{"location":"dialects/python/data/#kirin.dialects.py.tuple.ConstPropTable","title":"ConstPropTable  <code>dataclass</code>","text":"<pre><code>ConstPropTable()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/data/#kirin.dialects.py.tuple.ConstPropTable.new_tuple","title":"new_tuple","text":"<pre><code>new_tuple(\n    _: const.Propagate, frame: const.Frame, stmt: New\n) -&gt; interp.StatementResult[const.Result]\n</code></pre> Source code in <code>src/kirin/dialects/py/tuple.py</code> <pre><code>@interp.impl(New)\ndef new_tuple(\n    self,\n    _: const.Propagate,\n    frame: const.Frame,\n    stmt: New,\n) -&gt; interp.StatementResult[const.Result]:\n    return (const.PartialTuple(tuple(x for x in frame.get_values(stmt.args))),)\n</code></pre>"},{"location":"dialects/python/data/#kirin.dialects.py.tuple.JuliaTable","title":"JuliaTable  <code>dataclass</code>","text":"<pre><code>JuliaTable()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/data/#kirin.dialects.py.tuple.JuliaTable.emit_NewTuple","title":"emit_NewTuple","text":"<pre><code>emit_NewTuple(\n    emit: EmitJulia, frame: EmitStrFrame, stmt: New\n)\n</code></pre> Source code in <code>src/kirin/dialects/py/tuple.py</code> <pre><code>@interp.impl(New)\ndef emit_NewTuple(self, emit: EmitJulia, frame: EmitStrFrame, stmt: New):\n    return (\n        emit.write_assign(\n            frame, stmt.result, \"(\" + \", \".join(frame.get_values(stmt.args)) + \")\"\n        ),\n    )\n</code></pre>"},{"location":"dialects/python/data/#kirin.dialects.py.tuple.Lowering","title":"Lowering  <code>dataclass</code>","text":"<pre><code>Lowering()\n</code></pre> <p>               Bases: <code>FromPythonAST</code></p>"},{"location":"dialects/python/data/#kirin.dialects.py.tuple.Lowering.lower_Tuple","title":"lower_Tuple","text":"<pre><code>lower_Tuple(\n    state: lowering.State, node: ast.Tuple\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/tuple.py</code> <pre><code>def lower_Tuple(self, state: lowering.State, node: ast.Tuple) -&gt; lowering.Result:\n    return state.current_frame.push(\n        New(tuple(state.lower(elem).expect_one() for elem in node.elts))\n    )\n</code></pre>"},{"location":"dialects/python/data/#kirin.dialects.py.tuple.New","title":"New  <code>kirin-statement</code>","text":"<pre><code>New(values: tuple[ir.SSAValue, ...])\n</code></pre> <p>               Bases: <code>Statement</code></p> Source code in <code>src/kirin/dialects/py/tuple.py</code> <pre><code>def __init__(self, values: tuple[ir.SSAValue, ...]) -&gt; None:\n    result_type = types.Generic(tuple, *tuple(value.type for value in values))\n    super().__init__(\n        args=values,\n        result_types=[\n            result_type,\n        ],\n    )\n</code></pre>"},{"location":"dialects/python/data/#kirin.dialects.py.tuple.New.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result()\n</code></pre>"},{"location":"dialects/python/data/#kirin.dialects.py.tuple.New.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({Pure(), FromPythonCall()})\n</code></pre>"},{"location":"dialects/python/data/#kirin.dialects.py.tuple.TypeInfer","title":"TypeInfer  <code>dataclass</code>","text":"<pre><code>TypeInfer()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/data/#kirin.dialects.py.tuple.TypeInfer.add","title":"add","text":"<pre><code>add(interp, frame: interp.Frame[types.TypeAttribute], stmt)\n</code></pre> Source code in <code>src/kirin/dialects/py/tuple.py</code> <pre><code>@interp.impl(Add, types.PyClass(tuple), types.PyClass(tuple))\ndef add(self, interp, frame: interp.Frame[types.TypeAttribute], stmt):\n    lhs = frame.get(stmt.lhs)\n    rhs = frame.get(stmt.rhs)\n    if isinstance(lhs, types.Generic) and isinstance(rhs, types.Generic):\n        return (types.Generic(tuple, *(lhs.vars + rhs.vars)),)\n    else:\n        return (types.PyClass(tuple),)  # no type param, so unknown\n</code></pre>"},{"location":"dialects/python/data/#kirin.dialects.py.tuple.TypeInfer.eltype_tuple","title":"eltype_tuple","text":"<pre><code>eltype_tuple(interp, frame: interp.Frame, stmt: ElType)\n</code></pre> Source code in <code>src/kirin/dialects/py/tuple.py</code> <pre><code>@interp.impl(ElType, types.PyClass(tuple))\ndef eltype_tuple(self, interp, frame: interp.Frame, stmt: ElType):\n    tuple_type = frame.get(stmt.container)\n    if isinstance(tuple_type, types.Generic):\n        ret = tuple_type.vars[0]\n        for var in tuple_type.vars[1:]:\n            ret = ret.join(var)\n        return (ret,)\n    else:\n        return (types.Any,)\n</code></pre>"},{"location":"dialects/python/data/#list","title":"List","text":""},{"location":"dialects/python/data/#kirin.dialects.py.list","title":"kirin.dialects.py.list","text":"<p>The list dialect for Python.</p> <p>This module contains the dialect for list semantics in Python, including:</p> <ul> <li>The <code>New</code> and <code>Append</code> statement classes.</li> <li>The lowering pass for list operations.</li> <li>The concrete implementation of list operations.</li> <li>The type inference implementation of list operations.</li> </ul> <p>This dialect maps <code>list()</code>, <code>ast.List</code> and <code>append()</code> calls to the <code>New</code> and <code>Append</code> statements.</p>"},{"location":"dialects/python/sfunc/","title":"Special Functions","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"dialects/python/sfunc/#dialects-for-special-python-functions","title":"Dialects for special Python functions","text":"<p>There are some special built-in Python functions that does not necessarily provide new data types when using them as Kirin dialects.</p> <p>For example, the <code>py.range</code> dialect may not use a Python <code>range</code> type, the actual type can be decided by another dialect that implements the type inference method for <code>Range</code> statement, e.g <code>ilist</code> dialect provides an <code>IList</code> implementation for <code>Range</code> statement.</p> <p>The reason for this is that in many cases, eDSLs are not interested in the actual data type of the result, but rather the semantics of the operation. For <code>ilist</code> dialect, the <code>Range</code> statement is just a syntax sugar for creating a list of integers. The compiler will decide what the actual implementation (such as the memory layout) of the list should be.</p>"},{"location":"dialects/python/sfunc/#references","title":"References","text":""},{"location":"dialects/python/sfunc/#iterable","title":"Iterable","text":""},{"location":"dialects/python/sfunc/#kirin.dialects.py.iterable","title":"kirin.dialects.py.iterable","text":"<p>This module provides access to Python iterables.</p> <p>This is used to lower Python loops into <code>cf</code> dialect.</p> <p>This module contains the common methods for the Python iterable:</p> <ul> <li>The <code>Iter</code> statement class.</li> <li>The <code>Next</code> statement class.</li> <li>The lowering pass for the iterable.</li> <li>The concrete implementation of the iterable.</li> </ul> <p>This dialect maps <code>iter()</code> and <code>next()</code> calls to the <code>Iter</code> and <code>Next</code> statements.</p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.iterable.PyRangeIterType","title":"PyRangeIterType  <code>module-attribute</code>","text":"<pre><code>PyRangeIterType = PyClass(type(iter(range(0))))\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.iterable.dialect","title":"dialect  <code>module-attribute</code>","text":"<pre><code>dialect = Dialect('py.iterable')\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.iterable.Concrete","title":"Concrete  <code>dataclass</code>","text":"<pre><code>Concrete()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.iterable.Concrete.iter_","title":"iter_","text":"<pre><code>iter_(interp, frame: interp.Frame, stmt: Iter)\n</code></pre> Source code in <code>src/kirin/dialects/py/iterable.py</code> <pre><code>@interp.impl(Iter)\ndef iter_(self, interp, frame: interp.Frame, stmt: Iter):\n    return (iter(frame.get(stmt.value)),)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.iterable.Concrete.next_","title":"next_","text":"<pre><code>next_(interp, frame: interp.Frame, stmt: Next)\n</code></pre> Source code in <code>src/kirin/dialects/py/iterable.py</code> <pre><code>@interp.impl(Next)\ndef next_(self, interp, frame: interp.Frame, stmt: Next):\n    return (next(frame.get(stmt.iter), None),)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.iterable.Iter","title":"Iter  <code>kirin-statement</code>","text":"<pre><code>Iter(value: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>This is equivalent to <code>iter(value)</code> in Python.</p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.iterable.Iter.iter","title":"iter  <code>kirin-result</code>","text":"<pre><code>iter: ResultValue = result(Any)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.iterable.Iter.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({Pure()})\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.iterable.Iter.value","title":"value  <code>kirin-argument</code>","text":"<pre><code>value: SSAValue = argument(Any)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.iterable.Lowering","title":"Lowering  <code>dataclass</code>","text":"<pre><code>Lowering()\n</code></pre> <p>               Bases: <code>FromPythonAST</code></p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.iterable.Lowering.lower_Call_iter","title":"lower_Call_iter","text":"<pre><code>lower_Call_iter(\n    state: lowering.State, node: Call\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/iterable.py</code> <pre><code>@lowering.akin(iter)\ndef lower_Call_iter(self, state: lowering.State, node: Call) -&gt; lowering.Result:\n    if len(node.args) != 1:\n        raise lowering.BuildError(\"iter() takes exactly 1 argument\")\n    return state.current_frame.push(\n        Iter(state.lower(node.args[0]).expect_one()),\n    )\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.iterable.Lowering.lower_Call_next","title":"lower_Call_next","text":"<pre><code>lower_Call_next(\n    state: lowering.State, node: Call\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/iterable.py</code> <pre><code>@lowering.akin(next)\ndef lower_Call_next(self, state: lowering.State, node: Call) -&gt; lowering.Result:\n    if len(node.args) == 2:\n        raise lowering.BuildError(\n            \"next() does not throw StopIteration inside kernel\"\n        )\n    if len(node.args) != 1:\n        raise lowering.BuildError(\"next() takes exactly 1 argument\")\n\n    return state.current_frame.push(\n        Next(state.lower(node.args[0]).expect_one()),\n    )\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.iterable.Next","title":"Next  <code>kirin-statement</code>","text":"<pre><code>Next(iter: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>This is equivalent to <code>next(iterable, None)</code> in Python.</p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.iterable.Next.iter","title":"iter  <code>kirin-argument</code>","text":"<pre><code>iter: SSAValue = argument(Any)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.iterable.Next.value","title":"value  <code>kirin-result</code>","text":"<pre><code>value: ResultValue = result(Any)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.iterable.TypeInfer","title":"TypeInfer  <code>dataclass</code>","text":"<pre><code>TypeInfer()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.iterable.TypeInfer.iter_","title":"iter_","text":"<pre><code>iter_(interp, frame: interp.Frame, stmt: Iter)\n</code></pre> Source code in <code>src/kirin/dialects/py/iterable.py</code> <pre><code>@interp.impl(Iter, types.PyClass(range))\ndef iter_(self, interp, frame: interp.Frame, stmt: Iter):\n    return (PyRangeIterType,)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.iterable.TypeInfer.next_","title":"next_","text":"<pre><code>next_(interp, frame: interp.Frame, stmt: Next)\n</code></pre> Source code in <code>src/kirin/dialects/py/iterable.py</code> <pre><code>@interp.impl(Next, PyRangeIterType)\ndef next_(self, interp, frame: interp.Frame, stmt: Next):\n    return (types.Int,)\n</code></pre>"},{"location":"dialects/python/sfunc/#len","title":"Len","text":""},{"location":"dialects/python/sfunc/#kirin.dialects.py.len","title":"kirin.dialects.py.len","text":"<p>The <code>Len</code> dialect.</p> <p>This dialect maps the <code>len()</code> call to the <code>Len</code> statement:</p> <ul> <li>The <code>Len</code> statement class.</li> <li>The lowering pass for the <code>len()</code> call.</li> <li>The concrete implementation of the <code>len()</code> call.</li> </ul>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.len.dialect","title":"dialect  <code>module-attribute</code>","text":"<pre><code>dialect = Dialect('py.len')\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.len.Concrete","title":"Concrete  <code>dataclass</code>","text":"<pre><code>Concrete()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.len.Concrete.len","title":"len","text":"<pre><code>len(interp, frame: interp.Frame, stmt: Len)\n</code></pre> Source code in <code>src/kirin/dialects/py/len.py</code> <pre><code>@interp.impl(Len)\ndef len(self, interp, frame: interp.Frame, stmt: Len):\n    return (len(frame.get(stmt.value)),)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.len.ConstProp","title":"ConstProp  <code>dataclass</code>","text":"<pre><code>ConstProp()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.len.ConstProp.len","title":"len","text":"<pre><code>len(interp, frame: interp.Frame, stmt: Len)\n</code></pre> Source code in <code>src/kirin/dialects/py/len.py</code> <pre><code>@interp.impl(Len)\ndef len(self, interp, frame: interp.Frame, stmt: Len):\n    value = frame.get(stmt.value)\n    if isinstance(value, const.Value):\n        return (const.Value(len(value.data)),)\n    elif isinstance(value, const.PartialTuple):\n        return (const.Value(len(value.data)),)\n    else:\n        return (const.Result.top(),)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.len.Len","title":"Len  <code>kirin-statement</code>","text":"<pre><code>Len(value: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.len.Len.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'len'\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.len.Len.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(Int)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.len.Len.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({Pure(), FromPythonCall()})\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.len.Len.value","title":"value  <code>kirin-argument</code>","text":"<pre><code>value: SSAValue = argument(Any)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.len.Lowering","title":"Lowering  <code>dataclass</code>","text":"<pre><code>Lowering()\n</code></pre> <p>               Bases: <code>FromPythonAST</code></p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.len.Lowering.lower_Call_len","title":"lower_Call_len","text":"<pre><code>lower_Call_len(\n    state: lowering.State, node: ast.Call\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/len.py</code> <pre><code>@lowering.akin(len)\ndef lower_Call_len(self, state: lowering.State, node: ast.Call) -&gt; lowering.Result:\n    return state.current_frame.push(Len(state.lower(node.args[0]).expect_one()))\n</code></pre>"},{"location":"dialects/python/sfunc/#range","title":"Range","text":""},{"location":"dialects/python/sfunc/#kirin.dialects.py.range","title":"kirin.dialects.py.range","text":"<p>The range dialect for Python.</p> <p>This dialect models the builtin <code>range()</code> function in Python.</p> <p>The dialect includes: - The <code>Range</code> statement class. - The lowering pass for the <code>range()</code> function.</p> <p>This dialect does not include a concrete implementation or type inference for the <code>range()</code> function. One needs to use other dialect for the concrete implementation and type inference, e.g., <code>ilist</code> dialect.</p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.range.dialect","title":"dialect  <code>module-attribute</code>","text":"<pre><code>dialect = Dialect('py.range')\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.range.Range","title":"Range  <code>kirin-statement</code>","text":"<pre><code>Range(\n    start: ir.SSAValue, stop: ir.SSAValue, step: ir.SSAValue\n)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.range.Range.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'range'\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.range.Range.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(PyClass(range))\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.range.Range.start","title":"start  <code>kirin-argument</code>","text":"<pre><code>start: SSAValue = argument(Int)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.range.Range.step","title":"step  <code>kirin-argument</code>","text":"<pre><code>step: SSAValue = argument(Int)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.range.Range.stop","title":"stop  <code>kirin-argument</code>","text":"<pre><code>stop: SSAValue = argument(Int)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.range.Range.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({Pure(), FromPythonRangeLike()})\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.range.TypeInfer","title":"TypeInfer  <code>dataclass</code>","text":"<pre><code>TypeInfer()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.range.TypeInfer.eltype_range","title":"eltype_range","text":"<pre><code>eltype_range(\n    interp_, frame: interp.Frame, stmt: eltype.ElType\n)\n</code></pre> Source code in <code>src/kirin/dialects/py/range.py</code> <pre><code>@interp.impl(eltype.ElType, types.PyClass(range))\ndef eltype_range(self, interp_, frame: interp.Frame, stmt: eltype.ElType):\n    return (types.Int,)\n</code></pre>"},{"location":"dialects/python/sfunc/#slice","title":"Slice","text":""},{"location":"dialects/python/sfunc/#kirin.dialects.py.slice","title":"kirin.dialects.py.slice","text":"<p>The slice dialect for Python.</p> <p>This dialect provides a <code>Slice</code> statement that represents a slice object in Python:</p> <ul> <li>The <code>Slice</code> statement class.</li> <li>The lowering pass for the <code>slice</code> call.</li> <li>The concrete implementation of the <code>slice</code> call.</li> <li>The type inference implementation of the <code>slice</code> call.</li> </ul>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.slice.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T')\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.slice.dialect","title":"dialect  <code>module-attribute</code>","text":"<pre><code>dialect = Dialect('py.slice')\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.slice.Concrete","title":"Concrete  <code>dataclass</code>","text":"<pre><code>Concrete()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.slice.Concrete._slice","title":"_slice","text":"<pre><code>_slice(interp, frame: interp.Frame, stmt: Slice)\n</code></pre> Source code in <code>src/kirin/dialects/py/slice.py</code> <pre><code>@interp.impl(Slice)\ndef _slice(self, interp, frame: interp.Frame, stmt: Slice):\n    start, stop, step = frame.get_values(stmt.args)\n    if start is None and step is None:\n        return (slice(stop),)\n    elif step is None:\n        return (slice(start, stop),)\n    else:\n        return (slice(start, stop, step),)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.slice.Lowering","title":"Lowering  <code>dataclass</code>","text":"<pre><code>Lowering()\n</code></pre> <p>               Bases: <code>FromPythonAST</code></p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.slice.Lowering.lower_Call_slice","title":"lower_Call_slice","text":"<pre><code>lower_Call_slice(\n    state: lowering.State, node: ast.Call\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/slice.py</code> <pre><code>@lowering.akin(slice)\ndef lower_Call_slice(\n    self, state: lowering.State, node: ast.Call\n) -&gt; lowering.Result:\n    return _lower_slice(state, node)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.slice.Lowering.lower_Slice","title":"lower_Slice","text":"<pre><code>lower_Slice(\n    state: lowering.State, node: ast.Slice\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/slice.py</code> <pre><code>def lower_Slice(self, state: lowering.State, node: ast.Slice) -&gt; lowering.Result:\n    def value_or_none(expr: ast.expr | None) -&gt; ir.SSAValue:\n        if expr is not None:\n            return state.lower(expr).expect_one()\n        else:\n            return state.current_frame.push(Constant(None)).result\n\n    lower = value_or_none(node.lower)\n    upper = value_or_none(node.upper)\n    step = value_or_none(node.step)\n\n    return state.current_frame.push(Slice(start=lower, stop=upper, step=step))\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.slice.Slice","title":"Slice  <code>kirin-statement</code>","text":"<pre><code>Slice(\n    start: ir.SSAValue, stop: ir.SSAValue, step: ir.SSAValue\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> Source code in <code>src/kirin/dialects/py/slice.py</code> <pre><code>def __init__(\n    self, start: ir.SSAValue, stop: ir.SSAValue, step: ir.SSAValue\n) -&gt; None:\n    if not (\n        isinstance(stop.type, types.TypeAttribute)\n        and isinstance(start.type, types.TypeAttribute)\n    ):\n        result_type = types.Bottom\n    elif start.type.is_subseteq(types.NoneType):\n        if stop.type.is_subseteq(types.NoneType):\n            result_type = types.Bottom\n        else:\n            result_type = types.Slice[stop.type]\n    else:\n        result_type = types.Slice[start.type]\n\n    super().__init__(\n        args=(start, stop, step),\n        result_types=[result_type],\n        args_slice={\"start\": 0, \"stop\": 1, \"step\": 2},\n    )\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.slice.Slice.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'slice'\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.slice.Slice.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(Slice[T])\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.slice.Slice.start","title":"start  <code>kirin-argument</code>","text":"<pre><code>start: SSAValue = argument(T | NoneType)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.slice.Slice.step","title":"step  <code>kirin-argument</code>","text":"<pre><code>step: SSAValue = argument(T | NoneType)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.slice.Slice.stop","title":"stop  <code>kirin-argument</code>","text":"<pre><code>stop: SSAValue = argument(T | NoneType)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.slice.Slice.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({Pure(), SliceLowering()})\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.slice.SliceLowering","title":"SliceLowering  <code>dataclass</code>","text":"<pre><code>SliceLowering()\n</code></pre> <p>               Bases: <code>FromPythonCall['Slice']</code></p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.slice.SliceLowering.lower","title":"lower","text":"<pre><code>lower(\n    stmt: type[Slice], state: lowering.State, node: ast.Call\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/slice.py</code> <pre><code>def lower(\n    self, stmt: type[\"Slice\"], state: lowering.State, node: ast.Call\n) -&gt; lowering.Result:\n    return _lower_slice(state, node)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.slice._lower_slice","title":"_lower_slice","text":"<pre><code>_lower_slice(\n    state: lowering.State, node: ast.Call\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/slice.py</code> <pre><code>def _lower_slice(state: lowering.State, node: ast.Call) -&gt; lowering.Result:\n    if len(node.args) == 1:\n        start = state.lower(ast.Constant(None)).expect_one()\n        stop = state.lower(node.args[0]).expect_one()\n        step = state.lower(ast.Constant(None)).expect_one()\n    elif len(node.args) == 2:\n        start = state.lower(node.args[0]).expect_one()\n        stop = state.lower(node.args[1]).expect_one()\n        step = state.lower(ast.Constant(None)).expect_one()\n    elif len(node.args) == 3:\n        start = state.lower(node.args[0]).expect_one()\n        stop = state.lower(node.args[1]).expect_one()\n        step = state.lower(node.args[2]).expect_one()\n    else:\n        raise lowering.BuildError(\"slice() takes 1-3 arguments\")\n\n    return state.current_frame.push(Slice(start, stop, step))\n</code></pre>"},{"location":"dialects/python/sfunc/#built-in-function","title":"Built-in Function","text":""},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin","title":"kirin.dialects.py.builtin","text":"<p>builtin dialect for python builtins</p> <p>This dialect provides implementations for builtin functions like abs and sum.</p> <ul> <li>Statements: <code>Abs</code>, <code>Sum</code>.</li> <li>The lowering pass for the builtin functions.</li> <li>The concrete implementation of the builtin functions.</li> <li>The type inference implementation of the builtin functions.</li> </ul> <p>This dialect maps <code>ast.Call</code> nodes of builtin functions to the <code>Abs</code> and <code>Sum</code> statements.</p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T', bound=Int | Float)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.dialect","title":"dialect  <code>module-attribute</code>","text":"<pre><code>dialect = Dialect('py.builtin')\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.Abs","title":"Abs  <code>kirin-statement</code>","text":"<pre><code>Abs(value: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.Abs.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'abs'\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.Abs.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(T)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.Abs.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({Pure(), FromPythonCall()})\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.Abs.value","title":"value  <code>kirin-argument</code>","text":"<pre><code>value: SSAValue = argument(T, print=False)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.Concrete","title":"Concrete  <code>dataclass</code>","text":"<pre><code>Concrete()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.Concrete._sum","title":"_sum","text":"<pre><code>_sum(interp, frame: interp.Frame, stmt: Sum)\n</code></pre> Source code in <code>src/kirin/dialects/py/builtin.py</code> <pre><code>@interp.impl(Sum)\ndef _sum(self, interp, frame: interp.Frame, stmt: Sum):\n    return (sum(frame.get(stmt.value)),)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.Concrete.abs","title":"abs","text":"<pre><code>abs(interp, frame: interp.Frame, stmt: Abs)\n</code></pre> Source code in <code>src/kirin/dialects/py/builtin.py</code> <pre><code>@interp.impl(Abs)\ndef abs(self, interp, frame: interp.Frame, stmt: Abs):\n    return (abs(frame.get(stmt.value)),)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.Lowering","title":"Lowering  <code>dataclass</code>","text":"<pre><code>Lowering()\n</code></pre> <p>               Bases: <code>FromPythonAST</code></p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.Lowering.lower_Call_abs","title":"lower_Call_abs","text":"<pre><code>lower_Call_abs(\n    state: lowering.State, node: Call\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/builtin.py</code> <pre><code>@lowering.akin(abs)\ndef lower_Call_abs(self, state: lowering.State, node: Call) -&gt; lowering.Result:\n    return state.current_frame.push(Abs(state.lower(node.args[0]).expect_one()))\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.Lowering.lower_Call_sum","title":"lower_Call_sum","text":"<pre><code>lower_Call_sum(\n    state: lowering.State, node: Call\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/builtin.py</code> <pre><code>@lowering.akin(sum)\ndef lower_Call_sum(self, state: lowering.State, node: Call) -&gt; lowering.Result:\n    return state.current_frame.push(Sum(state.lower(node.args[0]).expect_one()))\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.Sum","title":"Sum  <code>kirin-statement</code>","text":"<pre><code>Sum(value: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.Sum.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'sum'\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.Sum.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(Any)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.Sum.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({Pure(), FromPythonCall()})\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.Sum.value","title":"value  <code>kirin-argument</code>","text":"<pre><code>value: SSAValue = argument(Any, print=False)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.TypeInfer","title":"TypeInfer  <code>dataclass</code>","text":"<pre><code>TypeInfer()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.TypeInfer.absf","title":"absf","text":"<pre><code>absf(interp, frame, stmt)\n</code></pre> Source code in <code>src/kirin/dialects/py/builtin.py</code> <pre><code>@interp.impl(Abs, types.Float)\ndef absf(self, interp, frame, stmt):\n    return (types.Float,)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.TypeInfer.absi","title":"absi","text":"<pre><code>absi(interp, frame, stmt)\n</code></pre> Source code in <code>src/kirin/dialects/py/builtin.py</code> <pre><code>@interp.impl(Abs, types.Int)\ndef absi(self, interp, frame, stmt):\n    return (types.Int,)\n</code></pre>"},{"location":"dialects/python/sugar/","title":"Syntax Sugar","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"dialects/python/sugar/#dialects-for-python-syntax-sugar","title":"Dialects for Python Syntax Sugar","text":"<p>This page contains the dialects designed to represent Python syntax sugar. They provide an implementation of lowering transform from the corresponding Python AST to the dialects' statements. All the statements are typed <code>Any</code> thus one can always use a custom rewrite pass after type inference to support the desired syntax sugar.</p>"},{"location":"dialects/python/sugar/#reference","title":"Reference","text":""},{"location":"dialects/python/sugar/#indexing","title":"Indexing","text":""},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing","title":"kirin.dialects.py.indexing","text":"<p>The indexing dialect for Python.</p> <p>This module contains the dialect for the Python indexing syntax, including:</p> <ul> <li>The <code>GetItem</code> statement class.</li> <li>A base class <code>Subscript</code> for indexing statements.</li> <li>A trait <code>GetItemLike</code> for indexing statements.</li> <li>The lowering pass for the indexing statement.</li> <li>The concrete implementation of the indexing statement.</li> <li>The constant propagation implementation (special case) of the indexing statement.</li> <li>The type inference implementation of the indexing statement.</li> <li>A canonical rewrite rule for the rewriting of a given getitem-like     statement to another getitem-like statement.</li> </ul>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.GetItemLikeStmt","title":"GetItemLikeStmt  <code>module-attribute</code>","text":"<pre><code>GetItemLikeStmt = TypeVar(\n    \"GetItemLikeStmt\", bound=Statement\n)\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.PyGetItemLikeStmt","title":"PyGetItemLikeStmt  <code>module-attribute</code>","text":"<pre><code>PyGetItemLikeStmt = TypeVar(\n    \"PyGetItemLikeStmt\", bound=\"GetItem\"\n)\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.dialect","title":"dialect  <code>module-attribute</code>","text":"<pre><code>dialect = Dialect('py.indexing')\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.Concrete","title":"Concrete  <code>dataclass</code>","text":"<pre><code>Concrete()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.Concrete.getindex","title":"getindex","text":"<pre><code>getindex(interp, frame: interp.Frame, stmt: GetItem)\n</code></pre> Source code in <code>src/kirin/dialects/py/indexing.py</code> <pre><code>@interp.impl(GetItem)\ndef getindex(self, interp, frame: interp.Frame, stmt: GetItem):\n    return (frame.get(stmt.obj)[frame.get(stmt.index)],)\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.ConstProp","title":"ConstProp  <code>dataclass</code>","text":"<pre><code>ConstProp()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.ConstProp.getitem","title":"getitem","text":"<pre><code>getitem(\n    _: const.Propagate, frame: const.Frame, stmt: GetItem\n) -&gt; interp.StatementResult[const.Result]\n</code></pre> Source code in <code>src/kirin/dialects/py/indexing.py</code> <pre><code>@interp.impl(GetItem)\ndef getitem(\n    self,\n    _: const.Propagate,\n    frame: const.Frame,\n    stmt: GetItem,\n) -&gt; interp.StatementResult[const.Result]:\n    obj = frame.get(stmt.obj)\n    index = frame.get(stmt.index)\n    if not isinstance(index, const.Value):\n        return (const.Unknown(),)\n\n    if isinstance(obj, const.Value):\n        return (const.Value(obj.data[index.data]),)\n    elif isinstance(obj, const.PartialTuple):\n        obj = obj.data\n        if isinstance(index.data, int) and 0 &lt;= index.data &lt; len(obj):\n            return (obj[index.data],)\n        elif isinstance(index.data, slice):\n            start, stop, step = index.data.indices(len(obj))\n            return (const.PartialTuple(obj[start:stop:step]),)\n    return (const.Unknown(),)\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.GetItem","title":"GetItem  <code>kirin-statement</code>","text":"<pre><code>GetItem(obj: ir.SSAValue, index: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Subscript</code></p>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.GetItem.index","title":"index  <code>kirin-argument</code>","text":"<pre><code>index: SSAValue = argument(print=False)\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.GetItem.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'getitem'\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.GetItem.obj","title":"obj  <code>kirin-argument</code>","text":"<pre><code>obj: SSAValue = argument(print=False)\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.GetItem.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(Any)\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.GetItem.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset(\n    {Pure(), PyGetItemLike(), FromPythonCall()}\n)\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.GetItemLike","title":"GetItemLike  <code>dataclass</code>","text":"<pre><code>GetItemLike()\n</code></pre> <p>               Bases: <code>Trait[Statement]</code>, <code>Generic[GetItemLikeStmt]</code></p>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.GetItemLike.get_index","title":"get_index  <code>abstractmethod</code>","text":"<pre><code>get_index(stmt: GetItemLikeStmt) -&gt; ir.SSAValue\n</code></pre> Source code in <code>src/kirin/dialects/py/indexing.py</code> <pre><code>@abstractmethod\ndef get_index(self, stmt: GetItemLikeStmt) -&gt; ir.SSAValue: ...\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.GetItemLike.get_object","title":"get_object  <code>abstractmethod</code>","text":"<pre><code>get_object(stmt: GetItemLikeStmt) -&gt; ir.SSAValue\n</code></pre> Source code in <code>src/kirin/dialects/py/indexing.py</code> <pre><code>@abstractmethod\ndef get_object(self, stmt: GetItemLikeStmt) -&gt; ir.SSAValue: ...\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.GetItemLike.new","title":"new  <code>abstractmethod</code>","text":"<pre><code>new(\n    stmt_type: type[GetItemLikeStmt],\n    obj: ir.SSAValue,\n    index: ir.SSAValue,\n) -&gt; GetItemLikeStmt\n</code></pre> Source code in <code>src/kirin/dialects/py/indexing.py</code> <pre><code>@abstractmethod\ndef new(\n    self, stmt_type: type[GetItemLikeStmt], obj: ir.SSAValue, index: ir.SSAValue\n) -&gt; GetItemLikeStmt: ...\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.Lowering","title":"Lowering  <code>dataclass</code>","text":"<pre><code>Lowering()\n</code></pre> <p>               Bases: <code>FromPythonAST</code></p>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.Lowering.lower_Subscript","title":"lower_Subscript","text":"<pre><code>lower_Subscript(\n    state: lowering.State, node: ast.Subscript\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/indexing.py</code> <pre><code>def lower_Subscript(\n    self, state: lowering.State, node: ast.Subscript\n) -&gt; lowering.Result:\n    value = state.lower(node.value).expect_one()\n    slice = state.lower(node.slice).expect_one()\n    if isinstance(node.ctx, ast.Load):\n        stmt = GetItem(obj=value, index=slice)\n    else:\n        raise lowering.BuildError(f\"unsupported subscript context {node.ctx}\")\n    return state.current_frame.push(stmt)\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.PyGetItemLike","title":"PyGetItemLike  <code>dataclass</code>","text":"<pre><code>PyGetItemLike()\n</code></pre> <p>               Bases: <code>GetItemLike[PyGetItemLikeStmt]</code></p>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.PyGetItemLike.get_index","title":"get_index","text":"<pre><code>get_index(stmt: PyGetItemLikeStmt) -&gt; ir.SSAValue\n</code></pre> Source code in <code>src/kirin/dialects/py/indexing.py</code> <pre><code>def get_index(self, stmt: PyGetItemLikeStmt) -&gt; ir.SSAValue:\n    return stmt.index\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.PyGetItemLike.get_object","title":"get_object","text":"<pre><code>get_object(stmt: PyGetItemLikeStmt) -&gt; ir.SSAValue\n</code></pre> Source code in <code>src/kirin/dialects/py/indexing.py</code> <pre><code>def get_object(self, stmt: PyGetItemLikeStmt) -&gt; ir.SSAValue:\n    return stmt.obj\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.PyGetItemLike.new","title":"new","text":"<pre><code>new(\n    stmt_type: type[PyGetItemLikeStmt],\n    obj: ir.SSAValue,\n    index: ir.SSAValue,\n) -&gt; PyGetItemLikeStmt\n</code></pre> Source code in <code>src/kirin/dialects/py/indexing.py</code> <pre><code>def new(\n    self, stmt_type: type[PyGetItemLikeStmt], obj: ir.SSAValue, index: ir.SSAValue\n) -&gt; PyGetItemLikeStmt:\n    return stmt_type(obj=obj, index=index)\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.RewriteGetItem","title":"RewriteGetItem  <code>dataclass</code>","text":"<pre><code>RewriteGetItem(\n    stmt_type: type[GetItemLikeStmt],\n    obj_type: types.TypeAttribute,\n)\n</code></pre> <p>               Bases: <code>RewriteRule</code>, <code>Generic[GetItemLikeStmt]</code></p> Source code in <code>src/kirin/dialects/py/indexing.py</code> <pre><code>def __init__(self, stmt_type: type[GetItemLikeStmt], obj_type: types.TypeAttribute):\n    trait = stmt_type.get_trait(GetItemLike)\n    if trait is None:\n        raise ValueError(f\"{stmt_type} does not have GetItemLike trait\")\n\n    self.obj_type = obj_type\n    self.target_stmt_type = stmt_type\n    self.getitem_like = trait\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.RewriteGetItem.getitem_like","title":"getitem_like  <code>instance-attribute</code>","text":"<pre><code>getitem_like: GetItemLike[GetItemLikeStmt] = trait\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.RewriteGetItem.obj_type","title":"obj_type  <code>instance-attribute</code>","text":"<pre><code>obj_type: TypeAttribute = obj_type\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.RewriteGetItem.target_stmt_type","title":"target_stmt_type  <code>instance-attribute</code>","text":"<pre><code>target_stmt_type: type[GetItemLikeStmt] = stmt_type\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.RewriteGetItem.rewrite_Statement","title":"rewrite_Statement","text":"<pre><code>rewrite_Statement(node: ir.Statement) -&gt; RewriteResult\n</code></pre> Source code in <code>src/kirin/dialects/py/indexing.py</code> <pre><code>def rewrite_Statement(self, node: ir.Statement) -&gt; RewriteResult:\n    if not isinstance(node, GetItem):\n        return RewriteResult()\n\n    if not node.obj.type.is_subseteq(self.obj_type):\n        return RewriteResult()\n\n    node.replace_by(\n        self.getitem_like.new(self.target_stmt_type, node.obj, node.index)\n    )\n    return RewriteResult(has_done_something=True)\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.Subscript","title":"Subscript  <code>kirin-statement</code>","text":"<pre><code>Subscript()\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.TypeInfer","title":"TypeInfer  <code>dataclass</code>","text":"<pre><code>TypeInfer()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.TypeInfer.getitem","title":"getitem","text":"<pre><code>getitem(\n    interp: TypeInference,\n    frame: interp.Frame[types.TypeAttribute],\n    stmt: GetItem,\n)\n</code></pre> Source code in <code>src/kirin/dialects/py/indexing.py</code> <pre><code>@interp.impl(GetItem)\ndef getitem(\n    self,\n    interp: TypeInference,\n    frame: interp.Frame[types.TypeAttribute],\n    stmt: GetItem,\n):\n    obj = frame.get(stmt.obj)\n    index: types.TypeAttribute = frame.get(stmt.index)\n    # TODO: replace this when we can multiple dispatch\n    if obj.is_subseteq(types.Tuple):\n        return self.getitem_tuple(interp, stmt, obj, index)\n    elif obj.is_subseteq(types.String):\n        return (types.String,)\n    else:\n        return (types.Any,)\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.TypeInfer.getitem_tuple","title":"getitem_tuple","text":"<pre><code>getitem_tuple(\n    interp,\n    stmt: GetItem,\n    obj: types.TypeAttribute,\n    index: types.TypeAttribute,\n)\n</code></pre> Source code in <code>src/kirin/dialects/py/indexing.py</code> <pre><code>def getitem_tuple(\n    self,\n    interp,\n    stmt: GetItem,\n    obj: types.TypeAttribute,\n    index: types.TypeAttribute,\n):\n    if isinstance(obj, types.Generic):\n        if index.is_subseteq(types.Int):\n            return self.getitem_tuple_index(interp, stmt, obj, index)\n        elif index.is_subseteq(types.Slice):\n            return self.getitem_tuple_slice(interp, stmt, obj, index)\n        else:\n            return (types.Bottom,)\n    elif isinstance(obj, types.PyClass):\n        return (types.Any,)\n    else:\n        return (types.Bottom,)\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.TypeInfer.getitem_tuple_index","title":"getitem_tuple_index","text":"<pre><code>getitem_tuple_index(\n    interp: TypeInference,\n    stmt: GetItem,\n    obj: types.Generic,\n    index: types.TypeAttribute,\n)\n</code></pre> Source code in <code>src/kirin/dialects/py/indexing.py</code> <pre><code>def getitem_tuple_index(\n    self,\n    interp: TypeInference,\n    stmt: GetItem,\n    obj: types.Generic,\n    index: types.TypeAttribute,\n):\n    if index_ := interp.maybe_const(stmt.index, int):\n        if obj.vararg and (index_ &gt;= len(obj.vars) or -len(obj.vars) &lt;= index_ &lt; 0):\n            return (obj.vararg.typ,)\n        elif obj.vars and (\n            0 &lt;= index_ &lt; len(obj.vars) or -len(obj.vars) &lt;= index_ &lt; 0\n        ):\n            return (obj.vars[index_],)\n        else:\n            return (types.Bottom,)\n    else:\n        return (self.getitem_tuple_union(obj),)\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.TypeInfer.getitem_tuple_slice","title":"getitem_tuple_slice","text":"<pre><code>getitem_tuple_slice(\n    interp: TypeInference,\n    stmt: GetItem,\n    obj: types.Generic,\n    index: types.TypeAttribute,\n)\n</code></pre> Source code in <code>src/kirin/dialects/py/indexing.py</code> <pre><code>def getitem_tuple_slice(\n    self,\n    interp: TypeInference,\n    stmt: GetItem,\n    obj: types.Generic,\n    index: types.TypeAttribute,\n):\n    if index_ := interp.maybe_const(stmt.index, slice):\n        if obj.vararg and index_.stop &gt;= len(obj.vars):\n            return (\n                types.Union(\n                    *obj.vars[slice(index_.start, len(obj.vars), index_.step)],\n                    obj.vararg.typ,\n                ),\n            )\n        elif index_.stop is None or index_.stop &lt; len(obj.vars):\n            return (\n                types.Tuple.where(\n                    obj.vars[slice(index_.start, index_.stop, index_.step)]\n                ),\n            )\n        else:  # out of bounds\n            return (types.Bottom,)\n    else:\n        return (types.Tuple[types.Vararg(self.getitem_tuple_union(obj))],)\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.TypeInfer.getitem_tuple_union","title":"getitem_tuple_union","text":"<pre><code>getitem_tuple_union(obj: types.Generic)\n</code></pre> Source code in <code>src/kirin/dialects/py/indexing.py</code> <pre><code>def getitem_tuple_union(self, obj: types.Generic):\n    if obj.vararg:\n        return types.Union(*obj.vars, obj.vararg.typ)\n    else:\n        return types.Union(*obj.vars)\n</code></pre>"},{"location":"dialects/python/sugar/#attribute","title":"Attribute","text":""},{"location":"dialects/python/sugar/#kirin.dialects.py.attr","title":"kirin.dialects.py.attr","text":"<p>Attribute access dialect for Python.</p> <p>This module contains the dialect for the Python attribute access statement, including:</p> <ul> <li>The <code>GetAttr</code> statement class.</li> <li>The lowering pass for the attribute access statement.</li> <li>The concrete implementation of the attribute access statement.</li> </ul> <p>This dialect maps <code>ast.Attribute</code> nodes to the <code>GetAttr</code> statement.</p>"},{"location":"dialects/python/sugar/#kirin.dialects.py.attr.dialect","title":"dialect  <code>module-attribute</code>","text":"<pre><code>dialect = Dialect('py.attr')\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.attr.Concrete","title":"Concrete  <code>dataclass</code>","text":"<pre><code>Concrete()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/sugar/#kirin.dialects.py.attr.Concrete.getattr","title":"getattr","text":"<pre><code>getattr(\n    interp: interp.Interpreter,\n    frame: interp.Frame,\n    stmt: GetAttr,\n)\n</code></pre> Source code in <code>src/kirin/dialects/py/attr.py</code> <pre><code>@interp.impl(GetAttr)\ndef getattr(self, interp: interp.Interpreter, frame: interp.Frame, stmt: GetAttr):\n    return (getattr(frame.get(stmt.obj), stmt.attrname),)\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.attr.GetAttr","title":"GetAttr  <code>kirin-statement</code>","text":"<pre><code>GetAttr(obj: ir.SSAValue, *, attrname: str)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/python/sugar/#kirin.dialects.py.attr.GetAttr.attrname","title":"attrname  <code>kirin-attribute</code> <code>kw-only</code>","text":"<pre><code>attrname: str = attribute()\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.attr.GetAttr.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'getattr'\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.attr.GetAttr.obj","title":"obj  <code>kirin-argument</code>","text":"<pre><code>obj: SSAValue = argument(print=False)\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.attr.GetAttr.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result()\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.attr.GetAttr.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({FromPythonCall()})\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.attr.Lowering","title":"Lowering  <code>dataclass</code>","text":"<pre><code>Lowering()\n</code></pre> <p>               Bases: <code>FromPythonAST</code></p>"},{"location":"dialects/python/sugar/#kirin.dialects.py.attr.Lowering.lower_Attribute","title":"lower_Attribute","text":"<pre><code>lower_Attribute(\n    state: lowering.State, node: ast.Attribute\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/attr.py</code> <pre><code>def lower_Attribute(\n    self, state: lowering.State, node: ast.Attribute\n) -&gt; lowering.Result:\n\n    if not isinstance(node.ctx, ast.Load):\n        raise lowering.BuildError(f\"unsupported attribute context {node.ctx}\")\n\n    # NOTE: eagerly load global variables\n    value = state.get_global(node, no_raise=True)\n    if value is not None:\n        return state.lower(ast.Constant(value.data)).expect_one()\n\n    value = state.lower(node.value).expect_one()\n    return state.current_frame.push(GetAttr(obj=value, attrname=node.attr))\n</code></pre>"},{"location":"reference/kirin/","title":"Index","text":""},{"location":"reference/kirin/#kirin.disable_stracetrace","title":"disable_stracetrace","text":"<pre><code>disable_stracetrace()\n</code></pre> <p>Disable the stacktrace for all exceptions.</p> Source code in <code>src/kirin/exception.py</code> <pre><code>def disable_stracetrace():\n    \"\"\"Disable the stacktrace for all exceptions.\"\"\"\n    global stacktrace\n    stacktrace = False\n</code></pre>"},{"location":"reference/kirin/#kirin.enable_stracetrace","title":"enable_stracetrace","text":"<pre><code>enable_stracetrace()\n</code></pre> <p>Enable the stacktrace for all exceptions.</p> Source code in <code>src/kirin/exception.py</code> <pre><code>def enable_stracetrace():\n    \"\"\"Enable the stacktrace for all exceptions.\"\"\"\n    global stacktrace\n    stacktrace = True\n</code></pre>"},{"location":"reference/kirin/exception/","title":"Exception","text":"<p>This module contains custom exception handling for the Kirin-based compilers.</p>"},{"location":"reference/kirin/exception/#kirin.exception.disable_stracetrace","title":"disable_stracetrace","text":"<pre><code>disable_stracetrace()\n</code></pre> <p>Disable the stacktrace for all exceptions.</p> Source code in <code>src/kirin/exception.py</code> <pre><code>def disable_stracetrace():\n    \"\"\"Disable the stacktrace for all exceptions.\"\"\"\n    global stacktrace\n    stacktrace = False\n</code></pre>"},{"location":"reference/kirin/exception/#kirin.exception.enable_stracetrace","title":"enable_stracetrace","text":"<pre><code>enable_stracetrace()\n</code></pre> <p>Enable the stacktrace for all exceptions.</p> Source code in <code>src/kirin/exception.py</code> <pre><code>def enable_stracetrace():\n    \"\"\"Enable the stacktrace for all exceptions.\"\"\"\n    global stacktrace\n    stacktrace = True\n</code></pre>"},{"location":"reference/kirin/exception/#kirin.exception.exception_handler","title":"exception_handler","text":"<pre><code>exception_handler(\n    exc_type, exc_value, exc_tb: types.TracebackType\n)\n</code></pre> <p>Custom exception handler to format and print exceptions.</p> Source code in <code>src/kirin/exception.py</code> <pre><code>def exception_handler(exc_type, exc_value, exc_tb: types.TracebackType):\n    \"\"\"Custom exception handler to format and print exceptions.\"\"\"\n    if not stacktrace and issubclass(exc_type, NoPythonStackTrace):\n        print(\"\".join(msg for msg in exc_value.args), file=sys.stderr)\n        return\n\n    if not stacktrace and issubclass(exc_type, CustomStackTrace):\n        # Handle custom stack trace exceptions\n        exc_value.print_stacktrace()\n        return\n\n    # Call the default exception handler\n    sys.__excepthook__(exc_type, exc_value, exc_tb)\n</code></pre>"},{"location":"reference/kirin/graph/","title":"Graph","text":""},{"location":"reference/kirin/graph/#kirin.graph.Graph","title":"Graph","text":"<p>               Bases: <code>Protocol</code>, <code>Generic[Node]</code></p> <p>The graph interface.</p> <p>This interface defines the methods that a graph object must implement. The graph interface is mainly for compatibility reasons so that one can use multiple graph implementations interchangeably.</p>"},{"location":"reference/kirin/graph/#kirin.graph.Graph.get_edges","title":"get_edges","text":"<pre><code>get_edges() -&gt; Iterable[tuple[Node, Node]]\n</code></pre> <p>Get all the edges in the graph.</p> Source code in <code>src/kirin/graph.py</code> <pre><code>def get_edges(self) -&gt; Iterable[tuple[Node, Node]]:\n    \"\"\"Get all the edges in the graph.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/graph/#kirin.graph.Graph.get_neighbors","title":"get_neighbors","text":"<pre><code>get_neighbors(node: Node) -&gt; Iterable[Node]\n</code></pre> <p>Get the neighbors of a node.</p> Source code in <code>src/kirin/graph.py</code> <pre><code>def get_neighbors(self, node: Node) -&gt; Iterable[Node]:\n    \"\"\"Get the neighbors of a node.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/graph/#kirin.graph.Graph.get_nodes","title":"get_nodes","text":"<pre><code>get_nodes() -&gt; Iterable[Node]\n</code></pre> <p>Get all the nodes in the graph.</p> Source code in <code>src/kirin/graph.py</code> <pre><code>def get_nodes(self) -&gt; Iterable[Node]:\n    \"\"\"Get all the nodes in the graph.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/idtable/","title":"IdTable","text":""},{"location":"reference/kirin/idtable/#kirin.idtable.IdTable","title":"IdTable  <code>dataclass</code>","text":"<pre><code>IdTable(\n    prefix: str = \"%\",\n    table: dict[T, str] = dict(),\n    name_count: dict[str, int] = dict(),\n    next_id: int = 0,\n    prefix_if_none: str = \"\",\n)\n</code></pre> <p>               Bases: <code>Generic[T]</code></p> <p>A table that maps values to \"human readable\" unique names. This is used for IR printing and code generation of SSA values and basic blocks, or anything else required to have a unique name.</p>"},{"location":"reference/kirin/idtable/#kirin.idtable.IdTable--example","title":"Example","text":"<pre><code>from kirin import ir\nfrom kirin.idtable import IdTable\ntable = IdTable()\nx = ir.TestValue()\ntable[x] # \"%0\"\ntable[x] # \"%0\"\ny = ir.TestValue()\ntable[y] # \"%1\"\n</code></pre>"},{"location":"reference/kirin/idtable/#kirin.idtable.IdTable.name_count","title":"name_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name_count: dict[str, int] = field(default_factory=dict)\n</code></pre> <p>The count of names that have been generated.</p>"},{"location":"reference/kirin/idtable/#kirin.idtable.IdTable.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id: int = 0\n</code></pre> <p>The next ID to use for generating names.</p>"},{"location":"reference/kirin/idtable/#kirin.idtable.IdTable.prefix","title":"prefix  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>prefix: str = '%'\n</code></pre> <p>The prefix to use for generated names.</p>"},{"location":"reference/kirin/idtable/#kirin.idtable.IdTable.prefix_if_none","title":"prefix_if_none  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>prefix_if_none: str = ''\n</code></pre> <p>An alternate prefix to use when the name is None.</p>"},{"location":"reference/kirin/idtable/#kirin.idtable.IdTable.table","title":"table  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>table: dict[T, str] = field(default_factory=dict)\n</code></pre> <p>The table that maps values to names.</p>"},{"location":"reference/kirin/idtable/#kirin.idtable.IdTable.add","title":"add","text":"<pre><code>add(value: T) -&gt; str\n</code></pre> <p>Add a value to the table and return the name.</p> Source code in <code>src/kirin/idtable.py</code> <pre><code>def add(self, value: T) -&gt; str:\n    \"\"\"Add a value to the table and return the name.\"\"\"\n    id = self.next_id\n    if (value_name := getattr(value, \"name\", None)) is not None:\n        curr_ind = self.name_count.get(value_name, 0)\n        suffix = f\"_{curr_ind}\" if curr_ind != 0 else \"\"\n        self.name_count[value_name] = curr_ind + 1\n        name = self.prefix + value_name + suffix\n        self.table[value] = name\n    else:\n        name = f\"{self.prefix}{self.prefix_if_none}{id}\"\n        self.next_id += 1\n        self.table[value] = name\n    return name\n</code></pre>"},{"location":"reference/kirin/prelude/","title":"Prelude","text":"<p>This module contains some common eDSLs that can be used to build more complex eDSLs. The eDSLs in this module are built on top of the basic dialects provided by the <code>kirin.dialects</code> module.</p>"},{"location":"reference/kirin/prelude/#kirin.prelude.basic","title":"basic","text":"<pre><code>basic(self)\n</code></pre> <p>The basic kernel.</p> <p>This eDSL includes the basic dialects and the basic optimization passes. Other eDSL can usually be built on top of this eDSL by utilizing the <code>basic.add</code> method to add more dialects and optimization passes.</p> <p>See also <code>basic_no_opt</code> for the basic kernel without optimization passes.</p>"},{"location":"reference/kirin/prelude/#kirin.prelude.basic--example","title":"Example","text":"<pre><code>from kirin.prelude import basic\n\n@basic(typeinfer=True)\ndef main(x: int) -&gt; int:\n    return x + 1 + 1\n\nmain.print() # main is a Method!\n</code></pre> Source code in <code>src/kirin/prelude.py</code> <pre><code>@dialect_group(basic_no_opt)\ndef basic(self):\n    \"\"\"The basic kernel.\n\n    This eDSL includes the basic dialects and the basic optimization passes.\n    Other eDSL can usually be built on top of this eDSL by utilizing the\n    `basic.add` method to add more dialects and optimization passes.\n\n    See also [`basic_no_opt`][kirin.prelude.basic_no_opt] for the basic kernel without optimization passes.\n\n    ## Example\n\n    ```python\n    from kirin.prelude import basic\n\n    @basic(typeinfer=True)\n    def main(x: int) -&gt; int:\n        return x + 1 + 1\n\n    main.print() # main is a Method!\n    ```\n    \"\"\"\n\n    def run_pass(\n        mt: Annotated[Method, Doc(\"The method to run pass on.\")],\n        *,\n        verify: Annotated[\n            bool, Doc(\"run `verify` before running passes, default is `True`\")\n        ] = True,\n        typeinfer: Annotated[\n            bool,\n            Doc(\n                \"run type inference and apply the inferred type to IR, default `False`\"\n            ),\n        ] = False,\n        fold: Annotated[bool, Doc(\"run folding passes\")] = True,\n        aggressive: Annotated[\n            bool, Doc(\"run aggressive folding passes if `fold=True`\")\n        ] = False,\n        no_raise: Annotated[bool, Doc(\"do not raise exception during analysis\")] = True,\n    ) -&gt; None:\n        default_pass = Default(\n            self,\n            verify=verify,\n            fold=fold,\n            aggressive=aggressive,\n            typeinfer=typeinfer,\n            no_raise=no_raise,\n        )\n        default_pass.fixpoint(mt)\n\n    return run_pass\n</code></pre>"},{"location":"reference/kirin/prelude/#kirin.prelude.basic_no_opt","title":"basic_no_opt","text":"<pre><code>basic_no_opt(self)\n</code></pre> <p>The basic kernel without optimization passes. This is a builtin eDSL that includes the basic dialects that are commonly used in Python-like eDSLs.</p> <p>This eDSL includes the basic dialects without any optimization passes. Other eDSL can usually be built on top of this eDSL by utilizing the <code>basic_no_opt.add</code> method to add more dialects and optimization passes.</p> <p>Note that unlike Python, list in this eDSL is immutable, and the <code>append</code> method is not available. Use <code>+</code> operator to concatenate lists instead. Immutable list is easier to optimize and reason about.</p> <p>See also <code>basic</code> for the basic kernel with optimization passes. See also <code>ilist</code> for the immutable list dialect.</p> Source code in <code>src/kirin/prelude.py</code> <pre><code>@dialect_group(\n    python_basic.union(\n        [\n            ilist,\n            slice,\n            cf,\n            func,\n            math,\n            lowering.cf,\n            lowering.func,\n            lowering.call,\n            lowering.range.ilist,\n        ]\n    )\n)\ndef basic_no_opt(self):\n    \"\"\"The basic kernel without optimization passes. This is a builtin\n    eDSL that includes the basic dialects that are commonly used in\n    Python-like eDSLs.\n\n    This eDSL includes the basic dialects without any optimization passes.\n    Other eDSL can usually be built on top of this eDSL by utilizing the\n    `basic_no_opt.add` method to add more dialects and optimization passes.\n\n    Note that unlike Python, list in this eDSL is immutable, and the\n    `append` method is not available. Use `+` operator to concatenate lists\n    instead. Immutable list is easier to optimize and reason about.\n\n    See also [`basic`][kirin.prelude.basic] for the basic kernel with optimization passes.\n    See also [`ilist`][kirin.dialects.ilist] for the immutable list dialect.\n    \"\"\"\n    ilist_desugar = ilist.IListDesugar(self)\n\n    def run_pass(mt: Method) -&gt; None:\n        ilist_desugar.fixpoint(mt)\n\n    return run_pass\n</code></pre>"},{"location":"reference/kirin/prelude/#kirin.prelude.python_basic","title":"python_basic","text":"<pre><code>python_basic(self)\n</code></pre> <p>The basic Python dialect without list, range, and slice.</p> Source code in <code>src/kirin/prelude.py</code> <pre><code>@dialect_group(\n    [\n        base,\n        binop,\n        cmp,\n        unary,\n        assign,\n        attr,\n        boolop,\n        builtin,\n        constant,\n        indexing,\n        len,\n        tuple,\n        assertion,\n        iterable,\n    ]\n)\ndef python_basic(self):\n    \"\"\"The basic Python dialect without list, range, and slice.\"\"\"\n\n    def run_pass(mt: Method) -&gt; None:\n        pass\n\n    return run_pass\n</code></pre>"},{"location":"reference/kirin/prelude/#kirin.prelude.python_no_opt","title":"python_no_opt","text":"<pre><code>python_no_opt(self)\n</code></pre> <p>The Python dialect without optimization passes.</p> Source code in <code>src/kirin/prelude.py</code> <pre><code>@dialect_group(\n    python_basic.union(\n        [\n            list,\n            slice,\n            cf,\n            func,\n            lowering.cf,\n            lowering.func,\n            lowering.call,\n            lowering.range.ilist,\n            math,\n        ]\n    )\n)\ndef python_no_opt(self):\n    \"\"\"The Python dialect without optimization passes.\"\"\"\n\n    def run_pass(mt: Method) -&gt; None:\n        pass\n\n    return run_pass\n</code></pre>"},{"location":"reference/kirin/prelude/#kirin.prelude.structural","title":"structural","text":"<pre><code>structural(self)\n</code></pre> <p>Structural kernel with optimization passes.</p> Source code in <code>src/kirin/prelude.py</code> <pre><code>@dialect_group(\n    python_basic.union(\n        [\n            ilist,\n            slice,\n            scf,\n            cf,\n            func,\n            math,\n            lowering.func,\n            lowering.call,\n            lowering.range.ilist,\n        ]\n    )\n)\ndef structural(self):\n    \"\"\"Structural kernel with optimization passes.\"\"\"\n\n    def run_pass(\n        mt: Annotated[Method, Doc(\"The method to run pass on.\")],\n        *,\n        verify: Annotated[\n            bool, Doc(\"run `verify` before running passes, default is `True`\")\n        ] = True,\n        typeinfer: Annotated[\n            bool,\n            Doc(\n                \"run type inference and apply the inferred type to IR, default `False`\"\n            ),\n        ] = False,\n        fold: Annotated[bool, Doc(\"run folding passes\")] = True,\n        aggressive: Annotated[\n            bool, Doc(\"run aggressive folding passes if `fold=True`\")\n        ] = False,\n        no_raise: Annotated[bool, Doc(\"do not raise exception during analysis\")] = True,\n    ) -&gt; None:\n        default_pass = Default(\n            self,\n            verify=verify,\n            fold=fold,\n            aggressive=aggressive,\n            typeinfer=typeinfer,\n            no_raise=no_raise,\n        )\n        default_pass.fixpoint(mt)\n\n    return run_pass\n</code></pre>"},{"location":"reference/kirin/prelude/#kirin.prelude.structural_no_opt","title":"structural_no_opt","text":"<pre><code>structural_no_opt(self)\n</code></pre> <p>Structural kernel without optimization passes.</p> Source code in <code>src/kirin/prelude.py</code> <pre><code>@dialect_group(\n    python_basic.union(\n        [\n            ilist,\n            slice,\n            scf,\n            cf,\n            func,\n            math,\n            lowering.func,\n            lowering.call,\n            lowering.range.ilist,\n        ]\n    )\n)\ndef structural_no_opt(self):\n    \"\"\"Structural kernel without optimization passes.\"\"\"\n\n    def run_pass(method: Method) -&gt; None:\n        pass\n\n    return run_pass\n</code></pre>"},{"location":"reference/kirin/registry/","title":"Registry","text":""},{"location":"reference/kirin/registry/#kirin.registry.Registry","title":"Registry  <code>dataclass</code>","text":"<pre><code>Registry(dialects: DialectGroup)\n</code></pre> <p>Proxy class to build different registries from a dialect group.</p>"},{"location":"reference/kirin/registry/#kirin.registry.Registry.dialects","title":"dialects  <code>instance-attribute</code>","text":"<pre><code>dialects: DialectGroup\n</code></pre> <p>The dialect group to build the registry from.</p>"},{"location":"reference/kirin/registry/#kirin.registry.Registry.ast","title":"ast","text":"<pre><code>ast(keys: Iterable[str]) -&gt; LoweringRegistry\n</code></pre> <p>select the dialect lowering interpreters for the given key.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>Iterable[str]</code> <p>the keys to search for in the dialects</p> required <p>Returns:</p> Type Description <code>LoweringRegistry</code> <p>a map of dialects to their lowering interpreters</p> Source code in <code>src/kirin/registry.py</code> <pre><code>def ast(self, keys: Iterable[str]) -&gt; LoweringRegistry:\n    \"\"\"select the dialect lowering interpreters for the given key.\n\n    Args:\n        keys (Iterable[str]): the keys to search for in the dialects\n\n    Returns:\n        a map of dialects to their lowering interpreters\n    \"\"\"\n    ret: dict[str, \"FromPythonAST\"] = {}\n    callee_table: dict[object, CallLoweringFunction] = {}\n    from_ast = None\n    for dialect in self.dialects.data:\n        for key in keys:\n            if key in dialect.lowering:\n                from_ast = dialect.lowering[key]\n                break\n\n        if from_ast is None:\n            msg = \",\".join(keys)\n            raise KeyError(f\"Lowering not found for {msg}\")\n\n        for name in from_ast.names:\n            if name.startswith(\"lower_Call_\"):\n                continue  # ignore the Call nodes\n            if name in ret:\n                raise KeyError(f\"Lowering {name} already exists\")\n            ret[name] = from_ast\n\n        for obj, trans in from_ast.callee_table.items():\n            if obj in callee_table:\n                raise KeyError(f\"Lowering {obj} already exists\")\n            callee_table[obj] = CallLoweringFunction(from_ast, trans.func)\n    return LoweringRegistry(ret, callee_table)\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.Registry.interpreter","title":"interpreter","text":"<pre><code>interpreter(keys: Iterable[str]) -&gt; InterpreterRegistry\n</code></pre> <p>select the dialect interpreter for the given key.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>Iterable[str]</code> <p>the keys to search for in the dialects</p> required <p>Returns:</p> Type Description <code>InterpreterRegistry</code> <p>a map of statement signatures to their interpretation functions,</p> <code>InterpreterRegistry</code> <p>and a map of dialects to their fallback interpreters.</p> Source code in <code>src/kirin/registry.py</code> <pre><code>def interpreter(self, keys: Iterable[str]):\n    \"\"\"select the dialect interpreter for the given key.\n\n    Args:\n        keys (Iterable[str]): the keys to search for in the dialects\n\n    Returns:\n        a map of statement signatures to their interpretation functions,\n        and a map of dialects to their fallback interpreters.\n    \"\"\"\n    attributes: dict[type[\"Attribute\"], \"AttributeImpl\"] = {}\n    table: dict[\"Signature\", \"StatementImpl\"] = {}\n    for dialect in self.dialects.data:\n        dialect_table = None\n        for key in keys:\n            if key not in dialect.interps:\n                continue\n\n            dialect_table = dialect.interps[key]\n            for sig, func in dialect_table.attribute.items():\n                if sig not in attributes:\n                    attributes[sig] = AttributeImpl(dialect_table, func)\n\n            for sig, func in dialect_table.table.items():\n                if sig not in table:\n                    table[sig] = StatementImpl(dialect_table, func)\n\n    return InterpreterRegistry(attributes, table)\n</code></pre>"},{"location":"reference/kirin/source/","title":"Source","text":""},{"location":"reference/kirin/source/#kirin.source.SourceInfo","title":"SourceInfo  <code>dataclass</code>","text":"<pre><code>SourceInfo(\n    lineno: int,\n    col_offset: int,\n    end_lineno: int | None,\n    end_col_offset: int | None,\n    file: str | None = None,\n    lineno_offset: int = 0,\n)\n</code></pre>"},{"location":"reference/kirin/source/#kirin.source.SourceInfo.error_hint","title":"error_hint","text":"<pre><code>error_hint(\n    lines: list[str],\n    err: Exception,\n    *,\n    file: str | None = None,\n    indent: int = 2,\n    show_lineno: bool = True,\n    max_lines: int = 3\n) -&gt; str\n</code></pre> <p>Generate a hint for the error.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>list[str]</code> <p>The lines of code.</p> required <code>err</code> <code>Exception</code> <p>The error to display. If the error object has a <code>help</code> attribute, it will be used as the help message at the location of the error.</p> required <code>file</code> <code>str | None</code> <p>The name of the file.</p> <code>None</code> <code>indent</code> <code>int</code> <p>The indentation level.</p> <code>2</code> <code>show_lineno</code> <code>bool</code> <p>Whether to show the line number.</p> <code>True</code> <code>max_lines</code> <code>int</code> <p>The maximum number of lines to display.</p> <code>3</code> <code>lineno_offset</code> <code>int</code> <p>The offset for the line number.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The hint for the error.</p> Source code in <code>src/kirin/source.py</code> <pre><code>def error_hint(\n    self,\n    lines: list[str],\n    err: Exception,\n    *,\n    file: str | None = None,\n    indent: int = 2,\n    show_lineno: bool = True,\n    max_lines: int = 3,\n) -&gt; str:\n    \"\"\"Generate a hint for the error.\n\n    Args:\n        lines (list[str]): The lines of code.\n        err (Exception): The error to display. If the error object has a\n            `help` attribute, it will be used as the help message at the\n            location of the error.\n        file (str | None): The name of the file.\n        indent (int): The indentation level.\n        show_lineno (bool): Whether to show the line number.\n        max_lines (int): The maximum number of lines to display.\n        lineno_offset (int): The offset for the line number.\n\n    Returns:\n        str: The hint for the error.\n    \"\"\"\n    help = getattr(err, \"help\", None)\n    begin = max(0, self.lineno - max_lines - self.lineno_offset)\n    end = max(\n        max(self.lineno + max_lines, self.end_lineno or 0) - self.lineno_offset,\n        0,\n    )\n    end = min(len(lines), end)  # make sure end is within bounds\n    lines = lines[begin:end]\n    error_lineno = self.lineno - self.lineno_offset - 1\n    error_lineno_len = len(str(self.lineno))\n    code_indent = min(map(self.__get_indent, lines), default=0)\n\n    console = Console(force_terminal=True)\n    with console.capture() as capture:\n        console.print()\n        console.print(\n            f\"File: [dim]{file or 'stdin'}:{self.lineno}[/dim]\",\n            markup=True,\n            highlight=False,\n        )\n        emsg = \"\\n  \".join(err.args)\n        console.print(f\"[red]  {type(err).__name__}: {emsg}[/red]\")\n        for lineno, line in enumerate(lines, begin):\n            line = \" \" * indent + line[code_indent:]\n            if show_lineno:\n                if lineno == error_lineno:\n                    line = f\"{self.lineno}[dim]\u2502[/dim]\" + line\n                else:\n                    line = \"[dim]\" + \" \" * (error_lineno_len) + \"\u2502[/dim]\" + line\n            console.print(\"  \" + line, markup=True, highlight=False)\n            if lineno == error_lineno:\n                console.print(\n                    \"  \"\n                    + self.__arrow(\n                        code_indent, error_lineno_len, help, indent, show_lineno\n                    ),\n                    markup=True,\n                    highlight=False,\n                )\n\n        if end == error_lineno:\n            console.print(\n                \"  \"\n                + self.__arrow(\n                    code_indent, error_lineno_len, help, indent, show_lineno\n                ),\n                markup=True,\n                highlight=False,\n            )\n\n    return capture.get()\n</code></pre>"},{"location":"reference/kirin/source/#kirin.source.SourceInfo.offset","title":"offset","text":"<pre><code>offset(lineno_offset: int = 0, col_offset: int = 0)\n</code></pre> <p>Offset the source info by the given offsets.</p> <p>Parameters:</p> Name Type Description Default <code>lineno_offset</code> <code>int</code> <p>The line number offset.</p> <code>0</code> <code>col_offset</code> <code>int</code> <p>The column offset.</p> <code>0</code> Source code in <code>src/kirin/source.py</code> <pre><code>def offset(self, lineno_offset: int = 0, col_offset: int = 0):\n    \"\"\"Offset the source info by the given offsets.\n\n    Args:\n        lineno_offset (int): The line number offset.\n        col_offset (int): The column offset.\n    \"\"\"\n    self.lineno += lineno_offset\n    self.col_offset += col_offset\n    if self.end_lineno is not None:\n        self.end_lineno += lineno_offset\n    if self.end_col_offset is not None:\n        self.end_col_offset += col_offset\n    return self\n</code></pre>"},{"location":"reference/kirin/symbol_table/","title":"Symbol table","text":""},{"location":"reference/kirin/symbol_table/#kirin.symbol_table.SymbolTable","title":"SymbolTable  <code>dataclass</code>","text":"<pre><code>SymbolTable(\n    names: dict[str, T] = dict(),\n    *,\n    prefix: str = \"\",\n    name_count: dict[str, int] = dict()\n)\n</code></pre> <p>               Bases: <code>Generic[T]</code></p>"},{"location":"reference/kirin/symbol_table/#kirin.symbol_table.SymbolTable.name_count","title":"name_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name_count: dict[str, int] = field(\n    default_factory=dict, kw_only=True\n)\n</code></pre> <p>The count of names that have been requested.</p>"},{"location":"reference/kirin/symbol_table/#kirin.symbol_table.SymbolTable.names","title":"names  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>names: dict[str, T] = field(default_factory=dict)\n</code></pre> <p>The table that maps names to values.</p>"},{"location":"reference/kirin/types/","title":"Types","text":"<p>Bindings for built-in types.</p>"},{"location":"reference/kirin/worklist/","title":"WorkList","text":""},{"location":"reference/kirin/worklist/#kirin.worklist.WorkList","title":"WorkList  <code>dataclass</code>","text":"<pre><code>WorkList()\n</code></pre> <p>               Bases: <code>Generic[ElemType]</code></p> <p>The worklist data structure.</p> <p>The worklist is a stack that allows for O(1) removal of elements from the stack.</p>"},{"location":"reference/kirin/analysis/","title":"Index","text":"<p>Analysis module for kirin.</p> <p>This module contains the analysis framework for kirin. The analysis framework is built on top of the interpreter framework. This module provides a set of base classes and frameworks for implementing compiler analysis passes on the IR.</p> <p>The analysis framework contains the following modules:</p> <ul> <li><code>cfg</code>: Control flow graph for a given IR.</li> <li><code>forward</code>: Forward dataflow analysis.</li> <li><code>callgraph</code>: Call graph for a given IR.</li> <li><code>typeinfer</code>: Type inference analysis.</li> <li><code>const</code>: Constants used in the analysis framework.</li> </ul>"},{"location":"reference/kirin/analysis/callgraph/","title":"Call Graph","text":""},{"location":"reference/kirin/analysis/callgraph/#kirin.analysis.callgraph.CallGraph","title":"CallGraph  <code>dataclass</code>","text":"<pre><code>CallGraph(mt: ir.Method)\n</code></pre> <p>               Bases: <code>Printable</code></p> <p>Call graph for a given <code>ir.Method</code>.</p> <p>This class implements the <code>kirin.graph.Graph</code> protocol.</p> <p>Pretty Printing</p> <p>This object is pretty printable via <code>.print()</code> method.</p> Source code in <code>src/kirin/analysis/callgraph.py</code> <pre><code>def __init__(self, mt: ir.Method):\n    self.defs = {}\n    self.backedges = {}\n    self.__build(mt)\n</code></pre>"},{"location":"reference/kirin/analysis/callgraph/#kirin.analysis.callgraph.CallGraph.backedges","title":"backedges  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>backedges: dict[str, set[str]] = {}\n</code></pre> <p>Mapping from symbol names to backedges.</p>"},{"location":"reference/kirin/analysis/callgraph/#kirin.analysis.callgraph.CallGraph.defs","title":"defs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>defs: dict[str, Method] = {}\n</code></pre> <p>Mapping from symbol names to methods.</p>"},{"location":"reference/kirin/analysis/callgraph/#kirin.analysis.callgraph.CallGraph.get_edges","title":"get_edges","text":"<pre><code>get_edges() -&gt; Iterable[tuple[str, str]]\n</code></pre> <p>Get the edges of the call graph.</p> Source code in <code>src/kirin/analysis/callgraph.py</code> <pre><code>def get_edges(self) -&gt; Iterable[tuple[str, str]]:\n    \"\"\"Get the edges of the call graph.\"\"\"\n    for node, neighbors in self.backedges.items():\n        for neighbor in neighbors:\n            yield node, neighbor\n</code></pre>"},{"location":"reference/kirin/analysis/callgraph/#kirin.analysis.callgraph.CallGraph.get_neighbors","title":"get_neighbors","text":"<pre><code>get_neighbors(node: str) -&gt; Iterable[str]\n</code></pre> <p>Get the neighbors of a node in the call graph.</p> Source code in <code>src/kirin/analysis/callgraph.py</code> <pre><code>def get_neighbors(self, node: str) -&gt; Iterable[str]:\n    \"\"\"Get the neighbors of a node in the call graph.\"\"\"\n    return self.backedges.get(node, ())\n</code></pre>"},{"location":"reference/kirin/analysis/callgraph/#kirin.analysis.callgraph.CallGraph.get_nodes","title":"get_nodes","text":"<pre><code>get_nodes() -&gt; Iterable[str]\n</code></pre> <p>Get the nodes of the call graph.</p> Source code in <code>src/kirin/analysis/callgraph.py</code> <pre><code>def get_nodes(self) -&gt; Iterable[str]:\n    \"\"\"Get the nodes of the call graph.\"\"\"\n    return self.defs.keys()\n</code></pre>"},{"location":"reference/kirin/analysis/cfg/","title":"CFG","text":""},{"location":"reference/kirin/analysis/cfg/#kirin.analysis.cfg.CFG","title":"CFG  <code>dataclass</code>","text":"<pre><code>CFG(parent: ir.Region, entry: ir.Block | None = None)\n</code></pre> <p>               Bases: <code>Printable</code></p> <p>Control Flow Graph of a given IR statement.</p> <p>This class implements the <code>kirin.graph.Graph</code> protocol.</p> <p>Pretty Printing</p> <p>This object is pretty printable via <code>.print()</code> method.</p>"},{"location":"reference/kirin/analysis/cfg/#kirin.analysis.cfg.CFG.entry","title":"entry  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>entry: Block | None = None\n</code></pre> <p>Entry block of the CFG.</p>"},{"location":"reference/kirin/analysis/cfg/#kirin.analysis.cfg.CFG.parent","title":"parent  <code>instance-attribute</code>","text":"<pre><code>parent: Region\n</code></pre> <p>Parent IR statement.</p>"},{"location":"reference/kirin/analysis/cfg/#kirin.analysis.cfg.CFG.predecessors","title":"predecessors  <code>cached</code> <code>property</code>","text":"<pre><code>predecessors\n</code></pre> <p>CFG data, mapping a block to its predecessors.</p>"},{"location":"reference/kirin/analysis/cfg/#kirin.analysis.cfg.CFG.successors","title":"successors  <code>cached</code> <code>property</code>","text":"<pre><code>successors\n</code></pre> <p>CFG data, mapping a block to its neighbors.</p>"},{"location":"reference/kirin/analysis/forward/","title":"Forward Dataflow","text":""},{"location":"reference/kirin/analysis/forward/#kirin.analysis.forward.Forward","title":"Forward  <code>dataclass</code>","text":"<pre><code>Forward(\n    dialects: DialectGroup,\n    *,\n    fuel: int | None = None,\n    debug: bool = False,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192\n)\n</code></pre> <p>               Bases: <code>ForwardExtra[ForwardFrame[LatticeElemType], LatticeElemType]</code>, <code>ABC</code></p> <p>Forward dataflow analysis.</p> <p>This is the base class for forward dataflow analysis. If your analysis requires extra information per frame, you should subclass <code>ForwardExtra</code> instead.</p>"},{"location":"reference/kirin/analysis/forward/#kirin.analysis.forward.Forward.initialize_frame","title":"initialize_frame","text":"<pre><code>initialize_frame(\n    code: ir.Statement, *, has_parent_access: bool = False\n) -&gt; ForwardFrame[LatticeElemType]\n</code></pre> <p>Create a new frame for the given method.</p> Source code in <code>src/kirin/analysis/forward.py</code> <pre><code>def initialize_frame(\n    self, code: ir.Statement, *, has_parent_access: bool = False\n) -&gt; ForwardFrame[LatticeElemType]:\n    return ForwardFrame(code, has_parent_access=has_parent_access)\n</code></pre>"},{"location":"reference/kirin/analysis/forward/#kirin.analysis.forward.ForwardExtra","title":"ForwardExtra  <code>dataclass</code>","text":"<pre><code>ForwardExtra(\n    dialects: DialectGroup,\n    *,\n    fuel: int | None = None,\n    debug: bool = False,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192\n)\n</code></pre> <p>               Bases: <code>AbstractInterpreter[ForwardFrameType, LatticeElemType]</code>, <code>ABC</code></p> <p>Abstract interpreter but record results for each SSA value.</p> <p>Parameters:</p> Name Type Description Default <code>LatticeElemType</code> <p>The lattice element type.</p> required <code>ExtraType</code> <p>The type of extra information to be stored in the frame.</p> required"},{"location":"reference/kirin/analysis/forward/#kirin.analysis.forward.ForwardExtra.run_analysis","title":"run_analysis","text":"<pre><code>run_analysis(\n    method: ir.Method,\n    args: tuple[LatticeElemType, ...] | None = None,\n    *,\n    no_raise: bool = True\n) -&gt; tuple[ForwardFrameType, LatticeElemType]\n</code></pre> <p>Run the forward dataflow analysis.</p> <p>Parameters:</p> Name Type Description Default <code>method(ir.Method)</code> <p>The method to analyze.</p> required <code>args(tuple[LatticeElemType])</code> <p>The arguments to the method. Defaults to tuple of top values.</p> required <p>Other Parameters:</p> Name Type Description <code>no_raise(bool)</code> <p>If True, return bottom values if the analysis fails. Defaults to True.</p> <p>Returns:</p> Name Type Description <code>ForwardFrameType</code> <code>ForwardFrameType</code> <p>The results of the analysis contained in the frame.</p> <code>LatticeElemType</code> <code>LatticeElemType</code> <p>The result of the analysis for the method return value.</p> Source code in <code>src/kirin/analysis/forward.py</code> <pre><code>def run_analysis(\n    self,\n    method: ir.Method,\n    args: tuple[LatticeElemType, ...] | None = None,\n    *,\n    no_raise: bool = True,\n) -&gt; tuple[ForwardFrameType, LatticeElemType]:\n    \"\"\"Run the forward dataflow analysis.\n\n    Args:\n        method(ir.Method): The method to analyze.\n        args(tuple[LatticeElemType]): The arguments to the method. Defaults to tuple of top values.\n\n    Keyword Args:\n        no_raise(bool): If True, return bottom values if the analysis fails. Defaults to True.\n\n    Returns:\n        ForwardFrameType: The results of the analysis contained in the frame.\n        LatticeElemType: The result of the analysis for the method return value.\n    \"\"\"\n    args = args or tuple(self.lattice.top() for _ in method.args)\n\n    if self._eval_lock:\n        raise interp.InterpreterError(\n            \"recursive eval is not allowed, use run_method instead\"\n        )\n\n    self._eval_lock = True\n    self.initialize()\n    current_recursion_limit = sys.getrecursionlimit()\n    sys.setrecursionlimit(self.max_python_recursion_depth)\n    try:\n        frame, ret = self.run_method(method, args)\n    except Exception as e:\n        # NOTE: initialize will create new State\n        # so we don't need to copy the frames.\n        if not no_raise:\n            raise e\n        return self.state.current_frame, self.lattice.bottom()\n    finally:\n        self._eval_lock = False\n        sys.setrecursionlimit(current_recursion_limit)\n    return frame, ret\n</code></pre>"},{"location":"reference/kirin/analysis/forward/#kirin.analysis.forward.ForwardExtra.set_values","title":"set_values","text":"<pre><code>set_values(\n    frame: AbstractFrame[LatticeElemType],\n    ssa: Iterable[ir.SSAValue],\n    results: Iterable[LatticeElemType],\n)\n</code></pre> <p>Set the abstract values for the given SSA values in the frame.</p> <p>This method is used to customize how the abstract values are set in the frame. By default, the abstract values are set directly in the frame. This method is overridden to join the results if the SSA value already exists in the frame.</p> Source code in <code>src/kirin/analysis/forward.py</code> <pre><code>def set_values(\n    self,\n    frame: AbstractFrame[LatticeElemType],\n    ssa: Iterable[ir.SSAValue],\n    results: Iterable[LatticeElemType],\n):\n    \"\"\"Set the abstract values for the given SSA values in the frame.\n\n    This method is used to customize how the abstract values are set in\n    the frame. By default, the abstract values are set directly in the\n    frame. This method is overridden to join the results if the SSA value\n    already exists in the frame.\n    \"\"\"\n    for ssa_value, result in zip(ssa, results):\n        if ssa_value in frame.entries:\n            frame.entries[ssa_value] = frame.entries[ssa_value].join(result)\n        else:\n            frame.entries[ssa_value] = result\n</code></pre>"},{"location":"reference/kirin/analysis/const/","title":"Index","text":"<p>Const analysis module.</p> <p>This module contains the constant analysis framework for kirin. The constant analysis framework is built on top of the interpreter framework.</p> <p>This module provides a lattice for constant propagation analysis and a propagation algorithm for computing the constant values for each SSA value in the IR.</p>"},{"location":"reference/kirin/analysis/const/lattice/","title":"Lattice","text":"<p>Lattice for constant analysis.</p>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.Bottom","title":"Bottom  <code>dataclass</code>","text":"<pre><code>Bottom()\n</code></pre> <p>               Bases: <code>Result</code></p> <p>Bottom element of the lattice.</p>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.Bottom.is_subseteq","title":"is_subseteq","text":"<pre><code>is_subseteq(other: Result) -&gt; bool\n</code></pre> <p>Subseteq operation.</p> Source code in <code>src/kirin/analysis/const/lattice.py</code> <pre><code>def is_subseteq(self, other: Result) -&gt; bool:\n    return True\n</code></pre>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.PartialConst","title":"PartialConst  <code>dataclass</code>","text":"<pre><code>PartialConst()\n</code></pre> <p>               Bases: <code>Result</code></p> <p>Base class for partial constant values.</p>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.PartialLambda","title":"PartialLambda  <code>dataclass</code>","text":"<pre><code>PartialLambda(\n    argnames: list[str],\n    code: ir.Statement,\n    captured: tuple[Result, ...],\n)\n</code></pre> <p>               Bases: <code>PartialConst</code></p> <p>Partial lambda constant value.</p> <p>This represents a closure with captured variables.</p>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.PartialLambda.join","title":"join","text":"<pre><code>join(other: Result) -&gt; Result\n</code></pre> <p>Join operation.</p> Source code in <code>src/kirin/analysis/const/lattice.py</code> <pre><code>def join(self, other: Result) -&gt; Result:\n    if other is other.bottom():\n        return self\n\n    if not isinstance(other, PartialLambda):\n        return Unknown().join(other)  # widen self\n\n    if self.code is not other.code:\n        return Unknown()  # lambda stmt is pure\n\n    if len(self.captured) != len(other.captured):\n        return self.bottom()  # err\n\n    return PartialLambda(\n        self.argnames,\n        self.code,\n        tuple(x.join(y) for x, y in zip(self.captured, other.captured)),\n    )\n</code></pre>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.PartialLambda.meet","title":"meet","text":"<pre><code>meet(other: Result) -&gt; Result\n</code></pre> <p>Meet operation.</p> Source code in <code>src/kirin/analysis/const/lattice.py</code> <pre><code>def meet(self, other: Result) -&gt; Result:\n    if not isinstance(other, PartialLambda):\n        return Unknown().meet(other)\n\n    if self.code is not other.code:\n        return self.bottom()\n\n    if len(self.captured) != len(other.captured):\n        return Unknown()\n\n    return PartialLambda(\n        self.argnames,\n        self.code,\n        tuple(x.meet(y) for x, y in zip(self.captured, other.captured)),\n    )\n</code></pre>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.PartialTuple","title":"PartialTuple  <code>dataclass</code>","text":"<pre><code>PartialTuple(data: tuple[Result, ...])\n</code></pre> <p>               Bases: <code>PartialConst</code></p> <p>Partial tuple constant value.</p>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.PartialTuple.is_equal","title":"is_equal","text":"<pre><code>is_equal(other: Result) -&gt; bool\n</code></pre> <p>Check if two lattices are equal.</p> Source code in <code>src/kirin/analysis/const/lattice.py</code> <pre><code>def is_equal(self, other: Result) -&gt; bool:\n    if isinstance(other, PartialTuple):\n        return all(x.is_equal(y) for x, y in zip(self.data, other.data))\n    elif isinstance(other, Value) and isinstance(other.data, tuple):\n        return all(x.is_equal(Value(y)) for x, y in zip(self.data, other.data))\n    return False\n</code></pre>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.PartialTuple.join","title":"join","text":"<pre><code>join(other: Result) -&gt; Result\n</code></pre> <p>Join operation.</p> Source code in <code>src/kirin/analysis/const/lattice.py</code> <pre><code>def join(self, other: Result) -&gt; Result:\n    if other.is_subseteq(self):\n        return self\n    elif self.is_subseteq(other):\n        return other\n    elif isinstance(other, PartialTuple):\n        return PartialTuple(tuple(x.join(y) for x, y in zip(self.data, other.data)))\n    elif isinstance(other, Value) and isinstance(other.data, tuple):\n        return PartialTuple(\n            tuple(x.join(Value(y)) for x, y in zip(self.data, other.data))\n        )\n    return Unknown()\n</code></pre>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.PartialTuple.meet","title":"meet","text":"<pre><code>meet(other: Result) -&gt; Result\n</code></pre> <p>Meet operation.</p> Source code in <code>src/kirin/analysis/const/lattice.py</code> <pre><code>def meet(self, other: Result) -&gt; Result:\n    if self.is_subseteq(other):\n        return self\n    elif other.is_subseteq(self):\n        return other\n    elif isinstance(other, PartialTuple):\n        return PartialTuple(tuple(x.meet(y) for x, y in zip(self.data, other.data)))\n    elif isinstance(other, Value) and isinstance(other.data, tuple):\n        return PartialTuple(\n            tuple(x.meet(Value(y)) for x, y in zip(self.data, other.data))\n        )\n    return self.bottom()\n</code></pre>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.PartialTupleMeta","title":"PartialTupleMeta","text":"<p>               Bases: <code>LatticeAttributeMeta</code></p> <p>Metaclass for PartialTuple.</p> <p>This metaclass canonicalizes PartialTuple instances with all Value elements into a single Value instance.</p>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.Result","title":"Result  <code>dataclass</code>","text":"<pre><code>Result()\n</code></pre> <p>               Bases: <code>Attribute</code>, <code>IsSubsetEqMixin['Result']</code>, <code>SimpleJoinMixin['Result']</code>, <code>SimpleMeetMixin['Result']</code>, <code>BoundedLattice['Result']</code>, <code>_ElemVisitor</code></p> <p>Base class for constant analysis results.</p>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.Unknown","title":"Unknown  <code>dataclass</code>","text":"<pre><code>Unknown()\n</code></pre> <p>               Bases: <code>Result</code></p> <p>Unknown constant value. This is the top element of the lattice.</p>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.Unknown.is_subseteq","title":"is_subseteq","text":"<pre><code>is_subseteq(other: Result) -&gt; bool\n</code></pre> <p>Subseteq operation.</p> Source code in <code>src/kirin/analysis/const/lattice.py</code> <pre><code>def is_subseteq(self, other: Result) -&gt; bool:\n    return isinstance(other, Unknown)\n</code></pre>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.Value","title":"Value  <code>dataclass</code>","text":"<pre><code>Value(data: Any)\n</code></pre> <p>               Bases: <code>Result</code></p> <p>Constant value. Wraps any hashable Python value.</p>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.Value.is_equal","title":"is_equal","text":"<pre><code>is_equal(other: Result) -&gt; bool\n</code></pre> <p>Check if two lattices are equal.</p> Source code in <code>src/kirin/analysis/const/lattice.py</code> <pre><code>def is_equal(self, other: Result) -&gt; bool:\n    if isinstance(other, Value):\n        return self.data == other.data\n    return False\n</code></pre>"},{"location":"reference/kirin/analysis/const/prop/","title":"Prop","text":""},{"location":"reference/kirin/analysis/const/prop/#kirin.analysis.const.prop.Frame","title":"Frame  <code>dataclass</code>","text":"<pre><code>Frame(\n    code: Statement,\n    worklist: WorkList[Successor[ResultType]] = WorkList(),\n    visited: dict[\n        Block, set[Successor[ResultType]]\n    ] = dict(),\n    should_be_pure: set[ir.Statement] = set(),\n    frame_is_not_pure: bool = False,\n    *,\n    parent: Self | None = None,\n    has_parent_access: bool = False,\n    lineno_offset: int = 0,\n    globals: dict[str, Any] = dict(),\n    entries: dict[SSAValue, ValueType] = dict()\n)\n</code></pre> <p>               Bases: <code>ForwardFrame[Result]</code></p>"},{"location":"reference/kirin/analysis/const/prop/#kirin.analysis.const.prop.Frame.frame_is_not_pure","title":"frame_is_not_pure  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>frame_is_not_pure: bool = False\n</code></pre> <p>If we hit any non-pure statement.</p>"},{"location":"reference/kirin/analysis/const/prop/#kirin.analysis.const.prop.Frame.should_be_pure","title":"should_be_pure  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>should_be_pure: set[Statement] = field(default_factory=set)\n</code></pre> <p>If any ir.MaybePure is actually pure.</p>"},{"location":"reference/kirin/analysis/const/prop/#kirin.analysis.const.prop.Propagate","title":"Propagate  <code>dataclass</code>","text":"<pre><code>Propagate(\n    dialects: DialectGroup,\n    *,\n    fuel: int | None = None,\n    debug: bool = False,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192\n)\n</code></pre> <p>               Bases: <code>ForwardExtra[Frame, Result]</code></p> <p>Forward dataflow analysis for constant propagation.</p> <p>This analysis is a forward dataflow analysis that propagates constant values through the program. It uses the <code>Result</code> lattice to track the constant values and purity of the values.</p> <p>The analysis is implemented as a forward dataflow analysis, where the <code>eval_stmt</code> method is overridden to handle the different types of statements in the IR. The analysis uses the <code>interp.Interpreter</code> to evaluate the statements and propagate the constant values.</p> <p>When a statement is registered under the \"constprop\" key in the method table, the analysis will call the method to evaluate the statement instead of using the interpreter. This allows for custom handling of statements.</p>"},{"location":"reference/kirin/analysis/const/prop/#kirin.analysis.const.prop.Propagate.keys","title":"keys  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>keys = ['constprop']\n</code></pre> <p>The name of the interpreter to select from dialects by order.</p>"},{"location":"reference/kirin/analysis/const/prop/#kirin.analysis.const.prop.Propagate.lattice","title":"lattice  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lattice = Result\n</code></pre> <p>lattice type for the abstract interpreter.</p>"},{"location":"reference/kirin/analysis/const/prop/#kirin.analysis.const.prop.Propagate.eval_stmt","title":"eval_stmt","text":"<pre><code>eval_stmt(\n    frame: Frame, stmt: ir.Statement\n) -&gt; interp.StatementResult[Result]\n</code></pre> <p>Run a statement within the current frame. This is the entry point of running a statement. It will look up the statement implementation in the dialect registry, or optionally call a fallback implementation.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>FrameType</code> <p>the current frame</p> required <code>stmt</code> <code>Statement</code> <p>the statement to run</p> required <p>Returns:</p> Name Type Description <code>StatementResult</code> <code>StatementResult[ValueType]</code> <p>the result of running the statement</p> Note <p>Overload this method for the following reasons: - to change the source tracking information - to take control of how to run a statement - to change the implementation lookup behavior that cannot acheive     by overloading <code>lookup_registry</code></p> Example <ul> <li>implement an interpreter that only handles MyStmt: <pre><code>    class MyInterpreter(BaseInterpreter):\n        ...\n        def eval_stmt(self, frame: FrameType, stmt: Statement) -&gt; StatementResult[ValueType]:\n            if isinstance(stmt, MyStmt):\n                return self.run_my_stmt(frame, stmt)\n            else:\n                return ()\n</code></pre></li> </ul> Source code in <code>src/kirin/analysis/const/prop.py</code> <pre><code>def eval_stmt(\n    self, frame: Frame, stmt: ir.Statement\n) -&gt; interp.StatementResult[Result]:\n    method = self.lookup_registry(frame, stmt)\n    if method is None:\n        if stmt.has_trait(ir.ConstantLike):\n            return self.try_eval_const_pure(frame, stmt, ())\n        elif stmt.has_trait(ir.Pure):\n            values = frame.get_values(stmt.args)\n            if types.is_tuple_of(values, Value):\n                return self.try_eval_const_pure(frame, stmt, values)\n\n        if stmt.has_trait(ir.Pure):\n            return (Unknown(),)  # no implementation but pure\n        # not pure, and no implementation, let's say it's not pure\n        frame.frame_is_not_pure = True\n        return (Unknown(),)\n\n    ret = method(self, frame, stmt)\n    if stmt.has_trait(ir.IsTerminator) or stmt.has_trait(ir.Pure):\n        return ret\n    elif not stmt.has_trait(ir.MaybePure):  # cannot be pure at all\n        frame.frame_is_not_pure = True\n    elif (\n        stmt not in frame.should_be_pure\n    ):  # implementation cannot decide if it's pure\n        frame.frame_is_not_pure = True\n    return ret\n</code></pre>"},{"location":"reference/kirin/analysis/const/prop/#kirin.analysis.const.prop.Propagate.initialize","title":"initialize","text":"<pre><code>initialize()\n</code></pre> <p>Initialize the interpreter global states. This method is called right upon calling <code>run</code> to initialize the interpreter global states.</p> <p>Default Implementation</p> <p>This method provides default behavior but may be overridden by subclasses to customize or extend functionality.</p> Source code in <code>src/kirin/analysis/const/prop.py</code> <pre><code>def initialize(self):\n    super().initialize()\n    self._interp.initialize()\n    return self\n</code></pre>"},{"location":"reference/kirin/analysis/const/prop/#kirin.analysis.const.prop.Propagate.initialize_frame","title":"initialize_frame","text":"<pre><code>initialize_frame(\n    code: ir.Statement, *, has_parent_access: bool = False\n) -&gt; Frame\n</code></pre> <p>Create a new frame for the given method.</p> Source code in <code>src/kirin/analysis/const/prop.py</code> <pre><code>def initialize_frame(\n    self, code: ir.Statement, *, has_parent_access: bool = False\n) -&gt; Frame:\n    return Frame(code, has_parent_access=has_parent_access)\n</code></pre>"},{"location":"reference/kirin/analysis/const/prop/#kirin.analysis.const.prop.Propagate.run_method","title":"run_method","text":"<pre><code>run_method(\n    method: ir.Method, args: tuple[Result, ...]\n) -&gt; tuple[Frame, Result]\n</code></pre> <p>How to run a method.</p> <p>This is defined by subclasses to describe what's the corresponding value of a method during the interpretation. Usually, this method just calls <code>run_callable</code>.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Method</code> <p>the method to run.</p> required <code>args</code> <code>tuple[ValueType, ...]</code> <p>the arguments to the method, does not include self.</p> required <p>Returns:</p> Name Type Description <code>ValueType</code> <code>tuple[FrameType, ValueType]</code> <p>the result of the method.</p> Source code in <code>src/kirin/analysis/const/prop.py</code> <pre><code>def run_method(\n    self, method: ir.Method, args: tuple[Result, ...]\n) -&gt; tuple[Frame, Result]:\n    return self.run_callable(method.code, (Value(method),) + args)\n</code></pre>"},{"location":"reference/kirin/analysis/typeinfer/","title":"Index","text":"<p>Type inference analysis for kirin.</p>"},{"location":"reference/kirin/analysis/typeinfer/analysis/","title":"Analysis","text":""},{"location":"reference/kirin/analysis/typeinfer/analysis/#kirin.analysis.typeinfer.analysis.TypeInference","title":"TypeInference  <code>dataclass</code>","text":"<pre><code>TypeInference(\n    dialects: DialectGroup,\n    *,\n    fuel: int | None = None,\n    debug: bool = False,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192\n)\n</code></pre> <p>               Bases: <code>Forward[TypeAttribute]</code></p> <p>Type inference analysis for kirin.</p> <p>This analysis uses the forward dataflow analysis framework to infer the types of the IR. The analysis uses the type information within the IR to determine the method dispatch.</p> <p>The analysis will fallback to a type resolution algorithm if the type information is not available in the IR but the type information is available in the abstract values.</p>"},{"location":"reference/kirin/analysis/typeinfer/analysis/#kirin.analysis.typeinfer.analysis.TypeInference.keys","title":"keys  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>keys = ['typeinfer']\n</code></pre> <p>The name of the interpreter to select from dialects by order.</p>"},{"location":"reference/kirin/analysis/typeinfer/analysis/#kirin.analysis.typeinfer.analysis.TypeInference.lattice","title":"lattice  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lattice = TypeAttribute\n</code></pre> <p>lattice type for the abstract interpreter.</p>"},{"location":"reference/kirin/analysis/typeinfer/analysis/#kirin.analysis.typeinfer.analysis.TypeInference.build_signature","title":"build_signature","text":"<pre><code>build_signature(\n    frame: ForwardFrame[types.TypeAttribute],\n    stmt: ir.Statement,\n) -&gt; Signature\n</code></pre> <p>build signature for querying the statement implementation.</p> Source code in <code>src/kirin/analysis/typeinfer/analysis.py</code> <pre><code>def build_signature(\n    self, frame: ForwardFrame[types.TypeAttribute], stmt: ir.Statement\n) -&gt; Signature:\n    _args = ()\n    for x in frame.get_values(stmt.args):\n        # TODO: remove this after we have multiple dispatch...\n        if isinstance(x, types.Generic):\n            _args += (x.body,)\n        else:\n            _args += (x,)\n    return Signature(stmt.__class__, _args)\n</code></pre>"},{"location":"reference/kirin/analysis/typeinfer/analysis/#kirin.analysis.typeinfer.analysis.TypeInference.eval_stmt_fallback","title":"eval_stmt_fallback","text":"<pre><code>eval_stmt_fallback(\n    frame: ForwardFrame[types.TypeAttribute],\n    stmt: ir.Statement,\n) -&gt; (\n    tuple[types.TypeAttribute, ...]\n    | interp.SpecialValue[types.TypeAttribute]\n)\n</code></pre> <p>The fallback implementation of statements.</p> <p>This is called when no implementation is found for the statement.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>FrameType</code> <p>the current frame</p> required <code>stmt</code> <code>Statement</code> <p>the statement to run</p> required <p>Returns:</p> Name Type Description <code>StatementResult</code> <code>StatementResult[ValueType]</code> <p>the result of running the statement</p> Note <p>Overload this method to provide a fallback implementation for statements.</p> Source code in <code>src/kirin/analysis/typeinfer/analysis.py</code> <pre><code>def eval_stmt_fallback(\n    self, frame: ForwardFrame[types.TypeAttribute], stmt: ir.Statement\n) -&gt; tuple[types.TypeAttribute, ...] | interp.SpecialValue[types.TypeAttribute]:\n    resolve = TypeResolution()\n    fs = fields(stmt)\n    for f, value in zip(fs.args.values(), frame.get_values(stmt.args)):\n        resolve.solve(f.type, value)\n    for arg, f in zip(stmt.args, fs.args.values()):\n        frame.set(arg, frame.get(arg).meet(resolve.substitute(f.type)))\n    return tuple(resolve.substitute(result.type) for result in stmt.results)\n</code></pre>"},{"location":"reference/kirin/analysis/typeinfer/analysis/#kirin.analysis.typeinfer.analysis.TypeInference.expect_const","title":"expect_const  <code>classmethod</code>","text":"<pre><code>expect_const(value: ir.SSAValue, type_: type[T])\n</code></pre> <p>Expect a constant value of a given type.</p> <p>If the value is not a constant or the constant is not of the given type, raise an <code>InterpreterError</code>.</p> Source code in <code>src/kirin/analysis/typeinfer/analysis.py</code> <pre><code>@classmethod\ndef expect_const(cls, value: ir.SSAValue, type_: type[T]):\n    \"\"\"Expect a constant value of a given type.\n\n    If the value is not a constant or the constant is not of the given type, raise\n    an `InterpreterError`.\n    \"\"\"\n    hint = cls.maybe_const(value, type_)\n    if hint is None:\n        raise interp.InterpreterError(f\"expected {type_}, got {hint}\")\n    return hint\n</code></pre>"},{"location":"reference/kirin/analysis/typeinfer/analysis/#kirin.analysis.typeinfer.analysis.TypeInference.maybe_const","title":"maybe_const  <code>classmethod</code>","text":"<pre><code>maybe_const(value: ir.SSAValue, type_: type[T]) -&gt; T | None\n</code></pre> <p>Get a constant value of a given type.</p> <p>If the value is not a constant or the constant is not of the given type, return <code>None</code>.</p> Source code in <code>src/kirin/analysis/typeinfer/analysis.py</code> <pre><code>@classmethod\ndef maybe_const(cls, value: ir.SSAValue, type_: type[T]) -&gt; T | None:\n    \"\"\"Get a constant value of a given type.\n\n    If the value is not a constant or the constant is not of the given type, return\n    `None`.\n    \"\"\"\n    hint = value.hints.get(\"const\")\n    if isinstance(hint, const.Value) and isinstance(hint.data, type_):\n        return hint.data\n</code></pre>"},{"location":"reference/kirin/analysis/typeinfer/analysis/#kirin.analysis.typeinfer.analysis.TypeInference.run_analysis","title":"run_analysis","text":"<pre><code>run_analysis(\n    method: ir.Method,\n    args: tuple[types.TypeAttribute, ...] | None = None,\n    *,\n    no_raise: bool = True\n) -&gt; tuple[\n    ForwardFrame[types.TypeAttribute], types.TypeAttribute\n]\n</code></pre> <p>Run the forward dataflow analysis.</p> <p>Parameters:</p> Name Type Description Default <code>method(ir.Method)</code> <p>The method to analyze.</p> required <code>args(tuple[LatticeElemType])</code> <p>The arguments to the method. Defaults to tuple of top values.</p> required <p>Other Parameters:</p> Name Type Description <code>no_raise(bool)</code> <p>If True, return bottom values if the analysis fails. Defaults to True.</p> <p>Returns:</p> Name Type Description <code>ForwardFrameType</code> <code>ForwardFrameType</code> <p>The results of the analysis contained in the frame.</p> <code>LatticeElemType</code> <code>LatticeElemType</code> <p>The result of the analysis for the method return value.</p> Source code in <code>src/kirin/analysis/typeinfer/analysis.py</code> <pre><code>def run_analysis(\n    self,\n    method: ir.Method,\n    args: tuple[types.TypeAttribute, ...] | None = None,\n    *,\n    no_raise: bool = True,\n) -&gt; tuple[ForwardFrame[types.TypeAttribute], types.TypeAttribute]:\n    if args is None:\n        args = method.arg_types\n    return super().run_analysis(method, args, no_raise=no_raise)\n</code></pre>"},{"location":"reference/kirin/analysis/typeinfer/analysis/#kirin.analysis.typeinfer.analysis.TypeInference.run_method","title":"run_method","text":"<pre><code>run_method(\n    method: ir.Method, args: tuple[types.TypeAttribute, ...]\n) -&gt; tuple[\n    ForwardFrame[types.TypeAttribute], types.TypeAttribute\n]\n</code></pre> <p>How to run a method.</p> <p>This is defined by subclasses to describe what's the corresponding value of a method during the interpretation. Usually, this method just calls <code>run_callable</code>.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Method</code> <p>the method to run.</p> required <code>args</code> <code>tuple[ValueType, ...]</code> <p>the arguments to the method, does not include self.</p> required <p>Returns:</p> Name Type Description <code>ValueType</code> <code>tuple[FrameType, ValueType]</code> <p>the result of the method.</p> Source code in <code>src/kirin/analysis/typeinfer/analysis.py</code> <pre><code>def run_method(\n    self, method: ir.Method, args: tuple[types.TypeAttribute, ...]\n) -&gt; tuple[ForwardFrame[types.TypeAttribute], types.TypeAttribute]:\n    return self.run_callable(method.code, (method.self_type,) + args)\n</code></pre>"},{"location":"reference/kirin/analysis/typeinfer/solve/","title":"Solve","text":"<p>Type resolution for type inference.</p> <p>This module contains the type resolution algorithm for type inference. A simple algorithm is used to resolve the types of the IR by comparing the input types with the output types.</p>"},{"location":"reference/kirin/analysis/typeinfer/solve/#kirin.analysis.typeinfer.solve.ResolutionError","title":"ResolutionError  <code>dataclass</code>","text":"<pre><code>ResolutionError(\n    expr: types.TypeAttribute, value: types.TypeAttribute\n)\n</code></pre> <p>               Bases: <code>TypeResolutionResult</code></p> <p>Type resolution result for failed resolution.</p>"},{"location":"reference/kirin/analysis/typeinfer/solve/#kirin.analysis.typeinfer.solve.ResolutionOk","title":"ResolutionOk  <code>dataclass</code>","text":"<pre><code>ResolutionOk()\n</code></pre> <p>               Bases: <code>TypeResolutionResult</code></p> <p>Type resolution result for successful resolution.</p>"},{"location":"reference/kirin/analysis/typeinfer/solve/#kirin.analysis.typeinfer.solve.TypeResolution","title":"TypeResolution  <code>dataclass</code>","text":"<pre><code>TypeResolution(\n    vars: dict[types.TypeVar, types.TypeAttribute] = dict()\n)\n</code></pre> <p>Type resolution algorithm for type inference.</p>"},{"location":"reference/kirin/analysis/typeinfer/solve/#kirin.analysis.typeinfer.solve.TypeResolution.solve","title":"solve","text":"<pre><code>solve(\n    annot: types.TypeAttribute, value: types.TypeAttribute\n) -&gt; TypeResolutionResult\n</code></pre> <p>Solve the type resolution problem.</p> <p>This method compares the expected type <code>annot</code> with the actual type <code>value</code> and returns a result indicating whether the types match or not.</p> <p>Parameters:</p> Name Type Description Default <code>annot</code> <code>TypeAttribute</code> <p>The expected type.</p> required <code>value</code> <code>TypeAttribute</code> <p>The actual type.</p> required <p>Returns:</p> Type Description <code>TypeResolutionResult</code> <p>A <code>TypeResolutionResult</code> object indicating the result of the</p> <code>TypeResolutionResult</code> <p>resolution.</p> Source code in <code>src/kirin/analysis/typeinfer/solve.py</code> <pre><code>def solve(\n    self, annot: types.TypeAttribute, value: types.TypeAttribute\n) -&gt; TypeResolutionResult:\n    \"\"\"Solve the type resolution problem.\n\n    This method compares the expected type `annot` with the actual\n    type `value` and returns a result indicating whether the types\n    match or not.\n\n    Args:\n        annot: The expected type.\n        value: The actual type.\n\n    Returns:\n        A `TypeResolutionResult` object indicating the result of the\n        resolution.\n    \"\"\"\n    if isinstance(annot, types.TypeVar):\n        return self.solve_TypeVar(annot, value)\n    elif isinstance(annot, types.Generic):\n        return self.solve_Generic(annot, value)\n    elif isinstance(annot, types.Union):\n        return self.solve_Union(annot, value)\n\n    if annot.is_subseteq(value):\n        return Ok\n    else:\n        return ResolutionError(annot, value)\n</code></pre>"},{"location":"reference/kirin/analysis/typeinfer/solve/#kirin.analysis.typeinfer.solve.TypeResolution.substitute","title":"substitute","text":"<pre><code>substitute(typ: types.TypeAttribute) -&gt; types.TypeAttribute\n</code></pre> <p>Substitute type variables in the type with their values.</p> <p>This method substitutes type variables in the given type with their values. If the type is a generic type, the method recursively substitutes the type variables in the type arguments.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>TypeAttribute</code> <p>The type to substitute.</p> required <p>Returns:</p> Type Description <code>TypeAttribute</code> <p>The type with the type variables substituted.</p> Source code in <code>src/kirin/analysis/typeinfer/solve.py</code> <pre><code>def substitute(self, typ: types.TypeAttribute) -&gt; types.TypeAttribute:\n    \"\"\"Substitute type variables in the type with their values.\n\n    This method substitutes type variables in the given type with their\n    values. If the type is a generic type, the method recursively\n    substitutes the type variables in the type arguments.\n\n    Args:\n        typ: The type to substitute.\n\n    Returns:\n        The type with the type variables substituted.\n    \"\"\"\n    if isinstance(typ, types.TypeVar):\n        return self.vars.get(typ, typ)\n    elif isinstance(typ, types.Generic):\n        return types.Generic(\n            typ.body, *tuple(self.substitute(var) for var in typ.vars)\n        )\n    elif isinstance(typ, types.Union):\n        return types.Union(self.substitute(t) for t in typ.types)\n    return typ\n</code></pre>"},{"location":"reference/kirin/analysis/typeinfer/solve/#kirin.analysis.typeinfer.solve.TypeResolutionResult","title":"TypeResolutionResult  <code>dataclass</code>","text":"<pre><code>TypeResolutionResult()\n</code></pre> <p>Base class for type resolution results.</p>"},{"location":"reference/kirin/decl/","title":"Index","text":""},{"location":"reference/kirin/decl/#kirin.decl.statement","title":"statement","text":"<pre><code>statement(\n    cls=None, **kwargs: Unpack[StatementOptions]\n) -&gt; Callable[[type[StmtType]], type[StmtType]]\n</code></pre> <p>Declare a new statement class.</p> <p>This decorator is used to declare a new statement class. It is used to generate the necessary boilerplate code for the class. The class should inherit from <code>kirin.ir.Statement</code>.</p> <p>Parameters:</p> Name Type Description Default <code>init(bool)</code> <p>Whether to generate an <code>__init__</code> method.</p> required <code>repr(bool)</code> <p>Whether to generate a <code>__repr__</code> method.</p> required <code>kw_only(bool)</code> <p>Whether to use keyword-only arguments in the <code>__init__</code> method.</p> required <code>dialect(Optional[Dialect])</code> <p>The dialect of the statement.</p> required <code>property(bool)</code> <p>Whether to generate property methods for attributes.</p> required Example <p>The following is an example of how to use the <code>statement</code> decorator.</p> <pre><code>@statement\nclass MyStatement(ir.Statement):\n    name = \"some_name\"\n    traits = frozenset({TraitA(), TraitB()})\n    some_input: ir.SSAValue = info.argument()\n    some_output: ir.ResultValue = info.result()\n    body: ir.Region = info.region()\n    successor: ir.Block = info.block()\n</code></pre> <p>If the <code>name</code> field is not specified, a lowercase name field will be auto generated.</p> <p>In addition, one can optionally register the statement to a dialect by providing the <code>dialect</code> argument to the decorator.</p> <p>The following example register the statement to a dialect <code>my_dialect_object</code>, and <code>name = \"myfoo\"</code> field is autogenerated</p> <pre><code>@statement(dialect=my_dialect_object)\nclass MyFoo(ir.Statement):\n    traits = frozenset({ir.FromPythonCall()})\n    value: str = info.attribute()\n</code></pre> Source code in <code>src/kirin/decl/__init__.py</code> <pre><code>@dataclass_transform(\n    field_specifiers=(\n        info.attribute,\n        info.argument,\n        info.region,\n        info.result,\n        info.block,\n    )\n)\ndef statement(\n    cls=None,\n    **kwargs: Unpack[StatementOptions],\n) -&gt; Callable[[type[StmtType]], type[StmtType]]:\n    \"\"\"Declare a new statement class.\n\n    This decorator is used to declare a new statement class. It is used to\n    generate the necessary boilerplate code for the class. The class should\n    inherit from `kirin.ir.Statement`.\n\n    Args:\n        init(bool): Whether to generate an `__init__` method.\n        repr(bool): Whether to generate a `__repr__` method.\n        kw_only(bool): Whether to use keyword-only arguments in the `__init__`\n            method.\n        dialect(Optional[Dialect]): The dialect of the statement.\n        property(bool): Whether to generate property methods for attributes.\n\n    Example:\n        The following is an example of how to use the `statement` decorator.\n\n        ```python\n        @statement\n        class MyStatement(ir.Statement):\n            name = \"some_name\"\n            traits = frozenset({TraitA(), TraitB()})\n            some_input: ir.SSAValue = info.argument()\n            some_output: ir.ResultValue = info.result()\n            body: ir.Region = info.region()\n            successor: ir.Block = info.block()\n        ```\n\n        If the `name` field is not specified, a lowercase name field will be auto generated.\n\n        In addition, one can optionally register the statement to a dialect\n        by providing the `dialect` argument to the decorator.\n\n        The following example register the statement to a dialect `my_dialect_object`, and `name = \"myfoo\"` field is autogenerated\n\n        ```python\n        @statement(dialect=my_dialect_object)\n        class MyFoo(ir.Statement):\n            traits = frozenset({ir.FromPythonCall()})\n            value: str = info.attribute()\n        ```\n    \"\"\"\n\n    def wrap(cls):\n        decl = StatementDecl(cls, **kwargs)\n        decl.scan_fields()\n        decl.verify()\n        decl.emit()\n        decl.register()\n        return cls\n\n    if cls is None:\n        return wrap\n    return wrap(cls)\n</code></pre>"},{"location":"reference/kirin/decl/base/","title":"Base","text":""},{"location":"reference/kirin/decl/camel2snake/","title":"Camel2snake","text":""},{"location":"reference/kirin/decl/info/","title":"Info","text":""},{"location":"reference/kirin/decl/info/#kirin.decl.info.ArgumentField","title":"ArgumentField  <code>dataclass</code>","text":"<pre><code>ArgumentField(\n    kw_only: bool,\n    alias: Optional[str],\n    type: types.TypeAttribute,\n    print: bool = True,\n    group: bool = False,\n)\n</code></pre> <p>               Bases: <code>Field</code></p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.ArgumentField.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>group: bool = False\n</code></pre> <p>if <code>True</code>, this argument is annotated with Tuple[SSAValue, ...]</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.ArgumentField.print","title":"print  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>print: bool = True\n</code></pre> <p>if <code>True</code>, this argument name is printed in the signature.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.ArgumentField.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: TypeAttribute\n</code></pre> <p>type of the argument, will be used in validation.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.AttributeField","title":"AttributeField  <code>dataclass</code>","text":"<pre><code>AttributeField(\n    kw_only: bool,\n    alias: Optional[str],\n    default: Any,\n    init: bool,\n    repr: bool,\n    default_factory: Optional[Callable[[], Attribute]],\n    type: types.TypeAttribute,\n    pytype: bool = False,\n)\n</code></pre> <p>               Bases: <code>Field</code></p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.AttributeField.pytype","title":"pytype  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pytype: bool = False\n</code></pre> <p>if <code>True</code>, annotation is a python type hint instead of <code>TypeAttribute</code></p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields","title":"StatementFields  <code>dataclass</code>","text":"<pre><code>StatementFields(\n    std_args: dict[str, ArgumentField] = dict(),\n    kw_args: dict[str, ArgumentField] = dict(),\n    results: dict[str, ResultField] = dict(),\n    regions: dict[str, RegionField] = dict(),\n    blocks: dict[str, BlockField] = dict(),\n    attributes: dict[str, AttributeField] = dict(),\n)\n</code></pre>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.args","title":"args  <code>property</code>","text":"<pre><code>args\n</code></pre> <p>iterable of all argument fields.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.attributes","title":"attributes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>attributes: dict[str, AttributeField] = field(\n    default_factory=dict\n)\n</code></pre> <p>attributes of the statement.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.blocks","title":"blocks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>blocks: dict[str, BlockField] = field(default_factory=dict)\n</code></pre> <p>blocks of the statement.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.kw_args","title":"kw_args  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kw_args: dict[str, ArgumentField] = field(\n    default_factory=dict\n)\n</code></pre> <p>keyword-only arguments of the statement.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.regions","title":"regions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>regions: dict[str, RegionField] = field(\n    default_factory=dict\n)\n</code></pre> <p>regions of the statement.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.required_names","title":"required_names  <code>cached</code> <code>property</code>","text":"<pre><code>required_names\n</code></pre> <p>set of all fields that do not have a default value.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.results","title":"results  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>results: dict[str, ResultField] = field(\n    default_factory=dict\n)\n</code></pre> <p>results of the statement.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.std_args","title":"std_args  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>std_args: dict[str, ArgumentField] = field(\n    default_factory=dict\n)\n</code></pre> <p>standard arguments of the statement.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.argument","title":"argument","text":"<pre><code>argument(\n    type: types.TypeAttribute = types.Any,\n    *,\n    print: bool = True,\n    kw_only: bool = False,\n    alias: Optional[str] = None\n) -&gt; Any\n</code></pre> <p>Field specifier for arguments.</p> <p>Parameters:</p> Name Type Description Default <code>type(TypeAttribute)</code> <p>type of the argument, will be used in validation.</p> required <code>print(bool)</code> <p>if <code>True</code>, this argument name is printed in the signature.</p> required <code>kw_only(bool)</code> <p>if <code>True</code>, this argument is keyword-only.</p> required <code>alias(Optional[str])</code> <p>an alias for the argument name in the <code>__init__</code> method.</p> required Source code in <code>src/kirin/decl/info.py</code> <pre><code>def argument(\n    type: types.TypeAttribute = types.Any,\n    *,\n    print: bool = True,\n    kw_only: bool = False,\n    alias: Optional[str] = None,\n) -&gt; Any:\n    \"\"\"Field specifier for arguments.\n\n    Args:\n        type(TypeAttribute): type of the argument, will be used in validation.\n        print(bool): if `True`, this argument name is printed in the signature.\n        kw_only(bool): if `True`, this argument is keyword-only.\n        alias(Optional[str]): an alias for the argument name in the `__init__` method.\n    \"\"\"\n    return ArgumentField(\n        type=type,\n        print=print,\n        kw_only=kw_only,\n        alias=alias,\n    )\n</code></pre>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.block","title":"block","text":"<pre><code>block(\n    *,\n    init: bool = True,\n    repr: bool = True,\n    kw_only: bool = True,\n    alias: Optional[str] = None,\n    default_factory: Callable[[], Block] = Block\n) -&gt; Any\n</code></pre> <p>Field specifier for blocks.</p> <p>Parameters:</p> Name Type Description Default <code>init(bool)</code> <p>if <code>True</code>, this block field is included in the <code>__init__</code> method.</p> required <code>repr(bool)</code> <p>if <code>True</code>, this block field is included in the <code>__repr__</code> and pretty printing.</p> required <code>kw_only(bool)</code> <p>if <code>True</code>, this block field is keyword-only.</p> required <code>alias(Optional[str])</code> <p>an alias for the block field name in the <code>__init__</code> method.</p> required <code>default_factory(Callable[[],</code> <code>Block]</code> <p>a factory function to create a default block.</p> required Source code in <code>src/kirin/decl/info.py</code> <pre><code>def block(\n    *,\n    init: bool = True,\n    repr: bool = True,\n    kw_only: bool = True,\n    alias: Optional[str] = None,\n    default_factory: Callable[[], Block] = Block,\n) -&gt; Any:\n    \"\"\"Field specifier for blocks.\n\n    Args:\n        init(bool): if `True`, this block field is included in the `__init__` method.\n        repr(bool): if `True`, this block field is included in the `__repr__` and pretty printing.\n        kw_only(bool): if `True`, this block field is keyword-only.\n        alias(Optional[str]): an alias for the block field name in the `__init__` method.\n        default_factory(Callable[[], Block]): a factory function to create a default block.\n    \"\"\"\n    if kw_only is False:\n        raise TypeError(\"block fields must be keyword-only\")\n\n    return BlockField(\n        init=init,\n        repr=repr,\n        kw_only=kw_only,\n        alias=alias,\n        default_factory=default_factory,\n    )\n</code></pre>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.region","title":"region","text":"<pre><code>region(\n    *,\n    init: bool = True,\n    repr: bool = True,\n    kw_only: bool = True,\n    alias: Optional[str] = None,\n    multi: bool = False,\n    default_factory: Callable[[], Region] = Region\n) -&gt; Any\n</code></pre> <p>Field specifier for regions.</p> <p>Parameters:</p> Name Type Description Default <code>init(bool)</code> <p>if <code>True</code>, this region field is included in the <code>__init__</code> method.</p> required <code>repr(bool)</code> <p>if <code>True</code>, this region field is included in the <code>__repr__</code> and pretty printing.</p> required <code>kw_only(bool)</code> <p>if <code>True</code>, this region field is keyword-only.</p> required <code>alias(Optional[str])</code> <p>an alias for the region field name in the <code>__init__</code> method.</p> required <code>multi(bool)</code> <p>if <code>True</code>, this region can contain multiple blocks.</p> required <code>default_factory(Callable[[],</code> <code>Region]</code> <p>a factory function to create a default region.</p> required Source code in <code>src/kirin/decl/info.py</code> <pre><code>def region(\n    *,\n    init: bool = True,  # so we can use the default_factory\n    repr: bool = True,\n    kw_only: bool = True,\n    alias: Optional[str] = None,\n    multi: bool = False,\n    default_factory: Callable[[], Region] = Region,\n) -&gt; Any:\n    \"\"\"Field specifier for regions.\n\n    Args:\n        init(bool): if `True`, this region field is included in the `__init__` method.\n        repr(bool): if `True`, this region field is included in the `__repr__` and pretty printing.\n        kw_only(bool): if `True`, this region field is keyword-only.\n        alias(Optional[str]): an alias for the region field name in the `__init__` method.\n        multi(bool): if `True`, this region can contain multiple blocks.\n        default_factory(Callable[[], Region]): a factory function to create a default region.\n    \"\"\"\n    if kw_only is False:\n        raise TypeError(\"region fields must be keyword-only\")\n\n    return RegionField(\n        init=init,\n        repr=repr,\n        kw_only=kw_only,\n        alias=alias,\n        multi=multi,\n        default_factory=default_factory,\n    )\n</code></pre>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.result","title":"result","text":"<pre><code>result(\n    type: types.TypeAttribute = types.Any,\n    *,\n    init: bool = False,\n    repr: bool = True,\n    kw_only: bool = True,\n    alias: Optional[str] = None\n) -&gt; Any\n</code></pre> <p>Field specifier for results.</p> <p>Parameters:</p> Name Type Description Default <code>type(TypeAttribute)</code> <p>type of the result.</p> required <code>init(bool)</code> <p>if <code>True</code>, this result field is included in the <code>__init__</code> method.</p> required <code>repr(bool)</code> <p>if <code>True</code>, this result field is included in the <code>__repr__</code> and pretty printing.</p> required <code>kw_only(bool)</code> <p>if <code>True</code>, this result field is keyword-only.</p> required <code>alias(Optional[str])</code> <p>an alias for the result field name in the <code>__init__</code> method.</p> required Source code in <code>src/kirin/decl/info.py</code> <pre><code>def result(\n    type: types.TypeAttribute = types.Any,\n    *,\n    # NOTE: init is false, use other hooks to set custom results\n    # or just mutate the statement after creation\n    init: bool = False,\n    repr: bool = True,\n    kw_only: bool = True,\n    alias: Optional[str] = None,\n) -&gt; Any:\n    \"\"\"Field specifier for results.\n\n    Args:\n        type(TypeAttribute): type of the result.\n        init(bool): if `True`, this result field is included in the `__init__` method.\n        repr(bool): if `True`, this result field is included in the `__repr__` and pretty printing.\n        kw_only(bool): if `True`, this result field is keyword-only.\n        alias(Optional[str]): an alias for the result field name in the `__init__` method.\n    \"\"\"\n    if kw_only is False:  # for linting\n        raise TypeError(\"result fields must be keyword-only\")\n\n    if init is True:\n        raise TypeError(\"result fields cannot appear in __init__\")\n\n    return ResultField(\n        type=type,\n        init=init,\n        repr=repr,\n        kw_only=kw_only,\n        alias=alias,\n    )\n</code></pre>"},{"location":"reference/kirin/decl/scan_fields/","title":"Scan fields","text":""},{"location":"reference/kirin/decl/scan_fields/#kirin.decl.scan_fields.ScanFields","title":"ScanFields","text":"<pre><code>ScanFields(cls: type, **kwargs: Unpack[StatementOptions])\n</code></pre> <p>               Bases: <code>BaseModifier</code></p> Source code in <code>src/kirin/decl/base.py</code> <pre><code>def __init__(self, cls: type, **kwargs: Unpack[StatementOptions]) -&gt; None:\n    self.cls = cls\n    self.cls_module = sys.modules.get(cls.__module__)\n\n    if \"dialect\" in kwargs:\n        self.dialect = kwargs[\"dialect\"]\n    else:\n        self.dialect = None\n    self.params = kwargs\n    setattr(cls, self._PARAMS, self.params)\n\n    if cls.__module__ in sys.modules:\n        self.globals = sys.modules[cls.__module__].__dict__\n    else:\n        # Theoretically this can happen if someone writes\n        # a custom string to cls.__module__.  In which case\n        # such dataclass won't be fully introspectable\n        # (w.r.t. typing.get_type_hints) but will still function\n        # correctly.\n        self.globals: dict[str, Any] = {}\n\n    # analysis state, used by scan_field, etc.\n    self.fields = StatementFields()\n    self.has_statement_bases = False\n    self.kw_only = self.params.get(\"kw_only\", False)\n    self.KW_ONLY_seen = False\n</code></pre>"},{"location":"reference/kirin/decl/verify/","title":"Verify","text":""},{"location":"reference/kirin/decl/emit/","title":"Index","text":""},{"location":"reference/kirin/decl/emit/check_type/","title":"Check type","text":""},{"location":"reference/kirin/decl/emit/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/decl/emit/init/","title":"Init","text":""},{"location":"reference/kirin/decl/emit/name/","title":"Name","text":""},{"location":"reference/kirin/decl/emit/property/","title":"Property","text":""},{"location":"reference/kirin/decl/emit/repr/","title":"Repr","text":""},{"location":"reference/kirin/decl/emit/traits/","title":"Traits","text":""},{"location":"reference/kirin/decl/emit/verify/","title":"Verify","text":""},{"location":"reference/kirin/dialects/","title":"Index","text":"<p>Built-in dialects for Kirin.</p> <p>This module contains the built-in dialects for Kirin. Each dialect is an instance of the <code>Dialect</code> class. Each submodule contains a <code>dialect</code> variable that is an instance of the corresponding <code>Dialect</code> class.</p> <p>The modules can be directly used as dialects. For example, you can write</p> <pre><code>from kirin.dialects import py, func\n</code></pre> <p>to import the Python and function dialects.</p>"},{"location":"reference/kirin/dialects/debug/","title":"Debug","text":""},{"location":"reference/kirin/dialects/debug/#kirin.dialects.debug.Info","title":"Info  <code>kirin-statement</code>","text":"<pre><code>Info(msg: ir.SSAValue, inputs: tuple[ir.SSAValue, ...])\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>print debug information.</p> <p>This statement is used to print debug information during execution. The compiler has freedom to choose how to print the information and send it back to the caller. Note that in the case of heterogeneous hardware, this may not be printed on the same device as the caller but instead being a log.</p>"},{"location":"reference/kirin/dialects/eltype/","title":"Eltype","text":"<p>This dialect offers a statement <code>eltype</code> for other dialects' type inference to query/implement the element type of a value. For example, the <code>ilist</code> dialect implements the <code>eltype</code> statement on the <code>ilist.IList</code> type to return the element type.</p>"},{"location":"reference/kirin/dialects/eltype/#kirin.dialects.eltype.ElType","title":"ElType  <code>kirin-statement</code>","text":"<pre><code>ElType(container: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>Returns the element type of a value.</p> <p>This statement is used by other dialects to query the element type of a value.</p>"},{"location":"reference/kirin/dialects/eltype/#kirin.dialects.eltype.ElType.container","title":"container  <code>kirin-argument</code>","text":"<pre><code>container: SSAValue = argument(Any)\n</code></pre> <p>The value to query the element type of.</p>"},{"location":"reference/kirin/dialects/eltype/#kirin.dialects.eltype.ElType.elem","title":"elem  <code>kirin-result</code>","text":"<pre><code>elem: ResultValue = result(PyClass(TypeAttribute))\n</code></pre> <p>The element type of the value.</p>"},{"location":"reference/kirin/dialects/module/","title":"Module","text":"<p>Module dialect provides a simple module that is roughly a list of function statements.</p> <p>This dialect provides the dialect necessary for compiling a function into lower-level IR with all its callee functions.</p>"},{"location":"reference/kirin/dialects/module/#kirin.dialects.module.Invoke","title":"Invoke  <code>kirin-statement</code>","text":"<pre><code>Invoke(\n    inputs: tuple[ir.SSAValue, ...],\n    *,\n    callee: str,\n    kwargs: tuple[str, ...]\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>A special statement that represents a function calling functions by symbol name.</p> Note <p>This statement is here for completeness, for interpretation, it is recommended to rewrite this statement into a <code>func.Invoke</code> after looking up the symbol table.</p>"},{"location":"reference/kirin/dialects/module/#kirin.dialects.module.Invoke.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>run mandatory validation checks. This is not same as verify_type, which may be optional.</p> Source code in <code>src/kirin/dialects/module.py</code> <pre><code>def verify(self) -&gt; None:\n    if self.kwargs:\n        for name in self.kwargs:\n            if name not in self.callee:\n                raise ir.ValidationError(\n                    self,\n                    f\"method {self.callee} does not have argument {name}\",\n                )\n    elif len(self.callee) - 1 != len(self.args):\n        raise ir.ValidationError(\n            self,\n            f\"expected {len(self.callee)} arguments, got {len(self.args)}\",\n        )\n</code></pre>"},{"location":"reference/kirin/dialects/cf/","title":"Index","text":"<p>Control flow dialect.</p> <p>This dialect provides a low-level control flow representation.</p> <p>This dialect does not provide any lowering strategies, to lowering a Python AST to this dialect, use the <code>kirin.dialects.lowering.cf</code> dialect with this dialect.</p>"},{"location":"reference/kirin/dialects/cf/constprop/","title":"Constprop","text":""},{"location":"reference/kirin/dialects/cf/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/dialects/cf/emit/","title":"Emit","text":""},{"location":"reference/kirin/dialects/cf/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/cf/stmts/","title":"Stmts","text":""},{"location":"reference/kirin/dialects/cf/stmts/#kirin.dialects.cf.stmts.Branch","title":"Branch  <code>kirin-statement</code>","text":"<pre><code>Branch(*, successor: ir.Block)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"reference/kirin/dialects/cf/stmts/#kirin.dialects.cf.stmts.Branch.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>run mandatory validation checks. This is not same as verify_type, which may be optional.</p> Source code in <code>src/kirin/dialects/cf/stmts.py</code> <pre><code>def verify(self) -&gt; None:\n    return\n</code></pre>"},{"location":"reference/kirin/dialects/cf/stmts/#kirin.dialects.cf.stmts.ConditionalBranch","title":"ConditionalBranch  <code>kirin-statement</code>","text":"<pre><code>ConditionalBranch(\n    cond: ir.SSAValue,\n    *,\n    then_successor: ir.Block,\n    else_successor: ir.Block\n)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"reference/kirin/dialects/cf/stmts/#kirin.dialects.cf.stmts.ConditionalBranch.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>run mandatory validation checks. This is not same as verify_type, which may be optional.</p> Source code in <code>src/kirin/dialects/cf/stmts.py</code> <pre><code>def verify(self) -&gt; None:\n    return\n</code></pre>"},{"location":"reference/kirin/dialects/cf/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/dialects/func/","title":"Index","text":"<p>A function dialect that is compatible with python semantics.</p>"},{"location":"reference/kirin/dialects/func/attrs/","title":"Attrs","text":""},{"location":"reference/kirin/dialects/func/attrs/#kirin.dialects.func.attrs.Signature","title":"Signature  <code>dataclass</code>","text":"<pre><code>Signature(\n    inputs: tuple[TypeLatticeElem, ...],\n    output: TypeLatticeElem,\n)\n</code></pre> <p>               Bases: <code>Generic[TypeLatticeElem]</code>, <code>Attribute</code></p> <p>function body signature.</p> <p>This is not a type attribute because it just stores the signature of a function at its definition site. We don't perform type inference on this directly.</p> <p>The type of a function is the type of <code>inputs[0]</code>, which typically is a <code>MethodType</code>.</p>"},{"location":"reference/kirin/dialects/func/attrs/#kirin.dialects.func.attrs.Signature.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'Signature'\n</code></pre> <p>Name of the attribute in printing and other text format.</p>"},{"location":"reference/kirin/dialects/func/constprop/","title":"Constprop","text":""},{"location":"reference/kirin/dialects/func/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/dialects/func/emit/","title":"Emit","text":""},{"location":"reference/kirin/dialects/func/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/func/stmts/","title":"Stmts","text":""},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.Call","title":"Call  <code>kirin-statement</code>","text":"<pre><code>Call(\n    callee: ir.SSAValue,\n    inputs: tuple[ir.SSAValue, ...],\n    *,\n    kwargs: tuple[str, ...] = (),\n    purity: bool\n)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.Call.check_type","title":"check_type","text":"<pre><code>check_type() -&gt; None\n</code></pre> <p>Check the types of the Block. Raises <code>Exception</code> if the types are not correct. This method is called by the <code>verify_type</code> method, which will detect the source of the error in the IR. One should always call the <code>verify_type</code> method to verify the types of the IR.</p> Note <p>This method is generated by the <code>@statement</code> decorator. But can be overridden if needed.</p> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>def check_type(self) -&gt; None:\n    if not self.callee.type.is_subseteq(types.MethodType):\n        if self.callee.type.is_subseteq(types.PyClass(FunctionType)):\n            raise ir.TypeCheckError(\n                self,\n                f\"callee must be a method type, got {self.callee.type}\",\n                help=\"did you call a Python function directly? \"\n                \"consider decorating it with kernel decorator\",\n            )\n\n        if self.callee.type.is_subseteq(types.PyClass(ClassMethodType)):\n            raise ir.TypeCheckError(\n                self,\n                \"callee must be a method type, got class method\",\n                help=\"did you try to call a Python class method within a kernel? \"\n                \"consider rewriting it with a captured variable instead of calling it inside the kernel\",\n            )\n\n        if self.callee.type is types.Any:\n            return\n        raise ir.TypeCheckError(\n            self,\n            f\"callee must be a method type, got {self.callee.type}\",\n            help=\"did you forget to decorate the function with kernel decorator?\",\n        )\n</code></pre>"},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.ConstantNone","title":"ConstantNone  <code>kirin-statement</code>","text":"<pre><code>ConstantNone()\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>A constant None value.</p> <p>This is mainly used to represent the None return value of a function to match Python semantics.</p>"},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.FuncOpCallableInterface","title":"FuncOpCallableInterface  <code>dataclass</code>","text":"<pre><code>FuncOpCallableInterface()\n</code></pre> <p>               Bases: <code>CallableStmtInterface['Function']</code></p>"},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.FuncOpCallableInterface.get_callable_region","title":"get_callable_region  <code>classmethod</code>","text":"<pre><code>get_callable_region(stmt: Function) -&gt; ir.Region\n</code></pre> <p>Returns the body of the callable region</p> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>@classmethod\ndef get_callable_region(cls, stmt: \"Function\") -&gt; ir.Region:\n    return stmt.body\n</code></pre>"},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.Function","title":"Function  <code>kirin-statement</code>","text":"<pre><code>Function(\n    *, sym_name: str, signature: Signature, body: ir.Region\n)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.Function.sym_name","title":"sym_name  <code>kirin-attribute</code> <code>kw-only</code>","text":"<pre><code>sym_name: str = attribute()\n</code></pre> <p>The symbol name of the function.</p>"},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.Invoke","title":"Invoke  <code>kirin-statement</code>","text":"<pre><code>Invoke(\n    inputs: tuple[ir.SSAValue, ...],\n    *,\n    callee: ir.Method,\n    kwargs: tuple[str, ...],\n    purity: bool\n)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.Invoke.check","title":"check","text":"<pre><code>check() -&gt; None\n</code></pre> <p>Check the statement. Raises <code>Exception</code> if the statement is not correct. This method is called by the <code>verify</code> method, which will detect the source of the error in the IR. One should always call the <code>verify</code> method to verify the IR.</p> <p>The difference between <code>check</code> and <code>check_type</code> is that <code>check</code> is called at any time to check the structure of the IR by <code>verify</code>, while <code>check_type</code> is called after the type inference to check the types of the IR.</p> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>def check(self) -&gt; None:\n    if self.kwargs:\n        for name in self.kwargs:\n            assert (\n                name in self.callee.arg_names\n            ), f\"method {self.callee.sym_name} does not have argument {name}\"\n    elif len(self.callee.arg_names) - 1 != len(self.args):\n        raise ValueError(\n            f\"expected {len(self.callee.arg_names)} arguments, got {len(self.args)}\"\n        )\n</code></pre>"},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.Lambda","title":"Lambda  <code>kirin-statement</code>","text":"<pre><code>Lambda(\n    captured: tuple[ir.SSAValue, ...],\n    *,\n    sym_name: str,\n    signature: Signature,\n    body: ir.Region\n)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.Lambda.check","title":"check","text":"<pre><code>check() -&gt; None\n</code></pre> <p>Check the statement. Raises <code>Exception</code> if the statement is not correct. This method is called by the <code>verify</code> method, which will detect the source of the error in the IR. One should always call the <code>verify</code> method to verify the IR.</p> <p>The difference between <code>check</code> and <code>check_type</code> is that <code>check</code> is called at any time to check the structure of the IR by <code>verify</code>, while <code>check_type</code> is called after the type inference to check the types of the IR.</p> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>def check(self) -&gt; None:\n    assert self.body.blocks, \"lambda body must not be empty\"\n</code></pre>"},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.Return","title":"Return  <code>kirin-statement</code>","text":"<pre><code>Return(\n    value_or_stmt: ir.SSAValue | ir.Statement | None = None,\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>def __init__(self, value_or_stmt: ir.SSAValue | ir.Statement | None = None) -&gt; None:\n    if isinstance(value_or_stmt, ir.SSAValue):\n        args = [value_or_stmt]\n    elif isinstance(value_or_stmt, ir.Statement):\n        if len(value_or_stmt._results) == 1:\n            args = [value_or_stmt._results[0]]\n        else:\n            raise ValueError(\n                f\"expected a single result, got {len(value_or_stmt._results)} results from {value_or_stmt.name}\"\n            )\n    elif value_or_stmt is None:\n        args = []\n    else:\n        raise ValueError(f\"expected SSAValue or Statement, got {value_or_stmt}\")\n\n    super().__init__(args=args, args_slice={\"value\": 0})\n</code></pre>"},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.Return.check","title":"check","text":"<pre><code>check() -&gt; None\n</code></pre> <p>Check the statement. Raises <code>Exception</code> if the statement is not correct. This method is called by the <code>verify</code> method, which will detect the source of the error in the IR. One should always call the <code>verify</code> method to verify the IR.</p> <p>The difference between <code>check</code> and <code>check_type</code> is that <code>check</code> is called at any time to check the structure of the IR by <code>verify</code>, while <code>check_type</code> is called after the type inference to check the types of the IR.</p> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>def check(self) -&gt; None:\n    assert self.args, \"return statement must have at least one value\"\n    assert len(self.args) &lt;= 1, (\n        \"return statement must have at most one value\"\n        \", wrap multiple values in a tuple\"\n    )\n</code></pre>"},{"location":"reference/kirin/dialects/func/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/dialects/ilist/","title":"Index","text":"<p>Immutable list dialect for Python.</p> <p>This dialect provides a simple, immutable list dialect similar to Python's built-in list type.</p>"},{"location":"reference/kirin/dialects/ilist/constprop/","title":"Constprop","text":""},{"location":"reference/kirin/dialects/ilist/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/ilist/lowering/","title":"Lowering","text":""},{"location":"reference/kirin/dialects/ilist/passes/","title":"Passes","text":""},{"location":"reference/kirin/dialects/ilist/passes/#kirin.dialects.ilist.passes.IListDesugar","title":"IListDesugar  <code>dataclass</code>","text":"<pre><code>IListDesugar(\n    dialects: DialectGroup, *, no_raise: bool = True\n)\n</code></pre> <p>               Bases: <code>Pass</code></p> <p>This pass desugars the Python list dialect to the immutable list dialect by rewriting all constant <code>list</code> type into <code>IList</code> type.</p>"},{"location":"reference/kirin/dialects/ilist/runtime/","title":"Runtime","text":""},{"location":"reference/kirin/dialects/ilist/runtime/#kirin.dialects.ilist.runtime.IList","title":"IList  <code>dataclass</code>","text":"<pre><code>IList(\n    data: Sequence[T], elem: types.TypeAttribute = types.Any\n)\n</code></pre> <p>               Bases: <code>Data[Sequence[T]]</code>, <code>Sequence[T]</code>, <code>Generic[T, L]</code></p> <p>A simple immutable list.</p>"},{"location":"reference/kirin/dialects/ilist/runtime/#kirin.dialects.ilist.runtime.IList.unwrap","title":"unwrap","text":"<pre><code>unwrap() -&gt; Sequence[T]\n</code></pre> <p>Returns the underlying data value.</p> Source code in <code>src/kirin/dialects/ilist/runtime.py</code> <pre><code>def unwrap(self) -&gt; Sequence[T]:\n    return self\n</code></pre>"},{"location":"reference/kirin/dialects/ilist/stmts/","title":"Stmts","text":""},{"location":"reference/kirin/dialects/ilist/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/dialects/ilist/rewrite/","title":"Index","text":""},{"location":"reference/kirin/dialects/ilist/rewrite/const/","title":"Const","text":""},{"location":"reference/kirin/dialects/ilist/rewrite/const/#kirin.dialects.ilist.rewrite.const.ConstList2IList","title":"ConstList2IList  <code>dataclass</code>","text":"<pre><code>ConstList2IList()\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <p>Rewrite type annotation for SSAValue with constant <code>IList</code> in <code>Hinted</code> type. This should be run after constant folding and <code>WrapConst</code> rule.</p>"},{"location":"reference/kirin/dialects/ilist/rewrite/hint_len/","title":"Hint len","text":""},{"location":"reference/kirin/dialects/ilist/rewrite/list/","title":"List","text":""},{"location":"reference/kirin/dialects/ilist/rewrite/unroll/","title":"Unroll","text":""},{"location":"reference/kirin/dialects/lowering/","title":"Index","text":"<p>This module contains the dialects for choosing different lowering strategies.</p> <p>The dialects defined inside this module do not provide any new statements, it only provide different lowering strategies for existing statements.</p>"},{"location":"reference/kirin/dialects/lowering/call/","title":"Call","text":""},{"location":"reference/kirin/dialects/lowering/cf/","title":"Cf","text":"<p>Lowering Python AST to cf dialect.</p>"},{"location":"reference/kirin/dialects/lowering/cf/#kirin.dialects.lowering.cf.CfLowering","title":"CfLowering  <code>dataclass</code>","text":"<pre><code>CfLowering()\n</code></pre> <p>               Bases: <code>FromPythonAST</code></p>"},{"location":"reference/kirin/dialects/lowering/cf/#kirin.dialects.lowering.cf.CfLowering.branch_next_if_not_terminated","title":"branch_next_if_not_terminated","text":"<pre><code>branch_next_if_not_terminated(frame: lowering.Frame)\n</code></pre> <p>Branch to the next block if the current block is not terminated.</p> <p>This must be used after exhausting the current frame and before popping the frame.</p> Source code in <code>src/kirin/dialects/lowering/cf.py</code> <pre><code>def branch_next_if_not_terminated(self, frame: lowering.Frame):\n    \"\"\"Branch to the next block if the current block is not terminated.\n\n    This must be used after exhausting the current frame and before popping the frame.\n    \"\"\"\n    if not frame.curr_block.last_stmt or not frame.curr_block.last_stmt.has_trait(\n        ir.IsTerminator\n    ):\n        frame.curr_block.stmts.append(\n            cf.Branch(arguments=(), successor=frame.next_block)\n        )\n</code></pre>"},{"location":"reference/kirin/dialects/lowering/func/","title":"Func","text":""},{"location":"reference/kirin/dialects/lowering/range/","title":"Range","text":""},{"location":"reference/kirin/dialects/lowering/range/#kirin.dialects.lowering.range.ilist","title":"ilist  <code>module-attribute</code>","text":"<pre><code>ilist = Dialect('lowering.range.ilist')\n</code></pre> <p>provides the syntax sugar from built-in range() function to ilist.range()</p>"},{"location":"reference/kirin/dialects/lowering/range/#kirin.dialects.lowering.range.py","title":"py  <code>module-attribute</code>","text":"<pre><code>py = Dialect('lowering.range.py')\n</code></pre> <p>provides the syntax sugar from built-in range() function to py.range()</p>"},{"location":"reference/kirin/dialects/math/","title":"Index","text":"<p>math dialect, modeling functions in python's <code>math</code> stdlib</p>"},{"location":"reference/kirin/dialects/math/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/dialects/math/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/math/stmts/","title":"Stmts","text":""},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.acos","title":"acos  <code>kirin-statement</code>","text":"<pre><code>acos(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>acos statement, wrapping the math.acos function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.asin","title":"asin  <code>kirin-statement</code>","text":"<pre><code>asin(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>asin statement, wrapping the math.asin function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.asinh","title":"asinh  <code>kirin-statement</code>","text":"<pre><code>asinh(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>asinh statement, wrapping the math.asinh function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.atan","title":"atan  <code>kirin-statement</code>","text":"<pre><code>atan(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>atan statement, wrapping the math.atan function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.atan2","title":"atan2  <code>kirin-statement</code>","text":"<pre><code>atan2(y: ir.SSAValue, x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>atan2 statement, wrapping the math.atan2 function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.atanh","title":"atanh  <code>kirin-statement</code>","text":"<pre><code>atanh(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>atanh statement, wrapping the math.atanh function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.ceil","title":"ceil  <code>kirin-statement</code>","text":"<pre><code>ceil(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>ceil statement, wrapping the math.ceil function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.copysign","title":"copysign  <code>kirin-statement</code>","text":"<pre><code>copysign(x: ir.SSAValue, y: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>copysign statement, wrapping the math.copysign function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.cos","title":"cos  <code>kirin-statement</code>","text":"<pre><code>cos(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>cos statement, wrapping the math.cos function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.cosh","title":"cosh  <code>kirin-statement</code>","text":"<pre><code>cosh(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>cosh statement, wrapping the math.cosh function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.degrees","title":"degrees  <code>kirin-statement</code>","text":"<pre><code>degrees(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>degrees statement, wrapping the math.degrees function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.erf","title":"erf  <code>kirin-statement</code>","text":"<pre><code>erf(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>erf statement, wrapping the math.erf function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.erfc","title":"erfc  <code>kirin-statement</code>","text":"<pre><code>erfc(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>erfc statement, wrapping the math.erfc function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.exp","title":"exp  <code>kirin-statement</code>","text":"<pre><code>exp(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>exp statement, wrapping the math.exp function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.expm1","title":"expm1  <code>kirin-statement</code>","text":"<pre><code>expm1(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>expm1 statement, wrapping the math.expm1 function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.fabs","title":"fabs  <code>kirin-statement</code>","text":"<pre><code>fabs(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>fabs statement, wrapping the math.fabs function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.floor","title":"floor  <code>kirin-statement</code>","text":"<pre><code>floor(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>floor statement, wrapping the math.floor function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.fmod","title":"fmod  <code>kirin-statement</code>","text":"<pre><code>fmod(x: ir.SSAValue, y: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>fmod statement, wrapping the math.fmod function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.gamma","title":"gamma  <code>kirin-statement</code>","text":"<pre><code>gamma(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>gamma statement, wrapping the math.gamma function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.isfinite","title":"isfinite  <code>kirin-statement</code>","text":"<pre><code>isfinite(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>isfinite statement, wrapping the math.isfinite function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.isinf","title":"isinf  <code>kirin-statement</code>","text":"<pre><code>isinf(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>isinf statement, wrapping the math.isinf function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.isnan","title":"isnan  <code>kirin-statement</code>","text":"<pre><code>isnan(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>isnan statement, wrapping the math.isnan function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.lgamma","title":"lgamma  <code>kirin-statement</code>","text":"<pre><code>lgamma(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>lgamma statement, wrapping the math.lgamma function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.log10","title":"log10  <code>kirin-statement</code>","text":"<pre><code>log10(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>log10 statement, wrapping the math.log10 function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.log1p","title":"log1p  <code>kirin-statement</code>","text":"<pre><code>log1p(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>log1p statement, wrapping the math.log1p function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.log2","title":"log2  <code>kirin-statement</code>","text":"<pre><code>log2(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>log2 statement, wrapping the math.log2 function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.pow","title":"pow  <code>kirin-statement</code>","text":"<pre><code>pow(x: ir.SSAValue, y: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>pow statement, wrapping the math.pow function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.radians","title":"radians  <code>kirin-statement</code>","text":"<pre><code>radians(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>radians statement, wrapping the math.radians function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.remainder","title":"remainder  <code>kirin-statement</code>","text":"<pre><code>remainder(x: ir.SSAValue, y: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>remainder statement, wrapping the math.remainder function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.sin","title":"sin  <code>kirin-statement</code>","text":"<pre><code>sin(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>sin statement, wrapping the math.sin function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.sinh","title":"sinh  <code>kirin-statement</code>","text":"<pre><code>sinh(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>sinh statement, wrapping the math.sinh function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.sqrt","title":"sqrt  <code>kirin-statement</code>","text":"<pre><code>sqrt(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>sqrt statement, wrapping the math.sqrt function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.tan","title":"tan  <code>kirin-statement</code>","text":"<pre><code>tan(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>tan statement, wrapping the math.tan function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.tanh","title":"tanh  <code>kirin-statement</code>","text":"<pre><code>tanh(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>tanh statement, wrapping the math.tanh function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.trunc","title":"trunc  <code>kirin-statement</code>","text":"<pre><code>trunc(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>trunc statement, wrapping the math.trunc function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.ulp","title":"ulp  <code>kirin-statement</code>","text":"<pre><code>ulp(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>ulp statement, wrapping the math.ulp function</p>"},{"location":"reference/kirin/dialects/py/","title":"Index","text":"<p>Python dialects module.</p> <p>This module contains a set of dialects that represent different fractions of the Python language. The dialects are designed to be used in a union to represent the entire Python language.</p>"},{"location":"reference/kirin/dialects/py/#kirin.dialects.py.statement","title":"statement","text":"<pre><code>statement(\n    cls=None, **kwargs: Unpack[StatementOptions]\n) -&gt; Callable[[type[StmtType]], type[StmtType]]\n</code></pre> <p>Declare a new statement class.</p> <p>This decorator is used to declare a new statement class. It is used to generate the necessary boilerplate code for the class. The class should inherit from <code>kirin.ir.Statement</code>.</p> <p>Parameters:</p> Name Type Description Default <code>init(bool)</code> <p>Whether to generate an <code>__init__</code> method.</p> required <code>repr(bool)</code> <p>Whether to generate a <code>__repr__</code> method.</p> required <code>kw_only(bool)</code> <p>Whether to use keyword-only arguments in the <code>__init__</code> method.</p> required <code>dialect(Optional[Dialect])</code> <p>The dialect of the statement.</p> required <code>property(bool)</code> <p>Whether to generate property methods for attributes.</p> required Example <p>The following is an example of how to use the <code>statement</code> decorator.</p> <pre><code>@statement\nclass MyStatement(ir.Statement):\n    name = \"some_name\"\n    traits = frozenset({TraitA(), TraitB()})\n    some_input: ir.SSAValue = info.argument()\n    some_output: ir.ResultValue = info.result()\n    body: ir.Region = info.region()\n    successor: ir.Block = info.block()\n</code></pre> <p>If the <code>name</code> field is not specified, a lowercase name field will be auto generated.</p> <p>In addition, one can optionally register the statement to a dialect by providing the <code>dialect</code> argument to the decorator.</p> <p>The following example register the statement to a dialect <code>my_dialect_object</code>, and <code>name = \"myfoo\"</code> field is autogenerated</p> <pre><code>@statement(dialect=my_dialect_object)\nclass MyFoo(ir.Statement):\n    traits = frozenset({ir.FromPythonCall()})\n    value: str = info.attribute()\n</code></pre> Source code in <code>src/kirin/decl/__init__.py</code> <pre><code>@dataclass_transform(\n    field_specifiers=(\n        info.attribute,\n        info.argument,\n        info.region,\n        info.result,\n        info.block,\n    )\n)\ndef statement(\n    cls=None,\n    **kwargs: Unpack[StatementOptions],\n) -&gt; Callable[[type[StmtType]], type[StmtType]]:\n    \"\"\"Declare a new statement class.\n\n    This decorator is used to declare a new statement class. It is used to\n    generate the necessary boilerplate code for the class. The class should\n    inherit from `kirin.ir.Statement`.\n\n    Args:\n        init(bool): Whether to generate an `__init__` method.\n        repr(bool): Whether to generate a `__repr__` method.\n        kw_only(bool): Whether to use keyword-only arguments in the `__init__`\n            method.\n        dialect(Optional[Dialect]): The dialect of the statement.\n        property(bool): Whether to generate property methods for attributes.\n\n    Example:\n        The following is an example of how to use the `statement` decorator.\n\n        ```python\n        @statement\n        class MyStatement(ir.Statement):\n            name = \"some_name\"\n            traits = frozenset({TraitA(), TraitB()})\n            some_input: ir.SSAValue = info.argument()\n            some_output: ir.ResultValue = info.result()\n            body: ir.Region = info.region()\n            successor: ir.Block = info.block()\n        ```\n\n        If the `name` field is not specified, a lowercase name field will be auto generated.\n\n        In addition, one can optionally register the statement to a dialect\n        by providing the `dialect` argument to the decorator.\n\n        The following example register the statement to a dialect `my_dialect_object`, and `name = \"myfoo\"` field is autogenerated\n\n        ```python\n        @statement(dialect=my_dialect_object)\n        class MyFoo(ir.Statement):\n            traits = frozenset({ir.FromPythonCall()})\n            value: str = info.attribute()\n        ```\n    \"\"\"\n\n    def wrap(cls):\n        decl = StatementDecl(cls, **kwargs)\n        decl.scan_fields()\n        decl.verify()\n        decl.emit()\n        decl.register()\n        return cls\n\n    if cls is None:\n        return wrap\n    return wrap(cls)\n</code></pre>"},{"location":"reference/kirin/dialects/py/assertion/","title":"Assertion","text":"<p>Assertion dialect for Python.</p> <p>This module contains the dialect for the Python <code>assert</code> statement, including:</p> <ul> <li>The <code>Assert</code> statement class.</li> <li>The lowering pass for the <code>assert</code> statement.</li> <li>The concrete implementation of the <code>assert</code> statement.</li> <li>The type inference implementation of the <code>assert</code> statement.</li> <li>The Julia emitter for the <code>assert</code> statement.</li> </ul> <p>This dialect maps <code>ast.Assert</code> nodes to the <code>Assert</code> statement.</p>"},{"location":"reference/kirin/dialects/py/assign/","title":"Assign","text":"<p>Assignment dialect for Python.</p> <p>This module contains the dialect for the Python assignment statement, including:</p> <ul> <li>Statements: <code>Alias</code>, <code>SetItem</code>.</li> <li>The lowering pass for the assignments.</li> <li>The concrete implementation of the assignment statements.</li> </ul> <p>This dialects maps Python assignment syntax.</p>"},{"location":"reference/kirin/dialects/py/attr/","title":"Attr","text":"<p>Attribute access dialect for Python.</p> <p>This module contains the dialect for the Python attribute access statement, including:</p> <ul> <li>The <code>GetAttr</code> statement class.</li> <li>The lowering pass for the attribute access statement.</li> <li>The concrete implementation of the attribute access statement.</li> </ul> <p>This dialect maps <code>ast.Attribute</code> nodes to the <code>GetAttr</code> statement.</p>"},{"location":"reference/kirin/dialects/py/base/","title":"Base","text":"<p>Base dialect for Python.</p> <p>This dialect does not contain statements. It only contains lowering rules for <code>ast.Name</code> and <code>ast.Expr</code>.</p>"},{"location":"reference/kirin/dialects/py/boolop/","title":"Boolop","text":"<p>Boolean operators for Python dialect.</p> <p>This module contains the dialect for the Python boolean operators, including:</p> <ul> <li>The <code>And</code> and <code>Or</code> statement classes.</li> <li>The lowering pass for the boolean operators.</li> <li>The concrete implementation of the boolean operators.</li> <li>The Julia emitter for the boolean operators.</li> </ul> <p>This dialect maps <code>ast.BoolOp</code> nodes to the <code>And</code> and <code>Or</code> statements.</p>"},{"location":"reference/kirin/dialects/py/builtin/","title":"Builtin","text":"<p>builtin dialect for python builtins</p> <p>This dialect provides implementations for builtin functions like abs and sum.</p> <ul> <li>Statements: <code>Abs</code>, <code>Sum</code>.</li> <li>The lowering pass for the builtin functions.</li> <li>The concrete implementation of the builtin functions.</li> <li>The type inference implementation of the builtin functions.</li> </ul> <p>This dialect maps <code>ast.Call</code> nodes of builtin functions to the <code>Abs</code> and <code>Sum</code> statements.</p>"},{"location":"reference/kirin/dialects/py/constant/","title":"Constant","text":"<p>Constant statement for Python dialect.</p> <p>This module contains the dialect for the Python <code>constant</code> statement, including:</p> <ul> <li>The <code>Constant</code> statement class.</li> <li>The lowering pass for the <code>constant</code> statement.</li> <li>The concrete implementation of the <code>constant</code> statement.</li> <li>The Julia emitter for the <code>constant</code> statement.</li> </ul> <p>This dialect maps <code>ast.Constant</code> nodes to the <code>Constant</code> statement.</p>"},{"location":"reference/kirin/dialects/py/constant/#kirin.dialects.py.constant.Constant","title":"Constant  <code>kirin-statement</code>","text":"<pre><code>Constant(value: T | ir.Data[T])\n</code></pre> <p>               Bases: <code>Statement</code>, <code>Generic[T]</code></p> Source code in <code>src/kirin/dialects/py/constant.py</code> <pre><code>def __init__(self, value: T | ir.Data[T]) -&gt; None:\n    if not isinstance(value, ir.Data):\n        value = ir.PyAttr(value)\n    super().__init__(\n        attributes={\"value\": value},\n        result_types=(value.type,),\n    )\n</code></pre>"},{"location":"reference/kirin/dialects/py/constant/#kirin.dialects.py.constant.Constant.check_type","title":"check_type","text":"<pre><code>check_type() -&gt; None\n</code></pre> <p>Check the types of the Block. Raises <code>Exception</code> if the types are not correct. This method is called by the <code>verify_type</code> method, which will detect the source of the error in the IR. One should always call the <code>verify_type</code> method to verify the types of the IR.</p> Note <p>This method is generated by the <code>@statement</code> decorator. But can be overridden if needed.</p> Source code in <code>src/kirin/dialects/py/constant.py</code> <pre><code>def check_type(self) -&gt; None:\n    if not isinstance(self.result.type, types.TypeAttribute):\n        raise TypeError(\n            f\"Expected result type to be PyType, got {self.result.type}\"\n        )\n</code></pre>"},{"location":"reference/kirin/dialects/py/indexing/","title":"Indexing","text":"<p>The indexing dialect for Python.</p> <p>This module contains the dialect for the Python indexing syntax, including:</p> <ul> <li>The <code>GetItem</code> statement class.</li> <li>A base class <code>Subscript</code> for indexing statements.</li> <li>A trait <code>GetItemLike</code> for indexing statements.</li> <li>The lowering pass for the indexing statement.</li> <li>The concrete implementation of the indexing statement.</li> <li>The constant propagation implementation (special case) of the indexing statement.</li> <li>The type inference implementation of the indexing statement.</li> <li>A canonical rewrite rule for the rewriting of a given getitem-like     statement to another getitem-like statement.</li> </ul>"},{"location":"reference/kirin/dialects/py/iterable/","title":"Iterable","text":"<p>This module provides access to Python iterables.</p> <p>This is used to lower Python loops into <code>cf</code> dialect.</p> <p>This module contains the common methods for the Python iterable:</p> <ul> <li>The <code>Iter</code> statement class.</li> <li>The <code>Next</code> statement class.</li> <li>The lowering pass for the iterable.</li> <li>The concrete implementation of the iterable.</li> </ul> <p>This dialect maps <code>iter()</code> and <code>next()</code> calls to the <code>Iter</code> and <code>Next</code> statements.</p>"},{"location":"reference/kirin/dialects/py/iterable/#kirin.dialects.py.iterable.Iter","title":"Iter  <code>kirin-statement</code>","text":"<pre><code>Iter(value: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>This is equivalent to <code>iter(value)</code> in Python.</p>"},{"location":"reference/kirin/dialects/py/iterable/#kirin.dialects.py.iterable.Next","title":"Next  <code>kirin-statement</code>","text":"<pre><code>Next(iter: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>This is equivalent to <code>next(iterable, None)</code> in Python.</p>"},{"location":"reference/kirin/dialects/py/len/","title":"Len","text":"<p>The <code>Len</code> dialect.</p> <p>This dialect maps the <code>len()</code> call to the <code>Len</code> statement:</p> <ul> <li>The <code>Len</code> statement class.</li> <li>The lowering pass for the <code>len()</code> call.</li> <li>The concrete implementation of the <code>len()</code> call.</li> </ul>"},{"location":"reference/kirin/dialects/py/range/","title":"Range","text":"<p>The range dialect for Python.</p> <p>This dialect models the builtin <code>range()</code> function in Python.</p> <p>The dialect includes: - The <code>Range</code> statement class. - The lowering pass for the <code>range()</code> function.</p> <p>This dialect does not include a concrete implementation or type inference for the <code>range()</code> function. One needs to use other dialect for the concrete implementation and type inference, e.g., <code>ilist</code> dialect.</p>"},{"location":"reference/kirin/dialects/py/slice/","title":"Slice","text":"<p>The slice dialect for Python.</p> <p>This dialect provides a <code>Slice</code> statement that represents a slice object in Python:</p> <ul> <li>The <code>Slice</code> statement class.</li> <li>The lowering pass for the <code>slice</code> call.</li> <li>The concrete implementation of the <code>slice</code> call.</li> <li>The type inference implementation of the <code>slice</code> call.</li> </ul>"},{"location":"reference/kirin/dialects/py/tuple/","title":"Tuple","text":"<p>The tuple dialect for Python.</p> <p>This dialect provides a way to work with Python tuples in the IR, including:</p> <ul> <li>The <code>New</code> statement class.</li> <li>The lowering pass for the tuple statement.</li> <li>The concrete implementation of the tuple statement.</li> <li>The type inference implementation of the tuple addition with <code>py.binop.Add</code>.</li> <li>The constant propagation implementation of the tuple statement.</li> <li>The Julia emitter for the tuple statement.</li> </ul> <p>This dialect maps <code>ast.Tuple</code> nodes to the <code>New</code> statement.</p>"},{"location":"reference/kirin/dialects/py/unpack/","title":"Unpack","text":"<p>The unpack dialect for Python.</p> <p>This module contains the dialect for the Python unpack semantics, including:</p> <ul> <li>The <code>Unpack</code> statement class.</li> <li>The lowering pass for the unpack statement.</li> <li>The concrete implementation of the unpack statement.</li> <li>The type inference implementation of the unpack statement.</li> <li>A helper function <code>unpacking</code> for unpacking Python AST nodes during lowering.</li> </ul>"},{"location":"reference/kirin/dialects/py/binop/","title":"Index","text":"<p>The binop dialect for Python.</p> <p>This module contains the dialect for binary operation semantics in Python, including:</p> <ul> <li>The <code>Add</code>, <code>Sub</code>, <code>Mult</code>, <code>Div</code>, <code>FloorDiv</code>, <code>Mod</code>, <code>Pow</code>,     <code>LShift</code>, <code>RShift</code>, <code>BitOr</code>, <code>BitXor</code>, and <code>BitAnd</code> statement classes.</li> <li>The lowering pass for binary operations.</li> <li>The concrete implementation of binary operations.</li> <li>The type inference implementation of binary operations.</li> <li>The Julia emitter for binary operations.</li> </ul> <p>This dialect maps <code>ast.BinOp</code> nodes to the <code>Add</code>, <code>Sub</code>, <code>Mult</code>, <code>Div</code>, <code>FloorDiv</code>, <code>Mod</code>, <code>Pow</code>, <code>LShift</code>, <code>RShift</code>, <code>BitOr</code>, <code>BitXor</code>, and <code>BitAnd</code> statements.</p>"},{"location":"reference/kirin/dialects/py/binop/#kirin.dialects.py.binop.statement","title":"statement","text":"<pre><code>statement(\n    cls=None, **kwargs: Unpack[StatementOptions]\n) -&gt; Callable[[type[StmtType]], type[StmtType]]\n</code></pre> <p>Declare a new statement class.</p> <p>This decorator is used to declare a new statement class. It is used to generate the necessary boilerplate code for the class. The class should inherit from <code>kirin.ir.Statement</code>.</p> <p>Parameters:</p> Name Type Description Default <code>init(bool)</code> <p>Whether to generate an <code>__init__</code> method.</p> required <code>repr(bool)</code> <p>Whether to generate a <code>__repr__</code> method.</p> required <code>kw_only(bool)</code> <p>Whether to use keyword-only arguments in the <code>__init__</code> method.</p> required <code>dialect(Optional[Dialect])</code> <p>The dialect of the statement.</p> required <code>property(bool)</code> <p>Whether to generate property methods for attributes.</p> required Example <p>The following is an example of how to use the <code>statement</code> decorator.</p> <pre><code>@statement\nclass MyStatement(ir.Statement):\n    name = \"some_name\"\n    traits = frozenset({TraitA(), TraitB()})\n    some_input: ir.SSAValue = info.argument()\n    some_output: ir.ResultValue = info.result()\n    body: ir.Region = info.region()\n    successor: ir.Block = info.block()\n</code></pre> <p>If the <code>name</code> field is not specified, a lowercase name field will be auto generated.</p> <p>In addition, one can optionally register the statement to a dialect by providing the <code>dialect</code> argument to the decorator.</p> <p>The following example register the statement to a dialect <code>my_dialect_object</code>, and <code>name = \"myfoo\"</code> field is autogenerated</p> <pre><code>@statement(dialect=my_dialect_object)\nclass MyFoo(ir.Statement):\n    traits = frozenset({ir.FromPythonCall()})\n    value: str = info.attribute()\n</code></pre> Source code in <code>src/kirin/decl/__init__.py</code> <pre><code>@dataclass_transform(\n    field_specifiers=(\n        info.attribute,\n        info.argument,\n        info.region,\n        info.result,\n        info.block,\n    )\n)\ndef statement(\n    cls=None,\n    **kwargs: Unpack[StatementOptions],\n) -&gt; Callable[[type[StmtType]], type[StmtType]]:\n    \"\"\"Declare a new statement class.\n\n    This decorator is used to declare a new statement class. It is used to\n    generate the necessary boilerplate code for the class. The class should\n    inherit from `kirin.ir.Statement`.\n\n    Args:\n        init(bool): Whether to generate an `__init__` method.\n        repr(bool): Whether to generate a `__repr__` method.\n        kw_only(bool): Whether to use keyword-only arguments in the `__init__`\n            method.\n        dialect(Optional[Dialect]): The dialect of the statement.\n        property(bool): Whether to generate property methods for attributes.\n\n    Example:\n        The following is an example of how to use the `statement` decorator.\n\n        ```python\n        @statement\n        class MyStatement(ir.Statement):\n            name = \"some_name\"\n            traits = frozenset({TraitA(), TraitB()})\n            some_input: ir.SSAValue = info.argument()\n            some_output: ir.ResultValue = info.result()\n            body: ir.Region = info.region()\n            successor: ir.Block = info.block()\n        ```\n\n        If the `name` field is not specified, a lowercase name field will be auto generated.\n\n        In addition, one can optionally register the statement to a dialect\n        by providing the `dialect` argument to the decorator.\n\n        The following example register the statement to a dialect `my_dialect_object`, and `name = \"myfoo\"` field is autogenerated\n\n        ```python\n        @statement(dialect=my_dialect_object)\n        class MyFoo(ir.Statement):\n            traits = frozenset({ir.FromPythonCall()})\n            value: str = info.attribute()\n        ```\n    \"\"\"\n\n    def wrap(cls):\n        decl = StatementDecl(cls, **kwargs)\n        decl.scan_fields()\n        decl.verify()\n        decl.emit()\n        decl.register()\n        return cls\n\n    if cls is None:\n        return wrap\n    return wrap(cls)\n</code></pre>"},{"location":"reference/kirin/dialects/py/binop/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/py/binop/julia/","title":"Julia","text":""},{"location":"reference/kirin/dialects/py/binop/lowering/","title":"Lowering","text":""},{"location":"reference/kirin/dialects/py/binop/stmts/","title":"Stmts","text":""},{"location":"reference/kirin/dialects/py/binop/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/dialects/py/cmp/","title":"Index","text":"<p>The cmp dialect for Python.</p> <p>This module contains the dialect for comparison semantics in Python, including:</p> <ul> <li>The <code>Eq</code>, <code>NotEq</code>, <code>Lt</code>, <code>LtE</code>, <code>Gt</code>, <code>GtE</code>, <code>Is</code>, and <code>IsNot</code> statement classes.</li> <li>The lowering pass for comparison operations.</li> <li>The concrete implementation of comparison operations.</li> <li>The Julia emitter for comparison operations.</li> </ul> <p>This dialect maps <code>ast.Compare</code> nodes to the <code>Eq</code>, <code>NotEq</code>, <code>Lt</code>, <code>LtE</code>, <code>Gt</code>, <code>GtE</code>, <code>Is</code>, and <code>IsNot</code> statements.</p>"},{"location":"reference/kirin/dialects/py/cmp/#kirin.dialects.py.cmp.statement","title":"statement","text":"<pre><code>statement(\n    cls=None, **kwargs: Unpack[StatementOptions]\n) -&gt; Callable[[type[StmtType]], type[StmtType]]\n</code></pre> <p>Declare a new statement class.</p> <p>This decorator is used to declare a new statement class. It is used to generate the necessary boilerplate code for the class. The class should inherit from <code>kirin.ir.Statement</code>.</p> <p>Parameters:</p> Name Type Description Default <code>init(bool)</code> <p>Whether to generate an <code>__init__</code> method.</p> required <code>repr(bool)</code> <p>Whether to generate a <code>__repr__</code> method.</p> required <code>kw_only(bool)</code> <p>Whether to use keyword-only arguments in the <code>__init__</code> method.</p> required <code>dialect(Optional[Dialect])</code> <p>The dialect of the statement.</p> required <code>property(bool)</code> <p>Whether to generate property methods for attributes.</p> required Example <p>The following is an example of how to use the <code>statement</code> decorator.</p> <pre><code>@statement\nclass MyStatement(ir.Statement):\n    name = \"some_name\"\n    traits = frozenset({TraitA(), TraitB()})\n    some_input: ir.SSAValue = info.argument()\n    some_output: ir.ResultValue = info.result()\n    body: ir.Region = info.region()\n    successor: ir.Block = info.block()\n</code></pre> <p>If the <code>name</code> field is not specified, a lowercase name field will be auto generated.</p> <p>In addition, one can optionally register the statement to a dialect by providing the <code>dialect</code> argument to the decorator.</p> <p>The following example register the statement to a dialect <code>my_dialect_object</code>, and <code>name = \"myfoo\"</code> field is autogenerated</p> <pre><code>@statement(dialect=my_dialect_object)\nclass MyFoo(ir.Statement):\n    traits = frozenset({ir.FromPythonCall()})\n    value: str = info.attribute()\n</code></pre> Source code in <code>src/kirin/decl/__init__.py</code> <pre><code>@dataclass_transform(\n    field_specifiers=(\n        info.attribute,\n        info.argument,\n        info.region,\n        info.result,\n        info.block,\n    )\n)\ndef statement(\n    cls=None,\n    **kwargs: Unpack[StatementOptions],\n) -&gt; Callable[[type[StmtType]], type[StmtType]]:\n    \"\"\"Declare a new statement class.\n\n    This decorator is used to declare a new statement class. It is used to\n    generate the necessary boilerplate code for the class. The class should\n    inherit from `kirin.ir.Statement`.\n\n    Args:\n        init(bool): Whether to generate an `__init__` method.\n        repr(bool): Whether to generate a `__repr__` method.\n        kw_only(bool): Whether to use keyword-only arguments in the `__init__`\n            method.\n        dialect(Optional[Dialect]): The dialect of the statement.\n        property(bool): Whether to generate property methods for attributes.\n\n    Example:\n        The following is an example of how to use the `statement` decorator.\n\n        ```python\n        @statement\n        class MyStatement(ir.Statement):\n            name = \"some_name\"\n            traits = frozenset({TraitA(), TraitB()})\n            some_input: ir.SSAValue = info.argument()\n            some_output: ir.ResultValue = info.result()\n            body: ir.Region = info.region()\n            successor: ir.Block = info.block()\n        ```\n\n        If the `name` field is not specified, a lowercase name field will be auto generated.\n\n        In addition, one can optionally register the statement to a dialect\n        by providing the `dialect` argument to the decorator.\n\n        The following example register the statement to a dialect `my_dialect_object`, and `name = \"myfoo\"` field is autogenerated\n\n        ```python\n        @statement(dialect=my_dialect_object)\n        class MyFoo(ir.Statement):\n            traits = frozenset({ir.FromPythonCall()})\n            value: str = info.attribute()\n        ```\n    \"\"\"\n\n    def wrap(cls):\n        decl = StatementDecl(cls, **kwargs)\n        decl.scan_fields()\n        decl.verify()\n        decl.emit()\n        decl.register()\n        return cls\n\n    if cls is None:\n        return wrap\n    return wrap(cls)\n</code></pre>"},{"location":"reference/kirin/dialects/py/cmp/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/py/cmp/julia/","title":"Julia","text":""},{"location":"reference/kirin/dialects/py/cmp/lowering/","title":"Lowering","text":""},{"location":"reference/kirin/dialects/py/cmp/stmts/","title":"Stmts","text":""},{"location":"reference/kirin/dialects/py/list/","title":"Index","text":"<p>The list dialect for Python.</p> <p>This module contains the dialect for list semantics in Python, including:</p> <ul> <li>The <code>New</code> and <code>Append</code> statement classes.</li> <li>The lowering pass for list operations.</li> <li>The concrete implementation of list operations.</li> <li>The type inference implementation of list operations.</li> </ul> <p>This dialect maps <code>list()</code>, <code>ast.List</code> and <code>append()</code> calls to the <code>New</code> and <code>Append</code> statements.</p>"},{"location":"reference/kirin/dialects/py/list/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/py/list/lowering/","title":"Lowering","text":""},{"location":"reference/kirin/dialects/py/list/stmts/","title":"Stmts","text":""},{"location":"reference/kirin/dialects/py/list/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/dialects/py/unary/","title":"Index","text":"<p>The unary dialect for Python.</p> <p>This module contains the dialect for unary semantics in Python, including:</p> <ul> <li>The <code>UnaryOp</code> base class for unary operations.</li> <li>The <code>UAdd</code>, <code>USub</code>, <code>Not</code>, and <code>Invert</code> statement classes.</li> <li>The lowering pass for unary operations.</li> <li>The concrete implementation of unary operations.</li> <li>The type inference implementation of unary operations.</li> <li>The constant propagation implementation of unary operations.</li> <li>The Julia emitter for unary operations.</li> </ul> <p>This dialect maps <code>ast.UnaryOp</code> nodes to the <code>UAdd</code>, <code>USub</code>, <code>Not</code>, and <code>Invert</code> statements.</p>"},{"location":"reference/kirin/dialects/py/unary/#kirin.dialects.py.unary.statement","title":"statement","text":"<pre><code>statement(\n    cls=None, **kwargs: Unpack[StatementOptions]\n) -&gt; Callable[[type[StmtType]], type[StmtType]]\n</code></pre> <p>Declare a new statement class.</p> <p>This decorator is used to declare a new statement class. It is used to generate the necessary boilerplate code for the class. The class should inherit from <code>kirin.ir.Statement</code>.</p> <p>Parameters:</p> Name Type Description Default <code>init(bool)</code> <p>Whether to generate an <code>__init__</code> method.</p> required <code>repr(bool)</code> <p>Whether to generate a <code>__repr__</code> method.</p> required <code>kw_only(bool)</code> <p>Whether to use keyword-only arguments in the <code>__init__</code> method.</p> required <code>dialect(Optional[Dialect])</code> <p>The dialect of the statement.</p> required <code>property(bool)</code> <p>Whether to generate property methods for attributes.</p> required Example <p>The following is an example of how to use the <code>statement</code> decorator.</p> <pre><code>@statement\nclass MyStatement(ir.Statement):\n    name = \"some_name\"\n    traits = frozenset({TraitA(), TraitB()})\n    some_input: ir.SSAValue = info.argument()\n    some_output: ir.ResultValue = info.result()\n    body: ir.Region = info.region()\n    successor: ir.Block = info.block()\n</code></pre> <p>If the <code>name</code> field is not specified, a lowercase name field will be auto generated.</p> <p>In addition, one can optionally register the statement to a dialect by providing the <code>dialect</code> argument to the decorator.</p> <p>The following example register the statement to a dialect <code>my_dialect_object</code>, and <code>name = \"myfoo\"</code> field is autogenerated</p> <pre><code>@statement(dialect=my_dialect_object)\nclass MyFoo(ir.Statement):\n    traits = frozenset({ir.FromPythonCall()})\n    value: str = info.attribute()\n</code></pre> Source code in <code>src/kirin/decl/__init__.py</code> <pre><code>@dataclass_transform(\n    field_specifiers=(\n        info.attribute,\n        info.argument,\n        info.region,\n        info.result,\n        info.block,\n    )\n)\ndef statement(\n    cls=None,\n    **kwargs: Unpack[StatementOptions],\n) -&gt; Callable[[type[StmtType]], type[StmtType]]:\n    \"\"\"Declare a new statement class.\n\n    This decorator is used to declare a new statement class. It is used to\n    generate the necessary boilerplate code for the class. The class should\n    inherit from `kirin.ir.Statement`.\n\n    Args:\n        init(bool): Whether to generate an `__init__` method.\n        repr(bool): Whether to generate a `__repr__` method.\n        kw_only(bool): Whether to use keyword-only arguments in the `__init__`\n            method.\n        dialect(Optional[Dialect]): The dialect of the statement.\n        property(bool): Whether to generate property methods for attributes.\n\n    Example:\n        The following is an example of how to use the `statement` decorator.\n\n        ```python\n        @statement\n        class MyStatement(ir.Statement):\n            name = \"some_name\"\n            traits = frozenset({TraitA(), TraitB()})\n            some_input: ir.SSAValue = info.argument()\n            some_output: ir.ResultValue = info.result()\n            body: ir.Region = info.region()\n            successor: ir.Block = info.block()\n        ```\n\n        If the `name` field is not specified, a lowercase name field will be auto generated.\n\n        In addition, one can optionally register the statement to a dialect\n        by providing the `dialect` argument to the decorator.\n\n        The following example register the statement to a dialect `my_dialect_object`, and `name = \"myfoo\"` field is autogenerated\n\n        ```python\n        @statement(dialect=my_dialect_object)\n        class MyFoo(ir.Statement):\n            traits = frozenset({ir.FromPythonCall()})\n            value: str = info.attribute()\n        ```\n    \"\"\"\n\n    def wrap(cls):\n        decl = StatementDecl(cls, **kwargs)\n        decl.scan_fields()\n        decl.verify()\n        decl.emit()\n        decl.register()\n        return cls\n\n    if cls is None:\n        return wrap\n    return wrap(cls)\n</code></pre>"},{"location":"reference/kirin/dialects/py/unary/constprop/","title":"Constprop","text":""},{"location":"reference/kirin/dialects/py/unary/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/py/unary/julia/","title":"Julia","text":""},{"location":"reference/kirin/dialects/py/unary/lowering/","title":"Lowering","text":""},{"location":"reference/kirin/dialects/py/unary/stmts/","title":"Stmts","text":""},{"location":"reference/kirin/dialects/py/unary/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/dialects/scf/","title":"Index","text":"<p>A Python-like structural Control Flow dialect.</p> <p>This dialect provides constructs for expressing control flow in a structured manner. The dialect provides constructs for expressing loops and conditionals. Unlike MLIR SCF dialect, this dialect does not restrict the control flow to statically analyzable forms. This dialect is designed to be compatible with Python native control flow constructs.</p> <p>This dialect depends on the following dialects: - <code>eltype</code>: for obtaining the element type of a value.</p>"},{"location":"reference/kirin/dialects/scf/absint/","title":"Absint","text":""},{"location":"reference/kirin/dialects/scf/constprop/","title":"Constprop","text":""},{"location":"reference/kirin/dialects/scf/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/scf/lowering/","title":"Lowering","text":""},{"location":"reference/kirin/dialects/scf/stmts/","title":"Stmts","text":""},{"location":"reference/kirin/dialects/scf/stmts/#kirin.dialects.scf.stmts.For","title":"For  <code>kirin-statement</code>","text":"<pre><code>For(\n    iterable: ir.SSAValue,\n    body: ir.Region,\n    *initializers: ir.SSAValue\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> Source code in <code>src/kirin/dialects/scf/stmts.py</code> <pre><code>def __init__(\n    self,\n    iterable: ir.SSAValue,\n    body: ir.Region,\n    *initializers: ir.SSAValue,\n):\n    stmt = body.blocks[0].last_stmt\n    if isinstance(stmt, Yield):\n        result_types = tuple(value.type for value in stmt.values)\n    else:\n        result_types = ()\n    super().__init__(\n        args=(iterable, *initializers),\n        regions=(body,),\n        result_types=result_types,\n        args_slice={\"iterable\": 0, \"initializers\": slice(1, None)},\n        attributes={\"purity\": ir.PyAttr(False)},\n    )\n</code></pre>"},{"location":"reference/kirin/dialects/scf/stmts/#kirin.dialects.scf.stmts.For.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>run mandatory validation checks. This is not same as verify_type, which may be optional.</p> Source code in <code>src/kirin/dialects/scf/stmts.py</code> <pre><code>def verify(self) -&gt; None:\n    from kirin.dialects.func import Return\n\n    if len(self.body.blocks) != 1:\n        raise ir.ValidationError(self, \"for loop body must have a single block\")\n\n    if len(self.body.blocks[0].args) != len(self.initializers) + 1:\n        raise ir.ValidationError(\n            self,\n            \"for loop body must have arguments for all initializers and the loop variable\",\n        )\n\n    stmt = self.body.blocks[0].last_stmt\n    if stmt is None or not isinstance(stmt, (Yield, Return)):\n        raise ir.ValidationError(\n            self, \"for loop body must terminate with a yield or return\"\n        )\n\n    if isinstance(stmt, Return):\n        return\n\n    if len(stmt.values) != len(self.initializers):\n        raise ir.ValidationError(\n            self,\n            \"for loop body must have the same number of results as initializers\",\n        )\n    if len(self.results) != len(stmt.values):\n        raise ir.ValidationError(\n            self,\n            \"for loop must have the same number of results as the yield in the body\",\n        )\n</code></pre>"},{"location":"reference/kirin/dialects/scf/stmts/#kirin.dialects.scf.stmts.IfElse","title":"IfElse  <code>kirin-statement</code>","text":"<pre><code>IfElse(\n    cond: ir.SSAValue,\n    then_body: ir.Region | ir.Block,\n    else_body: ir.Region | ir.Block | None = None,\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>Python-like if-else statement.</p> <p>This statement has a condition, then body, and else body.</p> <p>Then body either terminates with a yield statement or <code>scf.return</code>.</p> Source code in <code>src/kirin/dialects/scf/stmts.py</code> <pre><code>def __init__(\n    self,\n    cond: ir.SSAValue,\n    then_body: ir.Region | ir.Block,\n    else_body: ir.Region | ir.Block | None = None,\n):\n    if isinstance(then_body, ir.Region):\n        then_body_region = then_body\n        if then_body_region.blocks:\n            then_body_block = then_body_region.blocks[-1]\n        else:\n            then_body_block = None\n    elif isinstance(then_body, ir.Block):\n        then_body_block = then_body\n        then_body_region = ir.Region(then_body)\n\n    if isinstance(else_body, ir.Region):\n        if not else_body.blocks:  # empty region\n            else_body_region = else_body\n            else_body_block = None\n        elif len(else_body.blocks) == 0:\n            else_body_region = else_body\n            else_body_block = None\n        else:\n            else_body_region = else_body\n            else_body_block = else_body_region.blocks[0]\n    elif isinstance(else_body, ir.Block):\n        else_body_region = ir.Region(else_body)\n        else_body_block = else_body\n    else:\n        else_body_region = ir.Region()\n        else_body_block = None\n\n    # if either then or else body has yield, we generate results\n    # we assume if both have yields, they have the same number of results\n    results = ()\n    if then_body_block is not None:\n        then_yield = then_body_block.last_stmt\n        else_yield = (\n            else_body_block.last_stmt if else_body_block is not None else None\n        )\n        if then_yield is not None and isinstance(then_yield, Yield):\n            results = then_yield.values\n        elif else_yield is not None and isinstance(else_yield, Yield):\n            results = else_yield.values\n\n    result_types = tuple(value.type for value in results)\n    super().__init__(\n        args=(cond,),\n        regions=(then_body_region, else_body_region),\n        result_types=result_types,\n        args_slice={\"cond\": 0},\n        attributes={\"purity\": ir.PyAttr(False)},\n    )\n</code></pre>"},{"location":"reference/kirin/dialects/scf/stmts/#kirin.dialects.scf.stmts.IfElse.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>run mandatory validation checks. This is not same as verify_type, which may be optional.</p> Source code in <code>src/kirin/dialects/scf/stmts.py</code> <pre><code>def verify(self) -&gt; None:\n    from kirin.dialects.func import Return\n\n    if len(self.then_body.blocks) != 1:\n        raise ir.ValidationError(self, \"then region must have a single block\")\n\n    if len(self.else_body.blocks) != 1:\n        raise ir.ValidationError(self, \"else region must have a single block\")\n\n    then_block = self.then_body.blocks[0]\n    else_block = self.else_body.blocks[0]\n    if len(then_block.args) != 1:\n        raise ir.ValidationError(\n            self, \"then block must have a single argument for condition\"\n        )\n\n    if len(else_block.args) != 1:\n        raise ir.ValidationError(\n            self, \"else block must have a single argument for condition\"\n        )\n\n    then_stmt = then_block.last_stmt\n    else_stmt = else_block.last_stmt\n    if then_stmt is None or not isinstance(then_stmt, (Yield, Return)):\n        raise ir.ValidationError(\n            self, \"then block must terminate with a yield or return\"\n        )\n\n    if else_stmt is None or not isinstance(else_stmt, (Yield, Return)):\n        raise ir.ValidationError(\n            self, \"else block must terminate with a yield or return\"\n        )\n</code></pre>"},{"location":"reference/kirin/dialects/scf/trim/","title":"Trim","text":""},{"location":"reference/kirin/dialects/scf/trim/#kirin.dialects.scf.trim.UnusedYield","title":"UnusedYield  <code>dataclass</code>","text":"<pre><code>UnusedYield()\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <p>Trim unused results from <code>For</code> and <code>IfElse</code> statements.</p>"},{"location":"reference/kirin/dialects/scf/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/dialects/scf/unroll/","title":"Unroll","text":""},{"location":"reference/kirin/emit/","title":"Index","text":""},{"location":"reference/kirin/emit/abc/","title":"Abc","text":""},{"location":"reference/kirin/emit/abc/#kirin.emit.abc.EmitABC","title":"EmitABC  <code>dataclass</code>","text":"<pre><code>EmitABC(\n    dialects: DialectGroup,\n    *,\n    fuel: int | None = None,\n    debug: bool = False,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192\n)\n</code></pre> <p>               Bases: <code>BaseInterpreter[FrameType, ValueType]</code>, <code>ABC</code></p>"},{"location":"reference/kirin/emit/abc/#kirin.emit.abc.EmitABC.run_callable_region","title":"run_callable_region","text":"<pre><code>run_callable_region(\n    frame: FrameType,\n    code: ir.Statement,\n    region: ir.Region,\n    args: tuple[ValueType, ...],\n) -&gt; ValueType\n</code></pre> <p>A hook defines how to run the callable region given the interpreter context. Frame should be pushed before calling this method and popped after calling this method.</p> <p>A callable region is a region that can be called as a function. Unlike a general region (or the MLIR convention), it always return a value to be compatible with the Python convention.</p> Source code in <code>src/kirin/emit/abc.py</code> <pre><code>def run_callable_region(\n    self,\n    frame: FrameType,\n    code: ir.Statement,\n    region: ir.Region,\n    args: tuple[ValueType, ...],\n) -&gt; ValueType:\n    results = self.eval_stmt(frame, code)\n    if isinstance(results, tuple):\n        if len(results) == 0:\n            return self.void\n        elif len(results) == 1:\n            return results[0]\n    raise interp.InterpreterError(f\"Unexpected results {results}\")\n</code></pre>"},{"location":"reference/kirin/emit/abc/#kirin.emit.abc.EmitABC.run_ssacfg_region","title":"run_ssacfg_region","text":"<pre><code>run_ssacfg_region(\n    frame: FrameType,\n    region: ir.Region,\n    args: tuple[ValueType, ...],\n) -&gt; tuple[ValueType, ...]\n</code></pre> <p>This implements how to run a region with MLIR SSA CFG convention.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>FrameType</code> <p>the current frame.</p> required <code>region</code> <code>Region</code> <p>the region to run.</p> required <code>args</code> <code>tuple[ValueType, ...]</code> <p>the arguments to the region.</p> required <p>Returns:</p> Type Description <code>tuple[ValueType, ...] | None | ReturnValue[ValueType]</code> <p>tuple[ValueType, ...] | SpecialValue[ValueType]: the result of running the region.</p> <p>when region returns <code>tuple[ValueType, ...]</code>, it means the region terminates normally with <code>YieldValue</code>. When region returns <code>ReturnValue</code>, it means the region terminates and needs to pop the frame. Region cannot return <code>Successor</code> because reference to external region is not allowed.</p> Source code in <code>src/kirin/emit/abc.py</code> <pre><code>def run_ssacfg_region(\n    self, frame: FrameType, region: ir.Region, args: tuple[ValueType, ...]\n) -&gt; tuple[ValueType, ...]:\n    frame.worklist.append(interp.Successor(region.blocks[0], *args))\n    while (succ := frame.worklist.pop()) is not None:\n        frame.set_values(succ.block.args, succ.block_args)\n        block_header = self.emit_block(frame, succ.block)\n        frame.block_ref[succ.block] = block_header\n    return ()\n</code></pre>"},{"location":"reference/kirin/emit/exceptions/","title":"Exceptions","text":""},{"location":"reference/kirin/emit/julia/","title":"Julia","text":""},{"location":"reference/kirin/emit/julia/#kirin.emit.julia.EmitJulia","title":"EmitJulia  <code>dataclass</code>","text":"<pre><code>EmitJulia(\n    dialects: DialectGroup,\n    file: IO_t,\n    *,\n    fuel: int | None = None,\n    debug: bool = False,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192,\n    prefix: str = \"\",\n    prefix_if_none: str = \"var_\"\n)\n</code></pre> <p>               Bases: <code>EmitStr[IO_t]</code></p>"},{"location":"reference/kirin/emit/julia/#kirin.emit.julia.EmitJulia.keys","title":"keys  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>keys = ['emit.julia']\n</code></pre> <p>The name of the interpreter to select from dialects by order.</p>"},{"location":"reference/kirin/emit/str/","title":"Str","text":""},{"location":"reference/kirin/emit/str/#kirin.emit.str.EmitStr","title":"EmitStr  <code>dataclass</code>","text":"<pre><code>EmitStr(\n    dialects: DialectGroup,\n    file: IO_t,\n    *,\n    fuel: int | None = None,\n    debug: bool = False,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192,\n    prefix: str = \"\",\n    prefix_if_none: str = \"var_\"\n)\n</code></pre> <p>               Bases: <code>EmitABC[EmitStrFrame, str]</code>, <code>ABC</code>, <code>Generic[IO_t]</code></p>"},{"location":"reference/kirin/emit/str/#kirin.emit.str.EmitStr.void","title":"void  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>void = ''\n</code></pre> <p>What to return when the interpreter evaluates nothing.</p>"},{"location":"reference/kirin/emit/str/#kirin.emit.str.EmitStr.initialize","title":"initialize","text":"<pre><code>initialize()\n</code></pre> <p>Initialize the interpreter global states. This method is called right upon calling <code>run</code> to initialize the interpreter global states.</p> <p>Default Implementation</p> <p>This method provides default behavior but may be overridden by subclasses to customize or extend functionality.</p> Source code in <code>src/kirin/emit/str.py</code> <pre><code>def initialize(self):\n    super().initialize()\n    self.ssa_id = idtable.IdTable[ir.SSAValue](\n        prefix=self.prefix, prefix_if_none=self.prefix_if_none\n    )\n    self.block_id = idtable.IdTable[ir.Block](prefix=self.prefix + \"block_\")\n    return self\n</code></pre>"},{"location":"reference/kirin/emit/str/#kirin.emit.str.EmitStr.initialize_frame","title":"initialize_frame","text":"<pre><code>initialize_frame(\n    code: ir.Statement, *, has_parent_access: bool = False\n) -&gt; EmitStrFrame\n</code></pre> <p>Create a new frame for the given method.</p> Source code in <code>src/kirin/emit/str.py</code> <pre><code>def initialize_frame(\n    self, code: ir.Statement, *, has_parent_access: bool = False\n) -&gt; EmitStrFrame:\n    return EmitStrFrame(code, has_parent_access=has_parent_access)\n</code></pre>"},{"location":"reference/kirin/emit/str/#kirin.emit.str.EmitStr.run_method","title":"run_method","text":"<pre><code>run_method(\n    method: ir.Method, args: tuple[str, ...]\n) -&gt; tuple[EmitStrFrame, str]\n</code></pre> <p>How to run a method.</p> <p>This is defined by subclasses to describe what's the corresponding value of a method during the interpretation. Usually, this method just calls <code>run_callable</code>.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Method</code> <p>the method to run.</p> required <code>args</code> <code>tuple[ValueType, ...]</code> <p>the arguments to the method, does not include self.</p> required <p>Returns:</p> Name Type Description <code>ValueType</code> <code>tuple[FrameType, ValueType]</code> <p>the result of the method.</p> Source code in <code>src/kirin/emit/str.py</code> <pre><code>def run_method(\n    self, method: ir.Method, args: tuple[str, ...]\n) -&gt; tuple[EmitStrFrame, str]:\n    if self.state.depth &gt;= self.max_depth:\n        raise interp.InterpreterError(\"maximum recursion depth exceeded\")\n    return self.run_callable(method.code, (method.sym_name,) + args)\n</code></pre>"},{"location":"reference/kirin/interp/","title":"Index","text":"<p>Interpreter module for Kirin.</p> <p>This module contains the interpreter framework for Kirin. The interpreter framework is used to implement concrete and abstract interpreters for the IR. The interpreter framework provides a set of classes and interfaces to implement interpreters for the IR.</p> <p>The interpreter framework is designed to be extensible and customizable. It provides a set of base classes and interfaces for implementing concrete and abstract interpreters:</p> <ul> <li><code>BaseInterpreter</code>: Base class for implementing concrete interpreters.</li> <li><code>AbstractInterpreter</code>: Base class for implementing abstract interpreters.</li> <li><code>Frame</code>: Base class for interpreter frame.</li> <li><code>MethodTable</code>: Method table for registering implementations of statements.</li> </ul>"},{"location":"reference/kirin/interp/abstract/","title":"Abstract","text":""},{"location":"reference/kirin/interp/abstract/#kirin.interp.abstract.AbstractFrame","title":"AbstractFrame  <code>dataclass</code>","text":"<pre><code>AbstractFrame(\n    code: Statement,\n    worklist: WorkList[Successor[ResultType]] = WorkList(),\n    visited: dict[\n        Block, set[Successor[ResultType]]\n    ] = dict(),\n    *,\n    parent: Self | None = None,\n    has_parent_access: bool = False,\n    lineno_offset: int = 0,\n    globals: dict[str, Any] = dict(),\n    entries: dict[SSAValue, ValueType] = dict()\n)\n</code></pre> <p>               Bases: <code>Frame[ResultType]</code></p> <p>Interpreter frame for abstract interpreter.</p> <p>This frame is used to store the state of the abstract interpreter. It contains the worklist of successors to be processed.</p>"},{"location":"reference/kirin/interp/abstract/#kirin.interp.abstract.AbstractInterpreter","title":"AbstractInterpreter  <code>dataclass</code>","text":"<pre><code>AbstractInterpreter(\n    dialects: DialectGroup,\n    *,\n    fuel: int | None = None,\n    debug: bool = False,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192\n)\n</code></pre> <p>               Bases: <code>BaseInterpreter[AbstractFrameType, ResultType]</code>, <code>ABC</code></p> <p>Abstract interpreter for the IR.</p> <p>This is a base class for implementing abstract interpreters for the IR. It provides a framework for implementing abstract interpreters given a bounded lattice type.</p> <p>The abstract interpreter is a forward dataflow analysis that computes the abstract values for each SSA value in the IR. The abstract values are computed by evaluating the statements in the IR using the abstract lattice operations.</p> <p>The abstract interpreter is implemented as a worklist algorithm. The worklist contains the successors of the current block to be processed. The abstract interpreter processes each successor by evaluating the statements in the block and updating the abstract values in the frame.</p> <p>The abstract interpreter provides hooks for customizing the behavior of the interpreter. The <code>prehook_succ</code> and <code>posthook_succ</code> methods can be used to perform custom actions before and after processing a successor.</p>"},{"location":"reference/kirin/interp/abstract/#kirin.interp.abstract.AbstractInterpreter.lattice","title":"lattice  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lattice: type[BoundedLattice[ResultType]] = field(\n    init=False\n)\n</code></pre> <p>lattice type for the abstract interpreter.</p>"},{"location":"reference/kirin/interp/abstract/#kirin.interp.abstract.AbstractInterpreter.eval_recursion_limit","title":"eval_recursion_limit","text":"<pre><code>eval_recursion_limit(\n    frame: AbstractFrameType,\n) -&gt; tuple[AbstractFrameType, ResultType]\n</code></pre> <p>Return the value of recursion exception, e.g in concrete interpreter, it will raise an exception if the limit is reached; in type inference, it will return a special value.</p> Source code in <code>src/kirin/interp/abstract.py</code> <pre><code>def eval_recursion_limit(\n    self, frame: AbstractFrameType\n) -&gt; tuple[AbstractFrameType, ResultType]:\n    return frame, self.lattice.bottom()\n</code></pre>"},{"location":"reference/kirin/interp/abstract/#kirin.interp.abstract.AbstractInterpreter.posthook_succ","title":"posthook_succ","text":"<pre><code>posthook_succ(frame: AbstractFrameType, succ: Successor)\n</code></pre> <p>Hook called after processing a successor.</p> <p>This method can be used to perform custom actions after processing a successor. It is called after evaluating the statements in the block.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>AbstractFrameType</code> <p>The current frame of the interpreter.</p> required <code>succ</code> <code>Successor</code> <p>The successor that was processed.</p> required Source code in <code>src/kirin/interp/abstract.py</code> <pre><code>def posthook_succ(self, frame: AbstractFrameType, succ: Successor):\n    \"\"\"Hook called after processing a successor.\n\n    This method can be used to perform custom actions after processing\n    a successor. It is called after evaluating the statements in the block.\n\n    Args:\n        frame: The current frame of the interpreter.\n        succ: The successor that was processed.\n    \"\"\"\n    return\n</code></pre>"},{"location":"reference/kirin/interp/abstract/#kirin.interp.abstract.AbstractInterpreter.prehook_succ","title":"prehook_succ","text":"<pre><code>prehook_succ(frame: AbstractFrameType, succ: Successor)\n</code></pre> <p>Hook called before processing a successor.</p> <p>This method can be used to perform custom actions before processing a successor. It is called before evaluating the statements in the block.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>AbstractFrameType</code> <p>The current frame of the interpreter.</p> required <code>succ</code> <code>Successor</code> <p>The successor to be processed.</p> required Source code in <code>src/kirin/interp/abstract.py</code> <pre><code>def prehook_succ(self, frame: AbstractFrameType, succ: Successor):\n    \"\"\"Hook called before processing a successor.\n\n    This method can be used to perform custom actions before processing\n    a successor. It is called before evaluating the statements in the block.\n\n    Args:\n        frame: The current frame of the interpreter.\n        succ: The successor to be processed.\n    \"\"\"\n    return\n</code></pre>"},{"location":"reference/kirin/interp/abstract/#kirin.interp.abstract.AbstractInterpreter.run_ssacfg_region","title":"run_ssacfg_region","text":"<pre><code>run_ssacfg_region(\n    frame: AbstractFrameType,\n    region: Region,\n    args: tuple[ResultType, ...],\n) -&gt; (\n    tuple[ResultType, ...] | None | ReturnValue[ResultType]\n)\n</code></pre> <p>This implements how to run a region with MLIR SSA CFG convention.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>FrameType</code> <p>the current frame.</p> required <code>region</code> <code>Region</code> <p>the region to run.</p> required <code>args</code> <code>tuple[ValueType, ...]</code> <p>the arguments to the region.</p> required <p>Returns:</p> Type Description <code>tuple[ValueType, ...] | None | ReturnValue[ValueType]</code> <p>tuple[ValueType, ...] | SpecialValue[ValueType]: the result of running the region.</p> <p>when region returns <code>tuple[ValueType, ...]</code>, it means the region terminates normally with <code>YieldValue</code>. When region returns <code>ReturnValue</code>, it means the region terminates and needs to pop the frame. Region cannot return <code>Successor</code> because reference to external region is not allowed.</p> Source code in <code>src/kirin/interp/abstract.py</code> <pre><code>def run_ssacfg_region(\n    self, frame: AbstractFrameType, region: Region, args: tuple[ResultType, ...]\n) -&gt; tuple[ResultType, ...] | None | ReturnValue[ResultType]:\n    result = None\n    frame.worklist.append(Successor(region.blocks[0], *args))\n    while (succ := frame.worklist.pop()) is not None:\n        if succ.block in frame.visited:\n            if succ in frame.visited[succ.block]:\n                continue\n        else:\n            frame.visited[succ.block] = set()\n        self.prehook_succ(frame, succ)\n        block_result = self.run_succ(frame, succ)\n        if len(frame.visited[succ.block]) &lt; 128:\n            frame.visited[succ.block].add(succ)\n        else:\n            continue\n\n        if isinstance(block_result, Successor):\n            raise InterpreterError(\n                \"unexpected successor, successors should be in worklist\"\n            )\n\n        result = self.join_results(result, block_result)\n        self.posthook_succ(frame, succ)\n\n    if isinstance(result, YieldValue):\n        return result.values\n    return result\n</code></pre>"},{"location":"reference/kirin/interp/abstract/#kirin.interp.abstract.AbstractInterpreter.run_succ","title":"run_succ","text":"<pre><code>run_succ(\n    frame: AbstractFrameType, succ: Successor\n) -&gt; SpecialValue[ResultType]\n</code></pre> <p>Run a successor within the current frame. Args:     frame: the current frame.     succ: the successor to run.</p> <p>Returns:</p> Name Type Description <code>SpecialValue</code> <code>SpecialValue[ValueType]</code> <p>the result of running the successor.</p> Source code in <code>src/kirin/interp/abstract.py</code> <pre><code>def run_succ(\n    self, frame: AbstractFrameType, succ: Successor\n) -&gt; SpecialValue[ResultType]:\n    frame.current_block = succ.block\n    self.set_values(frame, succ.block.args, succ.block_args)\n    for stmt in succ.block.stmts:\n        if self.should_exec_stmt(stmt) is False:\n            continue\n\n        frame.current_stmt = stmt\n        stmt_results = self.eval_stmt(frame, stmt)\n        if isinstance(stmt_results, tuple):\n            self.set_values(frame, stmt._results, stmt_results)\n        elif stmt_results is None:\n            continue  # empty result\n        else:  # terminate\n            return stmt_results\n    return None\n</code></pre>"},{"location":"reference/kirin/interp/abstract/#kirin.interp.abstract.AbstractInterpreter.set_values","title":"set_values","text":"<pre><code>set_values(\n    frame: AbstractFrameType,\n    ssa: Iterable[SSAValue],\n    results: Iterable[ResultType],\n)\n</code></pre> <p>Set the abstract values for the given SSA values in the frame.</p> <p>This method is used to customize how the abstract values are set in the frame. By default, the abstract values are set directly in the frame.</p> Source code in <code>src/kirin/interp/abstract.py</code> <pre><code>def set_values(\n    self,\n    frame: AbstractFrameType,\n    ssa: Iterable[SSAValue],\n    results: Iterable[ResultType],\n):\n    \"\"\"Set the abstract values for the given SSA values in the frame.\n\n    This method is used to customize how the abstract values are set in\n    the frame. By default, the abstract values are set directly in the\n    frame.\n    \"\"\"\n    frame.set_values(ssa, results)\n</code></pre>"},{"location":"reference/kirin/interp/abstract/#kirin.interp.abstract.AbstractInterpreter.should_exec_stmt","title":"should_exec_stmt","text":"<pre><code>should_exec_stmt(stmt: Statement) -&gt; bool\n</code></pre> <p>This method can be used to control which statements are executed during the abstract interpretation. By default, all statements are executed.</p> <p>This method is useful when one wants to skip certain statements during the abstract interpretation and is certain that the skipped statements do not affect the final result. This would allow saving computation time and memory by not evaluating the skipped statements and their results.</p> <p>Parameters:</p> Name Type Description Default <code>stmt</code> <code>Statement</code> <p>The statement to be executed.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the statement should be executed, False otherwise.</p> Source code in <code>src/kirin/interp/abstract.py</code> <pre><code>def should_exec_stmt(self, stmt: Statement) -&gt; bool:\n    \"\"\"This method can be used to control which statements are executed\n    during the abstract interpretation. By default, all statements are\n    executed.\n\n    This method is useful when one wants to skip certain statements\n    during the abstract interpretation and is certain that the skipped\n    statements do not affect the final result. This would allow saving\n    computation time and memory by not evaluating the skipped statements\n    and their results.\n\n    Args:\n        stmt: The statement to be executed.\n\n    Returns:\n        True if the statement should be executed, False otherwise.\n    \"\"\"\n    return True\n</code></pre>"},{"location":"reference/kirin/interp/base/","title":"Base","text":""},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter","title":"BaseInterpreter  <code>dataclass</code>","text":"<pre><code>BaseInterpreter(\n    dialects: DialectGroup,\n    *,\n    fuel: int | None = None,\n    debug: bool = False,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192\n)\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[FrameType, ValueType]</code></p> <p>A base class for interpreters.</p> <p>This class defines the basic structure of an interpreter. It is designed to be subclassed to provide the actual implementation of the interpreter.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter--required-overrides","title":"Required Overrides","text":"<p>When subclassing, if the subclass does not contain <code>ABC</code>, the subclass must define the following attributes:</p> <ul> <li><code>keys</code>: a list of strings that defines the order of dialects to select from.</li> <li><code>void</code>: the value to return when the interpreter evaluates nothing.</li> </ul>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.Frame","title":"Frame  <code>class-attribute</code>","text":"<pre><code>Frame: type[FrameABC] = field(init=False)\n</code></pre> <p>The type of the frame to use for this interpreter.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.debug","title":"debug  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug: bool = field(default=False, kw_only=True)\n</code></pre> <p>Whether to enable debug mode.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.dialects","title":"dialects  <code>instance-attribute</code>","text":"<pre><code>dialects: DialectGroup\n</code></pre> <p>The dialects to interpret.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.fuel","title":"fuel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fuel: int | None = field(default=None, kw_only=True)\n</code></pre> <p>The fuel limit for the interpreter.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.keys","title":"keys  <code>class-attribute</code>","text":"<pre><code>keys: list[str]\n</code></pre> <p>The name of the interpreter to select from dialects by order.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.max_depth","title":"max_depth  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_depth: int = field(default=128, kw_only=True)\n</code></pre> <p>The maximum depth of the interpreter stack.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.max_python_recursion_depth","title":"max_python_recursion_depth  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_python_recursion_depth: int = field(\n    default=8192, kw_only=True\n)\n</code></pre> <p>The maximum recursion depth of the Python interpreter.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.registry","title":"registry  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>registry: InterpreterRegistry = field(\n    init=False, compare=False\n)\n</code></pre> <p>The interpreter registry.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.state","title":"state  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>state: InterpreterState[FrameType] = field(\n    init=False, compare=False\n)\n</code></pre> <p>The interpreter state.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.symbol_table","title":"symbol_table  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol_table: dict[str, Statement] = field(\n    init=False, compare=False\n)\n</code></pre> <p>The symbol table.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.void","title":"void  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>void: ValueType = field(init=False)\n</code></pre> <p>What to return when the interpreter evaluates nothing.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.build_signature","title":"build_signature","text":"<pre><code>build_signature(\n    frame: FrameType, stmt: Statement\n) -&gt; Signature\n</code></pre> <p>build signature for querying the statement implementation.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def build_signature(self, frame: FrameType, stmt: Statement) -&gt; \"Signature\":\n    \"\"\"build signature for querying the statement implementation.\"\"\"\n    return Signature(stmt.__class__, tuple(arg.type for arg in stmt.args))\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.eval_recursion_limit","title":"eval_recursion_limit","text":"<pre><code>eval_recursion_limit(\n    frame: FrameType,\n) -&gt; tuple[FrameType, ValueType]\n</code></pre> <p>Return the value of recursion exception, e.g in concrete interpreter, it will raise an exception if the limit is reached; in type inference, it will return a special value.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def eval_recursion_limit(self, frame: FrameType) -&gt; tuple[FrameType, ValueType]:\n    \"\"\"Return the value of recursion exception, e.g in concrete\n    interpreter, it will raise an exception if the limit is reached;\n    in type inference, it will return a special value.\n    \"\"\"\n    raise InterpreterError(\"maximum recursion depth exceeded\")\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.eval_stmt","title":"eval_stmt","text":"<pre><code>eval_stmt(\n    frame: FrameType, stmt: Statement\n) -&gt; StatementResult[ValueType]\n</code></pre> <p>Run a statement within the current frame. This is the entry point of running a statement. It will look up the statement implementation in the dialect registry, or optionally call a fallback implementation.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>FrameType</code> <p>the current frame</p> required <code>stmt</code> <code>Statement</code> <p>the statement to run</p> required <p>Returns:</p> Name Type Description <code>StatementResult</code> <code>StatementResult[ValueType]</code> <p>the result of running the statement</p> Note <p>Overload this method for the following reasons: - to change the source tracking information - to take control of how to run a statement - to change the implementation lookup behavior that cannot acheive     by overloading <code>lookup_registry</code></p> Example <ul> <li>implement an interpreter that only handles MyStmt: <pre><code>    class MyInterpreter(BaseInterpreter):\n        ...\n        def eval_stmt(self, frame: FrameType, stmt: Statement) -&gt; StatementResult[ValueType]:\n            if isinstance(stmt, MyStmt):\n                return self.run_my_stmt(frame, stmt)\n            else:\n                return ()\n</code></pre></li> </ul> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def eval_stmt(\n    self, frame: FrameType, stmt: Statement\n) -&gt; StatementResult[ValueType]:\n    \"\"\"Run a statement within the current frame. This is the entry\n    point of running a statement. It will look up the statement implementation\n    in the dialect registry, or optionally call a fallback implementation.\n\n    Args:\n        frame: the current frame\n        stmt: the statement to run\n\n    Returns:\n        StatementResult: the result of running the statement\n\n    Note:\n        Overload this method for the following reasons:\n        - to change the source tracking information\n        - to take control of how to run a statement\n        - to change the implementation lookup behavior that cannot acheive\n            by overloading [`lookup_registry`][kirin.interp.base.BaseInterpreter.lookup_registry]\n\n    Example:\n        * implement an interpreter that only handles MyStmt:\n        ```python\n            class MyInterpreter(BaseInterpreter):\n                ...\n                def eval_stmt(self, frame: FrameType, stmt: Statement) -&gt; StatementResult[ValueType]:\n                    if isinstance(stmt, MyStmt):\n                        return self.run_my_stmt(frame, stmt)\n                    else:\n                        return ()\n        ```\n\n    \"\"\"\n    # TODO: update tracking information\n    method = self.lookup_registry(frame, stmt)\n    if method is not None:\n        results = method(self, frame, stmt)\n        if self.debug and not isinstance(results, (tuple, SpecialValue)):\n            raise InterpreterError(\n                f\"method must return tuple or SpecialResult, got {results}\"\n            )\n        return results\n    elif stmt.dialect not in self.dialects:\n        # NOTE: we should terminate the interpreter because this is a\n        # deveoper error, not a user error.\n        name = stmt.dialect.name if stmt.dialect else \"None\"\n        raise ValueError(f\"dialect {name} is not supported by {self.dialects}\")\n\n    return self.eval_stmt_fallback(frame, stmt)\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.eval_stmt_fallback","title":"eval_stmt_fallback","text":"<pre><code>eval_stmt_fallback(\n    frame: FrameType, stmt: Statement\n) -&gt; StatementResult[ValueType]\n</code></pre> <p>The fallback implementation of statements.</p> <p>This is called when no implementation is found for the statement.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>FrameType</code> <p>the current frame</p> required <code>stmt</code> <code>Statement</code> <p>the statement to run</p> required <p>Returns:</p> Name Type Description <code>StatementResult</code> <code>StatementResult[ValueType]</code> <p>the result of running the statement</p> Note <p>Overload this method to provide a fallback implementation for statements.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def eval_stmt_fallback(\n    self, frame: FrameType, stmt: Statement\n) -&gt; StatementResult[ValueType]:\n    \"\"\"The fallback implementation of statements.\n\n    This is called when no implementation is found for the statement.\n\n    Args:\n        frame: the current frame\n        stmt: the statement to run\n\n    Returns:\n        StatementResult: the result of running the statement\n\n    Note:\n        Overload this method to provide a fallback implementation for statements.\n    \"\"\"\n    # NOTE: not using f-string here because 3.10 and 3.11 have\n    #  parser bug that doesn't allow f-string in raise statement\n    raise InterpreterError(\n        \"no implementation for stmt \"\n        + stmt.print_str(end=\"\")\n        + \" from \"\n        + str(type(self))\n    )\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.initialize","title":"initialize","text":"<pre><code>initialize() -&gt; Self\n</code></pre> <p>Initialize the interpreter global states. This method is called right upon calling <code>run</code> to initialize the interpreter global states.</p> <p>Default Implementation</p> <p>This method provides default behavior but may be overridden by subclasses to customize or extend functionality.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def initialize(self) -&gt; Self:\n    \"\"\"Initialize the interpreter global states. This method is called right upon\n    calling [`run`][kirin.interp.base.BaseInterpreter.run] to initialize the\n    interpreter global states.\n\n    !!! note \"Default Implementation\"\n        This method provides default behavior but may be overridden by subclasses\n        to customize or extend functionality.\n    \"\"\"\n    self.symbol_table: dict[str, Statement] = {}\n    self.state: InterpreterState[FrameType] = InterpreterState()\n    return self\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.initialize_frame","title":"initialize_frame  <code>abstractmethod</code>","text":"<pre><code>initialize_frame(\n    code: Statement, *, has_parent_access: bool = False\n) -&gt; FrameType\n</code></pre> <p>Create a new frame for the given method.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>@abstractmethod\ndef initialize_frame(\n    self, code: Statement, *, has_parent_access: bool = False\n) -&gt; FrameType:\n    \"\"\"Create a new frame for the given method.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.lookup_registry","title":"lookup_registry","text":"<pre><code>lookup_registry(\n    frame: FrameType, stmt: Statement\n) -&gt; Optional[StatementImpl[Self, FrameType]]\n</code></pre> <p>Lookup the statement implementation in the registry.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>FrameType</code> <p>the current frame</p> required <code>stmt</code> <code>Statement</code> <p>the statement to run</p> required <p>Returns:</p> Type Description <code>Optional[StatementImpl[Self, FrameType]]</code> <p>Optional[StatementImpl]: the statement implementation if found, None otherwise.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def lookup_registry(\n    self, frame: FrameType, stmt: Statement\n) -&gt; Optional[\"StatementImpl[Self, FrameType]\"]:\n    \"\"\"Lookup the statement implementation in the registry.\n\n    Args:\n        frame: the current frame\n        stmt: the statement to run\n\n    Returns:\n        Optional[StatementImpl]: the statement implementation if found, None otherwise.\n    \"\"\"\n    sig = self.build_signature(frame, stmt)\n    if sig in self.registry.statements:\n        return self.registry.statements[sig]\n    elif (class_sig := Signature(stmt.__class__)) in self.registry.statements:\n        return self.registry.statements[class_sig]\n    return\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.new_frame","title":"new_frame","text":"<pre><code>new_frame(\n    code: Statement, *, has_parent_access: bool = False\n) -&gt; Generator[FrameType, Any, None]\n</code></pre> <p>Create a new frame for the given method and push it to the state.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>Statement</code> <p>the statement to run.</p> required <p>Other Parameters:</p> Name Type Description <code>has_parent_access</code> <code>bool</code> <p>whether this frame has access to the parent frame entries. Defaults to False.</p> <p>This is a context manager that creates a new frame, push and pop the frame automatically.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>@contextmanager\ndef new_frame(\n    self, code: Statement, *, has_parent_access: bool = False\n) -&gt; Generator[FrameType, Any, None]:\n    \"\"\"Create a new frame for the given method and push it to the state.\n\n    Args:\n        code (Statement): the statement to run.\n\n    Keyword Args:\n        has_parent_access (bool): whether this frame has access to the\n            parent frame entries. Defaults to False.\n\n    This is a context manager that creates a new frame, push and pop\n    the frame automatically.\n    \"\"\"\n    frame = self.initialize_frame(code, has_parent_access=has_parent_access)\n    self.state.push_frame(frame)\n    try:\n        yield frame\n    finally:\n        self.state.pop_frame()\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.permute_values","title":"permute_values  <code>staticmethod</code>","text":"<pre><code>permute_values(\n    arg_names: Sequence[str],\n    values: tuple[ValueType, ...],\n    kwarg_names: tuple[str, ...],\n) -&gt; tuple[ValueType, ...]\n</code></pre> <p>Permute the arguments according to the method signature and the given keyword arguments, where the keyword argument names refer to the last n arguments in the values tuple.</p> <p>Parameters:</p> Name Type Description Default <code>arg_names</code> <code>Sequence[str]</code> <p>the argument names</p> required <code>values</code> <code>tuple[ValueType, ...]</code> <p>the values tuple (should not contain method itself)</p> required <code>kwarg_names</code> <code>tuple[str, ...]</code> <p>the keyword argument names</p> required Source code in <code>src/kirin/interp/base.py</code> <pre><code>@staticmethod\ndef permute_values(\n    arg_names: Sequence[str],\n    values: tuple[ValueType, ...],\n    kwarg_names: tuple[str, ...],\n) -&gt; tuple[ValueType, ...]:\n    \"\"\"Permute the arguments according to the method signature and\n    the given keyword arguments, where the keyword argument names\n    refer to the last n arguments in the values tuple.\n\n    Args:\n        arg_names: the argument names\n        values: the values tuple (should not contain method itself)\n        kwarg_names: the keyword argument names\n    \"\"\"\n    n_total = len(values)\n    if kwarg_names:\n        kwargs = dict(zip(kwarg_names, values[n_total - len(kwarg_names) :]))\n    else:\n        kwargs = None\n\n    positionals = values[: n_total - len(kwarg_names)]\n    args = BaseInterpreter.get_args(\n        arg_names[len(positionals) + 1 :], positionals, kwargs\n    )\n    return args\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.run","title":"run","text":"<pre><code>run(\n    mt: Method,\n    args: tuple[ValueType, ...],\n    kwargs: dict[str, ValueType] | None = None,\n) -&gt; ValueType\n</code></pre> <p>Run a method. This is the main entry point of the interpreter.</p> <p>Parameters:</p> Name Type Description Default <code>mt</code> <code>Method</code> <p>the method to run.</p> required <code>args</code> <code>tuple[ValueType]</code> <p>the arguments to the method, does not include self.</p> required <code>kwargs</code> <code>dict[str, ValueType]</code> <p>the keyword arguments to the method.</p> <code>None</code> <p>Returns:</p> Type Description <code>ValueType</code> <p>Result[ValueType]: the result of the method.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def run(\n    self,\n    mt: Method,\n    args: tuple[ValueType, ...],\n    kwargs: dict[str, ValueType] | None = None,\n) -&gt; ValueType:\n    \"\"\"Run a method. This is the main entry point of the interpreter.\n\n    Args:\n        mt (Method): the method to run.\n        args (tuple[ValueType]): the arguments to the method, does not include self.\n        kwargs (dict[str, ValueType], optional): the keyword arguments to the method.\n\n    Returns:\n        Result[ValueType]: the result of the method.\n    \"\"\"\n    if self._eval_lock:\n        raise InterpreterError(\n            \"recursive eval is not allowed, use run_method instead\"\n        )\n\n    self._eval_lock = True\n    self.initialize()\n    current_recursion_limit = sys.getrecursionlimit()\n    sys.setrecursionlimit(self.max_python_recursion_depth)\n    args = self.get_args(mt.arg_names[len(args) + 1 :], args, kwargs)\n    try:\n        _, results = self.run_method(mt, args)\n    except Exception as e:\n        # NOTE: initialize will create new State\n        # so we don't need to copy the frames.\n        raise IntepreterExit(e, self.state) from e\n    finally:\n        self._eval_lock = False\n        sys.setrecursionlimit(current_recursion_limit)\n    return results\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.run_block","title":"run_block","text":"<pre><code>run_block(\n    frame: FrameType, block: Block\n) -&gt; SpecialValue[ValueType]\n</code></pre> <p>Run a block within the current frame.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>FrameType</code> <p>the current frame.</p> required <code>block</code> <code>Block</code> <p>the block to run.</p> required <p>Returns:</p> Name Type Description <code>SpecialValue</code> <code>SpecialValue[ValueType]</code> <p>the result of running the block terminator.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>@deprecated(\"use run_succ instead\")\ndef run_block(self, frame: FrameType, block: Block) -&gt; SpecialValue[ValueType]:\n    \"\"\"Run a block within the current frame.\n\n    Args:\n        frame: the current frame.\n        block: the block to run.\n\n    Returns:\n        SpecialValue: the result of running the block terminator.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.run_callable","title":"run_callable","text":"<pre><code>run_callable(\n    code: Statement, args: tuple[ValueType, ...]\n) -&gt; tuple[FrameType, ValueType]\n</code></pre> <p>Run a callable statement.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>Statement</code> <p>the statement to run.</p> required <code>args</code> <code>tuple[ValueType, ...]</code> <p>the arguments to the statement, includes self if the corresponding callable region contains a self argument.</p> required <p>Returns:</p> Name Type Description <code>ValueType</code> <code>tuple[FrameType, ValueType]</code> <p>the result of the statement.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def run_callable(\n    self, code: Statement, args: tuple[ValueType, ...]\n) -&gt; tuple[FrameType, ValueType]:\n    \"\"\"Run a callable statement.\n\n    Args:\n        code (Statement): the statement to run.\n        args (tuple[ValueType, ...]): the arguments to the statement,\n            includes self if the corresponding callable region contains a self argument.\n\n    Returns:\n        ValueType: the result of the statement.\n    \"\"\"\n    if self.state.depth &gt;= self.max_depth:\n        return self.eval_recursion_limit(self.state.current_frame)\n\n    interface = code.get_trait(traits.CallableStmtInterface)\n    if interface is None:\n        raise InterpreterError(f\"statement {code.name} is not callable\")\n\n    frame = self.initialize_frame(code)\n    self.state.push_frame(frame)\n    body = interface.get_callable_region(code)\n    if not body.blocks:\n        return self.state.pop_frame(), self.void\n    results = self.run_callable_region(frame, code, body, args)\n    return self.state.pop_frame(), results\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.run_callable_region","title":"run_callable_region","text":"<pre><code>run_callable_region(\n    frame: FrameType,\n    code: Statement,\n    region: Region,\n    args: tuple[ValueType, ...],\n) -&gt; ValueType\n</code></pre> <p>A hook defines how to run the callable region given the interpreter context. Frame should be pushed before calling this method and popped after calling this method.</p> <p>A callable region is a region that can be called as a function. Unlike a general region (or the MLIR convention), it always return a value to be compatible with the Python convention.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def run_callable_region(\n    self,\n    frame: FrameType,\n    code: Statement,\n    region: Region,\n    args: tuple[ValueType, ...],\n) -&gt; ValueType:\n    \"\"\"A hook defines how to run the callable region given\n    the interpreter context. Frame should be pushed before calling\n    this method and popped after calling this method.\n\n    A callable region is a region that can be called as a function.\n    Unlike a general region (or the MLIR convention), it always return a value\n    to be compatible with the Python convention.\n    \"\"\"\n    results = self.run_ssacfg_region(frame, region, args)\n    if isinstance(results, ReturnValue):\n        return results.value\n    elif not results:  # empty result or None\n        return self.void\n    raise InterpreterError(\n        f\"callable region {code.name} does not return `ReturnValue`, got {results}\"\n    )\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.run_method","title":"run_method  <code>abstractmethod</code>","text":"<pre><code>run_method(\n    method: Method, args: tuple[ValueType, ...]\n) -&gt; tuple[FrameType, ValueType]\n</code></pre> <p>How to run a method.</p> <p>This is defined by subclasses to describe what's the corresponding value of a method during the interpretation. Usually, this method just calls <code>run_callable</code>.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Method</code> <p>the method to run.</p> required <code>args</code> <code>tuple[ValueType, ...]</code> <p>the arguments to the method, does not include self.</p> required <p>Returns:</p> Name Type Description <code>ValueType</code> <code>tuple[FrameType, ValueType]</code> <p>the result of the method.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>@abstractmethod\ndef run_method(\n    self, method: Method, args: tuple[ValueType, ...]\n) -&gt; tuple[FrameType, ValueType]:\n    \"\"\"How to run a method.\n\n    This is defined by subclasses to describe what's the corresponding\n    value of a method during the interpretation. Usually, this method\n    just calls [`run_callable`][kirin.interp.base.BaseInterpreter.run_callable].\n\n    Args:\n        method (Method): the method to run.\n        args (tuple[ValueType, ...]): the arguments to the method, does not include self.\n\n    Returns:\n        ValueType: the result of the method.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.run_ssacfg_region","title":"run_ssacfg_region  <code>abstractmethod</code>","text":"<pre><code>run_ssacfg_region(\n    frame: FrameType,\n    region: Region,\n    args: tuple[ValueType, ...],\n) -&gt; tuple[ValueType, ...] | None | ReturnValue[ValueType]\n</code></pre> <p>This implements how to run a region with MLIR SSA CFG convention.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>FrameType</code> <p>the current frame.</p> required <code>region</code> <code>Region</code> <p>the region to run.</p> required <code>args</code> <code>tuple[ValueType, ...]</code> <p>the arguments to the region.</p> required <p>Returns:</p> Type Description <code>tuple[ValueType, ...] | None | ReturnValue[ValueType]</code> <p>tuple[ValueType, ...] | SpecialValue[ValueType]: the result of running the region.</p> <p>when region returns <code>tuple[ValueType, ...]</code>, it means the region terminates normally with <code>YieldValue</code>. When region returns <code>ReturnValue</code>, it means the region terminates and needs to pop the frame. Region cannot return <code>Successor</code> because reference to external region is not allowed.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>@abstractmethod\ndef run_ssacfg_region(\n    self, frame: FrameType, region: Region, args: tuple[ValueType, ...]\n) -&gt; tuple[ValueType, ...] | None | ReturnValue[ValueType]:\n    \"\"\"This implements how to run a region with MLIR SSA CFG convention.\n\n    Args:\n        frame: the current frame.\n        region: the region to run.\n        args: the arguments to the region.\n\n    Returns:\n        tuple[ValueType, ...] | SpecialValue[ValueType]: the result of running the region.\n\n    when region returns `tuple[ValueType, ...]`, it means the region terminates normally\n    with `YieldValue`. When region returns `ReturnValue`, it means the region terminates\n    and needs to pop the frame. Region cannot return `Successor` because reference to\n    external region is not allowed.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.run_stmt","title":"run_stmt","text":"<pre><code>run_stmt(\n    stmt: Statement, args: tuple[ValueType, ...]\n) -&gt; StatementResult[ValueType]\n</code></pre> <p>execute a statement with arguments in a new frame.</p> <p>Parameters:</p> Name Type Description Default <code>stmt</code> <code>Statement</code> <p>the statement to run.</p> required <code>args</code> <code>tuple[ValueType, ...]</code> <p>the arguments to the statement.</p> required <p>Returns:</p> Type Description <code>StatementResult[ValueType]</code> <p>StatementResult[ValueType]: the result of the statement.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def run_stmt(\n    self, stmt: Statement, args: tuple[ValueType, ...]\n) -&gt; StatementResult[ValueType]:\n    \"\"\"execute a statement with arguments in a new frame.\n\n    Args:\n        stmt (Statement): the statement to run.\n        args (tuple[ValueType, ...]): the arguments to the statement.\n\n    Returns:\n        StatementResult[ValueType]: the result of the statement.\n    \"\"\"\n    frame = self.initialize_frame(stmt)\n    self.state.push_frame(frame)\n    frame.set_values(stmt.args, args)\n    results = self.eval_stmt(frame, stmt)\n    self.state.pop_frame()\n    return results\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.run_succ","title":"run_succ","text":"<pre><code>run_succ(\n    frame: FrameType, succ: Successor\n) -&gt; SpecialValue[ValueType]\n</code></pre> <p>Run a successor within the current frame. Args:     frame: the current frame.     succ: the successor to run.</p> <p>Returns:</p> Name Type Description <code>SpecialValue</code> <code>SpecialValue[ValueType]</code> <p>the result of running the successor.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def run_succ(self, frame: FrameType, succ: Successor) -&gt; SpecialValue[ValueType]:\n    \"\"\"Run a successor within the current frame.\n    Args:\n        frame: the current frame.\n        succ: the successor to run.\n\n    Returns:\n        SpecialValue: the result of running the successor.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.InterpreterMeta","title":"InterpreterMeta","text":"<p>               Bases: <code>ABCMeta</code></p> <p>A metaclass for interpreters.</p>"},{"location":"reference/kirin/interp/concrete/","title":"Concrete","text":""},{"location":"reference/kirin/interp/concrete/#kirin.interp.concrete.Interpreter","title":"Interpreter  <code>dataclass</code>","text":"<pre><code>Interpreter(\n    dialects: DialectGroup,\n    *,\n    fuel: int | None = None,\n    debug: bool = False,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192\n)\n</code></pre> <p>               Bases: <code>BaseInterpreter[Frame[Any], Any]</code></p> <p>Concrete interpreter for the IR.</p> <p>This is a concrete interpreter for the IR. It evaluates the IR by executing the statements in the IR using a simple stack-based interpreter.</p>"},{"location":"reference/kirin/interp/concrete/#kirin.interp.concrete.Interpreter.keys","title":"keys  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>keys = ['main']\n</code></pre> <p>The name of the interpreter to select from dialects by order.</p>"},{"location":"reference/kirin/interp/concrete/#kirin.interp.concrete.Interpreter.void","title":"void  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>void = None\n</code></pre> <p>What to return when the interpreter evaluates nothing.</p>"},{"location":"reference/kirin/interp/concrete/#kirin.interp.concrete.Interpreter.initialize_frame","title":"initialize_frame","text":"<pre><code>initialize_frame(\n    code: Statement, *, has_parent_access: bool = False\n) -&gt; Frame[Any]\n</code></pre> <p>Create a new frame for the given method.</p> Source code in <code>src/kirin/interp/concrete.py</code> <pre><code>def initialize_frame(\n    self, code: Statement, *, has_parent_access: bool = False\n) -&gt; Frame[Any]:\n    return Frame(code, has_parent_access=has_parent_access)\n</code></pre>"},{"location":"reference/kirin/interp/concrete/#kirin.interp.concrete.Interpreter.run_method","title":"run_method","text":"<pre><code>run_method(\n    method: Method, args: tuple[Any, ...]\n) -&gt; tuple[Frame[Any], Any]\n</code></pre> <p>How to run a method.</p> <p>This is defined by subclasses to describe what's the corresponding value of a method during the interpretation. Usually, this method just calls <code>run_callable</code>.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Method</code> <p>the method to run.</p> required <code>args</code> <code>tuple[ValueType, ...]</code> <p>the arguments to the method, does not include self.</p> required <p>Returns:</p> Name Type Description <code>ValueType</code> <code>tuple[FrameType, ValueType]</code> <p>the result of the method.</p> Source code in <code>src/kirin/interp/concrete.py</code> <pre><code>def run_method(\n    self, method: Method, args: tuple[Any, ...]\n) -&gt; tuple[Frame[Any], Any]:\n    return self.run_callable(method.code, (method,) + args)\n</code></pre>"},{"location":"reference/kirin/interp/concrete/#kirin.interp.concrete.Interpreter.run_ssacfg_region","title":"run_ssacfg_region","text":"<pre><code>run_ssacfg_region(\n    frame: Frame[Any], region: Region, args: tuple[Any, ...]\n) -&gt; tuple[Any, ...] | None | ReturnValue[Any]\n</code></pre> <p>This implements how to run a region with MLIR SSA CFG convention.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>FrameType</code> <p>the current frame.</p> required <code>region</code> <code>Region</code> <p>the region to run.</p> required <code>args</code> <code>tuple[ValueType, ...]</code> <p>the arguments to the region.</p> required <p>Returns:</p> Type Description <code>tuple[ValueType, ...] | None | ReturnValue[ValueType]</code> <p>tuple[ValueType, ...] | SpecialValue[ValueType]: the result of running the region.</p> <p>when region returns <code>tuple[ValueType, ...]</code>, it means the region terminates normally with <code>YieldValue</code>. When region returns <code>ReturnValue</code>, it means the region terminates and needs to pop the frame. Region cannot return <code>Successor</code> because reference to external region is not allowed.</p> Source code in <code>src/kirin/interp/concrete.py</code> <pre><code>def run_ssacfg_region(\n    self, frame: Frame[Any], region: Region, args: tuple[Any, ...]\n) -&gt; tuple[Any, ...] | None | ReturnValue[Any]:\n    block = region.blocks[0]\n    succ = Successor(block, *args)\n    while succ is not None:\n        results = self.run_succ(frame, succ)\n        if isinstance(results, Successor):\n            succ = results\n        elif isinstance(results, ReturnValue):\n            return results\n        elif isinstance(results, YieldValue):\n            return results.values\n        else:\n            return results\n    return None  # region without terminator returns empty tuple\n</code></pre>"},{"location":"reference/kirin/interp/concrete/#kirin.interp.concrete.Interpreter.run_succ","title":"run_succ","text":"<pre><code>run_succ(\n    frame: Frame[Any], succ: Successor\n) -&gt; SpecialValue[Any]\n</code></pre> <p>Run a successor within the current frame. Args:     frame: the current frame.     succ: the successor to run.</p> <p>Returns:</p> Name Type Description <code>SpecialValue</code> <code>SpecialValue[ValueType]</code> <p>the result of running the successor.</p> Source code in <code>src/kirin/interp/concrete.py</code> <pre><code>def run_succ(self, frame: Frame[Any], succ: Successor) -&gt; SpecialValue[Any]:\n    frame.current_block = succ.block\n    frame.set_values(succ.block.args, succ.block_args)\n    for stmt in succ.block.stmts:\n        if self.consume_fuel() == self.FuelResult.Stop:\n            raise FuelExhaustedError(\"fuel exhausted\")\n        frame.current_stmt = stmt\n        stmt_results = self.eval_stmt(frame, stmt)\n        if isinstance(stmt_results, tuple):\n            frame.set_values(stmt._results, stmt_results)\n        elif stmt_results is None:\n            continue  # empty result\n        else:  # terminator\n            return stmt_results\n    return None\n</code></pre>"},{"location":"reference/kirin/interp/exceptions/","title":"Exceptions","text":""},{"location":"reference/kirin/interp/exceptions/#kirin.interp.exceptions.FuelExhaustedError","title":"FuelExhaustedError","text":"<p>               Bases: <code>InterpreterError</code></p> <p>An error raised when the interpreter runs out of fuel.</p>"},{"location":"reference/kirin/interp/exceptions/#kirin.interp.exceptions.IntepreterExit","title":"IntepreterExit  <code>dataclass</code>","text":"<pre><code>IntepreterExit(\n    exception: Exception, state: InterpreterState\n)\n</code></pre> <p>               Bases: <code>CustomStackTrace</code></p>"},{"location":"reference/kirin/interp/exceptions/#kirin.interp.exceptions.IntepreterExit.print_stacktrace","title":"print_stacktrace","text":"<pre><code>print_stacktrace() -&gt; None\n</code></pre> <p>Print the stacktrace of the interpreter.</p> Source code in <code>src/kirin/interp/exceptions.py</code> <pre><code>def print_stacktrace(self) -&gt; None:\n    \"\"\"Print the stacktrace of the interpreter.\"\"\"\n    frame: FrameABC | None = self.state.current_frame\n    print(f\"{type(self.exception).__name__}: {self.exception}\", file=sys.stderr)\n    print(\"Traceback (most recent call last):\", file=sys.stderr)\n    frames: list[FrameABC] = []\n    while frame is not None:\n        frames.append(frame)\n        frame = frame.parent\n    frames.reverse()\n    for frame in frames:\n        if stmt := frame.current_stmt:\n            print(\"  \" + repr(stmt.source), file=sys.stderr)\n            print(\"     \" + stmt.print_str(end=\"\"), file=sys.stderr)\n</code></pre>"},{"location":"reference/kirin/interp/exceptions/#kirin.interp.exceptions.InterpreterError","title":"InterpreterError","text":"<p>               Bases: <code>Exception</code></p> <p>Generic interpreter error.</p> <p>This is the base class for all interpreter errors. Interpreter errors will be catched by the interpreter and handled appropriately as an error with stack trace (of Kirin, not Python) from the interpreter.</p>"},{"location":"reference/kirin/interp/exceptions/#kirin.interp.exceptions.WrapException","title":"WrapException  <code>dataclass</code>","text":"<pre><code>WrapException(exception: Exception)\n</code></pre> <p>               Bases: <code>InterpreterError</code></p> <p>A special interpreter error that wraps a Python exception.</p>"},{"location":"reference/kirin/interp/frame/","title":"Frame","text":""},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame","title":"Frame  <code>dataclass</code>","text":"<pre><code>Frame(\n    code: Statement,\n    *,\n    parent: Self | None = None,\n    has_parent_access: bool = False,\n    lineno_offset: int = 0,\n    globals: dict[str, Any] = dict(),\n    entries: dict[SSAValue, ValueType] = dict()\n)\n</code></pre> <p>               Bases: <code>FrameABC[ValueType]</code></p> <p>Interpreter frame.</p>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame.entries","title":"entries  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>entries: dict[SSAValue, ValueType] = field(\n    default_factory=dict, kw_only=True\n)\n</code></pre> <p>SSA values and their corresponding values.</p>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame.globals","title":"globals  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>globals: dict[str, Any] = field(\n    default_factory=dict, kw_only=True\n)\n</code></pre> <p>Global variables this frame has access to.</p>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame.get","title":"get","text":"<pre><code>get(key: SSAValue) -&gt; ValueType\n</code></pre> <p>Get the value for the given <code>SSAValue</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key(SSAValue)</code> <p>The key to get the value for.</p> required <p>Returns:</p> Name Type Description <code>ValueType</code> <code>ValueType</code> <p>The value.</p> <p>Raises:</p> Type Description <code>InterpreterError</code> <p>If the value is not found. This will be catched by the interpreter.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>def get(self, key: SSAValue) -&gt; ValueType:\n    \"\"\"Get the value for the given [`SSAValue`][kirin.ir.SSAValue].\n\n    Args:\n        key(SSAValue): The key to get the value for.\n\n    Returns:\n        ValueType: The value.\n\n    Raises:\n        InterpreterError: If the value is not found. This will be catched by the interpreter.\n    \"\"\"\n    err = InterpreterError(f\"SSAValue {key} not found\")\n    value = self.entries.get(key, err)\n    if isinstance(value, InterpreterError):\n        if self.has_parent_access and self.parent:\n            return self.parent.get(key)\n        else:\n            raise err\n    else:\n        return value\n</code></pre>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame.get_casted","title":"get_casted","text":"<pre><code>get_casted(\n    key: SSAValue, type_: type[ExpectedType]\n) -&gt; ExpectedType\n</code></pre> <p>Same as <code>get</code> except it forces the linter to think the value is of the expected type.</p> <p>Parameters:</p> Name Type Description Default <code>key(SSAValue)</code> <p>The key to get the value for.</p> required <code>type_(type)</code> <p>The expected type.</p> required <p>Returns:</p> Name Type Description <code>ExpectedType</code> <code>ExpectedType</code> <p>The value.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>def get_casted(self, key: SSAValue, type_: type[ExpectedType]) -&gt; ExpectedType:\n    \"\"\"Same as [`get`][kirin.interp.frame.Frame.get] except it\n    forces the linter to think the value is of the expected type.\n\n    Args:\n        key(SSAValue): The key to get the value for.\n        type_(type): The expected type.\n\n    Returns:\n        ExpectedType: The value.\n    \"\"\"\n    return self.get(key)  # type: ignore\n</code></pre>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame.get_typed","title":"get_typed","text":"<pre><code>get_typed(\n    key: SSAValue, type_: type[ExpectedType]\n) -&gt; ExpectedType\n</code></pre> <p>Similar to <code>get</code> but also checks the type.</p> <p>Parameters:</p> Name Type Description Default <code>key(SSAValue)</code> <p>The key to get the value for.</p> required <code>type_(type)</code> <p>The expected type.</p> required <p>Returns:</p> Name Type Description <code>ExpectedType</code> <code>ExpectedType</code> <p>The value.</p> <p>Raises:</p> Type Description <code>InterpreterError</code> <p>If the value is not of the expected type.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>def get_typed(self, key: SSAValue, type_: type[ExpectedType]) -&gt; ExpectedType:\n    \"\"\"Similar to [`get`][kirin.interp.frame.Frame.get] but also checks the type.\n\n    Args:\n        key(SSAValue): The key to get the value for.\n        type_(type): The expected type.\n\n    Returns:\n        ExpectedType: The value.\n\n    Raises:\n        InterpreterError: If the value is not of the expected type.\n    \"\"\"\n    value = self.get(key)\n    if not isinstance(value, type_):\n        raise InterpreterError(f\"expected {type_}, got {type(value)}\")\n    return value\n</code></pre>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame.set","title":"set","text":"<pre><code>set(key: SSAValue, value: ValueType) -&gt; None\n</code></pre> <p>Set the value for the given <code>SSAValue</code> key. See also <code>set_values</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key(SSAValue)</code> <p>The key to set the value for.</p> required <code>value(ValueType)</code> <p>The value.</p> required Source code in <code>src/kirin/interp/frame.py</code> <pre><code>def set(self, key: SSAValue, value: ValueType) -&gt; None:\n    self.entries[key] = value\n</code></pre>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.FrameABC","title":"FrameABC  <code>dataclass</code>","text":"<pre><code>FrameABC(\n    code: Statement,\n    *,\n    parent: Self | None = None,\n    has_parent_access: bool = False,\n    lineno_offset: int = 0\n)\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[ValueType]</code></p> <p>Abstract base class for the IR interpreter frame.</p> <p>While the IR is in SSA form which does not have the need of scoping, the frame is still useful to keep track of the current statement being interpreted and the call stack. As well as various other interpreter state based on the specific interpreter implementation.</p> <p>This base class provides the minimum interface for the interpreter frame.</p>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.FrameABC.code","title":"code  <code>instance-attribute</code>","text":"<pre><code>code: Statement\n</code></pre> <p>statement whose region is being interpreted, e.g a function.</p>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.FrameABC.current_block","title":"current_block  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>current_block: Block | None = field(\n    default=None, init=False, compare=False, repr=False\n)\n</code></pre> <p>Current block being interpreted.</p>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.FrameABC.current_stmt","title":"current_stmt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>current_stmt: Statement | None = field(\n    default=None, init=False, compare=False, repr=False\n)\n</code></pre> <p>Current statement being interpreted.</p>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.FrameABC.has_parent_access","title":"has_parent_access  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>has_parent_access: bool = field(\n    default=False, kw_only=True, compare=True\n)\n</code></pre> <p>If we have access to the entries of the parent frame.</p>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.FrameABC.parent","title":"parent  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parent: Self | None = field(\n    default=None, kw_only=True, compare=True, repr=False\n)\n</code></pre> <p>Parent frame.</p>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.FrameABC.get","title":"get  <code>abstractmethod</code>","text":"<pre><code>get(key: SSAValue) -&gt; ValueType\n</code></pre> <p>Get the value for the given <code>SSAValue</code> key. See also <code>get_values</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key(SSAValue)</code> <p>The key to get the value for.</p> required <p>Returns:</p> Name Type Description <code>ValueType</code> <code>ValueType</code> <p>The value.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>@abstractmethod\ndef get(self, key: SSAValue) -&gt; ValueType:\n    \"\"\"Get the value for the given [`SSAValue`][kirin.ir.SSAValue] key.\n    See also [`get_values`][kirin.interp.frame.Frame.get_values].\n\n    Args:\n        key(SSAValue): The key to get the value for.\n\n    Returns:\n        ValueType: The value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.FrameABC.get_values","title":"get_values","text":"<pre><code>get_values(\n    keys: Iterable[SSAValue],\n) -&gt; tuple[ValueType, ...]\n</code></pre> <p>Get the values of the given <code>SSAValue</code> keys. See also <code>get</code>.</p> <p>Parameters:</p> Name Type Description Default <code>keys(Iterable[SSAValue])</code> <p>The keys to get the values for.</p> required <p>Returns:</p> Type Description <code>tuple[ValueType, ...]</code> <p>tuple[ValueType, ...]: The values.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>def get_values(self, keys: Iterable[SSAValue]) -&gt; tuple[ValueType, ...]:\n    \"\"\"Get the values of the given [`SSAValue`][kirin.ir.SSAValue] keys.\n    See also [`get`][kirin.interp.frame.Frame.get].\n\n    Args:\n        keys(Iterable[SSAValue]): The keys to get the values for.\n\n    Returns:\n        tuple[ValueType, ...]: The values.\n    \"\"\"\n    return tuple(self.get(key) for key in keys)\n</code></pre>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.FrameABC.set","title":"set  <code>abstractmethod</code>","text":"<pre><code>set(key: SSAValue, value: ValueType) -&gt; None\n</code></pre> <p>Set the value for the given <code>SSAValue</code> key. See also <code>set_values</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key(SSAValue)</code> <p>The key to set the value for.</p> required <code>value(ValueType)</code> <p>The value.</p> required Source code in <code>src/kirin/interp/frame.py</code> <pre><code>@abstractmethod\ndef set(self, key: SSAValue, value: ValueType) -&gt; None:\n    \"\"\"Set the value for the given [`SSAValue`][kirin.ir.SSAValue] key.\n    See also [`set_values`][kirin.interp.frame.Frame.set_values].\n\n    Args:\n        key(SSAValue): The key to set the value for.\n        value(ValueType): The value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.FrameABC.set_values","title":"set_values","text":"<pre><code>set_values(\n    keys: Iterable[SSAValue], values: Iterable[ValueType]\n) -&gt; None\n</code></pre> <p>Set the values of the given <code>SSAValue</code> keys. This is a convenience method to set multiple values at once.</p> <p>Parameters:</p> Name Type Description Default <code>keys(Iterable[SSAValue])</code> <p>The keys to set the values for.</p> required <code>values(Iterable[ValueType])</code> <p>The values.</p> required Source code in <code>src/kirin/interp/frame.py</code> <pre><code>def set_values(self, keys: Iterable[SSAValue], values: Iterable[ValueType]) -&gt; None:\n    \"\"\"Set the values of the given [`SSAValue`][kirin.ir.SSAValue] keys.\n    This is a convenience method to set multiple values at once.\n\n    Args:\n        keys(Iterable[SSAValue]): The keys to set the values for.\n        values(Iterable[ValueType]): The values.\n    \"\"\"\n    for key, value in zip(keys, values):\n        self.set(key, value)\n</code></pre>"},{"location":"reference/kirin/interp/impl/","title":"Impl","text":""},{"location":"reference/kirin/interp/impl/#kirin.interp.impl.AttributeImplDef","title":"AttributeImplDef  <code>dataclass</code>","text":"<pre><code>AttributeImplDef(signature: SigType, impl: ImplType)\n</code></pre> <p>               Bases: <code>Def[type[Attribute], 'AttributeFunction']</code></p> <p>Definition of an interpreter implementation for an attribute.</p>"},{"location":"reference/kirin/interp/impl/#kirin.interp.impl.Def","title":"Def  <code>dataclass</code>","text":"<pre><code>Def(signature: SigType, impl: ImplType)\n</code></pre> <p>               Bases: <code>Generic[SigType, ImplType]</code></p> <p>Base class of an interpreter implementation definition.</p>"},{"location":"reference/kirin/interp/impl/#kirin.interp.impl.ImplDef","title":"ImplDef  <code>dataclass</code>","text":"<pre><code>ImplDef(\n    signature: SigType,\n    impl: ImplType,\n    parent: Type[Statement],\n)\n</code></pre> <p>               Bases: <code>Def[tuple[Signature, ...], 'MethodFunction']</code></p> <p>Definition of an interpreter implementation for a statement.</p>"},{"location":"reference/kirin/interp/impl/#kirin.interp.impl.Signature","title":"Signature  <code>dataclass</code>","text":"<pre><code>Signature(\n    stmt: Type[Statement],\n    args: tuple[types.TypeAttribute, ...] | None = None,\n)\n</code></pre> <p>Signature of a statement.</p>"},{"location":"reference/kirin/interp/impl/#kirin.interp.impl.impl","title":"impl","text":"<pre><code>impl(\n    stmt_or_attribute: Type[HeadType],\n    *args: types.TypeAttribute\n)\n</code></pre> <p>               Bases: <code>Generic[HeadType]</code></p> <p>Decorator to define an interpreter implementation for a statement or attribute.</p> <p>Note</p> <p>While the <code>impl</code> decorator accepts both statements and attributes, and optionally statements with its type signature, unlike a programming language, the actual dispatch behavior given an instance of a statement or attribute is defined by the implementation of the interpreter (via <code>lookup_registry</code>).</p>"},{"location":"reference/kirin/interp/impl/#kirin.interp.impl.impl--example","title":"Example","text":"<pre><code>@dialect.register\nclass MyMethods(interp.MethodTable):\n    @impl(Add)\n    def interp_add(\n        self,\n        interp: Interpreter,\n        frame: Frame,\n        stmt: Add,\n    ) -&gt; StatementResult:\n        ...\n</code></pre> Source code in <code>src/kirin/interp/impl.py</code> <pre><code>def __init__(\n    self, stmt_or_attribute: Type[HeadType], *args: types.TypeAttribute\n) -&gt; None:\n    if args and issubclass(stmt_or_attribute, Attribute):\n        raise ValueError(\"Attributes do not take arguments\")\n    self.stmt_or_attribute: type[HeadType] = stmt_or_attribute\n    self.args = args\n</code></pre>"},{"location":"reference/kirin/interp/state/","title":"State","text":""},{"location":"reference/kirin/interp/state/#kirin.interp.state.InterpreterState","title":"InterpreterState  <code>dataclass</code>","text":"<pre><code>InterpreterState()\n</code></pre> <p>               Bases: <code>Generic[FrameType]</code></p> <p>Interpreter state.</p> <p>This class represents the state of the interpreter. It contains the stack of frames for the interpreter. The stack of frames is used to store the current state of the interpreter during interpretation.</p>"},{"location":"reference/kirin/interp/state/#kirin.interp.state.InterpreterState.current_frame","title":"current_frame  <code>property</code>","text":"<pre><code>current_frame: FrameType\n</code></pre> <p>Get the current frame.</p> <p>Returns:</p> Name Type Description <code>FrameType</code> <code>FrameType</code> <p>The current frame.</p>"},{"location":"reference/kirin/interp/state/#kirin.interp.state.InterpreterState.depth","title":"depth  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>depth: int = field(\n    default=0, kw_only=True, init=False, repr=False\n)\n</code></pre> <p>stack depth of the interpreter.</p>"},{"location":"reference/kirin/interp/state/#kirin.interp.state.InterpreterState.pop_frame","title":"pop_frame","text":"<pre><code>pop_frame() -&gt; FrameType\n</code></pre> <p>Pop a frame from the stack.</p> <p>Returns:</p> Name Type Description <code>FrameType</code> <code>FrameType</code> <p>The frame that was popped.</p> Source code in <code>src/kirin/interp/state.py</code> <pre><code>def pop_frame(self) -&gt; FrameType:\n    \"\"\"Pop a frame from the stack.\n\n    Returns:\n        FrameType: The frame that was popped.\n    \"\"\"\n    if self._current_frame is None:\n        raise ValueError(\"no frame to pop\")\n    frame = self._current_frame\n    self._current_frame = self._current_frame.parent\n    self.depth -= 1\n    frame.parent = None\n    return frame\n</code></pre>"},{"location":"reference/kirin/interp/state/#kirin.interp.state.InterpreterState.push_frame","title":"push_frame","text":"<pre><code>push_frame(frame: FrameType) -&gt; FrameType\n</code></pre> <p>Push a frame onto the stack.</p> <p>Parameters:</p> Name Type Description Default <code>frame(FrameType)</code> <p>The frame to push onto the stack.</p> required <p>Returns:</p> Name Type Description <code>FrameType</code> <code>FrameType</code> <p>The frame that was pushed.</p> Source code in <code>src/kirin/interp/state.py</code> <pre><code>def push_frame(self, frame: FrameType) -&gt; FrameType:\n    \"\"\"Push a frame onto the stack.\n\n    Args:\n        frame(FrameType): The frame to push onto the stack.\n\n    Returns:\n        FrameType: The frame that was pushed.\n    \"\"\"\n    assert frame.parent is None, \"frame already has a parent\"\n    self.depth += 1\n    if self._current_frame is None:\n        self._current_frame = frame\n    else:\n        frame.parent = self._current_frame\n        self._current_frame = frame\n    return self._current_frame\n</code></pre>"},{"location":"reference/kirin/interp/table/","title":"Table","text":""},{"location":"reference/kirin/interp/table/#kirin.interp.table.MethodTable","title":"MethodTable  <code>dataclass</code>","text":"<pre><code>MethodTable()\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Base class to define lookup tables for interpreting code for IR nodes in a dialect.</p>"},{"location":"reference/kirin/interp/table/#kirin.interp.table.MethodTable.attribute","title":"attribute  <code>class-attribute</code>","text":"<pre><code>attribute: dict[type[Attribute], AttributeFunction]\n</code></pre> <p>Lookup table for interpreting code for IR attributes in a dialect.</p>"},{"location":"reference/kirin/interp/table/#kirin.interp.table.MethodTable.table","title":"table  <code>class-attribute</code>","text":"<pre><code>table: dict[Signature, MethodFunction]\n</code></pre> <p>Lookup table for interpreting code for IR nodes in a dialect.</p>"},{"location":"reference/kirin/interp/value/","title":"Value","text":""},{"location":"reference/kirin/interp/value/#kirin.interp.value.SpecialValue","title":"SpecialValue  <code>module-attribute</code>","text":"<pre><code>SpecialValue: TypeAlias = (\n    None\n    | ReturnValue[ValueType]\n    | YieldValue[ValueType]\n    | Successor[ValueType]\n)\n</code></pre> <p>Special value for statement evaluation.</p>"},{"location":"reference/kirin/interp/value/#kirin.interp.value.StatementResult","title":"StatementResult  <code>module-attribute</code>","text":"<pre><code>StatementResult: TypeAlias = (\n    tuple[ValueType, ...] | SpecialValue[ValueType]\n)\n</code></pre> <p>Type alias for the result of a statement evaluation.</p>"},{"location":"reference/kirin/interp/value/#kirin.interp.value.ReturnValue","title":"ReturnValue  <code>dataclass</code>","text":"<pre><code>ReturnValue(value: ValueType)\n</code></pre> <p>               Bases: <code>Generic[ValueType]</code></p> <p>Return value from a statement evaluation.</p> <p>This class represents a return value from a statement evaluation. It is used to indicate that the statement evaluation should later pop the frame and return the value. Kirin does not allow multiple return values to follow Python semantics. If you want to return multiple values, you should return a tuple.</p>"},{"location":"reference/kirin/interp/value/#kirin.interp.value.Successor","title":"Successor  <code>dataclass</code>","text":"<pre><code>Successor(block: Block, *block_args: ValueType)\n</code></pre> <p>               Bases: <code>Generic[ValueType]</code></p> <p>Successor block from a statement evaluation.</p> Source code in <code>src/kirin/interp/value.py</code> <pre><code>def __init__(self, block: Block, *block_args: ValueType):\n    super().__init__()\n    self.block = block\n    self.block_args = block_args\n</code></pre>"},{"location":"reference/kirin/interp/value/#kirin.interp.value.YieldValue","title":"YieldValue  <code>dataclass</code>","text":"<pre><code>YieldValue(values: tuple[ValueType, ...])\n</code></pre> <p>               Bases: <code>Generic[ValueType]</code></p> <p>Yield value from a statement evaluation.</p> <p>This class represents values returned from a statement that terminates current region execution and returns the values to the caller. Unlike <code>ReturnValue</code>, this class won't pop the frame and return the value to the caller.</p>"},{"location":"reference/kirin/ir/","title":"Index","text":"<p>IR module for kirin.</p> <p>This module contains the data structure definition of the intermediate representation (IR) for kirin.</p>"},{"location":"reference/kirin/ir/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/ir/dialect/#kirin.ir.dialect.Dialect","title":"Dialect  <code>dataclass</code>","text":"<pre><code>Dialect(\n    name: str,\n    stmts: list[type[Statement]] = list(),\n    attrs: list[type[Attribute]] = list(),\n    interps: dict[str, MethodTable] = dict(),\n    lowering: dict[str, FromPythonAST] = dict(),\n    rules: Rules = Rules(),\n    python_types: dict[tuple[str, str], \"PyClass\"] = dict(),\n)\n</code></pre> <p>Dialect is a collection of statements, attributes, interpreters, lowerings, and codegen.</p> Example <pre><code>    from kirin import ir\n\n    my_dialect = ir.Dialect(name=\"my_dialect\")\n</code></pre>"},{"location":"reference/kirin/ir/dialect/#kirin.ir.dialect.Dialect.attrs","title":"attrs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>attrs: list[type[Attribute]] = field(\n    default_factory=list, init=True\n)\n</code></pre> <p>A list of attributes in the dialect.</p>"},{"location":"reference/kirin/ir/dialect/#kirin.ir.dialect.Dialect.interps","title":"interps  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>interps: dict[str, MethodTable] = field(\n    default_factory=dict, init=True\n)\n</code></pre> <p>A dictionary of registered method table in the dialect.</p>"},{"location":"reference/kirin/ir/dialect/#kirin.ir.dialect.Dialect.lowering","title":"lowering  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lowering: dict[str, FromPythonAST] = field(\n    default_factory=dict, init=True\n)\n</code></pre> <p>A dictionary of registered python lowering implmentations in the dialect.</p>"},{"location":"reference/kirin/ir/dialect/#kirin.ir.dialect.Dialect.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the dialect.</p>"},{"location":"reference/kirin/ir/dialect/#kirin.ir.dialect.Dialect.rules","title":"rules  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rules: Rules = field(default_factory=Rules, init=True)\n</code></pre> <p>A collection of rewrite rules for the dialect.</p>"},{"location":"reference/kirin/ir/dialect/#kirin.ir.dialect.Dialect.stmts","title":"stmts  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stmts: list[type[Statement]] = field(\n    default_factory=list, init=True\n)\n</code></pre> <p>A list of statements in the dialect.</p>"},{"location":"reference/kirin/ir/dialect/#kirin.ir.dialect.Dialect.canonicalize","title":"canonicalize","text":"<pre><code>canonicalize(rule: type[RewriteRule]) -&gt; type[RewriteRule]\n</code></pre> <p>Register a rewrite rule to the canonicalization pass.</p> <p>Parameters:</p> Name Type Description Default <code>rule</code> <code>RewriteRule</code> <p>The rewrite rule to register.</p> required Source code in <code>src/kirin/ir/dialect.py</code> <pre><code>def canonicalize(self, rule: type[RewriteRule]) -&gt; type[RewriteRule]:\n    \"\"\"Register a rewrite rule to the canonicalization pass.\n\n    Args:\n        rule (RewriteRule): The rewrite rule to register.\n    \"\"\"\n    self.rules.canonicalize.append(rule())\n    return rule\n</code></pre>"},{"location":"reference/kirin/ir/dialect/#kirin.ir.dialect.Dialect.post_inference","title":"post_inference","text":"<pre><code>post_inference(\n    rule: type[RewriteRule],\n) -&gt; type[RewriteRule]\n</code></pre> <p>Register a rewrite rule to the inference pass. Usually, this is used to register a rule that requires type inference to be run first.</p> <p>Parameters:</p> Name Type Description Default <code>rule</code> <code>RewriteRule</code> <p>The rewrite rule to register.</p> required Source code in <code>src/kirin/ir/dialect.py</code> <pre><code>def post_inference(self, rule: type[RewriteRule]) -&gt; type[RewriteRule]:\n    \"\"\"Register a rewrite rule to the inference pass.\n    Usually, this is used to register a rule that requires\n    type inference to be run first.\n\n    Args:\n        rule (RewriteRule): The rewrite rule to register.\n    \"\"\"\n    self.rules.inference.append(rule())\n    return rule\n</code></pre>"},{"location":"reference/kirin/ir/dialect/#kirin.ir.dialect.Dialect.register","title":"register","text":"<pre><code>register(node: type | None = None, key: str | None = None)\n</code></pre> <p>register is a decorator to register a node to the dialect.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>type | None</code> <p>The node to register. Defaults to None.</p> <code>None</code> <code>key</code> <code>str | None</code> <p>The key to register the node to. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the node is not a subclass of Statement, Attribute, DialectInterpreter, FromPythonAST, or DialectEmit.</p> Example <ul> <li> <p>Register a method table for concrete interpreter (by default key=\"main\") to the dialect: <pre><code>    from kirin import ir\n\n    my_dialect = ir.Dialect(name=\"my_dialect\")\n\n    @my_dialect.register\n    class MyMethodTable(ir.MethodTable):\n        ...\n</code></pre></p> </li> <li> <p>Register a method table for the interpreter specified by <code>key</code> to the dialect: <pre><code>    from kirin import ir\n\n    my_dialect = ir.Dialect(name=\"my_dialect\")\n\n    @my_dialect.register(key=\"my_interp\")\n    class MyMethodTable(ir.MethodTable):\n        ...\n</code></pre></p> </li> </ul> Source code in <code>src/kirin/ir/dialect.py</code> <pre><code>@dataclass_transform()\ndef register(self, node: type | None = None, key: str | None = None):\n    \"\"\"register is a decorator to register a node to the dialect.\n\n    Args:\n        node (type | None): The node to register. Defaults to None.\n        key (str | None): The key to register the node to. Defaults to None.\n\n    Raises:\n        ValueError: If the node is not a subclass of Statement, Attribute, DialectInterpreter, FromPythonAST, or DialectEmit.\n\n    Example:\n        * Register a method table for concrete interpreter (by default key=\"main\") to the dialect:\n        ```python\n            from kirin import ir\n\n            my_dialect = ir.Dialect(name=\"my_dialect\")\n\n            @my_dialect.register\n            class MyMethodTable(ir.MethodTable):\n                ...\n        ```\n\n        * Register a method table for the interpreter specified by `key` to the dialect:\n        ```python\n            from kirin import ir\n\n            my_dialect = ir.Dialect(name=\"my_dialect\")\n\n            @my_dialect.register(key=\"my_interp\")\n            class MyMethodTable(ir.MethodTable):\n                ...\n        ```\n\n\n    \"\"\"\n    from kirin.interp.table import MethodTable\n    from kirin.lowering.python.dialect import FromPythonAST\n\n    if key is None:\n        key = \"main\"\n\n    def wrapper(node: type[T]) -&gt; type[T]:\n        if issubclass(node, Statement):\n            self.stmts.append(node)\n        elif issubclass(node, Attribute):\n            assert (\n                Attribute in node.__mro__\n            ), f\"{node} is not a subclass of Attribute\"\n            setattr(node, \"dialect\", self)\n            assert hasattr(node, \"name\"), f\"{node} does not have a name attribute\"\n            self.attrs.append(node)\n        elif issubclass(node, MethodTable):\n            if key in self.interps:\n                raise ValueError(\n                    f\"Cannot register {node} to Dialect, key {key} exists in {self}\"\n                )\n            self.interps[key] = node()\n        elif issubclass(node, FromPythonAST):\n            if key in self.lowering:\n                raise ValueError(\n                    f\"Cannot register {node} to Dialect, key {key} exists\"\n                )\n            self.lowering[key] = node()\n        else:\n            raise ValueError(f\"Cannot register {node} to Dialect\")\n        return node\n\n    if node is None:\n        return wrapper\n\n    return wrapper(node)\n</code></pre>"},{"location":"reference/kirin/ir/dialect/#kirin.ir.dialect.Rules","title":"Rules  <code>dataclass</code>","text":"<pre><code>Rules(\n    canonicalize: list[RewriteRule] = list(),\n    inference: list[RewriteRule] = list(),\n)\n</code></pre>"},{"location":"reference/kirin/ir/dialect/#kirin.ir.dialect.Rules.canonicalize","title":"canonicalize  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>canonicalize: list[RewriteRule] = field(\n    default_factory=list, init=True\n)\n</code></pre> <p>A collection of rules for Canonicalize pass.</p>"},{"location":"reference/kirin/ir/dialect/#kirin.ir.dialect.Rules.inference","title":"inference  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inference: list[RewriteRule] = field(\n    default_factory=list, init=True\n)\n</code></pre> <p>A collection of rules for Inference pass.</p>"},{"location":"reference/kirin/ir/exception/","title":"Exception","text":""},{"location":"reference/kirin/ir/group/","title":"Dialect Group","text":""},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup","title":"DialectGroup  <code>dataclass</code>","text":"<pre><code>DialectGroup(\n    dialects: Iterable[Union[\"Dialect\", ModuleType]],\n    run_pass: RunPassGen[PassParams] | None = None,\n)\n</code></pre> <p>               Bases: <code>Generic[PassParams]</code></p> Source code in <code>src/kirin/ir/group.py</code> <pre><code>def __init__(\n    self,\n    dialects: Iterable[Union[\"Dialect\", ModuleType]],\n    run_pass: RunPassGen[PassParams] | None = None,\n):\n    def identity(code: Method):\n        pass\n\n    self.data = frozenset(self.map_module(dialect) for dialect in dialects)\n    if run_pass is None:\n        self.run_pass_gen = None\n        self.run_pass = None\n    else:\n        self.run_pass_gen = run_pass\n        self.run_pass = run_pass(self)\n\n    from kirin.lowering import Python\n\n    self.lowering = Python(self)\n</code></pre>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data: frozenset[\"Dialect\"] = frozenset(\n    map_module(dialect) for dialect in dialects\n)\n</code></pre> <p>The set of dialects in the group.</p>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup.lowering","title":"lowering  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lowering: Python = Python(self)\n</code></pre> <p>the lowering object used to lower the method.</p>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup.registry","title":"registry  <code>property</code>","text":"<pre><code>registry: 'Registry'\n</code></pre> <p>return the registry for the dialect group. This returns a proxy object that can be used to select the lowering interpreters, interpreters, and codegen for the dialects in the group.</p> <p>Returns:</p> Name Type Description <code>Registry</code> <code>'Registry'</code> <p>the registry object.</p>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup.run_pass","title":"run_pass  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>run_pass: RunPass[PassParams] | None = None\n</code></pre> <p>the function that runs the passes on the method.</p>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup.run_pass_gen","title":"run_pass_gen  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>run_pass_gen: RunPassGen[PassParams] | None = None\n</code></pre> <p>the function that generates the <code>run_pass</code> function.</p> <p>This is used to create new dialect groups from existing ones, while keeping the same <code>run_pass</code> function.</p>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup.__call__","title":"__call__","text":"<pre><code>__call__(\n    py_func: Callable[Param, RetType],\n    *args: PassParams.args,\n    **options: PassParams.kwargs\n) -&gt; Method[Param, RetType]\n</code></pre><pre><code>__call__(\n    py_func: None = None,\n    *args: PassParams.args,\n    **options: PassParams.kwargs\n) -&gt; MethodTransform[Param, RetType]\n</code></pre> <pre><code>__call__(\n    py_func: Callable[Param, RetType] | None = None,\n    *args: PassParams.args,\n    **options: PassParams.kwargs\n) -&gt; (\n    Method[Param, RetType] | MethodTransform[Param, RetType]\n)\n</code></pre> <p>create a method from the python function.</p> <p>Parameters:</p> Name Type Description Default <code>py_func</code> <code>Callable</code> <p>the python function to create the method from.</p> <code>None</code> <code>args</code> <code>args</code> <p>the arguments to pass to the run_pass function.</p> <code>()</code> <code>options</code> <code>kwargs</code> <p>the keyword arguments to pass to the run_pass function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Method</code> <code>Method[Param, RetType] | MethodTransform[Param, RetType]</code> <p>the method created from the python function.</p> Source code in <code>src/kirin/ir/group.py</code> <pre><code>def __call__(\n    self,\n    py_func: Callable[Param, RetType] | None = None,\n    *args: PassParams.args,\n    **options: PassParams.kwargs,\n) -&gt; Method[Param, RetType] | MethodTransform[Param, RetType]:\n    \"\"\"create a method from the python function.\n\n    Args:\n        py_func (Callable): the python function to create the method from.\n        args (PassParams.args): the arguments to pass to the run_pass function.\n        options (PassParams.kwargs): the keyword arguments to pass to the run_pass function.\n\n    Returns:\n        Method: the method created from the python function.\n    \"\"\"\n    frame = inspect.currentframe()\n\n    def wrapper(py_func: Callable) -&gt; Method:\n        if py_func.__name__ == \"&lt;lambda&gt;\":\n            raise ValueError(\"Cannot compile lambda functions\")\n\n        lineno_offset, file = 0, \"\"\n        if frame and frame.f_back is not None:\n            call_site_frame = frame.f_back\n            if py_func.__name__ in call_site_frame.f_locals:\n                raise CompilerError(\n                    f\"overwriting function definition of `{py_func.__name__}`\"\n                )\n\n            lineno_offset = call_site_frame.f_lineno - 1\n            file = call_site_frame.f_code.co_filename\n\n        code = self.lowering.python_function(py_func, lineno_offset=lineno_offset)\n        mt = Method(\n            mod=inspect.getmodule(py_func),\n            py_func=py_func,\n            sym_name=py_func.__name__,\n            arg_names=[\"#self#\"] + inspect.getfullargspec(py_func).args,\n            dialects=self,\n            code=code,\n            lineno_offset=lineno_offset,\n            file=file,\n        )\n        if doc := inspect.getdoc(py_func):\n            mt.__doc__ = doc\n\n        if self.run_pass is not None:\n            self.run_pass(mt, *args, **options)\n        return mt\n\n    if py_func is not None:\n        return wrapper(py_func)\n    return wrapper\n</code></pre>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup.__contains__","title":"__contains__","text":"<pre><code>__contains__(dialect) -&gt; bool\n</code></pre> <p>check if the dialect is in the group.</p> <p>Parameters:</p> Name Type Description Default <code>dialect</code> <code>Union[Dialect, ModuleType]</code> <p>the dialect to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the dialect is in the group, False otherwise.</p> Source code in <code>src/kirin/ir/group.py</code> <pre><code>def __contains__(self, dialect) -&gt; bool:\n    \"\"\"check if the dialect is in the group.\n\n    Args:\n        dialect (Union[Dialect, ModuleType]): the dialect to check.\n\n    Returns:\n        bool: True if the dialect is in the group, False otherwise.\n    \"\"\"\n    return self.map_module(dialect) in self.data\n</code></pre>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup.add","title":"add","text":"<pre><code>add(\n    dialect: Union[\"Dialect\", ModuleType]\n) -&gt; \"DialectGroup\"\n</code></pre> <p>add a dialect to the group.</p> <p>Parameters:</p> Name Type Description Default <code>dialect</code> <code>Union[Dialect, ModuleType]</code> <p>the dialect to add</p> required <p>Returns:</p> Name Type Description <code>DialectGroup</code> <code>'DialectGroup'</code> <p>the new dialect group with the added</p> Source code in <code>src/kirin/ir/group.py</code> <pre><code>def add(self, dialect: Union[\"Dialect\", ModuleType]) -&gt; \"DialectGroup\":\n    \"\"\"add a dialect to the group.\n\n    Args:\n        dialect (Union[Dialect, ModuleType]): the dialect to add\n\n    Returns:\n        DialectGroup: the new dialect group with the added\n    \"\"\"\n    return self.union([dialect])\n</code></pre>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup.discard","title":"discard","text":"<pre><code>discard(\n    dialect: Union[\"Dialect\", ModuleType]\n) -&gt; \"DialectGroup\"\n</code></pre> <p>discard a dialect from the group.</p> <p>Note</p> <p>This does not raise an error if the dialect is not in the group.</p> <p>Parameters:</p> Name Type Description Default <code>dialect</code> <code>Union[Dialect, ModuleType]</code> <p>the dialect to discard</p> required <p>Returns:</p> Name Type Description <code>DialectGroup</code> <code>'DialectGroup'</code> <p>the new dialect group with the discarded dialect.</p> Source code in <code>src/kirin/ir/group.py</code> <pre><code>def discard(self, dialect: Union[\"Dialect\", ModuleType]) -&gt; \"DialectGroup\":\n    \"\"\"discard a dialect from the group.\n\n    !!! note\n        This does not raise an error if the dialect is not in the group.\n\n    Args:\n        dialect (Union[Dialect, ModuleType]): the dialect to discard\n\n    Returns:\n        DialectGroup: the new dialect group with the discarded dialect.\n    \"\"\"\n    dialect_ = self.map_module(dialect)\n    return DialectGroup(\n        dialects=frozenset(\n            each for each in self.data if each.name != dialect_.name\n        ),\n        run_pass=self.run_pass_gen,  # pass the run_pass_gen function\n    )\n</code></pre>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup.map_module","title":"map_module  <code>staticmethod</code>","text":"<pre><code>map_module(\n    dialect: Union[\"Dialect\", ModuleType]\n) -&gt; \"Dialect\"\n</code></pre> <p>map the module to the dialect if it is a module. It assumes that the module has a <code>dialect</code> attribute that is an instance of <code>Dialect</code>.</p> Source code in <code>src/kirin/ir/group.py</code> <pre><code>@staticmethod\ndef map_module(dialect: Union[\"Dialect\", ModuleType]) -&gt; \"Dialect\":\n    \"\"\"map the module to the dialect if it is a module.\n    It assumes that the module has a `dialect` attribute\n    that is an instance of [`Dialect`][kirin.ir.Dialect].\n    \"\"\"\n    if isinstance(dialect, ModuleType):\n        return getattr(dialect, \"dialect\")\n    return dialect\n</code></pre>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup.union","title":"union","text":"<pre><code>union(\n    dialect: Iterable[Union[\"Dialect\", ModuleType]]\n) -&gt; \"DialectGroup\"\n</code></pre> <p>union a set of dialects to the group.</p> <p>Parameters:</p> Name Type Description Default <code>dialect</code> <code>Iterable[Union[Dialect, ModuleType]]</code> <p>the dialects to union</p> required <p>Returns:</p> Name Type Description <code>DialectGroup</code> <code>'DialectGroup'</code> <p>the new dialect group with the union.</p> Source code in <code>src/kirin/ir/group.py</code> <pre><code>def union(self, dialect: Iterable[Union[\"Dialect\", ModuleType]]) -&gt; \"DialectGroup\":\n    \"\"\"union a set of dialects to the group.\n\n    Args:\n        dialect (Iterable[Union[Dialect, ModuleType]]): the dialects to union\n\n    Returns:\n        DialectGroup: the new dialect group with the union.\n    \"\"\"\n    return DialectGroup(\n        dialects=self.data.union(frozenset(self.map_module(d) for d in dialect)),\n        run_pass=self.run_pass_gen,  # pass the run_pass_gen function\n    )\n</code></pre>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.dialect_group","title":"dialect_group","text":"<pre><code>dialect_group(\n    dialects: Iterable[Union[\"Dialect\", ModuleType]]\n) -&gt; Callable[\n    [RunPassGen[PassParams]], DialectGroup[PassParams]\n]\n</code></pre> <p>Create a dialect group from the given dialects based on the definition of <code>run_pass</code> function.</p> <p>Parameters:</p> Name Type Description Default <code>dialects</code> <code>Iterable[Union[Dialect, ModuleType]]</code> <p>the dialects to include in the group.</p> required <p>Returns:</p> Type Description <code>Callable[[RunPassGen[PassParams]], DialectGroup[PassParams]]</code> <p>Callable[[RunPassGen[PassParams]], DialectGroup[PassParams]]: the dialect group.</p> Example <pre><code>from kirin.dialects import cf, fcf, func, math\n\n@dialect_group([cf, fcf, func, math])\ndef basic_no_opt(self):\n    # initializations\n    def run_pass(mt: Method) -&gt; None:\n        # how passes are applied to the method\n        pass\n\n    return run_pass\n</code></pre> Source code in <code>src/kirin/ir/group.py</code> <pre><code>def dialect_group(\n    dialects: Iterable[Union[\"Dialect\", ModuleType]],\n) -&gt; Callable[[RunPassGen[PassParams]], DialectGroup[PassParams]]:\n    \"\"\"Create a dialect group from the given dialects based on the\n    definition of `run_pass` function.\n\n    Args:\n        dialects (Iterable[Union[Dialect, ModuleType]]): the dialects to include in the group.\n\n    Returns:\n        Callable[[RunPassGen[PassParams]], DialectGroup[PassParams]]: the dialect group.\n\n    Example:\n        ```python\n        from kirin.dialects import cf, fcf, func, math\n\n        @dialect_group([cf, fcf, func, math])\n        def basic_no_opt(self):\n            # initializations\n            def run_pass(mt: Method) -&gt; None:\n                # how passes are applied to the method\n                pass\n\n            return run_pass\n        ```\n    \"\"\"\n\n    # NOTE: do not alias the annotation below\n    def wrapper(\n        transform: RunPassGen[PassParams],\n    ) -&gt; DialectGroup[PassParams]:\n        ret = DialectGroup(dialects, run_pass=transform)\n        update_wrapper(ret, transform)\n        return ret\n\n    return wrapper\n</code></pre>"},{"location":"reference/kirin/ir/method/","title":"Method","text":""},{"location":"reference/kirin/ir/method/#kirin.ir.method.Method","title":"Method  <code>dataclass</code>","text":"<pre><code>Method(\n    mod: ModuleType | None,\n    py_func: typing.Callable[Param, RetType] | None,\n    sym_name: str,\n    arg_names: list[str],\n    dialects: DialectGroup,\n    code: Statement,\n    fields: tuple = tuple(),\n    file: str = \"\",\n    lineno_offset: int = 0,\n    inferred: bool = False,\n)\n</code></pre> <p>               Bases: <code>Printable</code>, <code>Generic[Param, RetType]</code></p>"},{"location":"reference/kirin/ir/method/#kirin.ir.method.Method.arg_types","title":"arg_types  <code>property</code>","text":"<pre><code>arg_types\n</code></pre> <p>Return the types of the arguments of the method. (excluding self)</p>"},{"location":"reference/kirin/ir/method/#kirin.ir.method.Method.args","title":"args  <code>property</code>","text":"<pre><code>args\n</code></pre> <p>Return the arguments of the method. (excluding self)</p>"},{"location":"reference/kirin/ir/method/#kirin.ir.method.Method.inferred","title":"inferred  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inferred: bool = False\n</code></pre> <p>if typeinfer has been run on this method</p>"},{"location":"reference/kirin/ir/method/#kirin.ir.method.Method.self_type","title":"self_type  <code>property</code>","text":"<pre><code>self_type\n</code></pre> <p>Return the type of the self argument of the method.</p>"},{"location":"reference/kirin/ir/method/#kirin.ir.method.Method.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>verify the method body.</p> <p>This will raise a ValidationError if the method body is not valid.</p> Source code in <code>src/kirin/ir/method.py</code> <pre><code>def verify(self) -&gt; None:\n    \"\"\"verify the method body.\n\n    This will raise a ValidationError if the method body is not valid.\n    \"\"\"\n    try:\n        self.code.verify()\n    except ValidationError as e:\n        self.__postprocess_validation_error(e)\n</code></pre>"},{"location":"reference/kirin/ir/method/#kirin.ir.method.Method.verify_type","title":"verify_type","text":"<pre><code>verify_type() -&gt; None\n</code></pre> <p>verify the method type.</p> <p>This will raise a ValidationError if the method type is not valid.</p> Source code in <code>src/kirin/ir/method.py</code> <pre><code>def verify_type(self) -&gt; None:\n    \"\"\"verify the method type.\n\n    This will raise a ValidationError if the method type is not valid.\n    \"\"\"\n    # NOTE: verify the method body\n    self.verify()\n\n    try:\n        self.code.verify_type()\n    except ValidationError as e:\n        self.__postprocess_validation_error(e)\n</code></pre>"},{"location":"reference/kirin/ir/ssa/","title":"SSA values","text":""},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.BlockArgument","title":"BlockArgument  <code>dataclass</code>","text":"<pre><code>BlockArgument(\n    block: Block,\n    index: int,\n    type: TypeAttribute = AnyType(),\n)\n</code></pre> <p>               Bases: <code>SSAValue</code></p> <p>SSAValue that is an argument to a <code>Block</code>.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def __init__(\n    self, block: Block, index: int, type: TypeAttribute = AnyType()\n) -&gt; None:\n    super().__init__()\n    self.type = type\n    self.block = block\n    self.index = index\n</code></pre>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.BlockArgument.block","title":"block  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>block: Block = block\n</code></pre> <p>The block that this argument belongs to.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.BlockArgument.index","title":"index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>index: int = index\n</code></pre> <p>The index of this argument in the block's argument list.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.BlockArgument.owner","title":"owner  <code>property</code>","text":"<pre><code>owner: Block\n</code></pre> <p>The object that owns this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.BlockArgument.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type = type\n</code></pre> <p>The type of this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.BlockArgument.delete","title":"delete","text":"<pre><code>delete(safe: bool = True) -&gt; None\n</code></pre> <p>Delete this SSA value. If <code>safe</code> is <code>True</code>, raise an error if there are uses.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def delete(self, safe: bool = True) -&gt; None:\n    self.block.args.delete(self, safe=safe)\n</code></pre>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.DeletedSSAValue","title":"DeletedSSAValue  <code>dataclass</code>","text":"<pre><code>DeletedSSAValue(value: SSAValue)\n</code></pre> <p>               Bases: <code>SSAValue</code></p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def __init__(self, value: SSAValue) -&gt; None:\n    super().__init__()\n    self.value = value\n    self.type = value.type\n</code></pre>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.DeletedSSAValue.owner","title":"owner  <code>property</code>","text":"<pre><code>owner: Statement | Block\n</code></pre> <p>The object that owns this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.DeletedSSAValue.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type = type\n</code></pre> <p>The type of this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.ResultValue","title":"ResultValue  <code>dataclass</code>","text":"<pre><code>ResultValue(\n    stmt: Statement,\n    index: int,\n    type: TypeAttribute | None = None,\n)\n</code></pre> <p>               Bases: <code>SSAValue</code></p> <p>SSAValue that is a result of a <code>Statement</code>.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def __init__(\n    self, stmt: Statement, index: int, type: TypeAttribute | None = None\n) -&gt; None:\n    super().__init__()\n    self.type = type or AnyType()\n    self.stmt = stmt\n    self.index = index\n</code></pre>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.ResultValue.index","title":"index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>index: int = index\n</code></pre> <p>The index of this value in the statement's result list.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.ResultValue.owner","title":"owner  <code>property</code>","text":"<pre><code>owner: Statement\n</code></pre> <p>The object that owns this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.ResultValue.stmt","title":"stmt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stmt: Statement = stmt\n</code></pre> <p>The statement that this value is a result of.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.ResultValue.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type = type or AnyType()\n</code></pre> <p>The type of this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue","title":"SSAValue  <code>dataclass</code>","text":"<pre><code>SSAValue()\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Printable</code></p> <p>Base class for all SSA values in the IR.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue.hints","title":"hints  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hints: dict[str, Attribute] = field(\n    default_factory=dict, init=False, repr=False\n)\n</code></pre> <p>Hints for this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue.name","title":"name  <code>property</code> <code>writable</code>","text":"<pre><code>name: str | None\n</code></pre> <p>The name of this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue.name_pattern","title":"name_pattern  <code>class-attribute</code>","text":"<pre><code>name_pattern: Pattern[str] = compile(\n    \"([A-Za-z_$.-][\\\\w$.-]*)\"\n)\n</code></pre> <p>The pattern that the name of this SSA value must match.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue.owner","title":"owner  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>owner: Statement | Block\n</code></pre> <p>The object that owns this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type: TypeAttribute = field(\n    default_factory=AnyType, init=False, repr=True\n)\n</code></pre> <p>The type of this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue.uses","title":"uses  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>uses: set[Use] = field(\n    init=False, default_factory=set, repr=False\n)\n</code></pre> <p>The uses of this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue.add_use","title":"add_use","text":"<pre><code>add_use(use: Use) -&gt; Self\n</code></pre> <p>Add a use to this SSA value.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def add_use(self, use: Use) -&gt; Self:\n    \"\"\"Add a use to this SSA value.\"\"\"\n    self.uses.add(use)\n    return self\n</code></pre>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue.delete","title":"delete","text":"<pre><code>delete(safe: bool = True) -&gt; None\n</code></pre> <p>Delete this SSA value. If <code>safe</code> is <code>True</code>, raise an error if there are uses.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def delete(self, safe: bool = True) -&gt; None:\n    \"\"\"Delete this SSA value. If `safe` is `True`, raise an error if there are uses.\"\"\"\n    if safe and len(self.uses) &gt; 0:\n        raise ValueError(\"Cannot delete SSA value with uses\")\n    self.replace_by(DeletedSSAValue(self))\n</code></pre>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue.remove_use","title":"remove_use","text":"<pre><code>remove_use(use: Use) -&gt; Self\n</code></pre> <p>Remove a use from this SSA value.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def remove_use(self, use: Use) -&gt; Self:\n    \"\"\"Remove a use from this SSA value.\"\"\"\n    # print(use)\n    # assert use in self.uses, \"Use not found\"\n    if use in self.uses:\n        self.uses.remove(use)\n    return self\n</code></pre>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue.replace_by","title":"replace_by","text":"<pre><code>replace_by(other: SSAValue) -&gt; None\n</code></pre> <p>Replace this SSA value with another SSA value. Update all uses.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def replace_by(self, other: SSAValue) -&gt; None:\n    \"\"\"Replace this SSA value with another SSA value. Update all uses.\"\"\"\n    for use in self.uses.copy():\n        use.stmt.args[use.index] = other\n\n    if other.name is None and self.name is not None:\n        other.name = self.name\n\n    assert len(self.uses) == 0, \"Uses not empty\"\n</code></pre>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.TestValue","title":"TestValue  <code>dataclass</code>","text":"<pre><code>TestValue(type: TypeAttribute = AnyType())\n</code></pre> <p>               Bases: <code>SSAValue</code></p> <p>Test SSAValue for testing IR construction.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def __init__(self, type: TypeAttribute = AnyType()) -&gt; None:\n    super().__init__()\n    self.type = type\n</code></pre>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.TestValue.owner","title":"owner  <code>property</code>","text":"<pre><code>owner: Statement | Block\n</code></pre> <p>The object that owns this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.TestValue.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type = type\n</code></pre> <p>The type of this SSA value.</p>"},{"location":"reference/kirin/ir/use/","title":"Use","text":""},{"location":"reference/kirin/ir/use/#kirin.ir.use.Use","title":"Use  <code>dataclass</code>","text":"<pre><code>Use(stmt: Statement, index: int)\n</code></pre> <p>A use of an SSA value in a statement.</p>"},{"location":"reference/kirin/ir/use/#kirin.ir.use.Use.index","title":"index  <code>instance-attribute</code>","text":"<pre><code>index: int\n</code></pre> <p>The index of the use in the statement.</p>"},{"location":"reference/kirin/ir/use/#kirin.ir.use.Use.stmt","title":"stmt  <code>instance-attribute</code>","text":"<pre><code>stmt: Statement\n</code></pre> <p>The statement that uses the SSA value.</p>"},{"location":"reference/kirin/ir/attrs/","title":"Index","text":"<p>Compile-time values in Kirin IR.</p> <p>This module contains the following:</p>"},{"location":"reference/kirin/ir/attrs/#kirin.ir.attrs--abc-module","title":"<code>abc</code> module","text":"<p><code>abc.AttributeMeta</code>: The metaclass for all attributes. <code>abc.Attribute</code>: The base class for all attributes.</p>"},{"location":"reference/kirin/ir/attrs/#kirin.ir.attrs--types-module","title":"<code>types</code> module","text":"<p><code>types.TypeAttribute</code>: The base class for all type attributes. <code>types.PyClass</code>: A type attribute representing a Python class. <code>types.TypeVar</code>: A type attribute representing a type variable. <code>types.Literal</code>: A type attribute representing a literal type. <code>types.Generic</code>: A type attribute representing a generic type. <code>types.Union</code>: A type attribute representing a union type.</p>"},{"location":"reference/kirin/ir/attrs/#kirin.ir.attrs--py-module","title":"<code>py</code> module","text":"<p><code>py.PyAttr</code>: An attribute representing a Python value.</p>"},{"location":"reference/kirin/ir/attrs/abc/","title":"Abc","text":""},{"location":"reference/kirin/ir/attrs/abc/#kirin.ir.attrs.abc.Attribute","title":"Attribute  <code>dataclass</code>","text":"<pre><code>Attribute()\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Printable</code></p> <p>ABC for compile-time values. All attributes are hashable and thus need to implement the <code>__hash__</code> method.</p> <p>Pretty Printing</p> <p>This object is pretty printable via <code>.print()</code> method.</p>"},{"location":"reference/kirin/ir/attrs/abc/#kirin.ir.attrs.abc.Attribute.dialect","title":"dialect  <code>class-attribute</code>","text":"<pre><code>dialect: Optional[Dialect] = field(\n    default=None, init=False, repr=False\n)\n</code></pre> <p>Dialect of the attribute. (default: None)</p>"},{"location":"reference/kirin/ir/attrs/abc/#kirin.ir.attrs.abc.Attribute.name","title":"name  <code>class-attribute</code>","text":"<pre><code>name: str = field(init=False, repr=False)\n</code></pre> <p>Name of the attribute in printing and other text format.</p>"},{"location":"reference/kirin/ir/attrs/abc/#kirin.ir.attrs.abc.Attribute.traits","title":"traits  <code>class-attribute</code>","text":"<pre><code>traits: frozenset[Trait[Attribute]] = field(\n    default=frozenset(), init=False, repr=False\n)\n</code></pre> <p>Set of Attribute traits.</p>"},{"location":"reference/kirin/ir/attrs/abc/#kirin.ir.attrs.abc.Attribute.get_trait","title":"get_trait","text":"<pre><code>get_trait(trait: type[TraitType]) -&gt; Optional[TraitType]\n</code></pre> <p>Get the trait of the attribute.</p> <p>Parameters:</p> Name Type Description Default <code>trait</code> <code>type[Trait]</code> <p>the trait to get</p> required <p>Returns:</p> Type Description <code>Optional[TraitType]</code> <p>Optional[Trait]: the trait if found, None otherwise</p> Source code in <code>src/kirin/ir/attrs/abc.py</code> <pre><code>def get_trait(self, trait: type[TraitType]) -&gt; Optional[TraitType]:\n    \"\"\"Get the trait of the attribute.\n\n    Args:\n        trait (type[Trait]): the trait to get\n\n    Returns:\n        Optional[Trait]: the trait if found, None otherwise\n    \"\"\"\n    for t in self.traits:\n        if isinstance(t, trait):\n            return t\n\n    return None\n</code></pre>"},{"location":"reference/kirin/ir/attrs/abc/#kirin.ir.attrs.abc.Attribute.has_trait","title":"has_trait  <code>classmethod</code>","text":"<pre><code>has_trait(trait_type: type[Trait[Attribute]]) -&gt; bool\n</code></pre> <p>Check if the Statement has a specific trait.</p> <p>Parameters:</p> Name Type Description Default <code>trait_type</code> <code>type[Trait]</code> <p>The type of trait to check for.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the class has the specified trait, False otherwise.</p> Source code in <code>src/kirin/ir/attrs/abc.py</code> <pre><code>@classmethod\ndef has_trait(cls, trait_type: type[Trait[\"Attribute\"]]) -&gt; bool:\n    \"\"\"Check if the Statement has a specific trait.\n\n    Args:\n        trait_type (type[Trait]): The type of trait to check for.\n\n    Returns:\n        bool: True if the class has the specified trait, False otherwise.\n    \"\"\"\n    for trait in cls.traits:\n        if isinstance(trait, trait_type):\n            return True\n    return False\n</code></pre>"},{"location":"reference/kirin/ir/attrs/abc/#kirin.ir.attrs.abc.AttributeMeta","title":"AttributeMeta","text":"<p>               Bases: <code>ABCMeta</code></p> <p>Metaclass for attributes.</p>"},{"location":"reference/kirin/ir/attrs/abc/#kirin.ir.attrs.abc.LatticeAttributeMeta","title":"LatticeAttributeMeta","text":"<p>               Bases: <code>LatticeMeta</code>, <code>AttributeMeta</code></p> <p>Metaclass for lattice attributes.</p>"},{"location":"reference/kirin/ir/attrs/abc/#kirin.ir.attrs.abc.SingletonLatticeAttributeMeta","title":"SingletonLatticeAttributeMeta","text":"<pre><code>SingletonLatticeAttributeMeta(name, bases, attrs)\n</code></pre> <p>               Bases: <code>LatticeAttributeMeta</code>, <code>SingletonMeta</code></p> <p>Metaclass for singleton lattice attributes.</p> Source code in <code>src/kirin/lattice/abc.py</code> <pre><code>def __init__(cls, name, bases, attrs):\n    super().__init__(name, bases, attrs)\n    cls._instance = None\n</code></pre>"},{"location":"reference/kirin/ir/attrs/data/","title":"Data","text":""},{"location":"reference/kirin/ir/attrs/data/#kirin.ir.attrs.data.Data","title":"Data  <code>dataclass</code>","text":"<pre><code>Data()\n</code></pre> <p>               Bases: <code>Attribute</code>, <code>Generic[T]</code></p> <p>Base class for data attributes.</p> <p>Data attributes are compile-time constants that can be used to represent runtime data inside the IR.</p> <p>This class is meant to be subclassed by specific data attributes. It provides a <code>type</code> attribute that should be set to the type of the data.</p>"},{"location":"reference/kirin/ir/attrs/data/#kirin.ir.attrs.data.Data.unwrap","title":"unwrap  <code>abstractmethod</code>","text":"<pre><code>unwrap() -&gt; T\n</code></pre> <p>Returns the underlying data value.</p> Source code in <code>src/kirin/ir/attrs/data.py</code> <pre><code>@abstractmethod\ndef unwrap(self) -&gt; T:\n    \"\"\"Returns the underlying data value.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/ir/attrs/py/","title":"Py","text":""},{"location":"reference/kirin/ir/attrs/py/#kirin.ir.attrs.py.PyAttr","title":"PyAttr  <code>dataclass</code>","text":"<pre><code>PyAttr(data: T, pytype: TypeAttribute | None = None)\n</code></pre> <p>               Bases: <code>Data[T]</code></p> <p>Python attribute for compile-time values. This is a generic attribute that holds a Python value.</p> <p>The constructor takes a Python value and an optional type attribute. If the type attribute is not provided, the type of the value is inferred as <code>PyClass(type(value))</code>.</p> <p>Pretty Printing</p> <p>This object is pretty printable via <code>.print()</code> method.</p> Source code in <code>src/kirin/ir/attrs/py.py</code> <pre><code>def __init__(self, data: T, pytype: TypeAttribute | None = None):\n    self.data = data\n\n    if pytype is None:\n        self.type = PyClass(type(data))\n    else:\n        self.type = pytype\n</code></pre>"},{"location":"reference/kirin/ir/attrs/py/#kirin.ir.attrs.py.PyAttr.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'PyAttr'\n</code></pre> <p>Name of the attribute in printing and other text format.</p>"},{"location":"reference/kirin/ir/attrs/py/#kirin.ir.attrs.py.PyAttr.unwrap","title":"unwrap","text":"<pre><code>unwrap() -&gt; T\n</code></pre> <p>Returns the underlying data value.</p> Source code in <code>src/kirin/ir/attrs/py.py</code> <pre><code>def unwrap(self) -&gt; T:\n    return self.data\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/","title":"Types","text":""},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.AnyType","title":"AnyType  <code>dataclass</code>","text":"<pre><code>AnyType()\n</code></pre> <p>               Bases: <code>TypeAttribute</code></p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.AnyType.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'Any'\n</code></pre> <p>Name of the attribute in printing and other text format.</p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.BottomType","title":"BottomType  <code>dataclass</code>","text":"<pre><code>BottomType()\n</code></pre> <p>               Bases: <code>TypeAttribute</code></p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.BottomType.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'Bottom'\n</code></pre> <p>Name of the attribute in printing and other text format.</p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.BottomType.is_subseteq","title":"is_subseteq","text":"<pre><code>is_subseteq(other: TypeAttribute) -&gt; bool\n</code></pre> <p>Subseteq operation.</p> Source code in <code>src/kirin/ir/attrs/types.py</code> <pre><code>def is_subseteq(self, other: TypeAttribute) -&gt; bool:\n    if isinstance(other, TypeVar):\n        return self.is_subseteq(other.bound)\n    return True\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Generic","title":"Generic  <code>dataclass</code>","text":"<pre><code>Generic(\n    body: type[PyClassType] | PyClass[PyClassType],\n    *vars: TypeAttribute | list | Vararg\n)\n</code></pre> <p>               Bases: <code>TypeAttribute</code>, <code>Generic[PyClassType]</code></p> Source code in <code>src/kirin/ir/attrs/types.py</code> <pre><code>def __init__(\n    self,\n    body: type[PyClassType] | PyClass[PyClassType],\n    *vars: TypeAttribute | list | Vararg,\n):\n    if isinstance(body, PyClass):\n        self.body = body\n    else:\n        self.body = PyClass(body)\n    self.vars, self.vararg = _split_type_args(vars)\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Generic.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'Generic'\n</code></pre> <p>Name of the attribute in printing and other text format.</p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Literal","title":"Literal  <code>dataclass</code>","text":"<pre><code>Literal(\n    data: LiteralType, datatype: TypeAttribute | None = None\n)\n</code></pre> <p>               Bases: <code>TypeAttribute</code>, <code>Generic[LiteralType]</code></p> Source code in <code>src/kirin/ir/attrs/types.py</code> <pre><code>def __init__(self, data: LiteralType, datatype: TypeAttribute | None = None):\n    self.data = data\n    self.type = datatype or PyClass(type(data))\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Literal.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'Literal'\n</code></pre> <p>Name of the attribute in printing and other text format.</p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Literal.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: TypeAttribute = datatype or PyClass(type(data))\n</code></pre> <p>type of the literal, this is useful when the Python type of data does not represent the type in IR, e.g Literal(1, types.Int32)</p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Literal.is_equal","title":"is_equal","text":"<pre><code>is_equal(other: TypeAttribute) -&gt; bool\n</code></pre> <p>Check if two lattices are equal.</p> Source code in <code>src/kirin/ir/attrs/types.py</code> <pre><code>def is_equal(self, other: TypeAttribute) -&gt; bool:\n    return self is other\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.PyClass","title":"PyClass  <code>dataclass</code>","text":"<pre><code>PyClass(\n    typ: type[PyClassType],\n    *,\n    display_name: str | None = None,\n    prefix: str = \"py\"\n)\n</code></pre> <p>               Bases: <code>TypeAttribute</code>, <code>Generic[PyClassType]</code></p> Source code in <code>src/kirin/ir/attrs/types.py</code> <pre><code>def __init__(\n    self,\n    typ: type[PyClassType],\n    *,\n    display_name: str | None = None,\n    prefix: str = \"py\",\n) -&gt; None:\n    self.typ = typ\n    self.display_name = display_name if display_name is not None else typ.__name__\n    self.prefix = prefix\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.PyClass.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'PyClass'\n</code></pre> <p>Name of the attribute in printing and other text format.</p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.SingletonTypeMeta","title":"SingletonTypeMeta","text":"<pre><code>SingletonTypeMeta(name, bases, attrs)\n</code></pre> <p>               Bases: <code>TypeAttributeMeta</code>, <code>SingletonMeta</code></p> <p>Metaclass for singleton type attributes.</p> <p>Singleton type attributes are attributes that have only one instance.</p> <p>Examples: - <code>AnyType</code> - <code>BottomType</code></p> Source code in <code>src/kirin/lattice/abc.py</code> <pre><code>def __init__(cls, name, bases, attrs):\n    super().__init__(name, bases, attrs)\n    cls._instance = None\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.TypeAttribute","title":"TypeAttribute  <code>dataclass</code>","text":"<pre><code>TypeAttribute()\n</code></pre> <p>               Bases: <code>_TypeAttribute</code>, <code>SimpleMeetMixin['TypeAttribute']</code>, <code>IsSubsetEqMixin['TypeAttribute']</code>, <code>BoundedLattice['TypeAttribute']</code></p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.TypeAttribute.join","title":"join","text":"<pre><code>join(other: TypeAttribute) -&gt; TypeAttribute\n</code></pre> <p>Join operation.</p> Source code in <code>src/kirin/ir/attrs/types.py</code> <pre><code>def join(self, other: \"TypeAttribute\") -&gt; \"TypeAttribute\":\n    if self.is_subseteq(other):\n        return other\n    elif other.is_subseteq(self):\n        return self\n    elif isinstance(other, TypeAttribute):\n        return Union(self, other)\n    return AnyType()  # don't know how to join\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.TypeAttributeMeta","title":"TypeAttributeMeta","text":"<p>               Bases: <code>LatticeAttributeMeta</code></p> <p>Metaclass for type attributes.</p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.TypeVar","title":"TypeVar  <code>dataclass</code>","text":"<pre><code>TypeVar(name: str, bound: TypeAttribute | None = None)\n</code></pre> <p>               Bases: <code>TypeAttribute</code></p> Source code in <code>src/kirin/ir/attrs/types.py</code> <pre><code>def __init__(self, name: str, bound: TypeAttribute | None = None):\n    self.varname = name\n    self.bound = bound or AnyType()\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.TypeVar.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'TypeVar'\n</code></pre> <p>Name of the attribute in printing and other text format.</p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.TypeVar.is_equal","title":"is_equal","text":"<pre><code>is_equal(other: TypeAttribute) -&gt; bool\n</code></pre> <p>Check if two lattices are equal.</p> Source code in <code>src/kirin/ir/attrs/types.py</code> <pre><code>def is_equal(self, other: TypeAttribute) -&gt; bool:\n    return (\n        isinstance(other, TypeVar)\n        and self.varname == other.varname\n        and self.bound.is_equal(other.bound)\n    )\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Union","title":"Union  <code>dataclass</code>","text":"<pre><code>Union(\n    typ_or_set: (\n        TypeAttribute | typing.Iterable[TypeAttribute]\n    ),\n    *typs: TypeAttribute\n)\n</code></pre> <p>               Bases: <code>TypeAttribute</code></p> Source code in <code>src/kirin/ir/attrs/types.py</code> <pre><code>def __init__(\n    self,\n    typ_or_set: TypeAttribute | typing.Iterable[TypeAttribute],\n    *typs: TypeAttribute,\n):\n    if isinstance(typ_or_set, TypeAttribute):\n        params: typing.Iterable[TypeAttribute] = (typ_or_set, *typs)\n    else:\n        params = typ_or_set\n        assert not typs, \"Cannot pass multiple arguments when passing a set\"\n\n    types: frozenset[TypeAttribute] = frozenset()\n    for typ in params:\n        if isinstance(typ, Union):\n            types = types.union(typ.types)\n        else:\n            types = types.union({typ})\n    self.types = types\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Union.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'Union'\n</code></pre> <p>Name of the attribute in printing and other text format.</p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Union.is_equal","title":"is_equal","text":"<pre><code>is_equal(other: TypeAttribute) -&gt; bool\n</code></pre> <p>Check if two lattices are equal.</p> Source code in <code>src/kirin/ir/attrs/types.py</code> <pre><code>def is_equal(self, other: TypeAttribute) -&gt; bool:\n    return isinstance(other, Union) and self.types == other.types\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Union.join","title":"join","text":"<pre><code>join(other: TypeAttribute) -&gt; TypeAttribute\n</code></pre> <p>Join operation.</p> Source code in <code>src/kirin/ir/attrs/types.py</code> <pre><code>def join(self, other: TypeAttribute) -&gt; TypeAttribute:\n    if self.is_subseteq(other):\n        return other\n    elif other.is_subseteq(self):\n        return self\n    elif isinstance(other, Union):\n        return Union(self.types | other.types)\n    elif isinstance(other, TypeAttribute):\n        return Union(self.types | {other})\n    return BottomType()\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Union.meet","title":"meet","text":"<pre><code>meet(other: TypeAttribute) -&gt; TypeAttribute\n</code></pre> <p>Meet operation.</p> Source code in <code>src/kirin/ir/attrs/types.py</code> <pre><code>def meet(self, other: TypeAttribute) -&gt; TypeAttribute:\n    if self.is_subseteq(other):\n        return self\n    elif other.is_subseteq(self):\n        return other\n    elif isinstance(other, Union):\n        return Union(self.types &amp; other.types)\n    elif isinstance(other, TypeAttribute):\n        return Union(self.types &amp; {other})\n    return BottomType()\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Vararg","title":"Vararg  <code>dataclass</code>","text":"<pre><code>Vararg(typ: TypeAttribute)\n</code></pre> <p>               Bases: <code>Attribute</code></p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Vararg.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'Vararg'\n</code></pre> <p>Name of the attribute in printing and other text format.</p>"},{"location":"reference/kirin/ir/nodes/","title":"Index","text":"<p>Definition of Kirin's Intermediate Representation (IR) nodes.</p>"},{"location":"reference/kirin/ir/nodes/base/","title":"Base","text":""},{"location":"reference/kirin/ir/nodes/base/#kirin.ir.nodes.base.IRNode","title":"IRNode  <code>dataclass</code>","text":"<pre><code>IRNode()\n</code></pre> <p>               Bases: <code>Generic[ParentType]</code>, <code>ABC</code>, <code>Printable</code></p> <p>Base class for all IR nodes. All IR nodes are hashable and can be compared for equality. The hash of an IR node is the same as the id of the object.</p> <p>Pretty Printing</p> <p>This object is pretty printable via <code>.print()</code> method.</p>"},{"location":"reference/kirin/ir/nodes/base/#kirin.ir.nodes.base.IRNode.parent_node","title":"parent_node  <code>abstractmethod</code> <code>property</code> <code>writable</code>","text":"<pre><code>parent_node: ParentType | None\n</code></pre> <p>Parent node of the current node.</p>"},{"location":"reference/kirin/ir/nodes/base/#kirin.ir.nodes.base.IRNode.attach","title":"attach","text":"<pre><code>attach(parent: ParentType) -&gt; None\n</code></pre> <p>Attach the current node to the parent node.</p> Source code in <code>src/kirin/ir/nodes/base.py</code> <pre><code>def attach(self, parent: ParentType) -&gt; None:\n    \"\"\"Attach the current node to the parent node.\"\"\"\n    assert isinstance(parent, IRNode), f\"Expected IRNode, got {type(parent)}\"\n\n    if self.parent_node:\n        raise ValueError(\"Node already has a parent\")\n    if self.is_ancestor(parent):\n        raise ValueError(\"Node is an ancestor of the parent\")\n    self.parent_node = parent\n</code></pre>"},{"location":"reference/kirin/ir/nodes/base/#kirin.ir.nodes.base.IRNode.delete","title":"delete  <code>abstractmethod</code>","text":"<pre><code>delete(safe: bool = True) -&gt; None\n</code></pre> <p>Delete the current node.</p> <p>Parameters:</p> Name Type Description Default <code>safe</code> <code>bool</code> <p>If True, check if the node has any references before deleting.</p> <code>True</code> Source code in <code>src/kirin/ir/nodes/base.py</code> <pre><code>@abstractmethod\ndef delete(self, safe: bool = True) -&gt; None:\n    \"\"\"Delete the current node.\n\n    Args:\n        safe: If True, check if the node has any references before deleting.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/ir/nodes/base/#kirin.ir.nodes.base.IRNode.detach","title":"detach  <code>abstractmethod</code>","text":"<pre><code>detach() -&gt; None\n</code></pre> <p>Detach the current node from the parent node.</p> Source code in <code>src/kirin/ir/nodes/base.py</code> <pre><code>@abstractmethod\ndef detach(self) -&gt; None:\n    \"\"\"Detach the current node from the parent node.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/ir/nodes/base/#kirin.ir.nodes.base.IRNode.drop_all_references","title":"drop_all_references  <code>abstractmethod</code>","text":"<pre><code>drop_all_references() -&gt; None\n</code></pre> <p>Drop all references to other nodes.</p> Source code in <code>src/kirin/ir/nodes/base.py</code> <pre><code>@abstractmethod\ndef drop_all_references(self) -&gt; None:\n    \"\"\"Drop all references to other nodes.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/ir/nodes/base/#kirin.ir.nodes.base.IRNode.get_root","title":"get_root","text":"<pre><code>get_root() -&gt; IRNode\n</code></pre> <p>Get the root node of the current node.</p> Source code in <code>src/kirin/ir/nodes/base.py</code> <pre><code>def get_root(self) -&gt; IRNode:\n    \"\"\"Get the root node of the current node.\"\"\"\n    if (parent := self.parent_node) is None:\n        return self\n    return parent.get_root()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/base/#kirin.ir.nodes.base.IRNode.is_ancestor","title":"is_ancestor","text":"<pre><code>is_ancestor(op: IRNode) -&gt; bool\n</code></pre> <p>Check if the given node is an ancestor of the current node.</p> Source code in <code>src/kirin/ir/nodes/base.py</code> <pre><code>def is_ancestor(self, op: IRNode) -&gt; bool:\n    \"\"\"Check if the given node is an ancestor of the current node.\"\"\"\n    if op is self:\n        return True\n    if (parent := op.parent_node) is None:\n        return False\n    return self.is_ancestor(parent)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/base/#kirin.ir.nodes.base.IRNode.is_equal","title":"is_equal","text":"<pre><code>is_equal(other: IRNode, context: dict = {}) -&gt; bool\n</code></pre> <p>Check if the current node is equal to the other node.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>IRNode</code> <p>The other node to compare.</p> required <code>context</code> <code>dict</code> <p>The context to store the visited nodes. Defaults to {}.</p> <code>{}</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the nodes are equal, False otherwise.</p> <p>Note</p> <p>This method is not the same as the <code>==</code> operator. It checks for structural equality rather than identity. To change the behavior of structural equality, override the <code>is_structurally_equal</code> method.</p> Source code in <code>src/kirin/ir/nodes/base.py</code> <pre><code>def is_equal(self, other: IRNode, context: dict = {}) -&gt; bool:\n    \"\"\"Check if the current node is equal to the other node.\n\n    Args:\n        other: The other node to compare.\n        context: The context to store the visited nodes. Defaults to {}.\n\n    Returns:\n        True if the nodes are equal, False otherwise.\n\n    !!! note\n        This method is not the same as the `==` operator. It checks for\n        structural equality rather than identity. To change the behavior\n        of structural equality, override the `is_structurally_equal` method.\n    \"\"\"\n    if not isinstance(other, type(self)):\n        return False\n    return self.is_structurally_equal(other, context)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/base/#kirin.ir.nodes.base.IRNode.is_structurally_equal","title":"is_structurally_equal  <code>abstractmethod</code>","text":"<pre><code>is_structurally_equal(\n    other: Self,\n    context: (\n        dict[IRNode | SSAValue, IRNode | SSAValue] | None\n    ) = None,\n) -&gt; bool\n</code></pre> <p>Check if the current node is structurally equal to the other node.</p> <p>Note</p> <p>This method is for tweaking the behavior of structural equality. To check if two nodes are structurally equal, use the <code>is_equal</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>The other node to compare.</p> required <code>context</code> <code>dict[IRNode | SSAValue, IRNode | SSAValue] | None</code> <p>The context to store the visited nodes.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the nodes are structurally equal, False otherwise.</p> Source code in <code>src/kirin/ir/nodes/base.py</code> <pre><code>@abstractmethod\ndef is_structurally_equal(\n    self,\n    other: Self,\n    context: dict[IRNode | SSAValue, IRNode | SSAValue] | None = None,\n) -&gt; bool:\n    \"\"\"Check if the current node is structurally equal to the other node.\n\n    !!! note\n        This method is for tweaking the behavior of structural equality.\n        To check if two nodes are structurally equal, use the `is_equal` method.\n\n    Args:\n        other: The other node to compare.\n        context: The context to store the visited nodes.\n\n    Returns:\n        True if the nodes are structurally equal, False otherwise.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/ir/nodes/base/#kirin.ir.nodes.base.IRNode.verify","title":"verify  <code>abstractmethod</code>","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>run mandatory validation checks. This is not same as verify_type, which may be optional.</p> Source code in <code>src/kirin/ir/nodes/base.py</code> <pre><code>@abstractmethod\ndef verify(self) -&gt; None:\n    \"\"\"run mandatory validation checks. This is not same as verify_type, which may be optional.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/ir/nodes/base/#kirin.ir.nodes.base.IRNode.verify_type","title":"verify_type  <code>abstractmethod</code>","text":"<pre><code>verify_type() -&gt; None\n</code></pre> <p>verify the type of the node.</p> Source code in <code>src/kirin/ir/nodes/base.py</code> <pre><code>@abstractmethod\ndef verify_type(self) -&gt; None:\n    \"\"\"verify the type of the node.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/","title":"Block","text":""},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block","title":"Block  <code>dataclass</code>","text":"<pre><code>Block(\n    stmts: Sequence[Statement] = (),\n    argtypes: Iterable[TypeAttribute] = (),\n    *,\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>IRNode['Region']</code></p> <p>Block consist of a list of Statements and optionally input arguments.</p> <p>Pretty Printing</p> <p>This object is pretty printable via <code>.print()</code> method.</p> <pre><code>argtypes (Iterable[TypeAttribute], optional): The type of the block arguments. Defaults to ().\n</code></pre> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def __init__(\n    self,\n    stmts: Sequence[Statement] = (),\n    argtypes: Iterable[TypeAttribute] = (),\n    *,\n    source: SourceInfo | None = None,\n):\n    \"\"\"\n    Args:\n        stmts (Sequence[Statement], optional): A list of statements. Defaults to ().\n        argtypes (Iterable[TypeAttribute], optional): The type of the block arguments. Defaults to ().\n    \"\"\"\n    super().__init__()\n    self.source = source\n    self._args = tuple(\n        BlockArgument(self, i, argtype) for i, argtype in enumerate(argtypes)\n    )\n\n    self._first_stmt = None\n    self._last_stmt = None\n    self._first_branch = None\n    self._last_branch = None\n    self._stmt_len = 0\n    self.stmts.extend(stmts)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.args","title":"args  <code>property</code>","text":"<pre><code>args: BlockArguments\n</code></pre> <p>Get the  arguments of the Block.</p> <p>Returns:</p> Name Type Description <code>BlockArguments</code> <code>BlockArguments</code> <p>The arguments view of the Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.first_stmt","title":"first_stmt  <code>property</code>","text":"<pre><code>first_stmt: Statement | None\n</code></pre> <p>Get the first Statement of the Block.</p> <p>Returns:</p> Type Description <code>Statement | None</code> <p>Statement | None: The first Statement of the Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.last_stmt","title":"last_stmt  <code>property</code>","text":"<pre><code>last_stmt: Statement | None\n</code></pre> <p>Get the last Statement of the Block.</p> <p>Returns:</p> Type Description <code>Statement | None</code> <p>Statement | None: The last Statement of the Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.parent","title":"parent  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parent: Region | None = field(default=None, repr=False)\n</code></pre> <p>Parent Region of the Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.parent_node","title":"parent_node  <code>property</code> <code>writable</code>","text":"<pre><code>parent_node: Region | None\n</code></pre> <p>Get parent Region of the Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.parent_stmt","title":"parent_stmt  <code>property</code>","text":"<pre><code>parent_stmt: Statement | None\n</code></pre> <p>parent statement of the Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.stmts","title":"stmts  <code>property</code>","text":"<pre><code>stmts: BlockStmts\n</code></pre> <p>Get the list of Statements of the Block.</p> <p>Returns:</p> Name Type Description <code>BlockStmts</code> <code>BlockStmts</code> <p>The Statements of the Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.delete","title":"delete","text":"<pre><code>delete(safe: bool = True) -&gt; None\n</code></pre> <p>Delete the Block completely from the IR.</p> Note <p>This method will detach + remove references of the block.</p> <p>Parameters:</p> Name Type Description Default <code>safe</code> <code>bool</code> <p>If True, raise error if there is anything that still reference components in the block. Defaults to True.</p> <code>True</code> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def delete(self, safe: bool = True) -&gt; None:\n    \"\"\"Delete the Block completely from the IR.\n\n    Note:\n        This method will detach + remove references of the block.\n\n    Args:\n        safe (bool, optional): If True, raise error if there is anything that still reference components in the block. Defaults to True.\n    \"\"\"\n    self.detach()\n    self.drop_all_references()\n    for stmt in self.stmts:\n        stmt.delete(safe=safe)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.detach","title":"detach","text":"<pre><code>detach() -&gt; None\n</code></pre> <p>Detach this Block from the IR.</p> Note <p>Detach only detach the Block from the IR graph. It does not remove uses that reference the Block.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def detach(self) -&gt; None:\n    \"\"\"Detach this Block from the IR.\n\n    Note:\n        Detach only detach the Block from the IR graph. It does not remove uses that reference the Block.\n    \"\"\"\n    if self.parent is None:\n        return\n\n    idx = self.parent[self]\n    del self.parent._blocks[idx]\n    del self.parent._block_idx[self]\n    for block in self.parent._blocks[idx:]:\n        self.parent._block_idx[block] -= 1\n    self.parent = None\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.drop_all_references","title":"drop_all_references","text":"<pre><code>drop_all_references() -&gt; None\n</code></pre> <p>Remove all the dependency that reference/uses this Block.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def drop_all_references(self) -&gt; None:\n    \"\"\"Remove all the dependency that reference/uses this Block.\"\"\"\n    self.parent = None\n    for stmt in self.stmts:\n        stmt.drop_all_references()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.is_structurally_equal","title":"is_structurally_equal","text":"<pre><code>is_structurally_equal(\n    other: Self,\n    context: (\n        dict[IRNode | SSAValue, IRNode | SSAValue] | None\n    ) = None,\n) -&gt; bool\n</code></pre> <p>Check if the Block is structurally equal to another Block.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>The other Block to compare with.</p> required <code>context</code> <code>dict[IRNode | SSAValue, IRNode | SSAValue] | None</code> <p>A map of IRNode/SSAValue to hint that they are equivalent so the check will treat them as equivalent. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the Block is structurally equal to the other Block.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def is_structurally_equal(\n    self,\n    other: Self,\n    context: dict[IRNode | SSAValue, IRNode | SSAValue] | None = None,\n) -&gt; bool:\n    \"\"\"Check if the Block is structurally equal to another Block.\n\n    Args:\n        other (Self): The other Block to compare with.\n        context (dict[IRNode  |  SSAValue, IRNode  |  SSAValue] | None, optional): A map of IRNode/SSAValue to hint that they are equivalent so the check will treat them as equivalent. Defaults to None.\n\n    Returns:\n        bool: True if the Block is structurally equal to the other Block.\n    \"\"\"\n    if context is None:\n        context = {}\n\n    if len(self._args) != len(other._args) or len(self.stmts) != len(other.stmts):\n        return False\n\n    for arg, other_arg in zip(self._args, other._args):\n        if arg.type != other_arg.type:\n            return False\n        context[arg] = other_arg\n\n    context[self] = other\n    if not all(\n        stmt.is_structurally_equal(other_stmt, context)\n        for stmt, other_stmt in zip(self.stmts, other.stmts)\n    ):\n        return False\n\n    return True\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>Verify the correctness of the Block.</p> <p>Raises:</p> Type Description <code>IRValidationError</code> <p>If the Block is not correct.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def verify(self) -&gt; None:\n    \"\"\"Verify the correctness of the Block.\n\n    Raises:\n        IRValidationError: If the Block is not correct.\n    \"\"\"\n    from kirin.ir.nodes.stmt import Region\n\n    if not isinstance(self.parent, Region):\n        raise ValidationError(self, \"Parent is not a region\")\n\n    for stmt in self.stmts:\n        stmt.verify()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.verify_type","title":"verify_type","text":"<pre><code>verify_type() -&gt; None\n</code></pre> <p>Verify the types of the Block.</p> <p>Raises:</p> Type Description <code>IRValidationError</code> <p>If the Block is not correct.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def verify_type(self) -&gt; None:\n    \"\"\"Verify the types of the Block.\n\n    Raises:\n        IRValidationError: If the Block is not correct.\n    \"\"\"\n    for stmt in self.stmts:\n        stmt.verify_type()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.walk","title":"walk","text":"<pre><code>walk(\n    *, reverse: bool = False, region_first: bool = False\n) -&gt; Iterator[Statement]\n</code></pre> <p>Traversal the Statements in a Block.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>If walk in the reversed manner. Defaults to False.</p> <code>False</code> <code>region_first</code> <code>bool</code> <p>If the walk should go through the Statement first or the Region of a Statement first. Defaults to False.</p> <code>False</code> <p>Yields:</p> Type Description <code>Statement</code> <p>Iterator[Statement]: An iterator that yield Statements in the Block in the specified order.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def walk(\n    self, *, reverse: bool = False, region_first: bool = False\n) -&gt; Iterator[Statement]:\n    \"\"\"Traversal the Statements in a Block.\n\n    Args:\n        reverse (bool, optional): If walk in the reversed manner. Defaults to False.\n        region_first (bool, optional): If the walk should go through the Statement first or the Region of a Statement first. Defaults to False.\n\n    Yields:\n        Iterator[Statement]: An iterator that yield Statements in the Block in the specified order.\n    \"\"\"\n    for stmt in reversed(self.stmts) if reverse else self.stmts:\n        yield from stmt.walk(reverse=reverse, region_first=region_first)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockArguments","title":"BlockArguments  <code>dataclass</code>","text":"<pre><code>BlockArguments(node: NodeType, field: FieldType)\n</code></pre> <p>               Bases: <code>MutableSequenceView[tuple, 'Block', BlockArgument]</code></p> <p>A View object that contains a list of BlockArgument.</p> Description <p>This is a proxy object that provide safe API to manipulate the arguments of a Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockArguments.append_from","title":"append_from","text":"<pre><code>append_from(\n    typ: TypeAttribute, name: str | None = None\n) -&gt; BlockArgument\n</code></pre> <p>Append a new argument to the Block that this View reference to.</p> Description <p>This method will create a new <code>BlockArgument</code> and append it to the argument list of the reference <code>Block</code>.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>TypeAttribute</code> <p>The type of the argument.</p> required <code>name</code> <code>str | None</code> <p>name of the argument. Defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>BlockArgument</code> <code>BlockArgument</code> <p>The newly created <code>BlockArgument</code>.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def append_from(self, typ: TypeAttribute, name: str | None = None) -&gt; BlockArgument:\n    \"\"\"Append a new argument to the Block that this View reference to.\n\n    Description:\n        This method will create a new [`BlockArgument`][kirin.ir.BlockArgument] and append it to the argument list\n        of the reference `Block`.\n\n    Args:\n        typ (TypeAttribute): The type of the argument.\n        name (str | None, optional): name of the argument. Defaults to `None`.\n\n    Returns:\n        BlockArgument: The newly created [`BlockArgument`][kirin.ir.BlockArgument].\n\n    \"\"\"\n    new_arg = BlockArgument(self.node, len(self.node._args), typ)\n    if name:\n        new_arg.name = name\n\n    self.node._args += (new_arg,)\n    return new_arg\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockArguments.delete","title":"delete","text":"<pre><code>delete(arg: BlockArgument, safe: bool = True) -&gt; None\n</code></pre> <p>Delete a BlockArgument from the Block that this View reference to.</p> <p>Parameters:</p> Name Type Description Default <code>arg</code> <code>BlockArgument</code> <p>description</p> required <code>safe</code> <code>bool</code> <p>If True, error will be raised if the BlockArgument has any Use by others.  Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the argument does not belong to the reference block.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def delete(self, arg: BlockArgument, safe: bool = True) -&gt; None:\n    \"\"\"Delete a BlockArgument from the Block that this View reference to.\n\n\n    Args:\n        arg (BlockArgument): _description_\n        safe (bool, optional): If True, error will be raised if the BlockArgument has any Use by others.  Defaults to True.\n\n    Raises:\n        ValueError: If the argument does not belong to the reference block.\n    \"\"\"\n    if safe and len(arg.uses) &gt; 0:\n        raise ValueError(\"Cannot delete SSA value with uses\")\n\n    if arg.block is not self.node:\n        raise ValueError(\"Attempt to delete an argument that is not in the block\")\n\n    for block_arg in self.field[arg.index + 1 :]:\n        block_arg.index -= 1\n    self.node._args = (*self.field[: arg.index], *self.field[arg.index + 1 :])\n    arg.replace_by(DeletedSSAValue(arg))\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockArguments.insert_from","title":"insert_from","text":"<pre><code>insert_from(\n    idx: int, typ: TypeAttribute, name: str | None = None\n) -&gt; BlockArgument\n</code></pre> <p>Insert a new argument to the Block that this View reference to.</p> Description <p>This method will create a new <code>BlockArgument</code> and insert it to the argument list of the reference Block at the specified index</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>Insert location index.</p> required <code>typ</code> <code>TypeAttribute</code> <p>The type of the argument.</p> required <code>name</code> <code>str | None</code> <p>Name of the argument. Defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>BlockArgument</code> <code>BlockArgument</code> <p>The newly created BlockArgument.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def insert_from(\n    self, idx: int, typ: TypeAttribute, name: str | None = None\n) -&gt; BlockArgument:\n    \"\"\"Insert a new argument to the Block that this View reference to.\n\n    Description:\n        This method will create a new `BlockArgument` and insert it to the argument list\n        of the reference Block at the specified index\n\n    Args:\n        idx (int): Insert location index.\n        typ (TypeAttribute): The type of the argument.\n        name (str | None, optional): Name of the argument. Defaults to `None`.\n\n    Returns:\n        BlockArgument: The newly created BlockArgument.\n    \"\"\"\n    if idx &lt; 0 or idx &gt; len(self.node._args):\n        raise ValueError(\"Invalid index\")\n\n    new_arg = BlockArgument(self.node, idx, typ)\n    if name:\n        new_arg.name = name\n\n    for arg in self.node._args[idx:]:\n        arg.index += 1\n    self.node._args = self.node._args[:idx] + (new_arg,) + self.node._args[idx:]\n    return new_arg\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockStmtIterator","title":"BlockStmtIterator  <code>dataclass</code>","text":"<pre><code>BlockStmtIterator(next_stmt: Statement | None)\n</code></pre> <p>Proxy object to iterate over the Statements in a Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockStmts","title":"BlockStmts  <code>dataclass</code>","text":"<pre><code>BlockStmts(node: NodeType)\n</code></pre> <p>               Bases: <code>View['Block', 'Statement']</code></p> <p>A View object that contains a list of Statements.</p> Description <p>This is a proxy object that provide safe API to manipulate the statements of a Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockStmts.append","title":"append","text":"<pre><code>append(value: Statement) -&gt; None\n</code></pre> <p>Append a Statement to the reference Block.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Statement</code> <p>A Statement to be appended.</p> required Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def append(self, value: Statement) -&gt; None:\n    \"\"\"Append a Statement to the reference Block.\n\n    Args:\n        value (Statement): A Statement to be appended.\n    \"\"\"\n    from kirin.ir.nodes.stmt import Statement\n\n    if not isinstance(value, Statement):\n        raise ValueError(f\"Expected Statement, got {type(value).__name__}\")\n\n    if self.node._stmt_len == 0:  # empty block\n        value.attach(self.node)\n        self.node._first_stmt = value\n        self.node._last_stmt = value\n        self.node._stmt_len += 1\n    elif self.node._last_stmt:\n        value.insert_after(self.node._last_stmt)\n    else:\n        raise ValueError(\"Invalid block, last_stmt is None\")\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockStmts.at","title":"at","text":"<pre><code>at(index: int) -&gt; Statement\n</code></pre> <p>This is similar to getitem but due to the nature of the linked list, it is less efficient than getitem.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the Statement.</p> required <p>Returns:</p> Name Type Description <code>Statement</code> <code>Statement</code> <p>The Statement at the specified index.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def at(self, index: int) -&gt; Statement:\n    \"\"\"This is similar to __getitem__ but due to the nature of the linked list,\n    it is less efficient than __getitem__.\n\n    Args:\n        index (int): Index of the Statement.\n\n    Returns:\n        Statement: The Statement at the specified index.\n    \"\"\"\n    if index &gt;= len(self):\n        raise IndexError(\"Index out of range\")\n\n    if index &lt; 0:\n        return self._at_reverse(-index - 1)\n\n    return self._at_forward(index)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockStmtsReverseIterator","title":"BlockStmtsReverseIterator  <code>dataclass</code>","text":"<pre><code>BlockStmtsReverseIterator(next_stmt: Statement | None)\n</code></pre> <p>Proxy object to iterate over the Statements in a Block in reverse order.</p>"},{"location":"reference/kirin/ir/nodes/region/","title":"Region","text":""},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region","title":"Region  <code>dataclass</code>","text":"<pre><code>Region(\n    blocks: Block | Iterable[Block] = (),\n    parent: Statement | None = None,\n    *,\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>IRNode['Statement']</code></p> <p>Region consist of a list of Blocks</p> <p>Pretty Printing</p> <p>This object is pretty printable via <code>.print()</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>blocks</code> <code>Block | Iterable[Block]</code> <p>A single <code>Block</code> object or an iterable of Block objects. Defaults to ().</p> <code>()</code> <code>parent</code> <code>Statement | None</code> <p>The parent <code>Statement</code> object. Defaults to None.</p> <code>None</code> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def __init__(\n    self,\n    blocks: Block | Iterable[Block] = (),\n    parent: Statement | None = None,\n    *,\n    source: SourceInfo | None = None,\n):\n    \"\"\"Initialize a Region object.\n\n    Args:\n        blocks (Block | Iterable[Block], optional): A single [`Block`][kirin.ir.Block] object or an iterable of Block objects. Defaults to ().\n        parent (Statement | None, optional): The parent [`Statement`][kirin.ir.Statement] object. Defaults to None.\n    \"\"\"\n    super().__init__()\n    self.source = source\n    self._blocks = []\n    self._block_idx = {}\n    self.parent_node = parent\n    if isinstance(blocks, Block):\n        blocks = (blocks,)\n    for block in blocks:\n        self.blocks.append(block)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.blocks","title":"blocks  <code>property</code>","text":"<pre><code>blocks: RegionBlocks\n</code></pre> <p>Get the Blocks in the region.</p> <p>Returns:</p> Name Type Description <code>RegionBlocks</code> <code>RegionBlocks</code> <p>The blocks View object of the region.</p>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.parent_node","title":"parent_node  <code>property</code> <code>writable</code>","text":"<pre><code>parent_node: Statement | None\n</code></pre> <p>Get the parent statement of the region.</p>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.region_index","title":"region_index  <code>property</code>","text":"<pre><code>region_index: int\n</code></pre> <p>Get the index of the region within the parent scope.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The index of the region within the parent scope.</p>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(block: Block) -&gt; int\n</code></pre> <p>Get the index of a block within the region.</p> <p>Parameters:</p> Name Type Description Default <code>block</code> <code>Block</code> <p>The block to get the index of.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the block does not belong to the region.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The index of the block within the region.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def __getitem__(self, block: Block) -&gt; int:\n    \"\"\"Get the index of a block within the region.\n\n    Args:\n        block (Block): The block to get the index of.\n\n    Raises:\n        ValueError: If the block does not belong to the region.\n\n    Returns:\n        int: The index of the block within the region.\n    \"\"\"\n    if block.parent is not self:\n        raise ValueError(\"Block does not belong to the region\")\n    return self._block_idx[block]\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.clone","title":"clone","text":"<pre><code>clone(\n    ssamap: dict[SSAValue, SSAValue] | None = None\n) -&gt; Region\n</code></pre> <p>Clone a region. This will clone all blocks and statements in the region. <code>SSAValue</code> defined outside the region will not be cloned unless provided in <code>ssamap</code>.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def clone(self, ssamap: dict[SSAValue, SSAValue] | None = None) -&gt; Region:\n    \"\"\"Clone a region. This will clone all blocks and statements in the region.\n    `SSAValue` defined outside the region will not be cloned unless provided in `ssamap`.\n    \"\"\"\n    ret = Region()\n    successor_map: dict[Block, Block] = {}\n    _ssamap = ssamap or {}\n    for block in self.blocks:\n        new_block = Block()\n        ret.blocks.append(new_block)\n        successor_map[block] = new_block\n        for arg in block.args:\n            new_arg = new_block.args.append_from(arg.type, arg.name)\n            _ssamap[arg] = new_arg\n\n    # update statements\n    for block in self.blocks:\n        for stmt in block.stmts:\n            new_stmt = stmt.from_stmt(\n                stmt,\n                args=[_ssamap.get(arg, arg) for arg in stmt.args],\n                regions=[region.clone(_ssamap) for region in stmt.regions],\n                successors=[\n                    successor_map[successor] for successor in stmt.successors\n                ],\n            )\n            successor_map[block].stmts.append(new_stmt)\n            for result, new_result in zip(stmt.results, new_stmt.results):\n                _ssamap[result] = new_result\n                new_result.name = result.name\n\n    return ret\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.delete","title":"delete","text":"<pre><code>delete(safe: bool = True) -&gt; None\n</code></pre> <p>Delete the Region completely from the IR graph.</p> Note <p>This method will detach + remove references of the Region.</p> <p>Parameters:</p> Name Type Description Default <code>safe</code> <code>bool</code> <p>If True, raise error if there is anything that still reference components in the Region. Defaults to True.</p> <code>True</code> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def delete(self, safe: bool = True) -&gt; None:\n    \"\"\"Delete the Region completely from the IR graph.\n\n    Note:\n        This method will detach + remove references of the Region.\n\n    Args:\n        safe (bool, optional): If True, raise error if there is anything that still reference components in the Region. Defaults to True.\n    \"\"\"\n    self.detach()\n    self.drop_all_references()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.detach","title":"detach","text":"<pre><code>detach(index: int | None = None) -&gt; None\n</code></pre> <p>Detach this Region from the IR tree graph.</p> Note <p>Detach only detach the Region from the IR graph. It does not remove uses that reference the Region.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def detach(self, index: int | None = None) -&gt; None:\n    \"\"\"Detach this Region from the IR tree graph.\n\n    Note:\n        Detach only detach the Region from the IR graph. It does not remove uses that reference the Region.\n    \"\"\"\n    # already detached\n    if self.parent_node is None:\n        return\n\n    if index is not None:\n        region_idx = index\n    else:\n        region_idx = self.region_index\n\n    del self.parent_node._regions[region_idx]\n    self.parent_node = None\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.drop_all_references","title":"drop_all_references","text":"<pre><code>drop_all_references() -&gt; None\n</code></pre> <p>Remove all the dependency that reference/uses this Region.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def drop_all_references(self) -&gt; None:\n    \"\"\"Remove all the dependency that reference/uses this Region.\"\"\"\n    self.parent_node = None\n    for block in self._blocks:\n        block.drop_all_references()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.is_structurally_equal","title":"is_structurally_equal","text":"<pre><code>is_structurally_equal(\n    other: Self,\n    context: (\n        dict[IRNode | SSAValue, IRNode | SSAValue] | None\n    ) = None,\n) -&gt; bool\n</code></pre> <p>Check if the Region is structurally equal to another Region.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>The other Region to compare with.</p> required <code>context</code> <code>dict[IRNode | SSAValue, IRNode | SSAValue] | None</code> <p>A map of IRNode/SSAValue to hint that they are equivalent so the check will treat them as equivalent. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the Region is structurally equal to the other Region.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def is_structurally_equal(\n    self,\n    other: Self,\n    context: dict[IRNode | SSAValue, IRNode | SSAValue] | None = None,\n) -&gt; bool:\n    \"\"\"Check if the Region is structurally equal to another Region.\n\n    Args:\n        other (Self): The other Region to compare with.\n        context (dict[IRNode  |  SSAValue, IRNode  |  SSAValue] | None, optional): A map of IRNode/SSAValue to hint that they are equivalent so the check will treat them as equivalent. Defaults to None.\n\n    Returns:\n        bool: True if the Region is structurally equal to the other Region.\n    \"\"\"\n    if context is None:\n        context = {}\n\n    if len(self.blocks) != len(other.blocks):\n        return False\n\n    for block, other_block in zip(self.blocks, other.blocks):\n        context[block] = other_block\n\n    if not all(\n        block.is_structurally_equal(other_block, context)\n        for block, other_block in zip(self.blocks, other.blocks)\n    ):\n        return False\n\n    return True\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.stmts","title":"stmts","text":"<pre><code>stmts() -&gt; Iterator[Statement]\n</code></pre> <p>Iterate over all the Statements in the Region. This does not walk into nested Regions.</p> <p>Yields:</p> Type Description <code>Statement</code> <p>Iterator[Statement]: An iterator that yield Statements of Blocks in the Region.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def stmts(self) -&gt; Iterator[Statement]:\n    \"\"\"Iterate over all the Statements in the Region. This does not walk into nested Regions.\n\n    Yields:\n        Iterator[Statement]: An iterator that yield Statements of Blocks in the Region.\n    \"\"\"\n    for block in self.blocks:\n        yield from block.stmts\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>Verify the correctness of the Region.</p> <p>Raises:</p> Type Description <code>IRValidationError</code> <p>If the Region is not correct.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def verify(self) -&gt; None:\n    \"\"\"Verify the correctness of the Region.\n\n    Raises:\n        IRValidationError: If the Region is not correct.\n    \"\"\"\n    from kirin.ir.nodes.stmt import Statement\n\n    if not isinstance(self.parent_node, Statement):\n        raise ValidationError(\n            self, \"expect Region to have a parent of type Statement\"\n        )\n\n    for block in self.blocks:\n        block.verify()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.verify_type","title":"verify_type","text":"<pre><code>verify_type() -&gt; None\n</code></pre> <p>verify the type of the node.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def verify_type(self) -&gt; None:\n    for block in self.blocks:\n        block.verify_type()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.walk","title":"walk","text":"<pre><code>walk(\n    *, reverse: bool = False, region_first: bool = False\n) -&gt; Iterator[Statement]\n</code></pre> <p>Traversal the Statements of Blocks in the Region.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>If walk in the reversed manner. Defaults to False.</p> <code>False</code> <code>region_first</code> <code>bool</code> <p>If the walk should go through the Statement first or the Region of a Statement first. Defaults to False.</p> <code>False</code> <p>Yields:</p> Type Description <code>Statement</code> <p>Iterator[Statement]: An iterator that yield Statements of Blocks in the Region, in the specified order.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def walk(\n    self, *, reverse: bool = False, region_first: bool = False\n) -&gt; Iterator[Statement]:\n    \"\"\"Traversal the Statements of Blocks in the Region.\n\n    Args:\n        reverse (bool, optional): If walk in the reversed manner. Defaults to False.\n        region_first (bool, optional): If the walk should go through the Statement first or the Region of a Statement first. Defaults to False.\n\n    Yields:\n        Iterator[Statement]: An iterator that yield Statements of Blocks in the Region, in the specified order.\n    \"\"\"\n    for block in reversed(self.blocks) if reverse else self.blocks:\n        yield from block.walk(reverse=reverse, region_first=region_first)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.RegionBlocks","title":"RegionBlocks  <code>dataclass</code>","text":"<pre><code>RegionBlocks(node: NodeType, field: FieldType)\n</code></pre> <p>               Bases: <code>MutableSequenceView[list[Block], 'Region', Block]</code></p> <p>A View object that contains a list of Blocks of a Region.</p> Description <p>This is a proxy object that provide safe API to manipulate the Blocks of a Region.</p>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.RegionBlocks.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(\n    idx: int | slice,\n    block_or_blocks: Block | Iterable[Block],\n) -&gt; None\n</code></pre> <p>Replace/Set the Blocks of the Region.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int | slice</code> <p>The index or slice to replace the <code>Blocks</code>.</p> required <code>block_or_blocks</code> <code>Block | Iterable[Block]</code> <p>The Block or Blocks to replace the Blocks.</p> required Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def __setitem__(\n    self, idx: int | slice, block_or_blocks: Block | Iterable[Block]\n) -&gt; None:\n    \"\"\"Replace/Set the Blocks of the Region.\n\n    Args:\n        idx (int | slice): The index or slice to replace the [`Blocks`][kirin.ir.Block].\n        block_or_blocks (Block | Iterable[Block]): The Block or Blocks to replace the Blocks.\n\n    \"\"\"\n    if isinstance(idx, int) and isinstance(block_or_blocks, Block):\n        self.field[idx].detach()\n        block_or_blocks.attach(self.node)\n        self.field[idx] = block_or_blocks\n        self.node._block_idx[block_or_blocks] = idx\n    elif isinstance(idx, slice) and isinstance(block_or_blocks, Iterable):\n        for block in block_or_blocks:\n            block.attach(self.node)\n        self.field[idx] = block_or_blocks\n        self.node._block_idx = {\n            block: i for i, block in enumerate(self.field)\n        }  # reindex\n    else:\n        raise ValueError(\"Invalid assignment\")\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.RegionBlocks.append","title":"append","text":"<pre><code>append(value: Block) -&gt; None\n</code></pre> <p>Append a Block to the Region.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Block</code> <p>The block to be appended.</p> required Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def append(self, value: Block) -&gt; None:\n    \"\"\"Append a Block to the Region.\n\n    Args:\n        value (Block): The block to be appended.\n    \"\"\"\n    value.attach(self.node)\n    self.node._block_idx[value] = len(self.field)\n    self.field.append(value)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.RegionBlocks.insert","title":"insert","text":"<pre><code>insert(idx: int, value: Block) -&gt; None\n</code></pre> <p>Inserts a Block at the specified index.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>The index at which to insert the block.</p> required <code>value</code> <code>Block</code> <p>The block to be inserted.</p> required Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def insert(self, idx: int, value: Block) -&gt; None:\n    \"\"\"Inserts a Block at the specified index.\n\n    Args:\n        idx (int): The index at which to insert the block.\n        value (Block): The block to be inserted.\n    \"\"\"\n    value.attach(self.node)\n    self.field.insert(idx, value)\n    for i, value in enumerate(self.field[idx:], idx):\n        self.node._block_idx[value] = i\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/","title":"Stmt","text":""},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.ArgumentList","title":"ArgumentList  <code>dataclass</code>","text":"<pre><code>ArgumentList(node: NodeType, field: FieldType)\n</code></pre> <p>               Bases: <code>MutableSequenceView[tuple[SSAValue, ...], 'Statement', SSAValue]</code>, <code>Printable</code></p> <p>A View object that contains a list of Arguemnts of a Statement.</p> Description <p>This is a proxy object that provide safe API to manipulate the arguemnts of a statement.</p> <p>Pretty Printing</p> <p>This object is pretty printable via <code>.print()</code> method.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.ArgumentList.get_slice","title":"get_slice","text":"<pre><code>get_slice(name: str) -&gt; slice\n</code></pre> <p>Get the slice of the arguments.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the slice.</p> required <p>Returns:</p> Name Type Description <code>slice</code> <code>slice</code> <p>The slice of the arguments.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def get_slice(self, name: str) -&gt; slice:\n    \"\"\"Get the slice of the arguments.\n\n    Args:\n        name (str): The name of the slice.\n\n    Returns:\n        slice: The slice of the arguments.\n    \"\"\"\n    index = self.node._name_args_slice[name]\n    if isinstance(index, int):\n        return slice(index, index + 1)\n    return index\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.ArgumentList.insert","title":"insert","text":"<pre><code>insert(idx: int, value: SSAValue) -&gt; None\n</code></pre> <p>Insert the argument SSAValue at the specified index.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>The index to insert the value.</p> required <code>value</code> <code>SSAValue</code> <p>The value to insert.</p> required Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def insert(self, idx: int, value: SSAValue) -&gt; None:\n    \"\"\"Insert the argument SSAValue at the specified index.\n\n    Args:\n        idx (int): The index to insert the value.\n        value (SSAValue): The value to insert.\n    \"\"\"\n    args = self.field\n    value.add_use(Use(self.node, idx))\n    new_args = (*args[:idx], value, *args[idx:])\n    self.node._args = new_args\n    self.field = new_args\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.ArgumentList.set_item","title":"set_item","text":"<pre><code>set_item(idx: int, value: SSAValue) -&gt; None\n</code></pre> <p>Set the argument SSAVAlue at the specified index.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>The index of the item to set.</p> required <code>value</code> <code>SSAValue</code> <p>The value to set.</p> required Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def set_item(self, idx: int, value: SSAValue) -&gt; None:\n    \"\"\"Set the argument SSAVAlue at the specified index.\n\n    Args:\n        idx (int): The index of the item to set.\n        value (SSAValue): The value to set.\n    \"\"\"\n    args = self.field\n    args[idx].remove_use(Use(self.node, idx))\n    value.add_use(Use(self.node, idx))\n    new_args = (*args[:idx], value, *args[idx + 1 :])\n    self.node._args = new_args\n    self.field = new_args\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.ResultList","title":"ResultList  <code>dataclass</code>","text":"<pre><code>ResultList(node: NodeType, field: FieldType)\n</code></pre> <p>               Bases: <code>MutableSequenceView[list[ResultValue], 'Statement', ResultValue]</code></p> <p>A View object that contains a list of ResultValue of a Statement.</p> Description <p>This is a proxy object that provide safe API to manipulate the result values of a statement</p> <p>Pretty Printing</p> <p>This object is pretty printable via <code>.print()</code> method.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.ResultList.types","title":"types  <code>property</code>","text":"<pre><code>types: Sequence[TypeAttribute]\n</code></pre> <p>Get the result types of the Statement.</p> <p>Returns:</p> Type Description <code>Sequence[TypeAttribute]</code> <p>Sequence[TypeAttribute]: type of each result value.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement","title":"Statement  <code>dataclass</code>","text":"<pre><code>Statement(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>IRNode['Block']</code></p> <p>The Statment is an instruction in the IR</p> <p>Pretty Printing</p> <p>This object is pretty printable via <code>.print()</code> method.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.args","title":"args  <code>instance-attribute</code> <code>property</code> <code>writable</code>","text":"<pre><code>args: ArgumentList = args\n</code></pre> <p>Get the arguments of the Statement.</p> <p>Returns:</p> Name Type Description <code>ArgumentList</code> <code>ArgumentList</code> <p>The arguments View of the Statement.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.next_stmt","title":"next_stmt  <code>property</code> <code>writable</code>","text":"<pre><code>next_stmt: Statement | None\n</code></pre> <p>Get the next statement.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.parent_block","title":"parent_block  <code>property</code>","text":"<pre><code>parent_block: Block | None\n</code></pre> <p>Get the parent Block.</p> <p>Returns:</p> Type Description <code>Block | None</code> <p>Block | None: The parent Block.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.parent_node","title":"parent_node  <code>property</code> <code>writable</code>","text":"<pre><code>parent_node: Block | None\n</code></pre> <p>Get the parent node.</p> <p>Returns:</p> Type Description <code>Block | None</code> <p>Block | None: The parent node.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.parent_region","title":"parent_region  <code>property</code>","text":"<pre><code>parent_region: Region | None\n</code></pre> <p>Get the parent Region. Returns:     Region | None: The parent Region.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.parent_stmt","title":"parent_stmt  <code>property</code>","text":"<pre><code>parent_stmt: Statement | None\n</code></pre> <p>Get the parent statement.</p> <p>Returns:</p> Type Description <code>Statement | None</code> <p>Statement | None: The parent statement.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.prev_stmt","title":"prev_stmt  <code>property</code> <code>writable</code>","text":"<pre><code>prev_stmt: Statement | None\n</code></pre> <p>Get the previous statement.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.regions","title":"regions  <code>instance-attribute</code> <code>property</code> <code>writable</code>","text":"<pre><code>regions: list[Region] = list(regions)\n</code></pre> <p>Get a list of regions of the Statement.</p> <p>Returns:</p> Type Description <code>list[Region]</code> <p>list[Region]: The list of regions of the Statement.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.results","title":"results  <code>property</code>","text":"<pre><code>results: ResultList\n</code></pre> <p>Get the result values of the Statement.</p> <p>Returns:</p> Name Type Description <code>ResultList</code> <code>ResultList</code> <p>The result values View of the Statement.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.source","title":"source  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>source: SourceInfo | None = source\n</code></pre> <p>The source information of the Statement for debugging/stacktracing.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.check","title":"check","text":"<pre><code>check() -&gt; None\n</code></pre> <p>Check the statement. Raises <code>Exception</code> if the statement is not correct. This method is called by the <code>verify</code> method, which will detect the source of the error in the IR. One should always call the <code>verify</code> method to verify the IR.</p> <p>The difference between <code>check</code> and <code>check_type</code> is that <code>check</code> is called at any time to check the structure of the IR by <code>verify</code>, while <code>check_type</code> is called after the type inference to check the types of the IR.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def check(self) -&gt; None:\n    \"\"\"Check the statement. Raises `Exception` if the statement is not correct.\n    This method is called by the `verify` method, which will detect the source\n    of the error in the IR. One should always call the `verify` method to verify\n    the IR.\n\n    The difference between `check` and `check_type` is that `check` is called\n    at any time to check the structure of the IR by `verify`, while `check_type`\n    is called after the type inference to check the types of the IR.\n    \"\"\"\n    return\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.check_type","title":"check_type","text":"<pre><code>check_type() -&gt; None\n</code></pre> <p>Check the types of the Block. Raises <code>Exception</code> if the types are not correct. This method is called by the <code>verify_type</code> method, which will detect the source of the error in the IR. One should always call the <code>verify_type</code> method to verify the types of the IR.</p> Note <p>This method is generated by the <code>@statement</code> decorator. But can be overridden if needed.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def check_type(self) -&gt; None:\n    \"\"\"Check the types of the Block. Raises `Exception` if the types are not correct.\n    This method is called by the `verify_type` method, which will detect the source\n    of the error in the IR. One should always call the `verify_type` method to verify\n    the types of the IR.\n\n    Note:\n        This method is generated by the `@statement` decorator. But can be overridden\n        if needed.\n    \"\"\"\n    raise NotImplementedError(\n        \"check_type should be implemented in the \"\n        \"statement or generated by the @statement decorator\"\n    )\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.delete","title":"delete","text":"<pre><code>delete(safe: bool = True) -&gt; None\n</code></pre> <p>Delete the Statement completely from the IR graph.</p> Note <p>This method will detach + remove references of the Statement.</p> <p>Parameters:</p> Name Type Description Default <code>safe</code> <code>bool</code> <p>If True, raise error if there is anything that still reference components in the Statement. Defaults to True.</p> <code>True</code> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def delete(self, safe: bool = True) -&gt; None:\n    \"\"\"Delete the Statement completely from the IR graph.\n\n    Note:\n        This method will detach + remove references of the Statement.\n\n    Args:\n        safe (bool, optional): If True, raise error if there is anything that still reference components in the Statement. Defaults to True.\n    \"\"\"\n    self.detach()\n    self.drop_all_references()\n    for result in self._results:\n        result.delete(safe=safe)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.detach","title":"detach","text":"<pre><code>detach() -&gt; None\n</code></pre> <p>detach the statement from its parent block.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def detach(self) -&gt; None:\n    \"\"\"detach the statement from its parent block.\"\"\"\n    if self.parent is None:\n        return\n\n    parent: Block = self.parent\n    prev_stmt = self.prev_stmt\n    next_stmt = self.next_stmt\n\n    if prev_stmt is not None:\n        prev_stmt._next_stmt = next_stmt\n        self._prev_stmt = None\n    else:\n        assert (\n            parent._first_stmt is self\n        ), \"Invalid statement, has no prev_stmt but not first_stmt\"\n        parent._first_stmt = next_stmt\n\n    if next_stmt is not None:\n        next_stmt._prev_stmt = prev_stmt\n        self._next_stmt = None\n    else:\n        assert (\n            parent._last_stmt is self\n        ), \"Invalid statement, has no next_stmt but not last_stmt\"\n        parent._last_stmt = prev_stmt\n\n    self.parent = None\n    parent._stmt_len -= 1\n    return\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.drop_all_references","title":"drop_all_references","text":"<pre><code>drop_all_references() -&gt; None\n</code></pre> <p>Remove all the dependency that reference/uses this Statement.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def drop_all_references(self) -&gt; None:\n    \"\"\"Remove all the dependency that reference/uses this Statement.\"\"\"\n    self.parent = None\n    for idx, arg in enumerate(self._args):\n        arg.remove_use(Use(self, idx))\n    for region in self._regions:\n        region.drop_all_references()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.expect_one_result","title":"expect_one_result","text":"<pre><code>expect_one_result() -&gt; ResultValue\n</code></pre> <p>Check if the statement contain only one result, and return it</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def expect_one_result(self) -&gt; ResultValue:\n    \"\"\"Check if the statement contain only one result, and return it\"\"\"\n    if len(self._results) != 1:\n        raise ValueError(f\"expected one result, got {len(self._results)}\")\n    return self._results[0]\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.from_stmt","title":"from_stmt  <code>classmethod</code>","text":"<pre><code>from_stmt(\n    other: Statement,\n    args: Sequence[SSAValue] | None = None,\n    regions: list[Region] | None = None,\n    successors: list[Block] | None = None,\n    attributes: dict[str, Attribute] | None = None,\n) -&gt; Self\n</code></pre> <p>Create a similar Statement with new <code>ResultValue</code> and without attaching to any parent block. This still references to the old successor and regions.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>@classmethod\ndef from_stmt(\n    cls,\n    other: Statement,\n    args: Sequence[SSAValue] | None = None,\n    regions: list[Region] | None = None,\n    successors: list[Block] | None = None,\n    attributes: dict[str, Attribute] | None = None,\n) -&gt; Self:\n    \"\"\"Create a similar Statement with new `ResultValue` and without\n    attaching to any parent block. This still references to the old successor\n    and regions.\n    \"\"\"\n    obj = cls.__new__(cls)\n    Statement.__init__(\n        obj,\n        args=args or other._args,\n        regions=regions or other._regions,\n        successors=successors or other.successors,\n        attributes=attributes or other.attributes,\n        result_types=[result.type for result in other._results],\n        args_slice=other._name_args_slice,\n    )\n    # inherit the hint:\n    for result, other_result in zip(obj._results, other._results):\n        result.hints = dict(other_result.hints)\n\n    return obj\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.get_attr_or_prop","title":"get_attr_or_prop","text":"<pre><code>get_attr_or_prop(key: str) -&gt; Attribute | None\n</code></pre> <p>Get the attribute or property of the Statement.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the attribute or property.</p> required <p>Returns:</p> Type Description <code>Attribute | None</code> <p>Attribute | None: The attribute or property of the Statement.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def get_attr_or_prop(self, key: str) -&gt; Attribute | None:\n    \"\"\"Get the attribute or property of the Statement.\n\n    Args:\n        key (str): The key of the attribute or property.\n\n    Returns:\n        Attribute | None: The attribute or property of the Statement.\n    \"\"\"\n    return self.attributes.get(key)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.get_present_trait","title":"get_present_trait  <code>classmethod</code>","text":"<pre><code>get_present_trait(trait: type[TraitType]) -&gt; TraitType\n</code></pre> <p>Just like get_trait, but expects the trait to be there. Useful for linter checks, when you know the trait is present.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>@classmethod\ndef get_present_trait(cls, trait: type[TraitType]) -&gt; TraitType:\n    \"\"\"Just like get_trait, but expects the trait to be there.\n    Useful for linter checks, when you know the trait is present.\"\"\"\n    for t in cls.traits:\n        if isinstance(t, trait):\n            return t\n    raise ValueError(f\"Trait {trait} not present in statement {cls}\")\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.get_trait","title":"get_trait  <code>classmethod</code>","text":"<pre><code>get_trait(trait: type[TraitType]) -&gt; TraitType | None\n</code></pre> <p>Get the trait of the Statement.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>@classmethod\ndef get_trait(cls, trait: type[TraitType]) -&gt; TraitType | None:\n    \"\"\"Get the trait of the Statement.\"\"\"\n    for t in cls.traits:\n        if isinstance(t, trait):\n            return t\n    return None\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.has_trait","title":"has_trait  <code>classmethod</code>","text":"<pre><code>has_trait(trait_type: type[Trait['Statement']]) -&gt; bool\n</code></pre> <p>Check if the Statement has a specific trait.</p> <p>Parameters:</p> Name Type Description Default <code>trait_type</code> <code>type[StmtTrait]</code> <p>The type of trait to check for.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the class has the specified trait, False otherwise.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>@classmethod\ndef has_trait(cls, trait_type: type[Trait[\"Statement\"]]) -&gt; bool:\n    \"\"\"Check if the Statement has a specific trait.\n\n    Args:\n        trait_type (type[StmtTrait]): The type of trait to check for.\n\n    Returns:\n        bool: True if the class has the specified trait, False otherwise.\n    \"\"\"\n    for trait in cls.traits:\n        if isinstance(trait, trait_type):\n            return True\n    return False\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.insert_after","title":"insert_after","text":"<pre><code>insert_after(stmt: Statement) -&gt; None\n</code></pre> <p>Insert the current Statement after the input Statement.</p> <p>Parameters:</p> Name Type Description Default <code>stmt</code> <code>Statement</code> <p>Input Statement.</p> required Example <p>The following example demonstrates how to insert a Statement after another Statement. After <code>insert_after</code> is called, <code>stmt1</code> will be inserted after <code>stmt2</code>, which appears in IR in the order (stmt2 -&gt; stmt1) <pre><code>stmt1 = Statement()\nstmt2 = Statement()\nstmt1.insert_after(stmt2)\n</code></pre></p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def insert_after(self, stmt: Statement) -&gt; None:\n    \"\"\"Insert the current Statement after the input Statement.\n\n    Args:\n        stmt (Statement): Input Statement.\n\n    Example:\n        The following example demonstrates how to insert a Statement after another Statement.\n        After `insert_after` is called, `stmt1` will be inserted after `stmt2`, which appears in IR in the order (stmt2 -&gt; stmt1)\n        ```python\n        stmt1 = Statement()\n        stmt2 = Statement()\n        stmt1.insert_after(stmt2)\n        ```\n    \"\"\"\n    if self._next_stmt is not None and self._prev_stmt is not None:\n        raise ValueError(\n            f\"Cannot insert before a statement that is already in a block: {self.name}\"\n        )\n\n    if stmt._next_stmt is not None:\n        stmt._next_stmt._prev_stmt = self\n\n    self._prev_stmt = stmt\n    self._next_stmt = stmt._next_stmt\n\n    self.parent = stmt.parent\n    stmt._next_stmt = self\n\n    if self.parent:\n        self.parent._stmt_len += 1\n\n        if self._next_stmt is None:\n            self.parent._last_stmt = self\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.insert_before","title":"insert_before","text":"<pre><code>insert_before(stmt: Statement) -&gt; None\n</code></pre> <p>Insert the current Statement before the input Statement.</p> <p>Parameters:</p> Name Type Description Default <code>stmt</code> <code>Statement</code> <p>Input Statement.</p> required Example <p>The following example demonstrates how to insert a Statement before another Statement. After <code>insert_before</code> is called, <code>stmt1</code> will be inserted before <code>stmt2</code>, which appears in IR in the order (stmt1 -&gt; stmt2) <pre><code>stmt1 = Statement()\nstmt2 = Statement()\nstmt1.insert_before(stmt2)\n</code></pre></p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def insert_before(self, stmt: Statement) -&gt; None:\n    \"\"\"Insert the current Statement before the input Statement.\n\n    Args:\n        stmt (Statement): Input Statement.\n\n    Example:\n        The following example demonstrates how to insert a Statement before another Statement.\n        After `insert_before` is called, `stmt1` will be inserted before `stmt2`, which appears in IR in the order (stmt1 -&gt; stmt2)\n        ```python\n        stmt1 = Statement()\n        stmt2 = Statement()\n        stmt1.insert_before(stmt2)\n        ```\n    \"\"\"\n    if self._next_stmt is not None and self._prev_stmt is not None:\n        raise ValueError(\n            f\"Cannot insert before a statement that is already in a block: {self.name}\"\n        )\n\n    if stmt._prev_stmt is not None:\n        stmt._prev_stmt._next_stmt = self\n\n    self._next_stmt = stmt\n    self._prev_stmt = stmt._prev_stmt\n\n    self.parent = stmt.parent\n    stmt._prev_stmt = self\n\n    if self.parent:\n        self.parent._stmt_len += 1\n\n        if self._prev_stmt is None:\n            self.parent._first_stmt = self\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.is_structurally_equal","title":"is_structurally_equal","text":"<pre><code>is_structurally_equal(\n    other: Self,\n    context: (\n        dict[IRNode | SSAValue, IRNode | SSAValue] | None\n    ) = None,\n) -&gt; bool\n</code></pre> <p>Check if the Statement is structurally equal to another Statement.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>The other Statelemt to compare with.</p> required <code>context</code> <code>dict[IRNode | SSAValue, IRNode | SSAValue] | None</code> <p>A map of IRNode/SSAValue to hint that they are equivalent so the check will treat them as equivalent. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the IRNode is structurally equal to the other.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def is_structurally_equal(\n    self,\n    other: Self,\n    context: dict[IRNode | SSAValue, IRNode | SSAValue] | None = None,\n) -&gt; bool:\n    \"\"\"Check if the Statement is structurally equal to another Statement.\n\n    Args:\n        other (Self): The other Statelemt to compare with.\n        context (dict[IRNode  |  SSAValue, IRNode  |  SSAValue] | None, optional): A map of IRNode/SSAValue to hint that they are equivalent so the check will treat them as equivalent. Defaults to None.\n\n    Returns:\n        bool: True if the IRNode is structurally equal to the other.\n    \"\"\"\n    if context is None:\n        context = {}\n\n    if self.name != other.name:\n        return False\n\n    if (\n        len(self.args) != len(other.args)\n        or len(self.regions) != len(other.regions)\n        or len(self.successors) != len(other.successors)\n        or self.attributes != other.attributes\n    ):\n        return False\n\n    if (\n        self.parent is not None\n        and other.parent is not None\n        and context.get(self.parent) != other.parent\n    ):\n        return False\n\n    if not all(\n        context.get(arg, arg) == other_arg\n        for arg, other_arg in zip(self.args, other.args)\n    ):\n        return False\n\n    if not all(\n        context.get(successor, successor) == other_successor\n        for successor, other_successor in zip(self.successors, other.successors)\n    ):\n        return False\n\n    if not all(\n        region.is_structurally_equal(other_region, context)\n        for region, other_region in zip(self.regions, other.regions)\n    ):\n        return False\n\n    for result, other_result in zip(self._results, other._results):\n        context[result] = other_result\n\n    return True\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.replace_by","title":"replace_by","text":"<pre><code>replace_by(stmt: Statement) -&gt; None\n</code></pre> <p>Replace the current Statement by the input Statement.</p> <p>Parameters:</p> Name Type Description Default <code>stmt</code> <code>Statement</code> <p>Input Statement.</p> required Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def replace_by(self, stmt: Statement) -&gt; None:\n    \"\"\"Replace the current Statement by the input Statement.\n\n    Args:\n        stmt (Statement): Input Statement.\n    \"\"\"\n    stmt.insert_before(self)\n    for result, old_result in zip(stmt._results, self._results):\n        old_result.replace_by(result)\n        if old_result.name:\n            result.name = old_result.name\n    self.delete()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>run mandatory validation checks. This is not same as verify_type, which may be optional.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def verify(self) -&gt; None:\n    try:\n        self.check()\n    except ValidationError as e:\n        raise e\n    except Exception as e:\n        raise ValidationError(self, *e.args) from e\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.verify_type","title":"verify_type","text":"<pre><code>verify_type() -&gt; None\n</code></pre> <p>Verify the type of the statement.</p> Note <p>This API should be called after all the types are figured out (by typeinfer)</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def verify_type(self) -&gt; None:\n    \"\"\"Verify the type of the statement.\n\n    Note:\n        This API should be called after all the types are figured out (by typeinfer)\n    \"\"\"\n    try:\n        self.check_type()\n    except TypeCheckError as e:\n        raise e\n    except Exception as e:\n        raise TypeCheckError(self, *e.args) from e\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.walk","title":"walk","text":"<pre><code>walk(\n    *,\n    reverse: bool = False,\n    region_first: bool = False,\n    include_self: bool = True\n) -&gt; Iterator[Statement]\n</code></pre> <p>Traversal the Statements of Regions.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>If walk in the reversed manner. Defaults to False.</p> <code>False</code> <code>region_first</code> <code>bool</code> <p>If the walk should go through the Statement first or the Region of a Statement first. Defaults to False.</p> <code>False</code> <code>include_self</code> <code>bool</code> <p>If the walk should include the Statement itself. Defaults to True.</p> <code>True</code> <p>Yields:</p> Type Description <code>Statement</code> <p>Iterator[Statement]: An iterator that yield Statements of Blocks in the Region, in the specified order.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def walk(\n    self,\n    *,\n    reverse: bool = False,\n    region_first: bool = False,\n    include_self: bool = True,\n) -&gt; Iterator[Statement]:\n    \"\"\"Traversal the Statements of Regions.\n\n    Args:\n        reverse (bool, optional): If walk in the reversed manner. Defaults to False.\n        region_first (bool, optional): If the walk should go through the Statement first or the Region of a Statement first. Defaults to False.\n        include_self (bool, optional): If the walk should include the Statement itself. Defaults to True.\n\n    Yields:\n        Iterator[Statement]: An iterator that yield Statements of Blocks in the Region, in the specified order.\n    \"\"\"\n    if include_self and not region_first:\n        yield self\n\n    for region in reversed(self.regions) if reverse else self.regions:\n        yield from region.walk(reverse=reverse, region_first=region_first)\n\n    if include_self and region_first:\n        yield self\n</code></pre>"},{"location":"reference/kirin/ir/nodes/view/","title":"View","text":""},{"location":"reference/kirin/ir/nodes/view/#kirin.ir.nodes.view.MutableSequenceView","title":"MutableSequenceView  <code>dataclass</code>","text":"<pre><code>MutableSequenceView(node: NodeType, field: FieldType)\n</code></pre> <p>               Bases: <code>SequenceView[FieldType, NodeType, ElemType]</code></p>"},{"location":"reference/kirin/ir/nodes/view/#kirin.ir.nodes.view.MutableSequenceView.popfirst","title":"popfirst","text":"<pre><code>popfirst() -&gt; ElemType | None\n</code></pre> <p>Pop the first element from the view.</p> <p>Returns:</p> Type Description <code>ElemType | None</code> <p>The first element in the view.</p> Source code in <code>src/kirin/ir/nodes/view.py</code> <pre><code>def popfirst(self) -&gt; ElemType | None:\n    \"\"\"Pop the first element from the view.\n\n    Returns:\n        The first element in the view.\n    \"\"\"\n    if self:\n        return self.pop(0)\n    return None\n</code></pre>"},{"location":"reference/kirin/ir/nodes/view/#kirin.ir.nodes.view.MutableSequenceView.poplast","title":"poplast","text":"<pre><code>poplast() -&gt; ElemType | None\n</code></pre> <p>Pop the last element from the view.</p> <p>Returns:</p> Type Description <code>ElemType | None</code> <p>The last element in the view.</p> Source code in <code>src/kirin/ir/nodes/view.py</code> <pre><code>def poplast(self) -&gt; ElemType | None:\n    \"\"\"Pop the last element from the view.\n\n    Returns:\n        The last element in the view.\n    \"\"\"\n    if self:\n        return self.pop(-1)\n    return None\n</code></pre>"},{"location":"reference/kirin/ir/traits/","title":"Index","text":"<p>Kirin IR Traits.</p> <p>This module defines the traits that can be used to define the behavior of Kirin IR nodes. The base trait is <code>StmtTrait</code>, which is a <code>dataclass</code> that implements the <code>__hash__</code> and <code>__eq__</code> methods.</p> <p>There are also some basic traits that are provided for convenience, such as <code>Pure</code>, <code>HasParent</code>, <code>ConstantLike</code>, <code>IsTerminator</code>, <code>NoTerminator</code>, and <code>IsolatedFromAbove</code>.</p>"},{"location":"reference/kirin/ir/traits/abc/","title":"Abc","text":""},{"location":"reference/kirin/ir/traits/abc/#kirin.ir.traits.abc.AttrTrait","title":"AttrTrait  <code>dataclass</code>","text":"<pre><code>AttrTrait()\n</code></pre> <p>               Bases: <code>Trait['Attribute']</code></p> <p>Base class for all attribute traits.</p>"},{"location":"reference/kirin/ir/traits/abc/#kirin.ir.traits.abc.RegionTrait","title":"RegionTrait  <code>dataclass</code>","text":"<pre><code>RegionTrait()\n</code></pre> <p>               Bases: <code>StmtTrait</code>, <code>Generic[GraphType]</code></p> <p>A trait that indicates the properties of the statement's region.</p>"},{"location":"reference/kirin/ir/traits/abc/#kirin.ir.traits.abc.StmtTrait","title":"StmtTrait  <code>dataclass</code>","text":"<pre><code>StmtTrait()\n</code></pre> <p>               Bases: <code>Trait['Statement']</code>, <code>ABC</code></p> <p>Base class for all statement traits.</p>"},{"location":"reference/kirin/ir/traits/abc/#kirin.ir.traits.abc.Trait","title":"Trait  <code>dataclass</code>","text":"<pre><code>Trait()\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[IRNodeType]</code></p> <p>Base class for all statement traits.</p>"},{"location":"reference/kirin/ir/traits/basic/","title":"Basic","text":""},{"location":"reference/kirin/ir/traits/basic/#kirin.ir.traits.basic.ConstantLike","title":"ConstantLike  <code>dataclass</code>","text":"<pre><code>ConstantLike()\n</code></pre> <p>               Bases: <code>StmtTrait</code></p> <p>A trait that indicates that a statement is constant-like, i.e., it represents a constant value.</p>"},{"location":"reference/kirin/ir/traits/basic/#kirin.ir.traits.basic.HasParent","title":"HasParent  <code>dataclass</code>","text":"<pre><code>HasParent(parents: tuple[type[Statement]])\n</code></pre> <p>               Bases: <code>StmtTrait</code></p> <p>A trait that indicates that a statement has a parent statement.</p>"},{"location":"reference/kirin/ir/traits/basic/#kirin.ir.traits.basic.IsTerminator","title":"IsTerminator  <code>dataclass</code>","text":"<pre><code>IsTerminator()\n</code></pre> <p>               Bases: <code>StmtTrait</code></p> <p>A trait that indicates that a statement is a terminator, i.e., it terminates a block.</p>"},{"location":"reference/kirin/ir/traits/basic/#kirin.ir.traits.basic.MaybePure","title":"MaybePure  <code>dataclass</code>","text":"<pre><code>MaybePure()\n</code></pre> <p>               Bases: <code>StmtTrait</code></p> <p>A trait that indicates the statement may be pure, i.e., a call statement can be pure if the callee is pure.</p>"},{"location":"reference/kirin/ir/traits/basic/#kirin.ir.traits.basic.NoTerminator","title":"NoTerminator  <code>dataclass</code>","text":"<pre><code>NoTerminator()\n</code></pre> <p>               Bases: <code>StmtTrait</code></p> <p>A trait that indicates that the region of a statement has no terminator.</p>"},{"location":"reference/kirin/ir/traits/basic/#kirin.ir.traits.basic.Pure","title":"Pure  <code>dataclass</code>","text":"<pre><code>Pure()\n</code></pre> <p>               Bases: <code>StmtTrait</code></p> <p>A trait that indicates that a statement is pure, i.e., it has no side effects.</p>"},{"location":"reference/kirin/ir/traits/callable/","title":"Callable","text":""},{"location":"reference/kirin/ir/traits/callable/#kirin.ir.traits.callable.CallableStmtInterface","title":"CallableStmtInterface  <code>dataclass</code>","text":"<pre><code>CallableStmtInterface()\n</code></pre> <p>               Bases: <code>StmtTrait</code>, <code>ABC</code>, <code>Generic[StmtType]</code></p> <p>A trait that indicates that a statement is a callable statement.</p> <p>A callable statement is a statement that can be called as a function.</p>"},{"location":"reference/kirin/ir/traits/callable/#kirin.ir.traits.callable.CallableStmtInterface.get_callable_region","title":"get_callable_region  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>get_callable_region(stmt: StmtType) -&gt; Region\n</code></pre> <p>Returns the body of the callable region</p> Source code in <code>src/kirin/ir/traits/callable.py</code> <pre><code>@classmethod\n@abstractmethod\ndef get_callable_region(cls, stmt: \"StmtType\") -&gt; \"Region\":\n    \"\"\"Returns the body of the callable region\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/ir/traits/callable/#kirin.ir.traits.callable.HasSignature","title":"HasSignature  <code>dataclass</code>","text":"<pre><code>HasSignature()\n</code></pre> <p>               Bases: <code>StmtTrait</code>, <code>ABC</code></p> <p>A trait that indicates that a statement has a function signature attribute.</p>"},{"location":"reference/kirin/ir/traits/symbol/","title":"Symbol","text":""},{"location":"reference/kirin/ir/traits/symbol/#kirin.ir.traits.symbol.SymbolOpInterface","title":"SymbolOpInterface  <code>dataclass</code>","text":"<pre><code>SymbolOpInterface()\n</code></pre> <p>               Bases: <code>StmtTrait</code></p> <p>A trait that indicates that a statement is a symbol operation.</p> <p>A symbol operation is a statement that has a symbol name attribute.</p>"},{"location":"reference/kirin/ir/traits/symbol/#kirin.ir.traits.symbol.SymbolTable","title":"SymbolTable  <code>dataclass</code>","text":"<pre><code>SymbolTable()\n</code></pre> <p>               Bases: <code>StmtTrait</code></p> <p>Statement with SymbolTable trait can only have one region with one block.</p>"},{"location":"reference/kirin/ir/traits/region/","title":"Index","text":"<p>Builtin region traits.</p>"},{"location":"reference/kirin/ir/traits/region/ssacfg/","title":"Ssacfg","text":"<p>SSACFG region trait.</p> <p>This module defines the SSACFGRegion trait, which is used to indicate that a region has an SSACFG graph.</p>"},{"location":"reference/kirin/lattice/","title":"Index","text":""},{"location":"reference/kirin/lattice/abc/","title":"Lattice","text":""},{"location":"reference/kirin/lattice/abc/#kirin.lattice.abc.BoundedLattice","title":"BoundedLattice","text":"<p>               Bases: <code>Lattice[BoundedLatticeType]</code></p> <p>ABC for bounded lattices as Python class.</p> <p><code>BoundedLattice</code> is an abstract class that can be inherited from. It requires the implementation of the <code>bottom</code> and <code>top</code> methods.</p>"},{"location":"reference/kirin/lattice/abc/#kirin.lattice.abc.Lattice","title":"Lattice","text":"<p>               Bases: <code>ABC</code>, <code>Generic[LatticeType]</code></p> <p>ABC for lattices as Python class.</p> <p>While <code>Lattice</code> is only an interface, <code>LatticeABC</code> is an abstract class that can be inherited from. This provides a few default implementations for the lattice operations.</p>"},{"location":"reference/kirin/lattice/abc/#kirin.lattice.abc.Lattice.is_equal","title":"is_equal","text":"<pre><code>is_equal(other: LatticeType) -&gt; bool\n</code></pre> <p>Check if two lattices are equal.</p> Source code in <code>src/kirin/lattice/abc.py</code> <pre><code>def is_equal(self, other: LatticeType) -&gt; bool:\n    \"\"\"Check if two lattices are equal.\"\"\"\n    if self is other:\n        return True\n    else:\n        return self.is_subseteq(other) and other.is_subseteq(self)\n</code></pre>"},{"location":"reference/kirin/lattice/abc/#kirin.lattice.abc.Lattice.is_subseteq","title":"is_subseteq  <code>abstractmethod</code>","text":"<pre><code>is_subseteq(other: LatticeType) -&gt; bool\n</code></pre> <p>Subseteq operation.</p> Source code in <code>src/kirin/lattice/abc.py</code> <pre><code>@abstractmethod\ndef is_subseteq(self, other: LatticeType) -&gt; bool:\n    \"\"\"Subseteq operation.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/lattice/abc/#kirin.lattice.abc.Lattice.join","title":"join  <code>abstractmethod</code>","text":"<pre><code>join(other: LatticeType) -&gt; LatticeType\n</code></pre> <p>Join operation.</p> Source code in <code>src/kirin/lattice/abc.py</code> <pre><code>@abstractmethod\ndef join(self, other: LatticeType) -&gt; LatticeType:\n    \"\"\"Join operation.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/lattice/abc/#kirin.lattice.abc.Lattice.meet","title":"meet  <code>abstractmethod</code>","text":"<pre><code>meet(other: LatticeType) -&gt; LatticeType\n</code></pre> <p>Meet operation.</p> Source code in <code>src/kirin/lattice/abc.py</code> <pre><code>@abstractmethod\ndef meet(self, other: LatticeType) -&gt; LatticeType:\n    \"\"\"Meet operation.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/lattice/abc/#kirin.lattice.abc.SingletonMeta","title":"SingletonMeta","text":"<pre><code>SingletonMeta(name, bases, attrs)\n</code></pre> <p>               Bases: <code>LatticeMeta</code></p> <p>Singleton metaclass for lattices. It ensures that only one instance of a lattice is created.</p> <p>See https://stackoverflow.com/questions/674304/why-is-init-always-called-after-new/8665179#8665179</p> Source code in <code>src/kirin/lattice/abc.py</code> <pre><code>def __init__(cls, name, bases, attrs):\n    super().__init__(name, bases, attrs)\n    cls._instance = None\n</code></pre>"},{"location":"reference/kirin/lattice/abc/#kirin.lattice.abc.UnionMeta","title":"UnionMeta","text":"<pre><code>UnionMeta(name, bases, attrs)\n</code></pre> <p>               Bases: <code>LatticeMeta</code></p> <p>Meta class for union types. It simplifies the union if possible.</p> Source code in <code>src/kirin/lattice/abc.py</code> <pre><code>def __init__(self, name, bases, attrs):\n    super().__init__(name, bases, attrs)\n    if not issubclass(base := bases[0], BoundedLattice):\n        raise TypeError(f\"Union must inherit from Lattice, got {bases[0]}\")\n    self._bottom = base.bottom()\n</code></pre>"},{"location":"reference/kirin/lattice/empty/","title":"Empty","text":""},{"location":"reference/kirin/lattice/empty/#kirin.lattice.empty.EmptyLattice","title":"EmptyLattice","text":"<p>               Bases: <code>BoundedLattice['EmptyLattice']</code></p> <p>Empty lattice.</p>"},{"location":"reference/kirin/lattice/empty/#kirin.lattice.empty.EmptyLattice.is_subseteq","title":"is_subseteq","text":"<pre><code>is_subseteq(other: EmptyLattice) -&gt; bool\n</code></pre> <p>Subseteq operation.</p> Source code in <code>src/kirin/lattice/empty.py</code> <pre><code>def is_subseteq(self, other: \"EmptyLattice\") -&gt; bool:\n    return True\n</code></pre>"},{"location":"reference/kirin/lattice/empty/#kirin.lattice.empty.EmptyLattice.join","title":"join","text":"<pre><code>join(other: EmptyLattice) -&gt; EmptyLattice\n</code></pre> <p>Join operation.</p> Source code in <code>src/kirin/lattice/empty.py</code> <pre><code>def join(self, other: \"EmptyLattice\") -&gt; \"EmptyLattice\":\n    return self\n</code></pre>"},{"location":"reference/kirin/lattice/empty/#kirin.lattice.empty.EmptyLattice.meet","title":"meet","text":"<pre><code>meet(other: EmptyLattice) -&gt; EmptyLattice\n</code></pre> <p>Meet operation.</p> Source code in <code>src/kirin/lattice/empty.py</code> <pre><code>def meet(self, other: \"EmptyLattice\") -&gt; \"EmptyLattice\":\n    return self\n</code></pre>"},{"location":"reference/kirin/lattice/mixin/","title":"Mixin","text":""},{"location":"reference/kirin/lattice/mixin/#kirin.lattice.mixin.IsSubsetEqMixin","title":"IsSubsetEqMixin","text":"<p>               Bases: <code>BoundedLattice[BoundedLatticeType]</code></p> <p>A special mixin for lattices that provides a default implementation for <code>is_subseteq</code> by using the visitor pattern. This is useful if the lattice has a lot of different subclasses that need to be compared.</p> <p>Must be used before <code>BoundedLattice</code> in the inheritance chain.</p>"},{"location":"reference/kirin/lattice/mixin/#kirin.lattice.mixin.IsSubsetEqMixin.is_subseteq","title":"is_subseteq","text":"<pre><code>is_subseteq(other: BoundedLatticeType) -&gt; bool\n</code></pre> <p>Subseteq operation.</p> Source code in <code>src/kirin/lattice/mixin.py</code> <pre><code>def is_subseteq(self, other: BoundedLatticeType) -&gt; bool:\n    if other is self.top():\n        return True\n    elif other is self.bottom():\n        return False\n\n    method = getattr(\n        self,\n        \"is_subseteq_\" + other.__class__.__name__,\n        getattr(self, \"is_subseteq_fallback\", None),\n    )\n    if method is not None:\n        return method(other)\n    return False\n</code></pre>"},{"location":"reference/kirin/lattice/mixin/#kirin.lattice.mixin.SimpleJoinMixin","title":"SimpleJoinMixin","text":"<p>               Bases: <code>BoundedLattice[BoundedLatticeType]</code></p> <p>A mixin that provides a simple implementation for the join operation.</p>"},{"location":"reference/kirin/lattice/mixin/#kirin.lattice.mixin.SimpleJoinMixin.join","title":"join","text":"<pre><code>join(other: BoundedLatticeType) -&gt; BoundedLatticeType\n</code></pre> <p>Join operation.</p> Source code in <code>src/kirin/lattice/mixin.py</code> <pre><code>def join(self, other: BoundedLatticeType) -&gt; BoundedLatticeType:\n    if self.is_subseteq(other):\n        return other\n    elif other.is_subseteq(self):\n        return self  # type: ignore\n    return self.top()\n</code></pre>"},{"location":"reference/kirin/lattice/mixin/#kirin.lattice.mixin.SimpleMeetMixin","title":"SimpleMeetMixin","text":"<p>               Bases: <code>BoundedLattice[BoundedLatticeType]</code></p> <p>A mixin that provides a simple implementation for the meet operation.</p>"},{"location":"reference/kirin/lattice/mixin/#kirin.lattice.mixin.SimpleMeetMixin.meet","title":"meet","text":"<pre><code>meet(other: BoundedLatticeType) -&gt; BoundedLatticeType\n</code></pre> <p>Meet operation.</p> Source code in <code>src/kirin/lattice/mixin.py</code> <pre><code>def meet(self, other: BoundedLatticeType) -&gt; BoundedLatticeType:\n    if self.is_subseteq(other):\n        return self  # type: ignore\n    elif other.is_subseteq(self):\n        return other\n    return self.bottom()\n</code></pre>"},{"location":"reference/kirin/lowering/","title":"Index","text":""},{"location":"reference/kirin/lowering/abc/","title":"Abc","text":""},{"location":"reference/kirin/lowering/abc/#kirin.lowering.abc.Result","title":"Result  <code>module-attribute</code>","text":"<pre><code>Result: TypeAlias = (\n    SSAValue | tuple[SSAValue, ...] | Statement | None\n)\n</code></pre> <p>Result of lowering a node. This is used to indicate that the node can be lowered to a SSAValue or None.</p> <p>If the node is corresponding to a single statement that has a single result value, the result can also be a Statement for convenience.</p> <p>If the node can be assigned to a variable syntax-wise, it returns the SSAValue. If the node cannot be assigned to a variable, it returns None.</p>"},{"location":"reference/kirin/lowering/abc/#kirin.lowering.abc.LoweringABC","title":"LoweringABC  <code>dataclass</code>","text":"<pre><code>LoweringABC(dialects: DialectGroup)\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[ASTNodeType]</code></p> <p>Base class for lowering.</p> <p>This class is used to lower the AST nodes to IR. It contains the lowering process and the state of the lowering process.</p>"},{"location":"reference/kirin/lowering/abc/#kirin.lowering.abc.LoweringABC.dialects","title":"dialects  <code>instance-attribute</code>","text":"<pre><code>dialects: DialectGroup\n</code></pre> <p>dialects to lower to</p>"},{"location":"reference/kirin/lowering/abc/#kirin.lowering.abc.LoweringABC.lower_global","title":"lower_global  <code>abstractmethod</code>","text":"<pre><code>lower_global(\n    state: State[ASTNodeType], node: ASTNodeType\n) -&gt; LoweringABC.Result\n</code></pre> <p>Transform a given global expression to a SSAValue.</p> <p>This method is overridden by the subclass to transform a given global AST expression to a value as <code>LoweringABC.Result</code>.</p> <p>The subclass must implement this method to transform a given global AST expression to a SSAValue.</p> Source code in <code>src/kirin/lowering/abc.py</code> <pre><code>@abstractmethod\ndef lower_global(\n    self, state: State[ASTNodeType], node: ASTNodeType\n) -&gt; LoweringABC.Result:\n    \"\"\"Transform a given global expression to a SSAValue.\n\n    This method is overridden by the subclass to transform a given global\n    AST expression to a value as `LoweringABC.Result`.\n\n    The subclass must implement this method to transform a given global\n    AST expression to a SSAValue.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/lowering/abc/#kirin.lowering.abc.LoweringABC.lower_global_no_raise","title":"lower_global_no_raise","text":"<pre><code>lower_global_no_raise(\n    state: State[ASTNodeType], node: ASTNodeType\n) -&gt; LoweringABC.Result | None\n</code></pre> <p>Transform a given global expression to a SSAValue.</p> <p>This method can be overridden by the subclass to transform a given global AST expression to a SSAValue.</p> Source code in <code>src/kirin/lowering/abc.py</code> <pre><code>def lower_global_no_raise(\n    self, state: State[ASTNodeType], node: ASTNodeType\n) -&gt; LoweringABC.Result | None:\n    \"\"\"Transform a given global expression to a SSAValue.\n\n    This method can be overridden by the subclass to transform a given global\n    AST expression to a SSAValue.\n    \"\"\"\n    try:\n        return self.lower_global(state, node)\n    except BuildError:\n        return None\n</code></pre>"},{"location":"reference/kirin/lowering/abc/#kirin.lowering.abc.LoweringABC.visit","title":"visit  <code>abstractmethod</code>","text":"<pre><code>visit(\n    state: State[ASTNodeType], node: ASTNodeType\n) -&gt; Result\n</code></pre> <p>Entry point of AST visitors.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>State[ASTNodeType]</code> <p>lowering state</p> required <code>node</code> <code>ASTNodeType</code> <p>AST node to be lowered</p> required <p>Returns:     SSAValue: if the node can be assigned to a variable syntax-wise,         what is the <code>SSAValue</code>.     Statement: if the node is a single statement that has a single result value.         This is equivalent to returning <code>stmt.results[0]</code>.     None: If the node cannot be assigned to a variable syntax-wise. Raises:     lowering.BuildError: if the node cannot be lowered.</p> Source code in <code>src/kirin/lowering/abc.py</code> <pre><code>@abstractmethod\ndef visit(self, state: State[ASTNodeType], node: ASTNodeType) -&gt; Result:\n    \"\"\"Entry point of AST visitors.\n\n    Args:\n        state: lowering state\n        node: AST node to be lowered\n    Returns:\n        SSAValue: if the node can be assigned to a variable syntax-wise,\n            what is the `SSAValue`.\n        Statement: if the node is a single statement that has a single result value.\n            This is equivalent to returning `stmt.results[0]`.\n        None: If the node cannot be assigned to a variable syntax-wise.\n    Raises:\n        lowering.BuildError: if the node cannot be lowered.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/lowering/exception/","title":"Exception","text":""},{"location":"reference/kirin/lowering/exception/#kirin.lowering.exception.BuildError","title":"BuildError","text":"<pre><code>BuildError(*msgs: object, help: str | None = None)\n</code></pre> <p>               Bases: <code>NoPythonStackTrace</code></p> <p>Base class for all dialect lowering errors.</p> Source code in <code>src/kirin/lowering/exception.py</code> <pre><code>def __init__(self, *msgs: object, help: str | None = None):\n    super().__init__(*msgs)\n    self.help = help\n</code></pre>"},{"location":"reference/kirin/lowering/frame/","title":"Frame","text":""},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame","title":"Frame  <code>dataclass</code>","text":"<pre><code>Frame(\n    state: State,\n    stream: StmtStream[Stmt],\n    curr_region: Region,\n    entr_block: Block,\n    curr_block: Block,\n    next_block: Block,\n    defs: dict[str, SSAValue] = dict(),\n    globals: dict[str, Any] = dict(),\n    captures: dict[str, SSAValue] = dict(),\n    capture_callback: Optional[CallbackFn] = None,\n)\n</code></pre> <p>               Bases: <code>Generic[Stmt]</code></p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.capture_callback","title":"capture_callback  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>capture_callback: Optional[CallbackFn] = None\n</code></pre> <p>callback function that creates a local SSAValue value when an captured value was used.</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.captures","title":"captures  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>captures: dict[str, SSAValue] = field(default_factory=dict)\n</code></pre> <p>values accessed from the parent frame</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.curr_block","title":"curr_block  <code>instance-attribute</code>","text":"<pre><code>curr_block: Block\n</code></pre> <p>current block being lowered</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.curr_region","title":"curr_region  <code>instance-attribute</code>","text":"<pre><code>curr_region: Region\n</code></pre> <p>the region this frame is generating</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.defs","title":"defs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>defs: dict[str, SSAValue] = field(default_factory=dict)\n</code></pre> <p>values defined in the current frame</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.entr_block","title":"entr_block  <code>instance-attribute</code>","text":"<pre><code>entr_block: Block\n</code></pre> <p>entry block of the frame region</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.globals","title":"globals  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>globals: dict[str, Any] = field(default_factory=dict)\n</code></pre> <p>global values known to the current frame</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.next_block","title":"next_block  <code>instance-attribute</code>","text":"<pre><code>next_block: Block\n</code></pre> <p>next block to be lowered, but not yet inserted in the region</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.parent","title":"parent  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parent: Optional[Frame] = field(default=None, init=False)\n</code></pre> <p>parent frame, if any</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.state","title":"state  <code>instance-attribute</code>","text":"<pre><code>state: State\n</code></pre> <p>lowering state</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.stream","title":"stream  <code>instance-attribute</code>","text":"<pre><code>stream: StmtStream[Stmt]\n</code></pre> <p>stream of statements</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(name: str) -&gt; SSAValue\n</code></pre> <p>Get a variable from current scope.</p> <p>Parameters:</p> Name Type Description Default <code>name(str)</code> <p>variable name</p> required <p>Returns:</p> Name Type Description <code>SSAValue</code> <code>SSAValue</code> <p>the value of the variable</p> <p>Raises:</p> Type Description <code>BuildError</code> <p>if the variable is not found in the scope, or if the variable has multiple possible values.</p> Source code in <code>src/kirin/lowering/frame.py</code> <pre><code>def __getitem__(self, name: str) -&gt; SSAValue:\n    \"\"\"Get a variable from current scope.\n\n    Args:\n        name(str): variable name\n\n    Returns:\n        SSAValue: the value of the variable\n\n    Raises:\n        lowering.BuildError: if the variable is not found in the scope,\n            or if the variable has multiple possible values.\n    \"\"\"\n    value = self.defs.get(name)\n    if isinstance(value, SSAValue):\n        return value\n    else:\n        raise BuildError(f\"Variable {name} not found in scope\")\n</code></pre>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.exhaust","title":"exhaust","text":"<pre><code>exhaust()\n</code></pre> <p>Exhaust the current stream and return the remaining statements.</p> Source code in <code>src/kirin/lowering/frame.py</code> <pre><code>def exhaust(self):\n    \"\"\"Exhaust the current stream and return the remaining statements.\"\"\"\n    stream = self.stream\n    while stream:\n        stmt = stream.pop()\n        self.state.parent.visit(self.state, stmt)\n</code></pre>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.jump_next_block","title":"jump_next_block","text":"<pre><code>jump_next_block()\n</code></pre> <p>Jump to the next block and return it. This appends the current <code>Frame.next_block</code> to the current region and creates a new Block for <code>next_block</code>.</p> <p>Returns:</p> Name Type Description <code>Block</code> <p>the next block</p> Source code in <code>src/kirin/lowering/frame.py</code> <pre><code>def jump_next_block(self):\n    \"\"\"Jump to the next block and return it.\n    This appends the current `Frame.next_block` to the current region\n    and creates a new Block for `next_block`.\n\n    Returns:\n        Block: the next block\n    \"\"\"\n    block = self.push(self.next_block)\n    self.next_block = Block()\n    return block\n</code></pre>"},{"location":"reference/kirin/lowering/state/","title":"State","text":""},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.State","title":"State  <code>dataclass</code>","text":"<pre><code>State(\n    parent: LoweringABC[ASTNodeType],\n    *,\n    source: SourceInfo | None = None,\n    lines: list[str] = list(),\n    file: str | None = None,\n    lineno_offset: int = 0,\n    col_offset: int = 0\n)\n</code></pre> <p>               Bases: <code>Generic[ASTNodeType]</code></p> <p>State of the lowering process.</p> <p>This class is used to store the state of the lowering process. It contains the current frame, the current block, and the current source.</p>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.State.code","title":"code  <code>property</code>","text":"<pre><code>code\n</code></pre> <p>Obtain the code generated by the lowering process.</p>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.State.col_offset","title":"col_offset  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>col_offset: int = field(default=0, kw_only=True)\n</code></pre> <p>column offset at the beginning of the source</p>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.State.current_frame","title":"current_frame  <code>property</code>","text":"<pre><code>current_frame: Frame[ASTNodeType]\n</code></pre> <p>current frame being lowered</p>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.State.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>file: str | None = field(default=None, kw_only=True)\n</code></pre> <p>file name of the current node</p>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.State.lineno_offset","title":"lineno_offset  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lineno_offset: int = field(default=0, kw_only=True)\n</code></pre> <p>lineno offset at the beginning of the source</p>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.State.lines","title":"lines  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lines: list[str] = field(default_factory=list, kw_only=True)\n</code></pre> <p>source lines of the code being lowered</p>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.State.parent","title":"parent  <code>instance-attribute</code>","text":"<pre><code>parent: LoweringABC[ASTNodeType]\n</code></pre> <p>the parent lowering transform</p>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.State.root_frame","title":"root_frame  <code>property</code>","text":"<pre><code>root_frame: Frame[ASTNodeType]\n</code></pre> <p>root frame of the lowering process</p>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.State.source","title":"source  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>source: SourceInfo | None = field(\n    default=None, kw_only=True\n)\n</code></pre> <p>source info of the current node</p>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.State.Result","title":"Result  <code>dataclass</code>","text":"<pre><code>Result(data: tuple[SSAValue, ...])\n</code></pre> <p>A proxy object to the result of the lowering process.</p> <p>Use <code>.data</code> to access the result of the lowering process. Use <code>.expect_one()</code> to assert that the result is a single value.</p>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.State.error_hint","title":"error_hint","text":"<pre><code>error_hint(\n    e: Exception,\n    *,\n    max_lines: int = 3,\n    indent: int = 0,\n    show_lineno: bool = True\n) -&gt; str\n</code></pre> <p>Generate an error hint for the given error. Args:     e (Exception): The error to generate a hint for. If the error object         has a <code>help</code> attribute, it will be used as the help message at the         location of the error.     max_lines (int): The maximum number of lines to show in the hint.     indent (int): The indentation level for the hint.     show_lineno (bool): Whether to show the line number in the hint. Returns:     str: The generated error hint.</p> Source code in <code>src/kirin/lowering/state.py</code> <pre><code>def error_hint(\n    self,\n    e: Exception,\n    *,\n    max_lines: int = 3,\n    indent: int = 0,\n    show_lineno: bool = True,\n) -&gt; str:\n    \"\"\"Generate an error hint for the given error.\n    Args:\n        e (Exception): The error to generate a hint for. If the error object\n            has a `help` attribute, it will be used as the help message at the\n            location of the error.\n        max_lines (int): The maximum number of lines to show in the hint.\n        indent (int): The indentation level for the hint.\n        show_lineno (bool): Whether to show the line number in the hint.\n    Returns:\n        str: The generated error hint.\n    \"\"\"\n    if self.source is None:\n        return str(e)\n\n    return self.source.error_hint(\n        self.lines,\n        e,\n        file=self.file,\n        indent=indent,\n        show_lineno=show_lineno,\n        max_lines=max_lines,\n    )\n</code></pre>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.State.frame","title":"frame","text":"<pre><code>frame(\n    stmts: Sequence[ASTNodeType] | StmtStream[ASTNodeType],\n    region: Optional[Region] = None,\n    entr_block: Optional[Block] = None,\n    next_block: Optional[Block] = None,\n    globals: dict[str, Any] | None = None,\n    capture_callback: Optional[CallbackFn] = None,\n    finalize_next: bool = True,\n) -&gt; Generator[Frame[ASTNodeType], Any, None]\n</code></pre> <p>Context manager to push a new frame and pop it after the block.</p> Source code in <code>src/kirin/lowering/state.py</code> <pre><code>@contextmanager\ndef frame(\n    self,\n    stmts: Sequence[ASTNodeType] | StmtStream[ASTNodeType],\n    region: Optional[Region] = None,\n    entr_block: Optional[Block] = None,\n    next_block: Optional[Block] = None,\n    globals: dict[str, Any] | None = None,\n    capture_callback: Optional[CallbackFn] = None,\n    finalize_next: bool = True,\n) -&gt; Generator[Frame[ASTNodeType], Any, None]:\n    \"\"\"Context manager to push a new frame and pop it after the block.\"\"\"\n\n    if not isinstance(stmts, StmtStream):\n        stmts = StmtStream(stmts)\n\n    region = region or Region()\n    region.source = self.source\n\n    entr_block = entr_block or Block()\n    region.blocks.append(entr_block)\n\n    if self._current_frame is not None:\n        globals = globals or self.current_frame.globals\n    else:\n        globals = globals or {}\n\n    frame = Frame(\n        state=self,\n        stream=stmts,\n        curr_region=region or Region(entr_block),\n        entr_block=entr_block,\n        curr_block=entr_block,\n        next_block=next_block or Block(),\n        globals=globals,\n        capture_callback=capture_callback,\n    )\n    self.push_frame(frame)\n    try:\n        yield frame\n    finally:\n        self.pop_frame(finalize_next)\n</code></pre>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.State.get_global","title":"get_global","text":"<pre><code>get_global(\n    node: ASTNodeType, *, no_raise: Literal[True] | bool\n) -&gt; LoweringABC.Result | None\n</code></pre><pre><code>get_global(\n    node: ASTNodeType, *, no_raise: Literal[False] = False\n) -&gt; LoweringABC.Result\n</code></pre> <pre><code>get_global(node: ASTNodeType, *, no_raise: bool = False)\n</code></pre> <p>Get the global value of a node. Args:     node (ASTNodeType): the node to get the global value of.     no_raise (bool): if True, do not raise an exception if the value is not found. Returns:     <code>LoweringABC.Result</code>: a proxy object to the global value. <code>.data</code> is the         value, and <code>.expect(type)</code> will raise an exception if the value is the expected type.</p> Source code in <code>src/kirin/lowering/state.py</code> <pre><code>def get_global(self, node: ASTNodeType, *, no_raise: bool = False):\n    \"\"\"Get the global value of a node.\n    Args:\n        node (ASTNodeType): the node to get the global value of.\n        no_raise (bool): if True, do not raise an exception if the value is not found.\n    Returns:\n        `LoweringABC.Result`: a proxy object to the global value. `.data` is the\n            value, and `.expect(type)` will raise an exception if the value is the expected type.\n    \"\"\"\n    if no_raise:\n        return self.parent.lower_global_no_raise(self, node)\n    return self.parent.lower_global(self, node)\n</code></pre>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.State.pop_frame","title":"pop_frame","text":"<pre><code>pop_frame(finalize_next: bool = True)\n</code></pre> <p>Pop the current frame and return it.</p> <p>Parameters:</p> Name Type Description Default <code>finalize_next(bool)</code> <p>If True, append the next block of the current frame.</p> required <p>Returns:</p> Name Type Description <code>Frame</code> <p>The popped frame.</p> Source code in <code>src/kirin/lowering/state.py</code> <pre><code>def pop_frame(self, finalize_next: bool = True):\n    \"\"\"Pop the current frame and return it.\n\n    Args:\n        finalize_next(bool): If True, append the next block of the current frame.\n\n    Returns:\n        Frame: The popped frame.\n    \"\"\"\n    if self._current_frame is None:\n        raise ValueError(\"No frame to pop\")\n    frame = self._current_frame\n\n    if finalize_next and frame.next_block.parent is None:\n        frame.push(frame.next_block)\n    self._current_frame = frame.parent\n    return frame\n</code></pre>"},{"location":"reference/kirin/lowering/stream/","title":"Stream","text":""},{"location":"reference/kirin/lowering/python/","title":"Index","text":""},{"location":"reference/kirin/lowering/python/binding/","title":"Binding","text":""},{"location":"reference/kirin/lowering/python/binding/#kirin.lowering.python.binding.wraps","title":"wraps","text":"<pre><code>wraps(parent: type[Statement])\n</code></pre> <p>Wraps a <code>Statement</code> to a <code>Binding</code> object which will be special cased in the lowering process.</p> <p>This is useful for providing type hints by faking the call signature of a <code>Statement</code>.</p>"},{"location":"reference/kirin/lowering/python/binding/#kirin.lowering.python.binding.wraps--example","title":"Example","text":"<p>Directly writing a function with the statement will let Python linter think you intend to call the constructor of the statement class. However, given the context of a kernel, our intention is to actually \"call\" the statement, e.g the following will produce type errors with pyright or mypy:</p> <pre><code>from kirin.dialects import math\nfrom kirin.prelude import basic_no_opt\n\n@basic_no_opt\ndef main(x: float):\n    return math.sin(x) # this is a statement, not a function\n</code></pre> <p>the <code>@lowering.wraps</code> decorator allows us to provide a type hint for the statement, e.g:</p> <pre><code>from kirin import lowering\n\n@lowering.wraps(math.sin)\ndef sin(value: float) -&gt; float: ...\n\n@basic_no_opt\ndef main(x: float):\n    return sin(x) # linter now thinks this is a function\n\nsin(1.0) # this will raise a NotImplementedError(\"Binding of sin can only be called from a kernel\")\n</code></pre> Source code in <code>src/kirin/lowering/python/binding.py</code> <pre><code>def wraps(parent: type[\"Statement\"]):\n    \"\"\"Wraps a [`Statement`][kirin.ir.nodes.stmt.Statement] to a `Binding` object\n    which will be special cased in the lowering process.\n\n    This is useful for providing type hints by faking the call signature of a\n    [`Statement`][kirin.ir.nodes.stmt.Statement].\n\n    ## Example\n\n    Directly writing a function with the statement will let Python linter think\n    you intend to call the constructor of the statement class. However, given the\n    context of a kernel, our intention is to actually \"call\" the statement, e.g\n    the following will produce type errors with pyright or mypy:\n\n    ```python\n    from kirin.dialects import math\n    from kirin.prelude import basic_no_opt\n\n    @basic_no_opt\n    def main(x: float):\n        return math.sin(x) # this is a statement, not a function\n    ```\n\n    the `@lowering.wraps` decorator allows us to provide a type hint for the\n    statement, e.g:\n\n    ```python\n    from kirin import lowering\n\n    @lowering.wraps(math.sin)\n    def sin(value: float) -&gt; float: ...\n\n    @basic_no_opt\n    def main(x: float):\n        return sin(x) # linter now thinks this is a function\n\n    sin(1.0) # this will raise a NotImplementedError(\"Binding of sin can only be called from a kernel\")\n    ```\n    \"\"\"\n\n    def wrapper(func: Callable[Params, RetType]) -&gt; Binding[Params, RetType]:\n        return Binding(parent)\n\n    return wrapper\n</code></pre>"},{"location":"reference/kirin/lowering/python/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/lowering/python/dialect/#kirin.lowering.python.dialect.FromPythonAST","title":"FromPythonAST  <code>dataclass</code>","text":"<pre><code>FromPythonAST()\n</code></pre> <p>               Bases: <code>ABC</code></p>"},{"location":"reference/kirin/lowering/python/dialect/#kirin.lowering.python.dialect.FromPythonAST.callee_table","title":"callee_table  <code>class-attribute</code>","text":"<pre><code>callee_table: dict[object, Transform]\n</code></pre> <p>a table of lowering transforms for ast.Call based on the callable object if avaiable as a global value.</p>"},{"location":"reference/kirin/lowering/python/dialect/#kirin.lowering.python.dialect.FromPythonAST.lower","title":"lower","text":"<pre><code>lower(state: State[ast.AST], node: ast.AST) -&gt; Result\n</code></pre> <p>Entry point of dialect specific lowering.</p> Source code in <code>src/kirin/lowering/python/dialect.py</code> <pre><code>def lower(self, state: State[ast.AST], node: ast.AST) -&gt; Result:\n    \"\"\"Entry point of dialect specific lowering.\"\"\"\n    return getattr(self, f\"lower_{node.__class__.__name__}\", self.unreachable)(\n        state, node\n    )\n</code></pre>"},{"location":"reference/kirin/lowering/python/glob/","title":"Glob","text":""},{"location":"reference/kirin/lowering/python/glob/#kirin.lowering.python.glob.GlobalEvalError","title":"GlobalEvalError","text":"<pre><code>GlobalEvalError(\n    node: ast.AST, *msgs: object, help: str | None = None\n)\n</code></pre> <p>               Bases: <code>BuildError</code></p> <p>Exception raised when a global expression cannot be evaluated.</p> Source code in <code>src/kirin/lowering/python/glob.py</code> <pre><code>def __init__(self, node: ast.AST, *msgs: object, help: str | None = None):\n    super().__init__(*msgs, help=help)\n    self.source = SourceInfo.from_ast(node)\n</code></pre>"},{"location":"reference/kirin/lowering/python/lowering/","title":"Lowering","text":""},{"location":"reference/kirin/lowering/python/lowering/#kirin.lowering.python.lowering.Python","title":"Python  <code>dataclass</code>","text":"<pre><code>Python(\n    dialects: (\n        ir.DialectGroup | Iterable[ir.Dialect | ModuleType]\n    ),\n    *,\n    keys: list[str] | None = None,\n    max_lines: int = 3,\n    hint_indent: int = 2,\n    hint_lineno: bool = True,\n    stacktrace: bool = False\n)\n</code></pre> <p>               Bases: <code>LoweringABC[AST]</code></p> <p>Python lowering transform.</p> <p>This class is used to lower Python AST nodes to IR statements via a visitor pattern.</p> <p>Note</p> <p>the visitor pattern is not using the <code>ast.NodeVisitor</code> class because it customize the visit method to pass the lowering state and the source information to the visitor methods.</p> Source code in <code>src/kirin/lowering/python/lowering.py</code> <pre><code>def __init__(\n    self,\n    dialects: ir.DialectGroup | Iterable[ir.Dialect | ModuleType],\n    *,\n    keys: list[str] | None = None,\n    max_lines: int = 3,\n    hint_indent: int = 2,\n    hint_lineno: bool = True,\n    stacktrace: bool = False,\n):\n    if isinstance(dialects, ir.DialectGroup):\n        self.dialects = dialects\n    else:\n        self.dialects = ir.DialectGroup(dialects)\n\n    self.max_lines = max_lines\n    self.registry = self.dialects.registry.ast(keys=keys or [\"main\", \"default\"])\n    self.hint_indent = hint_indent\n    self.hint_show_lineno = hint_lineno\n    self.stacktrace = stacktrace\n</code></pre>"},{"location":"reference/kirin/lowering/python/lowering/#kirin.lowering.python.lowering.Python.dialects","title":"dialects  <code>instance-attribute</code>","text":"<pre><code>dialects = dialects\n</code></pre> <p>dialects to lower to</p>"},{"location":"reference/kirin/lowering/python/lowering/#kirin.lowering.python.lowering.Python.stacktrace","title":"stacktrace  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stacktrace: bool = stacktrace\n</code></pre> <p>If True, print the stacktrace of the error.</p>"},{"location":"reference/kirin/lowering/python/lowering/#kirin.lowering.python.lowering.Python.lower_global","title":"lower_global","text":"<pre><code>lower_global(\n    state: State[ast.AST], node: ast.AST\n) -&gt; LoweringABC.Result\n</code></pre> <p>Transform a given global expression to a SSAValue.</p> <p>This method is overridden by the subclass to transform a given global AST expression to a value as <code>LoweringABC.Result</code>.</p> <p>The subclass must implement this method to transform a given global AST expression to a SSAValue.</p> Source code in <code>src/kirin/lowering/python/lowering.py</code> <pre><code>def lower_global(self, state: State[ast.AST], node: ast.AST) -&gt; LoweringABC.Result:\n    return LoweringABC.Result(GlobalExprEval(state.current_frame).visit(node))\n</code></pre>"},{"location":"reference/kirin/lowering/python/lowering/#kirin.lowering.python.lowering.Python.visit","title":"visit","text":"<pre><code>visit(state: State[ast.AST], node: ast.AST) -&gt; Result\n</code></pre> <p>Entry point of AST visitors.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>State[ASTNodeType]</code> <p>lowering state</p> required <code>node</code> <code>ASTNodeType</code> <p>AST node to be lowered</p> required <p>Returns:     SSAValue: if the node can be assigned to a variable syntax-wise,         what is the <code>SSAValue</code>.     Statement: if the node is a single statement that has a single result value.         This is equivalent to returning <code>stmt.results[0]</code>.     None: If the node cannot be assigned to a variable syntax-wise. Raises:     lowering.BuildError: if the node cannot be lowered.</p> Source code in <code>src/kirin/lowering/python/lowering.py</code> <pre><code>def visit(self, state: State[ast.AST], node: ast.AST) -&gt; Result:\n    if hasattr(node, \"lineno\"):\n        state.source = SourceInfo.from_ast(\n            node, state.lineno_offset, state.col_offset, state.file\n        )\n    name = node.__class__.__name__\n    if name in self.registry.ast_table:\n        return self.registry.ast_table[name].lower(state, node)\n    return getattr(self, f\"visit_{name}\", self.generic_visit)(state, node)\n</code></pre>"},{"location":"reference/kirin/lowering/python/traits/","title":"Traits","text":""},{"location":"reference/kirin/lowering/python/traits/#kirin.lowering.python.traits.FromPythonCall","title":"FromPythonCall  <code>dataclass</code>","text":"<pre><code>FromPythonCall()\n</code></pre> <p>               Bases: <code>PythonLoweringTrait[StatementType, Call]</code></p> <p>Trait for customizing lowering of Python calls to a statement.</p> <p>Declared in a statement definition to indicate that the statement can be constructed from a Python call (i.e., a function call <code>ast.Call</code> in the Python AST).</p> <p>Subclassing this trait allows for customizing the lowering of Python calls to the statement. The <code>lower</code> method should be implemented to parse the arguments from the Python call and construct the statement instance.</p>"},{"location":"reference/kirin/lowering/python/traits/#kirin.lowering.python.traits.FromPythonRangeLike","title":"FromPythonRangeLike  <code>dataclass</code>","text":"<pre><code>FromPythonRangeLike()\n</code></pre> <p>               Bases: <code>FromPythonCall[StatementType]</code></p> <p>Provides a default lowering implementation for built-in <code>range</code>-like function to a statement that takes three arguments: start, stop, and step.</p>"},{"location":"reference/kirin/lowering/python/traits/#kirin.lowering.python.traits.FromPythonWith","title":"FromPythonWith  <code>dataclass</code>","text":"<pre><code>FromPythonWith()\n</code></pre> <p>               Bases: <code>PythonLoweringTrait[StatementType, With]</code></p> <p>Trait for customizing lowering of Python with statements to a statement.</p> <p>Subclassing this trait allows for customizing the lowering of Python with statements to the statement. The <code>lower</code> method should be implemented to parse the arguments from the Python with statement and construct the statement instance.</p>"},{"location":"reference/kirin/lowering/python/traits/#kirin.lowering.python.traits.FromPythonWithSingleItem","title":"FromPythonWithSingleItem  <code>dataclass</code>","text":"<pre><code>FromPythonWithSingleItem()\n</code></pre> <p>               Bases: <code>FromPythonWith[StatementType]</code></p> <p>Trait for customizing lowering of the following Python with syntax to a statement:</p> <pre><code>with &lt;stmt&gt;[ as &lt;name&gt;]:\n    &lt;body&gt;\n</code></pre> <p>where <code>&lt;stmt&gt;</code> is the statement being lowered, <code>&lt;name&gt;</code> is an optional name for the result of the statement, and <code>&lt;body&gt;</code> is the body of the with statement. The optional <code>as &lt;name&gt;</code> is not valid when the statement has no results.</p> <p>This syntax is slightly different from the standard Python <code>with</code> statement in that <code>&lt;name&gt;</code> refers to the result of the statement, not the context manager. Thus typically one sould access <code>&lt;name&gt;</code> in <code>&lt;body&gt;</code> to use the result of the statement.</p> <p>In some cases, however, <code>&lt;name&gt;</code> may be used as a reference of a special value <code>self</code> that is passed to the <code>&lt;body&gt;</code> of the statement. This is useful for statements that have a similar behavior to a closure.</p>"},{"location":"reference/kirin/lowering/python/traits/#kirin.lowering.python.traits.PythonLoweringTrait","title":"PythonLoweringTrait  <code>dataclass</code>","text":"<pre><code>PythonLoweringTrait()\n</code></pre> <p>               Bases: <code>Trait[Statement]</code>, <code>Generic[StmtType, ASTNode]</code></p> <p>A trait that indicates that a statement can be lowered from Python AST.</p>"},{"location":"reference/kirin/lowering/python/traits/#kirin.lowering.python.traits.PythonLoweringTrait.lower_Call_inputs","title":"lower_Call_inputs  <code>classmethod</code>","text":"<pre><code>lower_Call_inputs(\n    stmt: type[StmtType],\n    state: State[ast.AST],\n    node: ast.Call,\n) -&gt; tuple[\n    dict[str, ir.SSAValue | tuple[ir.SSAValue, ...]],\n    dict[str, Any],\n]\n</code></pre> <p>Lower the inputs of a Python call to corresponding SSA values or compile-time values (attributes).</p> <p>Parameters:</p> Name Type Description Default <code>stmt</code> <code>type[StmtType]</code> <p>The statement class to lower to.</p> required <code>state</code> <code>State[AST]</code> <p>The lowering state.</p> required <code>node</code> <code>Call</code> <p>The Python call node to lower.</p> required <p>Returns:</p> Type Description <code>dict[str, SSAValue | tuple[SSAValue, ...]]</code> <p>A tuple containing two dictionaries:</p> <code>dict[str, Any]</code> <ul> <li>The first dictionary contains the standard arguments and their values.</li> </ul> <code>tuple[dict[str, SSAValue | tuple[SSAValue, ...]], dict[str, Any]]</code> <ul> <li>The second dictionary contains the keyword arguments and their values.</li> </ul> <p>Raises:</p> Type Description <code>BuildError</code> <p>If the Python call cannot be lowered to the statement.</p> Source code in <code>src/kirin/lowering/python/traits.py</code> <pre><code>@classmethod\ndef lower_Call_inputs(\n    cls, stmt: type[StmtType], state: State[ast.AST], node: ast.Call\n) -&gt; tuple[dict[str, ir.SSAValue | tuple[ir.SSAValue, ...]], dict[str, Any]]:\n    \"\"\"Lower the inputs of a Python call to corresponding SSA values or\n    compile-time values (attributes).\n\n    Args:\n        stmt: The statement class to lower to.\n        state: The lowering state.\n        node: The Python call node to lower.\n\n    Returns:\n        A tuple containing two dictionaries:\n        - The first dictionary contains the standard arguments and their values.\n        - The second dictionary contains the keyword arguments and their values.\n\n    Raises:\n        lowering.BuildError: If the Python call cannot be lowered to the statement.\n    \"\"\"\n    fs = fields(stmt)\n    stmt_std_arg_names = fs.std_args.keys()\n    stmt_kw_args_name = fs.kw_args.keys()\n    stmt_attr_prop_names = fs.attr_or_props\n    stmt_required_names = fs.required_names\n    stmt_group_arg_names = fs.group_arg_names\n    args, kwargs = {}, {}\n    for name, value in zip(stmt_std_arg_names, node.args):\n        cls.__parse_arg(state, stmt_group_arg_names, args, name, value)\n    for kw in node.keywords:\n        if not isinstance(kw.arg, str):\n            raise BuildError(\"Expected string for keyword argument name\")\n\n        arg: str = kw.arg\n        if arg in node.args:\n            raise BuildError(\n                f\"Keyword argument {arg} is already present in positional arguments\"\n            )\n        elif arg in stmt_std_arg_names or arg in stmt_kw_args_name:\n            cls.__parse_arg(state, stmt_group_arg_names, kwargs, kw.arg, kw.value)\n        elif arg in stmt_attr_prop_names:\n            if (\n                isinstance(kw.value, ast.Name)\n                and state.current_frame.get_local(kw.value.id) is not None\n            ):\n                raise BuildError(\n                    f\"Expected global/constant value for attribute or property {arg}\"\n                )\n            global_value = state.get_global(kw.value)\n            if (decl := fs.attributes.get(arg)) is not None:\n                if decl.annotation is Any:\n                    kwargs[arg] = global_value.data\n                else:\n                    kwargs[arg] = global_value.expect(\n                        get_origin(decl.annotation) or decl.annotation\n                    )\n            else:\n                raise BuildError(f\"Unexpected attribute or property {arg}\")\n        else:\n            raise BuildError(f\"Unexpected keyword argument {arg}\")\n\n    for name in stmt_required_names:\n        if name not in args and name not in kwargs:\n            raise BuildError(f\"Missing required argument {name}\")\n\n    return args, kwargs\n</code></pre>"},{"location":"reference/kirin/passes/","title":"Index","text":""},{"location":"reference/kirin/passes/abc/","title":"Abc","text":""},{"location":"reference/kirin/passes/abc/#kirin.passes.abc.Pass","title":"Pass  <code>dataclass</code>","text":"<pre><code>Pass(dialects: DialectGroup, *, no_raise: bool = True)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>A pass is a transformation that is applied to a method. It wraps the analysis and rewrites needed to transform the method as an independent unit.</p> <p>Unlike LLVM/MLIR passes, a pass in Kirin does not apply to a module, this is because we focus on individual methods defined within python modules. This is a design choice to allow seamless integration within the Python interpreter.</p> <p>A Kirin compile unit is a <code>ir.Method</code> object, which is always equivalent to a LLVM/MLIR module if it were lowered to LLVM/MLIR just like other JIT compilers.</p>"},{"location":"reference/kirin/passes/canonicalize/","title":"Canonicalize","text":""},{"location":"reference/kirin/passes/default/","title":"Default","text":""},{"location":"reference/kirin/passes/fold/","title":"Fold","text":""},{"location":"reference/kirin/passes/hint_const/","title":"Hint const","text":""},{"location":"reference/kirin/passes/inline/","title":"Inline","text":""},{"location":"reference/kirin/passes/post_inference/","title":"Post inference","text":""},{"location":"reference/kirin/passes/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/passes/aggressive/","title":"Index","text":""},{"location":"reference/kirin/passes/aggressive/fold/","title":"Fold","text":""},{"location":"reference/kirin/print/","title":"Index","text":"<p>Pretty printing utilities.</p> <p>This module provides a pretty printing utility for the IR nodes and other objects in the compiler.</p> <p>The pretty printing utility is implemented using the visitor pattern. The <code>Printable</code> class is the base class for all objects that can be pretty printed.</p> <p>The <code>Printer</code> class is the visitor that traverses the object and prints the object to a string. The <code>Printer</code> class provides methods for printing different types of objects.</p>"},{"location":"reference/kirin/print/printable/","title":"Printable","text":""},{"location":"reference/kirin/print/printable/#kirin.print.printable.Printable","title":"Printable","text":"<p>Base class for all objects that can be pretty printed.</p> <p>This class provides an interface for pretty printing objects. The <code>print</code> method is the entry point for the printing process. The <code>print_impl</code> method is the implementation of the printing process and should be implemented by the derived classes.</p>"},{"location":"reference/kirin/print/printable/#kirin.print.printable.Printable.pager","title":"pager","text":"<pre><code>pager(\n    printer: Printer | None = None,\n    **options: Unpack[\"_PrintOptions\"]\n) -&gt; None\n</code></pre> <p>Pretty print the object with a pager.</p> <p>Parameters:</p> Name Type Description Default <code>printer</code> <code>Printer</code> <p><code>Printer</code> object to use for printing. If None, a new <code>Printer</code> object will be created.</p> <code>None</code> <p>Other Parameters:</p> Name Type Description <code>console</code> <code>Console</code> <p>The console to use for printing. If not provided, a new console will be created.</p> <code>analysis</code> <code>dict[SSAValue, Printable]</code> <p>Analysis results to use for printing. If <code>None</code>, no analysis results</p> <code>show_indent_mark</code> <code>bool</code> <p>Whether to show the indentation mark.</p> <code>theme</code> <code>Theme | dict | str</code> <p>The theme to use for printing, defaults to \"dark\".</p> <p>Note</p> <p>This function also accepts all other <code>rich.console.Console</code> options.</p> Source code in <code>src/kirin/print/printable.py</code> <pre><code>def pager(\n    self,\n    printer: Printer | None = None,\n    **options: Unpack[\"_PrintOptions\"],\n) -&gt; None:\n    \"\"\"Pretty print the object with a pager.\n\n    Args:\n        printer (Printer):\n            `Printer` object to use for printing.\n            If None, a new `Printer` object will be created.\n\n    Keyword Args:\n        console (rich.Console):\n            The console to use for printing. If not provided, a new console\n            will be created.\n        analysis (dict[ir.SSAValue, Printable]):\n            Analysis results to use for printing. If `None`, no analysis results\n        show_indent_mark (bool):\n            Whether to show the indentation mark.\n        theme (Theme | dict | str):\n            The theme to use for printing, defaults to \"dark\".\n\n    !!! note\n        This function also accepts all other `rich.console.Console` options.\n    \"\"\"\n    printer = self.__get_printer(printer, **options)\n    with printer.console.pager(styles=True, links=True):\n        self.print(printer)\n</code></pre>"},{"location":"reference/kirin/print/printable/#kirin.print.printable.Printable.print","title":"print","text":"<pre><code>print(\n    printer: Printer | None = None,\n    end: str = \"\\n\",\n    **options: Unpack[\"_PrintOptions\"]\n) -&gt; None\n</code></pre> <p>Entry point of the printing process.</p> <p>Parameters:</p> Name Type Description Default <code>printer</code> <code>Printer</code> <p><code>Printer</code> object to use for printing. If None, a new <code>Printer</code> object will be created.</p> <code>None</code> <p>Other Parameters:</p> Name Type Description <code>console</code> <code>Console</code> <p>The console to use for printing. If not provided, a new console will be created.</p> <code>analysis</code> <code>dict[SSAValue, Printable]</code> <p>Analysis results to use for printing. If <code>None</code>, no analysis results</p> <code>show_indent_mark</code> <code>bool</code> <p>Whether to show the indentation mark.</p> <code>theme</code> <code>Theme | dict | str</code> <p>The theme to use for printing, defaults to \"dark\".</p> <p>Note</p> <p>This function also accepts all other <code>rich.console.Console</code> options.</p> Source code in <code>src/kirin/print/printable.py</code> <pre><code>def print(\n    self,\n    printer: Printer | None = None,\n    end: str = \"\\n\",\n    **options: Unpack[\"_PrintOptions\"],\n) -&gt; None:\n    \"\"\"\n    Entry point of the printing process.\n\n    Args:\n        printer (Printer):\n            `Printer` object to use for printing.\n            If None, a new `Printer` object will be created.\n\n    Keyword Args:\n        console (rich.Console):\n            The console to use for printing. If not provided, a new console\n            will be created.\n        analysis (dict[ir.SSAValue, Printable]):\n            Analysis results to use for printing. If `None`, no analysis results\n        show_indent_mark (bool):\n            Whether to show the indentation mark.\n        theme (Theme | dict | str):\n            The theme to use for printing, defaults to \"dark\".\n\n    !!! note\n        This function also accepts all other `rich.console.Console` options.\n    \"\"\"\n    printer = self.__get_printer(printer, **options)\n    self.print_impl(printer)\n    printer.plain_print(end)\n</code></pre>"},{"location":"reference/kirin/print/printable/#kirin.print.printable.Printable.print_str","title":"print_str","text":"<pre><code>print_str(\n    printer: Printer | None = None,\n    end: str = \"\\n\",\n    **options: Unpack[\"_PrintOptions\"]\n) -&gt; str\n</code></pre> <p>Print the object to a string.</p> <p>Parameters:</p> Name Type Description Default <code>printer</code> <code>Printer</code> <p><code>Printer</code> object to use for printing. If None, a new <code>Printer</code> object will be created.</p> <code>None</code> <p>Other Parameters:</p> Name Type Description <code>console</code> <code>Console</code> <p>The console to use for printing. If not provided, a new console will be created.</p> <code>analysis</code> <code>dict[SSAValue, Printable]</code> <p>Analysis results to use for printing. If <code>None</code>, no analysis results</p> <code>show_indent_mark</code> <code>bool</code> <p>Whether to show the indentation mark.</p> <code>theme</code> <code>Theme | dict | str</code> <p>The theme to use for printing, defaults to \"dark\".</p> <p>Note</p> <p>This function also accepts all other <code>rich.console.Console</code> options.</p> Source code in <code>src/kirin/print/printable.py</code> <pre><code>def print_str(\n    self,\n    printer: Printer | None = None,\n    end: str = \"\\n\",\n    **options: Unpack[\"_PrintOptions\"],\n) -&gt; str:\n    \"\"\"Print the object to a string.\n\n    Args:\n        printer (Printer):\n            `Printer` object to use for printing.\n            If None, a new `Printer` object will be created.\n\n    Keyword Args:\n        console (rich.Console):\n            The console to use for printing. If not provided, a new console\n            will be created.\n        analysis (dict[ir.SSAValue, Printable]):\n            Analysis results to use for printing. If `None`, no analysis results\n        show_indent_mark (bool):\n            Whether to show the indentation mark.\n        theme (Theme | dict | str):\n            The theme to use for printing, defaults to \"dark\".\n\n    !!! note\n        This function also accepts all other `rich.console.Console` options.\n    \"\"\"\n    printer = self.__get_printer(printer, **options)\n    with printer.string_io() as stream:\n        self.print(printer, end=end, **options)\n        return stream.getvalue()\n</code></pre>"},{"location":"reference/kirin/print/printer/","title":"Printer","text":""},{"location":"reference/kirin/print/printer/#kirin.print.printer.PrintState","title":"PrintState  <code>dataclass</code>","text":"<pre><code>PrintState(\n    ssa_id: IdTable[ir.SSAValue] = IdTable[\"ir.SSAValue\"](),\n    block_id: IdTable[ir.Block] = lambda: IdTable[\n        \"ir.Block\"\n    ](prefix=\"^\")(),\n    indent: int = 0,\n    result_width: int = 0,\n    indent_marks: list[int] = list(),\n    rich_style: str | None = None,\n    rich_highlight: bool | None = False,\n    messages: list[str] = list(),\n)\n</code></pre>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.PrintState.result_width","title":"result_width  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result_width: int = 0\n</code></pre> <p>SSA-value column width in printing</p>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer","title":"Printer  <code>dataclass</code>","text":"<pre><code>Printer(\n    console: Console = _default_console(),\n    analysis: dict[ir.SSAValue, Any] | None = None,\n    hint: str | None = None,\n    state: PrintState = PrintState(),\n    *,\n    show_indent_mark: bool = True,\n    theme: Theme | dict | Literal[\"dark\", \"light\"] = \"dark\"\n)\n</code></pre> <p>A IR pretty printer build on top of Rich console.</p>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.analysis","title":"analysis  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>analysis: dict[SSAValue, Any] | None = None\n</code></pre> <p>Analysis results</p>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.console","title":"console  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>console: Console = field(default_factory=_default_console)\n</code></pre> <p>Rich console</p>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.hint","title":"hint  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hint: str | None = None\n</code></pre> <p>key of the SSAValue hint to print</p>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.show_indent_mark","title":"show_indent_mark  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>show_indent_mark: bool = field(default=True, kw_only=True)\n</code></pre> <p>Whether to show indent marks, e.g \u2502</p>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.state","title":"state  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>state: PrintState = field(default_factory=PrintState)\n</code></pre> <p>Printing state</p>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.theme","title":"theme  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>theme: Theme | dict | Literal[\"dark\", \"light\"] = field(\n    default=\"dark\", kw_only=True\n)\n</code></pre> <p>Theme to use for printing</p>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.align","title":"align","text":"<pre><code>align(width: int) -&gt; Generator[PrintState, Any, None]\n</code></pre> <p>align the result column width, and restore it after the context.</p> <p>Parameters:</p> Name Type Description Default <code>width(int)</code> <p>width of the column</p> required <p>Yields:</p> Name Type Description <code>PrintState</code> <code>PrintState</code> <p>the state with the new column width</p> Source code in <code>src/kirin/print/printer.py</code> <pre><code>@contextmanager\ndef align(self, width: int) -&gt; Generator[PrintState, Any, None]:\n    \"\"\"align the result column width, and restore it after the context.\n\n    Args:\n        width(int): width of the column\n\n    Yields:\n        PrintState: the state with the new column width\n    \"\"\"\n    old_width = self.state.result_width\n    self.state.result_width = width\n    try:\n        yield self.state\n    finally:\n        self.state.result_width = old_width\n</code></pre>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.debug","title":"debug","text":"<pre><code>debug(message: str)\n</code></pre> <p>Print a debug message.</p> Source code in <code>src/kirin/print/printer.py</code> <pre><code>def debug(self, message: str):\n    \"\"\"Print a debug message.\"\"\"\n    self.state.messages.append(f\"DEBUG: {message}\")\n</code></pre>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.indent","title":"indent","text":"<pre><code>indent(\n    increase: int = 2, mark: bool | None = None\n) -&gt; Generator[PrintState, Any, None]\n</code></pre> <p>increase the indentation level, and restore it after the context.</p> <p>Parameters:</p> Name Type Description Default <code>increase(int)</code> <p>amount to increase the indentation level, default to 2</p> required <code>mark(bool)</code> <p>whether to mark the indentation level, default to None</p> required <p>Yields:</p> Name Type Description <code>PrintState</code> <code>PrintState</code> <p>the state with the new indentation level.</p> Source code in <code>src/kirin/print/printer.py</code> <pre><code>@contextmanager\ndef indent(\n    self, increase: int = 2, mark: bool | None = None\n) -&gt; Generator[PrintState, Any, None]:\n    \"\"\"increase the indentation level, and restore it after the context.\n\n    Args:\n        increase(int): amount to increase the indentation level, default to 2\n        mark(bool): whether to mark the indentation level, default to None\n\n    Yields:\n        PrintState: the state with the new indentation level.\n    \"\"\"\n    mark = mark if mark is not None else self.show_indent_mark\n    self.state.indent += increase\n    if mark:\n        self.state.indent_marks.append(self.state.indent)\n    try:\n        yield self.state\n    finally:\n        self.state.indent -= increase\n        if mark:\n            self.state.indent_marks.pop()\n</code></pre>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.plain_print","title":"plain_print","text":"<pre><code>plain_print(\n    *objects, sep=\"\", end=\"\", style=None, highlight=None\n)\n</code></pre> <p>print objects without any formatting.</p> <p>Parameters:</p> Name Type Description Default <code>*objects</code> <p>objects to print</p> <code>()</code> <p>Other Parameters:</p> Name Type Description <code>sep(str)</code> <p>separator between objects, default to \"\"</p> <code>end(str)</code> <p>end character, default to \"\"</p> <code>style(str)</code> <p>style to use, default to None</p> <code>highlight(bool)</code> <p>whether to highlight the text, default to None</p> Source code in <code>src/kirin/print/printer.py</code> <pre><code>def plain_print(self, *objects, sep=\"\", end=\"\", style=None, highlight=None):\n    \"\"\"print objects without any formatting.\n\n    Args:\n        *objects: objects to print\n\n    Keyword Args:\n        sep(str): separator between objects, default to \"\"\n        end(str): end character, default to \"\"\n        style(str): style to use, default to None\n        highlight(bool): whether to highlight the text, default to None\n    \"\"\"\n    self.console.out(\n        *objects,\n        sep=sep,\n        end=end,\n        style=style or self.state.rich_style,\n        highlight=highlight or self.state.rich_highlight,\n    )\n</code></pre>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.print","title":"print","text":"<pre><code>print(object)\n</code></pre> <p>entry point for printing an object</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <p>object to print.</p> required Source code in <code>src/kirin/print/printer.py</code> <pre><code>def print(self, object):\n    \"\"\"entry point for printing an object\n\n    Args:\n        object: object to print.\n    \"\"\"\n    if isinstance(object, Printable):\n        object.print_impl(self)\n    else:\n        fn = getattr(self, f\"print_{object.__class__.__name__}\", None)\n        if fn is None:\n            raise NotImplementedError(\n                f\"Printer for {object.__class__.__name__} not found\"\n            )\n        fn(object)\n</code></pre>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.print_dialect_path","title":"print_dialect_path","text":"<pre><code>print_dialect_path(\n    node: Union[ir.Attribute, ir.Statement],\n    prefix: str = \"\",\n) -&gt; None\n</code></pre> <p>print the dialect path of a node.</p> <p>Parameters:</p> Name Type Description Default <code>node(ir.Attribute</code> <code>| ir.Statement</code> <p>node to print</p> required <code>prefix(str)</code> <p>prefix to print before the dialect path, default to \"\"</p> required Source code in <code>src/kirin/print/printer.py</code> <pre><code>def print_dialect_path(\n    self, node: Union[\"ir.Attribute\", \"ir.Statement\"], prefix: str = \"\"\n) -&gt; None:\n    \"\"\"print the dialect path of a node.\n\n    Args:\n        node(ir.Attribute | ir.Statement): node to print\n        prefix(str): prefix to print before the dialect path, default to \"\"\n    \"\"\"\n    if node.dialect:  # not None\n        self.plain_print(prefix)\n        self.plain_print(node.dialect.name, style=\"dialect\")\n    else:\n        self.plain_print(prefix)\n</code></pre>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.print_indent","title":"print_indent","text":"<pre><code>print_indent()\n</code></pre> <p>print the current indentation level optionally with indent marks.</p> Source code in <code>src/kirin/print/printer.py</code> <pre><code>def print_indent(self):\n    \"\"\"print the current indentation level optionally with indent marks.\"\"\"\n    indent_str = \"\"\n    if self.show_indent_mark and self.state.indent_marks:\n        indent_str = \"\".join(\n            \"\u2502\" if i in self.state.indent_marks else \" \"\n            for i in range(self.state.indent)\n        )\n        with self.rich(style=\"comment\"):\n            self.plain_print(indent_str)\n    else:\n        indent_str = \" \" * self.state.indent\n        self.plain_print(indent_str)\n</code></pre>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.print_mapping","title":"print_mapping","text":"<pre><code>print_mapping(\n    elems: dict[KeyType, ValueType],\n    *,\n    emit: Callable[[ValueType], None] | None = None,\n    delim: str = \", \"\n) -&gt; None\n</code></pre> <p>print a mapping of key-value pairs.</p> <p>Parameters:</p> Name Type Description Default <code>elems(dict[KeyType,</code> <code>ValueType]</code> <p>mapping to print</p> required <p>Other Parameters:</p> Name Type Description <code>emit(Callable[[ValueType],</code> <code>None]</code> <p>function to print each value, default to None</p> <code>delim(str)</code> <p>delimiter between key-value pairs, default to \", \"</p> Source code in <code>src/kirin/print/printer.py</code> <pre><code>def print_mapping(\n    self,\n    elems: dict[KeyType, ValueType],\n    *,\n    emit: Callable[[ValueType], None] | None = None,\n    delim: str = \", \",\n) -&gt; None:\n    \"\"\"print a mapping of key-value pairs.\n\n    Args:\n        elems(dict[KeyType, ValueType]): mapping to print\n\n    Keyword Args:\n        emit(Callable[[ValueType], None]): function to print each value, default to None\n        delim(str): delimiter between key-value pairs, default to \", \"\n    \"\"\"\n    emit = emit or self.print\n    for i, (key, value) in enumerate(elems.items()):\n        if i &gt; 0:\n            self.plain_print(delim)\n        self.plain_print(f\"{key}=\")\n        emit(value)\n</code></pre>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.print_name","title":"print_name","text":"<pre><code>print_name(\n    node: Union[ir.Attribute, ir.Statement],\n    prefix: str = \"\",\n) -&gt; None\n</code></pre> <p>print the name of a node</p> <p>Parameters:</p> Name Type Description Default <code>node(ir.Attribute</code> <code>| ir.Statement</code> <p>node to print</p> required <code>prefix(str)</code> <p>prefix to print before the name, default to \"\"</p> required Source code in <code>src/kirin/print/printer.py</code> <pre><code>def print_name(\n    self, node: Union[\"ir.Attribute\", \"ir.Statement\"], prefix: str = \"\"\n) -&gt; None:\n    \"\"\"print the name of a node\n\n    Args:\n        node(ir.Attribute | ir.Statement): node to print\n        prefix(str): prefix to print before the name, default to \"\"\n    \"\"\"\n    self.print_dialect_path(node, prefix=prefix)\n    if node.dialect:\n        self.plain_print(\".\")\n    self.plain_print(node.name)\n</code></pre>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.print_newline","title":"print_newline","text":"<pre><code>print_newline()\n</code></pre> <p>print a newline character.</p> <p>This method also prints any messages in the state for debugging.</p> Source code in <code>src/kirin/print/printer.py</code> <pre><code>def print_newline(self):\n    \"\"\"print a newline character.\n\n    This method also prints any messages in the state for debugging.\n    \"\"\"\n    self.plain_print(\"\\n\")\n\n    if self.state.messages:\n        for message in self.state.messages:\n            self.plain_print(message)\n            self.plain_print(\"\\n\")\n        self.state.messages.clear()\n    self.print_indent()\n</code></pre>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.print_seq","title":"print_seq","text":"<pre><code>print_seq(\n    seq: Iterable[ElemType],\n    *,\n    emit: Callable[[ElemType], None] | None = None,\n    delim: str = \", \",\n    prefix: str = \"\",\n    suffix: str = \"\",\n    style=None,\n    highlight=None\n) -&gt; None\n</code></pre> <p>print a sequence of objects.</p> <p>Parameters:</p> Name Type Description Default <code>seq(Iterable[ElemType])</code> <p>sequence of objects to print</p> required <p>Other Parameters:</p> Name Type Description <code>emit(Callable[[ElemType],</code> <code>None]</code> <p>function to print each element, default to None</p> <code>delim(str)</code> <p>delimiter between elements, default to \", \"</p> <code>prefix(str)</code> <p>prefix to print before the sequence, default to \"\"</p> <code>suffix(str)</code> <p>suffix to print after the sequence, default to \"\"</p> <code>style(str)</code> <p>style to use, default to None</p> <code>highlight(bool)</code> <p>whether to highlight the text, default to None</p> Source code in <code>src/kirin/print/printer.py</code> <pre><code>def print_seq(\n    self,\n    seq: Iterable[ElemType],\n    *,\n    emit: Callable[[ElemType], None] | None = None,\n    delim: str = \", \",\n    prefix: str = \"\",\n    suffix: str = \"\",\n    style=None,\n    highlight=None,\n) -&gt; None:\n    \"\"\"print a sequence of objects.\n\n    Args:\n        seq(Iterable[ElemType]): sequence of objects to print\n\n    Keyword Args:\n        emit(Callable[[ElemType], None]): function to print each element, default to None\n        delim(str): delimiter between elements, default to \", \"\n        prefix(str): prefix to print before the sequence, default to \"\"\n        suffix(str): suffix to print after the sequence, default to \"\"\n        style(str): style to use, default to None\n        highlight(bool): whether to highlight the text, default to None\n    \"\"\"\n    emit = emit or self.print\n    self.plain_print(prefix, style=style, highlight=highlight)\n    for idx, item in enumerate(seq):\n        if idx &gt; 0:\n            self.plain_print(delim, style=style)\n        emit(item)\n    self.plain_print(suffix, style=style, highlight=highlight)\n</code></pre>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.result_str","title":"result_str","text":"<pre><code>result_str(results: list[ir.ResultValue]) -&gt; str\n</code></pre> <p>return the string representation of a list of result values.</p> <p>Parameters:</p> Name Type Description Default <code>results(list[ir.ResultValue])</code> <p>list of result values to print</p> required Source code in <code>src/kirin/print/printer.py</code> <pre><code>def result_str(self, results: list[\"ir.ResultValue\"]) -&gt; str:\n    \"\"\"return the string representation of a list of result values.\n\n    Args:\n        results(list[ir.ResultValue]): list of result values to print\n    \"\"\"\n    with self.string_io() as stream:\n        self.print_seq(results, delim=\", \")\n        result_str = stream.getvalue()\n    return result_str\n</code></pre>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.result_width","title":"result_width","text":"<pre><code>result_width(stmts: Iterable[ir.Statement]) -&gt; int\n</code></pre> <p>return the maximum width of the result column for a sequence of statements.</p> <p>Parameters:</p> Name Type Description Default <code>stmts(Iterable[ir.Statement])</code> <p>sequence of statements</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>maximum width of the result column</p> Source code in <code>src/kirin/print/printer.py</code> <pre><code>def result_width(self, stmts: Iterable[\"ir.Statement\"]) -&gt; int:\n    \"\"\"return the maximum width of the result column for a sequence of statements.\n\n    Args:\n        stmts(Iterable[ir.Statement]): sequence of statements\n\n    Returns:\n        int: maximum width of the result column\n    \"\"\"\n    result_width = 0\n    for stmt in stmts:\n        result_width = max(result_width, len(self.result_str(stmt._results)))\n    return result_width\n</code></pre>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.rich","title":"rich","text":"<pre><code>rich(\n    style: str | None = None, highlight: bool = False\n) -&gt; Generator[PrintState, Any, None]\n</code></pre> <p>set the rich style and highlight, and restore them after the context.</p> <p>Parameters:</p> Name Type Description Default <code>style(str</code> <code>| None</code> <p>style to use, default to None</p> required <code>highlight(bool)</code> <p>whether to highlight the text, default to False</p> required <p>Yields:</p> Name Type Description <code>PrintState</code> <code>PrintState</code> <p>the state with the new style and highlight.</p> Source code in <code>src/kirin/print/printer.py</code> <pre><code>@contextmanager\ndef rich(\n    self, style: str | None = None, highlight: bool = False\n) -&gt; Generator[PrintState, Any, None]:\n    \"\"\"set the rich style and highlight, and restore them after the context.\n\n    Args:\n        style(str | None): style to use, default to None\n        highlight(bool): whether to highlight the text, default to False\n\n    Yields:\n        PrintState: the state with the new style and highlight.\n    \"\"\"\n    old_style = self.state.rich_style\n    old_highlight = self.state.rich_highlight\n    self.state.rich_style = style\n    self.state.rich_highlight = highlight\n    try:\n        yield self.state\n    finally:\n        self.state.rich_style = old_style\n        self.state.rich_highlight = old_highlight\n</code></pre>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.string_io","title":"string_io","text":"<pre><code>string_io() -&gt; Generator[io.StringIO, Any, None]\n</code></pre> <p>Temporary string IO for capturing output.</p> <p>Yields:</p> Type Description <code>StringIO</code> <p>io.StringIO: the string IO object.</p> Source code in <code>src/kirin/print/printer.py</code> <pre><code>@contextmanager\ndef string_io(self) -&gt; Generator[io.StringIO, Any, None]:\n    \"\"\"Temporary string IO for capturing output.\n\n    Yields:\n        io.StringIO: the string IO object.\n    \"\"\"\n    stream = io.StringIO()\n    old_file = self.console.file\n    self.console.file = stream\n    try:\n        yield stream\n    finally:\n        self.console.file = old_file\n        stream.close()\n</code></pre>"},{"location":"reference/kirin/rewrite/","title":"Index","text":""},{"location":"reference/kirin/rewrite/abc/","title":"Abc","text":""},{"location":"reference/kirin/rewrite/abc/#kirin.rewrite.abc.RewriteRule","title":"RewriteRule  <code>dataclass</code>","text":"<pre><code>RewriteRule()\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>A rewrite rule that matches and rewrites IR nodes.</p> <p>The rewrite rule is applied to an IR node by calling the instance with the node as an argument. The rewrite rule should mutate the node instead of returning a new node. A <code>RewriteResult</code> should be returned to indicate whether the rewrite rule has done something, whether the rewrite rule should terminate, and whether the rewrite rule has exceeded the maximum number of iterations.</p>"},{"location":"reference/kirin/rewrite/alias/","title":"Alias","text":""},{"location":"reference/kirin/rewrite/apply_type/","title":"Apply type","text":""},{"location":"reference/kirin/rewrite/call2invoke/","title":"Call2invoke","text":""},{"location":"reference/kirin/rewrite/call2invoke/#kirin.rewrite.call2invoke.Call2Invoke","title":"Call2Invoke  <code>dataclass</code>","text":"<pre><code>Call2Invoke()\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <p>Rewrite a <code>Call</code> statement to an <code>Invoke</code> statement.</p>"},{"location":"reference/kirin/rewrite/chain/","title":"Chain","text":""},{"location":"reference/kirin/rewrite/chain/#kirin.rewrite.chain.Chain","title":"Chain  <code>dataclass</code>","text":"<pre><code>Chain(\n    rule: RewriteRule | Iterable[RewriteRule],\n    *others: RewriteRule\n)\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <p>Chain multiple rewrites together.</p> <p>The chain will apply each rewrite in order until one of the rewrites terminates.</p> Source code in <code>src/kirin/rewrite/chain.py</code> <pre><code>def __init__(self, rule: RewriteRule | Iterable[RewriteRule], *others: RewriteRule):\n    if isinstance(rule, RewriteRule):\n        self.rules = [rule, *others]\n    else:\n        assert (\n            others == ()\n        ), \"Cannot pass multiple positional arguments if the first argument is an iterable\"\n        self.rules = list(rule)\n</code></pre>"},{"location":"reference/kirin/rewrite/compactify/","title":"Compactify","text":""},{"location":"reference/kirin/rewrite/compactify/#kirin.rewrite.compactify.CFGCompactify","title":"CFGCompactify  <code>dataclass</code>","text":"<pre><code>CFGCompactify()\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <p>Compactify the CFG by removing dead blocks and merging blocks if the statement uses the SSACFG convention. Do nothing if given <code>ir.Region</code> or <code>ir.Block</code> due to no context of the region.</p> <p>To compactify hierarchical CFG, combine this rule with <code>kirin.rewrite.Walk</code> to recursively apply this rule to all statements.</p>"},{"location":"reference/kirin/rewrite/compactify/#kirin.rewrite.compactify.CFGEdge","title":"CFGEdge  <code>dataclass</code>","text":"<pre><code>CFGEdge(cfg: CFG)\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <p>Merge non-branching blocks on the edge of the CFG.</p> <p>Example:</p> <pre><code>/---&gt; [B] --&gt; [D] --&gt; [E]\n</code></pre> <p>[A]-----&gt; [C] -------------^</p> <p>[B] and [D] are non-branching blocks on the same edge. They can be merged into one block.</p> <pre><code>/---&gt; [B,D] --&gt; [E]\n</code></pre> <p>[A]-----&gt; [C] -------^</p>"},{"location":"reference/kirin/rewrite/compactify/#kirin.rewrite.compactify.CompactifyRegion","title":"CompactifyRegion  <code>dataclass</code>","text":"<pre><code>CompactifyRegion(cfg: CFG)\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <p>Wrapper to share the CFG object with same CFG region.</p> Source code in <code>src/kirin/rewrite/compactify.py</code> <pre><code>def __init__(self, cfg: CFG):\n    self.cfg = cfg\n    self.rule = Fixpoint(\n        Chain(\n            DeadBlock(cfg), Walk(DuplicatedBranch()), SkipBlock(cfg), CFGEdge(cfg)\n        )\n    )\n</code></pre>"},{"location":"reference/kirin/rewrite/compactify/#kirin.rewrite.compactify.DeadBlock","title":"DeadBlock  <code>dataclass</code>","text":"<pre><code>DeadBlock(cfg: CFG)\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <p>Compactify the CFG by removing dead blocks.</p>"},{"location":"reference/kirin/rewrite/compactify/#kirin.rewrite.compactify.DuplicatedBranch","title":"DuplicatedBranch  <code>dataclass</code>","text":"<pre><code>DuplicatedBranch()\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <p>Merge duplicated branches into a single branch.</p> <p>Example:</p> <pre><code>[A]--&gt;[B]\n  -----^\n</code></pre> <p>Merge the two branches into one without changing the CFG:</p> <pre><code>[A]--&gt;[B]\n</code></pre>"},{"location":"reference/kirin/rewrite/compactify/#kirin.rewrite.compactify.SkipBlock","title":"SkipBlock  <code>dataclass</code>","text":"<pre><code>SkipBlock(cfg: CFG)\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <p>Simplify a block that only contains a branch statement.</p>"},{"location":"reference/kirin/rewrite/cse/","title":"Cse","text":""},{"location":"reference/kirin/rewrite/dce/","title":"Dce","text":""},{"location":"reference/kirin/rewrite/fixpoint/","title":"Fixpoint","text":""},{"location":"reference/kirin/rewrite/fixpoint/#kirin.rewrite.fixpoint.Fixpoint","title":"Fixpoint  <code>dataclass</code>","text":"<pre><code>Fixpoint(rule: RewriteRule, max_iter: int = 32)\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <p>Apply a rewrite rule until a fixpoint is reached.</p> <p>The rewrite rule is applied to the node until the rewrite rule does not do anything.</p>"},{"location":"reference/kirin/rewrite/fixpoint/#kirin.rewrite.fixpoint.Fixpoint--parameters","title":"Parameters","text":"<ul> <li><code>map</code>: The rewrite rule to apply.</li> <li><code>max_iter</code>: The maximum number of iterations to apply the rewrite rule. Default is 32.</li> </ul>"},{"location":"reference/kirin/rewrite/fold/","title":"Fold","text":""},{"location":"reference/kirin/rewrite/getfield/","title":"Getfield","text":""},{"location":"reference/kirin/rewrite/getitem/","title":"Getitem","text":""},{"location":"reference/kirin/rewrite/inline/","title":"Inline","text":""},{"location":"reference/kirin/rewrite/inline/#kirin.rewrite.inline.Inline","title":"Inline  <code>dataclass</code>","text":"<pre><code>Inline(heuristic: Callable[[ir.Statement], bool])\n</code></pre> <p>               Bases: <code>RewriteRule</code></p>"},{"location":"reference/kirin/rewrite/inline/#kirin.rewrite.inline.Inline.heuristic","title":"heuristic  <code>instance-attribute</code>","text":"<pre><code>heuristic: Callable[[Statement], bool]\n</code></pre> <p>inline heuristic that determines whether a function should be inlined</p>"},{"location":"reference/kirin/rewrite/inline/#kirin.rewrite.inline.Inline.inline_call_like","title":"inline_call_like","text":"<pre><code>inline_call_like(\n    call_like: ir.Statement,\n    args: tuple[ir.SSAValue, ...],\n    region: ir.Region,\n)\n</code></pre> <p>Inline a function call-like statement</p> <p>Parameters:</p> Name Type Description Default <code>call_like</code> <code>Statement</code> <p>the call-like statement</p> required <code>args</code> <code>tuple[SSAValue, ...]</code> <p>the arguments of the call (first one is the callee)</p> required <code>region</code> <code>Region</code> <p>the region of the callee</p> required Source code in <code>src/kirin/rewrite/inline.py</code> <pre><code>def inline_call_like(\n    self,\n    call_like: ir.Statement,\n    args: tuple[ir.SSAValue, ...],\n    region: ir.Region,\n):\n    \"\"\"\n    Inline a function call-like statement\n\n    Args:\n        call_like (ir.Statement): the call-like statement\n        args (tuple[ir.SSAValue, ...]): the arguments of the call (first one is the callee)\n        region (ir.Region): the region of the callee\n    \"\"\"\n    # &lt;stmt&gt;\n    # &lt;stmt&gt;\n    # &lt;br (a, b, c)&gt;\n\n    # &lt;block (a, b,c)&gt;:\n    # &lt;block&gt;:\n    # &lt;block&gt;:\n    # &lt;br&gt;\n\n    # ^&lt;block&gt;:\n    # &lt;stmt&gt;\n    # &lt;stmt&gt;\n\n    # 1. we insert the entry block of the callee function\n    # 2. we insert the rest of the blocks into the parent region\n    # 3.1 if the return is in the entry block, means no control flow,\n    #     replace the call results with the return values\n    # 3.2 if the return is some of the blocks, means control flow,\n    #     split the current block into two, and replace the return with\n    #     the branch instruction\n    # 4. remove the call\n    if not call_like.parent_block:\n        return\n\n    if not call_like.parent_region:\n        return\n\n    # NOTE: we cannot change region because it may be used elsewhere\n    inline_region: ir.Region = region.clone()\n    parent_block: ir.Block = call_like.parent_block\n    parent_region: ir.Region = call_like.parent_region\n\n    # wrap what's after invoke into a block\n    after_block = ir.Block()\n    stmt = call_like.next_stmt\n    while stmt is not None:\n        stmt.detach()\n        after_block.stmts.append(stmt)\n        stmt = call_like.next_stmt\n\n    for result in call_like.results:\n        block_arg = after_block.args.append_from(result.type, result.name)\n        result.replace_by(block_arg)\n\n    parent_block_idx = parent_region._block_idx[parent_block]\n    entry_block = inline_region.blocks.popfirst()\n    idx, block = 0, entry_block\n    while block is not None:\n        idx += 1\n\n        if block.last_stmt and isinstance(block.last_stmt, func.Return):\n            block.last_stmt.replace_by(\n                cf.Branch(\n                    arguments=(block.last_stmt.value,),\n                    successor=after_block,\n                )\n            )\n\n        parent_region.blocks.insert(parent_block_idx + idx, block)\n        block = inline_region.blocks.popfirst()\n\n    parent_region.blocks.append(after_block)\n\n    # NOTE: we expect always to have an entry block\n    # but we still check for it cuz we are not gonna\n    # error for empty regions here.\n    if entry_block:\n        cf.Branch(\n            arguments=args,\n            successor=entry_block,\n        ).insert_before(call_like)\n    call_like.delete()\n    return\n</code></pre>"},{"location":"reference/kirin/rewrite/type_assert/","title":"Type assert","text":""},{"location":"reference/kirin/rewrite/walk/","title":"Walk","text":""},{"location":"reference/kirin/rewrite/walk/#kirin.rewrite.walk.Walk","title":"Walk  <code>dataclass</code>","text":"<pre><code>Walk(\n    rule: RewriteRule,\n    worklist: WorkList[IRNode] = WorkList(),\n    skip: Callable[[IRNode], bool] = lambda _: False,\n    reverse: bool = False,\n    region_first: bool = False,\n)\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <p>Walk through the IR nodes and apply a rewrite rule.</p> <p>The walk will apply the rewrite rule to each node in the IR tree in a depth-first order.</p>"},{"location":"reference/kirin/rewrite/walk/#kirin.rewrite.walk.Walk--parameters","title":"Parameters","text":"<ul> <li><code>map</code>: The rewrite rule to apply.</li> <li><code>reverse</code>: Whether to traverse the IR tree in reverse order. Default is <code>False</code>.</li> <li><code>region_first</code>: Whether to traverse the regions before the blocks. Default is <code>False</code>.</li> </ul>"},{"location":"reference/kirin/rewrite/wrap_const/","title":"Wrap const","text":""},{"location":"reference/kirin/rewrite/wrap_const/#kirin.rewrite.wrap_const.WrapConst","title":"WrapConst  <code>dataclass</code>","text":"<pre><code>WrapConst(frame: const.Frame)\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <p>Insert constant hints into the SSA values.</p> <p>Note</p> <p>This pass is not exactly the same as ConstantFold. ConstantFold only rewrites the SSAValue with <code>const.Value</code> into a constant statement. This rule, however, inserts the entire constant lattice into the SSAValue's hints. Thus enabling other rules/analysis to utilize the constant information beyond just <code>const.Value</code>.</p>"},{"location":"reference/kirin/rewrite/aggressive/","title":"Index","text":""},{"location":"reference/kirin/rewrite/aggressive/fold/","title":"Fold","text":""},{"location":"blog/archive/2025/","title":"2025","text":""}]}