{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\: )\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Kirin","text":"<p>Kirin is the Kernel Intermediate Representation Infrastructure. It is a compiler infrastructure for building compilers for embedded domain-specific languages (eDSLs) that target scientific computing kernels.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>MLIR-like dialects as composable python packages</li> <li>Generated Python frontend for your DSLs</li> <li>Pythonic API for building compiler passes</li> <li>Julia-like abstract interpretation framework</li> <li>Builtin support for interpretation</li> <li>Builtin support Python type system and type inference</li> <li>Type hinted via modern Python type hints</li> </ul>"},{"location":"#kirins-mission","title":"Kirin's mission","text":"<p>Compiler toolchain for scientists. Scientists are building domain-specific languages (DSLs) for scientific purposes. Most scientists do not have any compiler engineering background. On the other hand, these DSLs are often high-level, and their instructions are usually slower than the low-level instructions and thus result in smaller programs. No need to generate high quality LLVM IR/native binary most of the time! So there are some chances to simplify terminologies, interfaces for the none-pros, while allowing good interactivity and fast prototyping.</p> <p>For the interested, please read the Kirin's Mission blog post for more details.</p>"},{"location":"#acknowledgement","title":"Acknowledgement","text":"<p>While the mission and audience may be very different, Kirin has been deeply inspired by a few projects:</p> <ul> <li>MLIR, the concept of dialects and the way it is designed.</li> <li>xDSL, about how IR data structure &amp; interpreter should be designed in Python.</li> <li>Julia, abstract interpretation, and certain design choices for scientific community.</li> <li>JAX and numba, the frontend syntax and the way it is designed.</li> <li>Symbolics.jl and its predecessors, the design of rule-based rewriter.</li> </ul>"},{"location":"#quick-example-the-beer-language","title":"Quick Example: the <code>beer</code> language","text":"<p>In this example, we will mutate python's semantics to support a small eDSL (embedded domain-specific language) called <code>beer</code>. It describes the process of brewing beer and get drunk.</p> <p>Before we start, let's take a look at what would our <code>beer</code> language look like:</p> <pre><code>@beer\ndef main(x):\n    beer = NewBeer(\"budlight\") # (1)!\n    Pour(beer, 12) # (2)!\n    Drink(beer) # (3)!\n    Puke() # (4)!\n    if x &gt; 1: # (5)!\n        Drink(NewBeer(\"heineken\")) # (6)!\n    else:\n        Drink(NewBeer(\"tsingdao\")) # (7)!\n    return x + 1 # (8)!\n</code></pre> <ol> <li>The <code>NewBeer</code> statement creates a new beer object with a given brand.</li> <li>The <code>Pour</code> statement pours a beer object.</li> <li>The <code>Drink</code> statement drinks a beer object.</li> <li>The <code>Puke</code> statement pukes. Now we are drunk!</li> <li>Instead of a normal <code>if else</code> branching statement, we execute the branches randomly because we are drunk.</li> <li>The <code>Drink</code> statement drinks a <code>heineken</code> beer object for some possibility.</li> <li>The <code>Drink</code> statement drinks a <code>tsingdao</code> beer object for some possibility.</li> <li>Doing some math to get a result.</li> </ol> <p>The beer language is wrapped with a decorator <code>@beer</code> to indicate that the function is written in the <code>beer</code> language instead of normal Python. (think about how would you program GPU kernels in Python, or how would you use <code>jax.jit</code> and <code>numba.jit</code> decorators).</p> <p>You can run the <code>main</code> function as if it is a normal Python function.</p> <pre><code>main(1)\n</code></pre> <p>or you can inspect the compile result via</p> <pre><code>main.print()\n</code></pre> <p></p>"},{"location":"#defining-the-dialect","title":"Defining the dialect","text":"<p>First, let's define the dialect object, which is a registry for all the objects modeling the semantics.</p> <pre><code>from kirin import ir\n\ndialect = ir.Dialect(\"beer\")\n</code></pre>"},{"location":"#defining-the-statements","title":"Defining the statements","text":"<p>Next, we want to define a runtime value <code>Beer</code> for the <code>beer</code> language so that we may use later in our interpreter. This is just a standard Python <code>dataclass</code>.</p> <pre><code>from dataclasses import dataclass\n\n@dataclass\nclass Beer:\n    brand: str\n</code></pre> <p>Now, we can define the <code>beer</code> language's statements.</p> <pre><code>from kirin.decl import statement, info\nfrom kirin.dialects.py import types\n\n@statement(dialect=dialect)\nclass NewBeer(Statement):\n    name = \"new_beer\" # (1)!\n    traits = frozenset({ir.Pure()}) # (2)!\n    brand: ir.SSAValue = info.argument(types.String) # (3)!\n    result: ir.ResultValue = info.result(types.PyClass(Beer)) # (4)!\n</code></pre> <ol> <li>The <code>name</code> field specifies the name of the statement in the IR text format (e.g printing).</li> <li>The <code>traits</code> field specifies the statement's traits, in this case, it is a    pure function because each brand name uniquely identifies a    beer object.</li> <li>The <code>brand</code> field specifies the argument of the statement. It is a string value. The arguments    of a <code>Statement</code> must be <code>ir.SSAValue</code> objects with a    field specifier <code>info.argument</code> that optionally specifies the type of the argument. The type used    here is <code>types.String</code> which is not Python's type but a <code>TypeAttribute</code> object    from the <code>py.types</code> dialect.</li> <li>The <code>result</code> field specifies the result of the statement. Usually a statement only has one result    value. The type of the result must be <code>ir.ResultValue</code> with a field specifier     <code>info.result</code> that optionally specifies the type of the result.</li> </ol> <p>the <code>NewBeer</code> statement creates a new beer object with a given brand. Thus it takes a string as an argument and returns a <code>Beer</code> object. Click the plus sign above to see the corresponding explanation.</p> <pre><code>@statement(dialect=dialect)\nclass Drink(Statement):\n    name = \"drink\"\n    beverage: ir.SSAValue = info.argument(types.PyClass(Beer))\n</code></pre> <p>Similarly, we define <code>Drink</code> statement that takes a <code>Beer</code> object as an argument. The <code>types.PyClass</code> type from <code>py.type</code> dialect understands Python classes and can take a Python class as an argument to create a type attribute.</p> <pre><code>@statement(dialect=dialect)\nclass Pour(Statement):\n    name = \"pour\"\n    beverage: ir.SSAValue = info.argument(types.PyClass(Beer))\n    amount: ir.SSAValue = info.argument(types.Int)\n</code></pre> <p>The <code>Pour</code> statement takes a <code>Beer</code> object and an integer amount as arguments. The <code>types.Int</code> type is from the <code>py.types</code> dialect. Now we can define a more complicated statement that involves control flow.</p> <pre><code>@statement(dialect=dialect)\nclass RandomBranch(Statement):\n    name = \"random_br\"\n    traits = frozenset({IsTerminator()}) # (1)!\n    cond: SSAValue = info.argument(types.Bool) # (2)!\n    then_arguments: tuple[ir.SSAValue, ...] = info.argument() # (3)!\n    else_arguments: tuple[ir.SSAValue, ...] = info.argument() # (4)!\n    then_successor: ir.Block = info.block() # (5)!\n    else_successor: ir.Block = info.block() # (6)!\n</code></pre> <ol> <li>The <code>traits</code> field specifies that this statement is a terminator. A terminator is a statement that    ends a block. In this case, the <code>RandomBranch</code> statement is a terminator because it decides which    block to go next.</li> <li>The <code>cond</code> field specifies the condition of the branch. It is a boolean value.</li> <li>The <code>then_arguments</code> field specifies the arguments that are passed to the <code>then_successor</code> block. Unlike    previous examples, the <code>then_arguments</code> field is annotated with <code>tuple[ir.SSAValue, ...]</code>, which means    it takes a tuple of <code>ir.SSAValue</code> objects (like what it means in a <code>dataclass</code>).</li> <li>The <code>else_arguments</code> field specifies the arguments that are passed to the <code>else_successor</code> block.</li> <li>The <code>then_successor</code> field specifies the block that the control flow goes to if the condition is true.</li> <li>The <code>else_successor</code> field specifies the block that the control flow goes to if the condition is false.</li> </ol> <p>the <code>RandomBranch</code> statement is a terminator that takes a boolean condition and two tuples of arguments. However, unlike a normal <code>if else</code> branching statement, it does not execute the branches based on the condition. Instead, it randomly chooses one of the branches to execute.</p>"},{"location":"#defining-the-interpreter","title":"Defining the interpreter","text":"<p>Now with the statements defined, we can define how to interpret them</p> <pre><code>from kirin.interp import DialectInterpreter, Interpreter, ResultValue, Successor, impl\n\n@dialect.register\nclass BeerInterpreter(DialectInterpreter):\n    ...\n</code></pre> <p>the <code>BeerInterpreter</code> class is a subclass of <code>DialectInterpreter</code> that registers the implementation of each implementation. The implementation is a method decorated with <code>@impl</code> that executes the statement.</p> <pre><code>    @impl(NewBeer)\n    def new_beer(self, interp: Interpreter, stmt: NewBeer, values: tuple):\n        return ResultValue(Beer(values[0]))\n\n    @impl(Drink)\n    def drink(self, interp: Interpreter, stmt: Drink, values: tuple):\n        print(f\"Drinking {values[0].brand}\")\n        return ResultValue()\n\n    @impl(Pour)\n    def pour(self, interp: Interpreter, stmt: Pour, values: tuple):\n        print(f\"Pouring {values[0].brand} {values[1]}\")\n        return ResultValue()\n\n    @impl(Puke)\n    def puke(self, interp: Interpreter, stmt: Puke, values: tuple):\n        print(\"Puking!!!\")\n        return ResultValue()\n</code></pre> <p>Normally, most implementations are just straightforward like the above except that they will do more meaningful things than printing. The <code>ResultValue</code> object is a result type of the interpreter that saying the return value is just a normal tuple of values. This will be different when we implement interpretation for a terminator:</p> <pre><code>    @impl(RandomBranch)\n    def random_branch(self, interp: Interpreter, stmt: RandomBranch, values: tuple):\n        frame = interp.state.current_frame()\n        if randint(0, 1):\n            return Successor(\n                stmt.then_successor, *frame.get_values(stmt.then_arguments)\n            )\n        else:\n            return Successor(\n                stmt.else_successor, *frame.get_values(stmt.then_arguments)\n            )\n</code></pre> <p>The <code>random_branch</code> implementation randomly chooses one of the branches to execute. The return value is a <code>Successor</code> object that specifies the next block to execute and the arguments to pass to the block.</p>"},{"location":"#rewrite-python-if-else-statement-to-randombranch","title":"Rewrite Python <code>if else</code> statement to <code>RandomBranch</code>","text":"<p>Now we can define a rewrite pass that rewrites Python <code>if else</code> statement to <code>RandomBranch</code> statement. This is done by defining a subclass of <code>RewriteRule</code> and implementing the <code>rewrite_Statement</code> method. The <code>RewriteRule</code> class is a standard Python visitor on Kirin's IR.</p> <p>Here, we only need to implement the <code>rewrite_Statement</code> method to rewrite the <code>if else</code> statement to <code>RandomBranch</code>.</p> <pre><code>from kirin.dialects import cf # (1)!\nfrom kirin.rewrite import RewriteResult, RewriteRule # (2)!\n\n@dataclass\nclass RewriteToRandomBranch(RewriteRule):\n\n    def rewrite_Statement(self, node: ir.Statement) -&gt; RewriteResult: # (3)!\n        if not isinstance(node, cf.ConditionalBranch): # (4)!\n            return RewriteResult()\n        node.replace_by(\n            RandomBranch(\n                cond=node.cond,\n                then_arguments=node.then_arguments,\n                then_successor=node.then_successor,\n                else_arguments=node.else_arguments,\n                else_successor=node.else_successor,\n            )\n        )\n        return RewriteResult(has_done_something=True) # (5)!\n</code></pre> <ol> <li>Import the control flow dialect <code>cf</code> which is what Python <code>if else</code> statement compiles to by default in the <code>basic</code> dialect group.</li> <li>Import the <code>RewriteRule</code> class from the <code>rewrite</code> module.</li> <li>This is the signature of <code>rewrite_Statement</code> method. Your IDE should hint you the type signature so you can auto-complete it.</li> <li>Check if the statement is a <code>ConditionalBranch</code> statement. If it is not, return an empty <code>RewriteResult</code>.</li> <li>Replace the <code>ConditionalBranch</code> statement with a <code>RandomBranch</code> statement and return a <code>RewriteResult</code> that indicates the rewrite has been done. Every statement has a <code>replace_by</code> method that replaces the statement with another statement.</li> </ol>"},{"location":"#putting-everything-together","title":"Putting everything together","text":"<p>Now we can put everything together and finally create the <code>beer</code> decorator, and you do not need to figure out the complicated type hinting and decorator implementation because Kirin will do it for you!</p> <pre><code>from kirin.ir import dialect_group\nfrom kirin.prelude import basic_no_opt\nfrom kirin.rewrite import Fixpoint, Walk\n\n@dialect_group(basic_no_opt.add(dialect)) # (1)!\ndef beer(self): # (2)!\n    # some initialization if you need it\n    def run_pass(mt): # (3)!\n        Fixpoint(Walk(RandomWalkBranch())).rewrite(mt.code) # (4)!\n\n    return run_pass # (5)!\n</code></pre> <ol> <li>The <code>dialect_group</code> decorator specifies the dialect group that the <code>beer</code> dialect belongs to. In this case, instead of rebuilding the whole dialect group, we just add our <code>dialect</code> object to the <code>basic_no_opt</code> dialect group which provides all the basic Python semantics, such as math, function, closure, control flows, etc.</li> <li>The <code>beer</code> function is the decorator that will be used to decorate the <code>main</code> function.</li> <li>The <code>run_pass</code> function wraps all the passes that need to run on the input method. It optionally can take some arguments or keyword arguments that will be passed to the <code>beer</code> decorator.</li> <li>Inside the <code>run_pass</code> function, we will traverse the entire IR and rewrite all the <code>ConditionalBranch</code> statements to <code>RandomBranch</code> statements until no more rewrites can be done.</li> <li>Remember to return the <code>run_pass</code> function at the end of the <code>beer</code> function.</li> </ol> <p>This is it!</p>"},{"location":"#license","title":"License","text":"<p>Apache License 2.0 with LLVM Exceptions</p>"},{"location":"101/","title":"Compiler 101","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"101/#compiler-101-for-scientists","title":"Compiler 101 for scientists","text":"<p>In this section, we cover some common compiler concepts that are useful to know when working with Kirin.</p>"},{"location":"101/#static-single-assignment-ssa-form","title":"Static Single Assignment (SSA) Form","text":"<p>Kirin IR is in Static Single Assignment (SSA) form. This means that each variable is assigned exactly once. This makes it easier to reason about the program and allows for more aggressive optimizations.</p>"},{"location":"101/#what-is-purity","title":"What is purity?","text":"<p>A function is said to be pure if it has no side effects. In other word, a pure function is a function that only depends on its input arguments and produces a result. This means that the function does not modify any state outside of its scope. This is useful because it allows the compiler to optimize the function more aggressively.</p>"},{"location":"analysis/","title":"Analysis","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"analysis/#analysis","title":"Analysis","text":"<p>Kirin provides a framework for performing dataflow analysis on the IR. This is done via</p> <ul> <li>IR walking</li> <li>Abstract interpretation</li> </ul>"},{"location":"analysis/#lattice","title":"Lattice","text":"<p>A lattice is a set of values that are partially ordered. In Kirin IR, a lattice is a subclass of the <code>Lattice</code> ABC class. A lattice can be used to represent the result of a statement that has multiple possible results.</p>"},{"location":"codegen/","title":"Codegen","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"comparison/","title":"Comparison","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"contrib/","title":"Contributing","text":"<p>Please see Installation for instructions on how to set up your development environment.</p>"},{"location":"contrib/#pre-commit-hooks","title":"Pre-commit hooks","text":"<p>We use <code>pre-commit</code> to run the linter checks before you commit your changes. The pre-commit hooks are installed as part of the development dependencies. You can setup <code>pre-commit</code> using the following command:</p> <pre><code>pre-commit install\n</code></pre> <p>This will run the linter checks before you commit your changes. If the checks fail, the commit will be rejected. Most of the following sections can be checked by the pre-commit hooks.</p>"},{"location":"contrib/#running-the-tests","title":"Running the tests","text":"<p>We use <code>pytest</code> for testing. To run the tests, simply run:</p> <pre><code>pytest\n</code></pre> <p>or for a specific test file with the <code>-s</code> flag to show the output of the program:</p> <pre><code>pytest -s tests/test_program.py\n</code></pre> <p>lots of tests contains pretty printing of the IR themselves, so it's useful to see the output.</p>"},{"location":"contrib/#code-style","title":"Code style","text":"<p>We use <code>black</code> for code formatting. Besides the linter requirements, we also require the following good-to-have practices:</p>"},{"location":"contrib/#naming","title":"Naming","text":"<ul> <li>try not to use abbreviation as names, unless it's a common abbreviation like <code>idx</code> for <code>index</code></li> <li>try not create a lot of duplicated name prefix unless the extra information is necessary when accessing the class object.</li> <li>try to use <code>snake_case</code> for naming variables and functions, and <code>CamelCase</code> for classes.</li> </ul>"},{"location":"contrib/#comments","title":"Comments","text":"<ul> <li>try not to write comments, unless it's really necessary. The code should be self-explanatory.</li> <li>if you have to write comments, try to use <code>NOTE:</code>, <code>TODO:</code> <code>FIXME:</code> tags to make it easier to search for them.</li> </ul>"},{"location":"contrib/#documentation","title":"Documentation","text":"<p>We use <code>just</code> for mangaging command line tools and scripts. It should be installed when you run <code>uv sync</code>. To build the documentation, simply run:</p> <pre><code>just doc\n</code></pre> <p>This will launch a local server to preview the documentation. You can also run <code>just doc-build</code> to build the documentation without launching the server.</p>"},{"location":"contrib/#license","title":"License","text":"<p>By contributing to this project, you agree to license your contributions under the Apache License 2.0 with LLVM Exceptions.</p>"},{"location":"def/","title":"Declarations","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"def/#understanding-kirin-ir-declarations","title":"Understanding Kirin IR Declarations","text":"<p>In this section, we will learn about the terminology used in Kirin IR. This will help you understand the structure of the IR and how to write your own compiler using Kirin.</p> <p>Note</p> <p>The examples in this section will also contain the equivalent MLIR and xDSL code to help you understand the differences between them if you are already familiar with MLIR or xDSL.</p>"},{"location":"def/#dialect","title":"Dialect","text":"<p>The <code>Dialect</code> object is the main registry of all the statements and attributes that are available in the IR. You can create a dialect by just following:</p> <pre><code>from kirin import ir\ndialect = ir.Dialect(\"my_dialect\") # (1)!\n</code></pre> <ol> <li>The <code>Dialect</code> object is created with the name <code>my_dialect</code>.</li> </ol>"},{"location":"def/#dialect-groups","title":"Dialect Groups","text":"<p>A dialect group is a collection of dialects that can be used as a decorator for Python frontend. It is used to group multiple dialects together and define the passes, compiler options, and other configurations for the dialects.</p> <pre><code>from kirin.ir import Method, dialect_group\n\n@dialect_group(\n    [\n        base,\n        binop,\n        cmp,\n        unary,\n        assign,\n        attr,\n        boolop,\n        constant,\n        indexing,\n        func,\n    ]\n) # (1)!\ndef python_basic(self): # (2)!\n    def run_pass(mt: Method) -&gt; None: # (3)!\n        pass # (4)!\n    return run_pass\n</code></pre> <ol> <li>The <code>dialect_group</code> decorator is used to create a dialect group with the specified dialects. In this case, we construct a basic Python dialect that allows some basic operations.</li> <li>The <code>python_basic</code> function is the entry point of the dialect group. It takes a <code>self</code> argument, which is the <code>DialectGroup</code> object. This argument is used to access the definition of the dialect group and optionally update the dialect group.</li> <li>The <code>run_pass</code> function is the function that will be called when the dialect group is applied to a given Python function. This is where you can define the passes that will be applied to the method. See the next example.</li> </ol> <p>Note</p> <p>Unlike MLIR/LLVM, because Kirin focuses on kernel functions, the minimal unit of compilation is a function. Therefore, the compiler pass always passes a <code>ir.Method</code> object which contains a function-like statement (a statement has <code>ir.traits.CallableStmtInterface</code>).</p> <p>The above dialect group <code>python_basic</code> allows you to use it as following:</p> <pre><code>@python_basic\ndef my_function():\n    pass\n</code></pre> <p>However, if we want to run some compilation passes on the function, we need to define some passes in the <code>run_pass</code> function.</p> <pre><code>from kirin.passes.fold import Fold\n\n@dialect_group(python_basic) # (1)!\ndef python(self):\n    fold_pass = Fold(self) # (2)!\n\n    def run_pass(mt: Method, *, verify: bool = True, fold: bool = True) -&gt; None: # (3)!\n        if verify: # (4)!\n            mt.verify()\n\n        if fold: # (5)!\n            fold_pass(mt)\n    return run_pass\n</code></pre> <ol> <li>The <code>dialect_group</code> decorator can also take a dialect group as an argument. This will use the dialects defined in the given dialect group with different passes.</li> <li>The <code>Fold</code> pass is created when initializing the dialect group. This pass is used later when running the <code>run_pass</code> function.</li> <li>The <code>run_pass</code> function is the function that will be called when the dialect group is applied to a given Python function. This function takes a <code>mt</code> argument, which is the <code>ir.Method</code> object, and optional arguments <code>verify</code>, <code>fold</code>, and <code>aggressive</code>.</li> <li>If the <code>verify</code> argument is <code>True</code>, the method will be verified.</li> <li>If the <code>fold</code> argument is <code>True</code>, the <code>Fold</code> pass will be applied to the method.</li> </ol> <p>The above dialect group <code>python</code> allows you to use it as following:</p> <pre><code>@python(fold=True) # (1)!\ndef my_function():\n    pass\n</code></pre> <ol> <li>The <code>fold</code> argument here is passed to the <code>run_pass</code> function defined in the dialect group. Looks complicated? Don't worry, the <code>@dialect_group</code> decorator will handle everything including the type hints!</li> </ol>"},{"location":"def/#statement","title":"Statement","text":"<p>In Kirin IR, a statement describes an operation that can be executed. Statements are the building blocks that contain the semantics of the program.</p>"},{"location":"def/#defining-a-statement","title":"Defining a Statement","text":"<p>While a statement can be hand-written by inheriting <code>ir.Statement</code>, we provide a python-<code>dataclass</code>-like decorator <code>statement</code> and in combine with the <code>info.argument</code>,<code>info.result</code>,<code>info.region</code>, <code>info.block</code> field specifier to make it easier to define a statement.</p> KirinMLIRxDSL <pre><code>from kirin import ir\nfrom kirin.decl import statement, info\n\n@statement # (1)!\nclass MyStatement(ir.Statement): # (2)!\n    name = \"awesome\" # (3)!\n    traits = frozenset({ir.Pure()}) # (4)!\n    # blabla, we will talk about this later\n</code></pre> <ol> <li>the decorator <code>@statement</code> is used to generate implementations for the <code>MyStatement</code> class based on the fields defined in the class.</li> <li>The <code>MyStatement</code> class inherits from <code>ir.Statement</code>.</li> <li>The <code>name</code> field is the name of the statement, if your desired name is just <code>my_statement</code>, you can omit this field, <code>@statement</code> will automatically generate the name by converting the class name to snake case. The name is what will be used in text/pretty printing.</li> <li>The <code>traits</code> field is used to specify the traits of the statement. In this case, the statement is pure.</li> </ol> <pre><code>\n</code></pre> <pre><code>\n</code></pre> <p>Like a function, a statement can have multiple inputs and outputs.</p> KirinMLIRxDSL <pre><code>@statement # (1)!\nclass Add(ir.Statement):\n    traits = frozenset({ir.Pure()}) # (2)!\n    lhs: ir.SSAValue = info.argument(ir.types.Int) # (3)!\n    rhs: ir.SSAValue = info.argument(ir.types.Int) # (4)!\n    output: ir.ResultValue = info.result(ir.types.Int) # (5)!\n</code></pre> <ol> <li>the decorator <code>@statement</code> is used to generate implementations for the <code>MyStatement</code> class based on the fields defined in the class.</li> <li>The <code>traits</code> field is used to specify the traits of the statement. In this case, the statement is pure.</li> <li>The <code>lhs</code> field is the left-hand side input value of the statement. The field descriptor <code>info.argument</code> is used to specify the type of the input value.</li> <li>The <code>rhs</code> field is the right-hand side input value of the statement. The field descriptor <code>info.argument</code> is used to specify the type of the input value.</li> <li>The <code>output</code> field is the output value of the statement. The field descriptor <code>info.result</code> is used to specify the type of the output value.</li> </ol> <pre><code>\n</code></pre> <pre><code>\n</code></pre> <p>A statement can have blocks as successors, which describe the control flow of the program.</p> KirinMLIRxDSL <pre><code>@statement\nclass Branch(Statement):\n   name = \"br\"\n   traits = frozenset({IsTerminator()}) # (1)!\n\n   arguments: tuple[SSAValue, ...] # (2)!\n   successor: Block = info.block() # (3)!\n</code></pre> <ol> <li>The <code>traits</code> field is used to specify the traits of the statement. In this case, the statement is a terminator.</li> <li>The <code>arguments</code> field is the input values of the statement. Branch can take multiple arguments, <code>tuple[SSAValue, ...]</code> is used to specify that the field is a tuple of <code>SSAValue</code>. Note that only <code>...</code> is supported because if the number of arguments is known, we recommend specifying them explicitly.</li> <li>The <code>successor</code> field is the block that the statement will go to after execution. The field descriptor <code>info.block</code> is used to specify the type of the field.</li> </ol> <pre><code>\n</code></pre> <pre><code>\n</code></pre> <p>It can also have a region that contains other statements, for example, a function statement</p> KirinMLIRxDSL <pre><code>@statement\nclass Function(ir.Statement):\n   name = \"func\"\n   traits = frozenset({SSACFGRegion()}) # (1)!\n   sym_name: str = info.attribute(property=True) # (2)!\n   body: Region = info.region(multi=True) # (3)!\n</code></pre> <ol> <li>The <code>traits</code> field contains the <code>SSACFGRegion</code> trait, which indicates that the region in the statement is a standard control-flow graph.</li> <li>The <code>sym_name</code> field is the name of the function. In the <code>@statement</code> decorator, if a field annotated with normal Python types (not an IR node, e.g <code>ir.SSAValue</code>, <code>ir.Block</code>, <code>ir.Region</code>), it will be treated as a <code>PyAttr</code> attribute.</li> <li>The <code>body</code> field is the region that contains the statements of the function. The field descriptor <code>info.region</code> is used to specify this region can contain multiple blocks.</li> </ol> <pre><code>\n</code></pre> <pre><code>\n</code></pre>"},{"location":"def/#constructing-a-statement","title":"Constructing a Statement","text":"<p>Statements can be constructed in similar ways to constructing a normal Python <code>dataclass</code>. Taking the previous definitions as an example:</p> <pre><code>from kirin.dialects.py.constant import Constant\n\nlhs, rhs = Constant(1), Constant(2) # (1)!\nadd = Add(lhs.result, rhs=rhs.result) # (2)!\n</code></pre> <ol> <li>Two <code>Constant</code> statements are created with the value <code>1</code> and <code>2</code>.</li> <li>An <code>Add</code> statement is created with the <code>lhs</code> and <code>rhs</code> fields set to the results of the <code>lhs</code> and <code>rhs</code> statements. Like <code>@dataclass</code> unless specified by <code>kw_only=True</code>, the fields are positional.</li> </ol>"},{"location":"def/#block","title":"Block","text":"<p>A block is a sequence of statements that are executed in order. Optionally, a block can have arguments that are passed from the predecessor block and terminates with a terminator statement. Unlike <code>ir.Statement</code>, the <code>ir.Block</code> class is final and cannot be extended.</p>"},{"location":"def/#constructing-a-block","title":"Constructing a Block","text":"<p><code>Block</code> takes a <code>Sequence</code> of statements as an argument, e.g a list of statements.</p> <pre><code>from kirin import ir\nir.Block() # Block(_args=())\nir.Block([stmt_a, stmt_b])\n</code></pre> <p>continue the example from Constructing a Statement, we can construct a block like following:</p> <pre><code>block = ir.Block()\narg_x = block.args.append_from(ir.types.Any)\narg_y = block.args.append_from(ir.types.Any)\nblock.stmts.append(Add(arg_x, arg_y))\n</code></pre> <p>Note</p> <p>Every IR node in Kirin has a pretty printer that can be used to print the node in a human-readable format. Just call <code>.print</code> method. In the above example, we have</p> <p><pre><code>^0(%0, %1):\n    %2 = add(lhs=%0, rhs=%1) : !py.int\n</code></pre> which is the pretty-printed version of the block. You may notice this is similar to MLIR text format, which is intentional.</p>"},{"location":"def/#region","title":"Region","text":"<p>A region is a sequence of blocks that are connected by control flow. A region can contain multiple blocks and can be nested within another region via statements that contain a region field. Unlike <code>ir.Statement</code>, the <code>ir.Region</code> class is final and cannot be extended.</p>"},{"location":"def/#constructing-a-region","title":"Constructing a Region","text":"<p>Continuing the example from Constructing a Block, we can construct a region like following:</p> <pre><code>region = ir.Region([block])\n</code></pre> <p>pretty printing the region will give you</p> <pre><code>{\n  ^0(%1, %2):\n  \u2502 %0 = add(lhs=%1, rhs=%2) : !py.int\n}\n</code></pre>"},{"location":"def/#ssa-value","title":"SSA Value","text":"<p>An SSA value is a value that is assigned only once in the program. In Kirin IR, an SSA value is represented by the <code>ir.SSAValue</code> class. Most of the time, one does not need to construct the SSA value directly, as it is automatically created when constructing a statement.</p> <p>There are 3 types of SSA values:</p> <ul> <li><code>ir.SSAValue</code>: the base class of SSA values.</li> <li><code>ir.ResultValue</code>: SSA values that are the result of a statement, this object allows you to access the parent statement via <code>result.owner</code> property.</li> <li><code>ir.BlockArgument</code>: SSA values that are the arguments of a block.</li> </ul>"},{"location":"install/","title":"Installation","text":"<p>Kirin is available in PyPI and thus can be installed via <code>pip</code>. Install Kirin using the following command:</p> <pre><code>pip install kirin-toolchain\n</code></pre> <p>Kirin supports Python 3.9 or later. We recommend using Python 3.10+ for the best experience.</p> <p>We strongly recommend developing your compiler project using <code>uv</code>, which is the official development environment for Kirin. You can install <code>uv</code> using the following command:</p> Linux and macOSWindows <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <p>then</p> <pre><code>uv add kirin-toolchain\n</code></pre> <pre><code>powershell -ExecutionPolicy ByPass -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n</code></pre> <p>then</p> <pre><code>uv add kirin-toolchain\n</code></pre>"},{"location":"install/#kirin-and-its-friends","title":"Kirin and its friends","text":"<p>Kirin also comes with a few friends that you might find useful:</p> <ul> <li><code>bloqade-qasm</code>: (link missing) A quantum assembly language (QASM 2.0) dialect for Kirin with a builtin QASM 2.0 text format parser.</li> <li><code>bloqade</code>: (available soon) QuEra's SDK for next-gen error-corrected neutral-atom quantum computers.</li> </ul>"},{"location":"install/#development","title":"Development","text":"<p>If you want to contribute to Kirin, you can clone the repository from GitHub:</p> <pre><code>git clone https://github.com/QuEraComputing/kirin.git\n</code></pre> <p>We use <code>uv</code> to manage the development environment, after you install <code>uv</code>, you can install the development dependencies using the following command:</p> <pre><code>uv sync\n</code></pre> <p>Our code review requires that you pass the tests and the linting checks. We recommend you to install <code>pre-commit</code> to run the checks before you commit your changes, the command line tool <code>pre-commit</code> has been installed as part of the development dependencies. You can setup <code>pre-commit</code> using the following command:</p> <pre><code>pre-commit install\n</code></pre>"},{"location":"install/#requirements","title":"Requirements","text":"<p>Kirin requires the following dependencies:</p> <ul> <li><code>rich</code>: for pretty-printing</li> <li><code>type-extensions</code>: for type hints</li> <li><code>beartype</code>: for runtime type checking and analysis of type hints in the python dialect</li> </ul>"},{"location":"interp/","title":"Interpretation","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"interp/#interpretation","title":"Interpretation","text":"<p>Kirin provides a framework for interpreting the IR. There are multiple ways to interpret the IR:</p> <ol> <li>concrete interpretation, which evaluates the IR using concrete values like CPython.</li> <li>abstract interpretation, which evaluates the IR on lattice values. (See also Analysis)</li> <li>tree walking, which walks the IR tree and performs actions on each node. (See also Code Generation)</li> </ol> <p>this page will focus on concrete interpretation.</p>"},{"location":"interp/#concrete-interpretation","title":"Concrete Interpretation","text":""},{"location":"interp/#function-call-like-interpretation","title":"Function-call like interpretation","text":"<p>The concrete interpreter is essentially a dispatcher of implementations for each statement in the IR. For dialect developers, the main task is to implement a method table, taking the <code>py.binop</code> dialect as an example:</p> <pre><code>from kirin import interp # (1)!\n\nfrom . import stmts # (2)!\nfrom ._dialect import dialect # (3)!\n\n@dialect.register # (4)!\nclass PyMethodTable(interp.MethodTable): # (4)!\n\n    @interp.impl(stmts.Add) # (5)!\n    def add(self, interp, frame: interp.Frame, stmt: stmts.Add): # (6)!\n        return (frame.get(stmt.lhs) + frame.get(stmt.rhs),) # (7)!\n</code></pre> <ol> <li>Import the <code>interp</code> module.</li> <li>Import the statements module. This is defined similarly as Declaring Statements.</li> <li>Import the dialect object. This is defined in a similar way as Declaring Dialect.</li> <li>Register the method table with the dialect. This will push the method table to the dialect's registry. By default this will be registered under the key <code>\"main\"</code>, equivalent to <code>@dialect.register(key=\"main\")</code>.</li> <li>Mark the method as an implementation of the <code>Add</code> statement. This can be dispatched on the type of the statement, e.g to only mark the implementation for <code>Add(Int, Int)</code>, you can write <code>@interp.impl(stmts.Add, types.Int, types.Int)</code>, where <code>types</code> can be imported by <code>from kirin import types</code>.</li> <li>While this is enforced, it is recommended to type hint the frame and the statement so you can get the hinting from the IDE. The <code>@interp.impl</code> decorator will also type check if the method signature is correct.</li> <li>In the actual implementation, <code>frame.get</code> is used to get the value of the operands. This will return the value of the operand if it is defined in the frame, otherwise it will raise an <code>InterpreterError</code>. Most of the case, the return value should be a <code>tuple</code> of the results of the statement. In this case, there is only one result, so it is returned as a single-element tuple.</li> </ol> <p>What is a frame?</p> <p>A frame is a mapping of <code>SSAValue</code> to their actual values. It represents the state of a function-like statement that cuts the scope of the variables. The frame is passed to the method table so that the interpreter can get the values of the operands from current frame.</p>"},{"location":"interp/#control-flow-statements","title":"Control flow statements","text":"<p>Except these \"normal\" statements that act more like a function call, there are also control flow statements. For example, the <code>Branch</code> statement from <code>cf</code> dialect, defined as follows (see also Declaring Statements):</p> <pre><code>@statement(dialect=dialect)\nclass Branch(Statement):\n    name = \"br\"\n    traits = frozenset({IsTerminator()})\n\n    arguments: tuple[SSAValue, ...]\n    successor: Block = info.block()\n</code></pre> <p>When interpreting a <code>Branch</code> statement, instead of actually executing something, we would like to instruct the interpreter to jump to a successor block. This is done by returning a special value <code>interp.Successor</code>:</p> <pre><code>@dialect.register\nclass CfMethods(MethodTable):\n\n    @impl(Branch)\n    def branch(self, interp: Interpreter, frame: Frame, stmt: Branch):\n        return Successor(stmt.successor, *frame.get_values(stmt.arguments))\n</code></pre> <p>Similar to <code>frame.get</code>, <code>frame.get_values</code> is a convenience method to get the values of multiple operands at once.</p> <p>What is a successor?</p> <p>A successor is a tuple of a block and the values to be passed to the block. The interpreter will use this information to jump to the block and pass the values to the block.</p> <p>Another special control flow statement is <code>ReturnValue</code>, unlike <code>interp.Successor</code> that jumps to another block, <code>ReturnValue</code> will let interpreter pop the current frame and return the values to the caller or finish the execution:</p> <pre><code>@dialect.register\nclass FuncMethods(MethodTable):\n\n    @impl(Return)\n    def return_(self, interp: Interpreter, frame: Frame, stmt: Return):\n        return interp.ReturnValue(*frame.get_values(stmt.values))\n</code></pre>"},{"location":"interp/#error-handling","title":"Error handling","text":"<p>Some statements will throw a runtime error, such as <code>cf.Assert</code> from the <code>cf</code> dialect, defined as follows:</p> <pre><code>@statement(dialect=dialect)\nclass Assert(Statement):\n    name = \"assert\"\n    condition: SSAValue\n    message: SSAValue = info.argument(String)\n</code></pre> <p>When interpreting an <code>Assert</code> statement, we need to check the condition and raise an error if it is false:</p> <pre><code>@dialect.register\nclass CfMethods(MethodTable):\n\n    @impl(Assert)\n    def assert_stmt(self, interp: Interpreter, frame: Frame, stmt: Assert):\n        if frame.get(stmt.condition) is True:\n            return ()\n\n        if stmt.message:\n            raise interp.WrapException(AssertionError(frame.get(stmt.message)))\n        else:\n            raise interp.WrapException(AssertionError(\"Assertion failed\"))\n</code></pre> <p>or raising an <code>InterpreterError</code>:</p> <pre><code>@dialect.register\nclass CfMethods(MethodTable):\n\n    @impl(Assert)\n    def assert_stmt(self, interp: Interpreter, frame: Frame, stmt: Assert):\n        if frame.get(stmt.condition) is True:\n            return ()\n\n        if stmt.message:\n            raise InterpreterError(frame.get(stmt.message))\n        else:\n            raise InterpreterError(\"assertion failed\")\n</code></pre>"},{"location":"interp/#running-the-interpreter","title":"Running the interpreter","text":"<p>To run the interpreter, you just need to pass the method to <code>eval</code>:</p> <pre><code>from kirin.interp import Interpreter\nfrom kirin.prelude import basic\ninterp = Interpreter(basic)\n\n@basic\ndef main(a: int, b: int) -&gt; int:\n    return a + b\n\ninterp.eval(main, 1, 2)\n</code></pre>"},{"location":"interp/#overlaying","title":"Overlaying","text":"<p>One of the most powerful features of the interpreter is overlaying. This allows you to override the implementation of a statement in a dialect by picking different order of method table lookup or even customize the method lookup. This is done by inheriting <code>Interpreter</code> and define the class variable <code>keys</code>:</p> <pre><code>class MyInterpreter(Interpreter):\n    keys = [\"my_overlay\", \"main\"]\n</code></pre> <p>When using this new <code>MyInterpreter</code>, the method lookup will first look for the methods registered in the <code>my_overlay</code> key. If the method is not found, it will fall back to the <code>main</code> key. This allows you to override the implementation of a statement in a dialect without modifying the dialect itself.</p> <p>We will talk about overlaying in abstract interpretation and analysis section which has more use cases.</p>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/2024/11/11/kirins-mission/","title":"Kirin's Mission","text":"<p>The field of scientific software has seen great development in the past decade. Scientists have been building more and more sophisticated simulators (quantum circuit simulators, differential equation solvers,  differentiable solvers), and many different human controlable physical systems (neutral atoms, trapped ions, superconducting qubits, optical lattices, etc) that may be used for multiple purposes.</p> <p>These impressive progress urges the need for a more sophisticated way to interact with these simulators and physical systems. Yes, it's not just about new hardware, computation, afterall, is about how to compile a problem description to human-controlable physical systems. In software community, a domain-specific language (DSL) and a corresponding compiler is the way to go. However, building a DSL and a compiler is a non-trivial task, and it is not something that scientists are familiar with.</p> <p>This is why we are building Kirin - we want to provide a set of tools for scientists to build their own DSLs and making their DSLs composable with each other. This article is to explain the mission of Kirin, and why we are building it.</p>"},{"location":"blog/2024/11/11/kirins-mission/#the-fragmentation-of-scientific-software","title":"The fragmentation of scientific software","text":"<p>I cannot talk about all scientific software, but software for quantum many-body system are already quite fragmented. For example, there are many different ways to represent sets of quantum operators system mathematically, such as tensor networks, quantum circuits, ZX diagrams<sup>1</sup>, operator table<sup>2</sup>, symbolic expressions, Quon<sup>3</sup>, etc. Each of these representations may result in a few different DSLs due to different design tradeoffs. In the lab, experimentalists also have different languages, such as pulse sequences, movings, QASM, QIR, etc. Almost every university lab has their own representation of the device, depsite of the sanity (e.g see last section). People have often been thinking if we can create a unified representation for all these problems, but it is not easy. Instead, the dream is: if we can make representations composable, we can build a unified representation by composing different representations from the experts.</p> <p>We, at QuEra Computing Inc., naturally falls into this fragmentation problem, and thus have many duplicated representations in the past. Then the question is, how can we improve composability? There are already an answer in the software engineering community, which is the Multi-Level Intermediate Representation (MLIR). I like MLIR, but we are not using it. I will explain why.</p>"},{"location":"blog/2024/11/11/kirins-mission/#why-didnt-use-x","title":"Why didn't use X?","text":"<p>This is a common question that one may ask when they see a new project. Here are some reasons why we are not using previous work.</p>"},{"location":"blog/2024/11/11/kirins-mission/#why-not-use-mlir","title":"Why not use MLIR?","text":"<p>We have been trying to adopt MLIR since 2021, and we found that MLIR is a great project, but it is not easy to use for scientists. The scope of compilation problems that MLIR is trying to solve is too broad, and thus the complexity of the project is inevitably high. More specifically, we do not care about:</p> <ul> <li>low-level semantics</li> <li>traditional hardware targets</li> <li>high-quality native binary</li> <li>roundtrip-able IR text format</li> <li>speed of the compiler or the generated code <sup>4</sup></li> </ul> <p>We do care about:</p> <ul> <li>high-level semantics</li> <li>new optimization techniques for the scientific problems</li> <li>interpretation and JIT compilation</li> <li>a frontend that is easy to use for scientists</li> </ul> <p>In the quantum computing community, we have seen a lot of projects that are trying to build a quantum DSL and a compiler using MLIR. However, everyone will build</p> <ul> <li>their own set of dialects, including control-flow dialects</li> <li>Python frontend for the DSL</li> <li>another infrastructure to write IR passes in Python</li> </ul> <p>This is mainly because how to compile such program is still under research. Thus we expect normal scientists (e.g theoretical/experimental physicists) to write compiler passes. And it is impossible for them to learn MLIR within one week. As a result, MLIR was never adopted by broader quantum community.</p> <p>A few existing compilers focus on building an eDSL in Python then JIT compile the kernel to native binary. However, at least in our case, we have to decompile such native binary back to a JSON in order to run the program on a Python-based control system. It turns out what is really needed for a lot of scientists is:</p> <ul> <li>a way to write a high-level eDSL in Python (model of the problem)</li> <li>then run some rewrites (problem simplification/compilation)</li> <li>run it with an interpreter (model execution)</li> <li>optionally compile it to another IR then run it with another interpreter. (simulation)</li> </ul> <p>This seems to be the case not only for quantum physicists but other scientists such as the original machine-learning engineer's use case in supporting interpreter framework in MLIR. To support such use case, because MLIR needs to consider a lot more complicated senarios, it will take a lot of thinking to do it right.</p> <p>Big entities with sufficient bandwidth can afford doing this by hiring a lot of engineers with professional compiler engineering background, but for small companies and individual researchers, this is not feasible. We see the issue is due to the complexity of a generic problem, and the lack of involvement of scientists in the design of a compiler infrastructure. We believe that the solution is to build a more user-friendly compiler infrastructure by scientists for scientists. This is possible by limiting the program to</p> <ul> <li>only kernel functions (program size are small)</li> <li>only existing langauge (e.g Python) frontend (so that we can focus on designing composable lowering framework)</li> <li>focus on interpretation (or abstract interpretation), turn every compilation into different interpretation steps</li> <li>focus on Python-like type system</li> </ul>"},{"location":"blog/2024/11/11/kirins-mission/#why-not-use-xdsl","title":"Why not use xDSL?","text":"<p>Ok, after we have decided not to use MLIR, we were excited to see this project called xDSL around late 2023 and tried to play with it. However, we found that the project is still sophisticated for scientists to use. Mostly because the project is built by professional compiler engineers with a great familarity of MLIR. This is an advantage for the project to be able to support a wide range of problems and being able to interop with MLIR. The project is great, if you are interested in a friendlier version of MLIR in Python, you should definitely check it out. However, as a result, the priority of the project is not to build something scientists can get started with in a few days. What was missing from our wishlist is:</p> <ul> <li>composable Python lowering (e.g Python syntax claims from different dialects)</li> <li>different ways of interpretation (e.g abstract interpretation)</li> <li>Python type system instead of MLIR type attributes</li> <li>dialects that supports Python semantics instead of MLIR dialects</li> </ul> <p>while maybe eventually this would be in xDSL but more realistically, because the focus is quite different and xDSL was also new, the priorities are different.</p>"},{"location":"blog/2024/11/11/kirins-mission/#why-not-julia-compiler-plugin","title":"Why not Julia compiler plugin?","text":"<p>For those who are familiar with my past work, I have been working with Julia since 2015. This is a great language for scientific computing, and scientists with performance needs definitely love it. And in fact, the idea of building some infrastructure to help scientists to build their own DSLs and compilers was initially from the Julia community because of automatic differentiation and sparsity optimization (check the CompilerPlugin org and Symbolics+ModelingToolkit). To enable automatic differentiation, we also end up building a small DSL in Yao to represent quantum circuits. In fact, to support automatic differentiation well, a lot of packages end up building their own DSLs and compilers.</p> <p>However, when I start moving towards a compiler for quantum circuit (YaoCompiler), the instability of the Julia compiler internal API quickly becomes a problem. On the other hand, the Julia SSA IR was not designed for custom DSLs, e.g it does not have the region semantics to represent hierarchical IRs, and it does not have the abstraction of dialects to allow composing different DSLs. While we have seen some promising progress in MLIR.jl, the project is still in its early stage.</p> <p>On the other hand, I do get jelous of how Julia compiler solve the dynamic language compilation problem, thus I learnt a lot from the Julia compiler and the Julia compiler plugin. This results in the design of the Kirin type system, and the abstract interpretation framework. <sup>5</sup></p> <p>Python has been a hard requirement for us in building production software. But I reserve the right to use Julia to rewrite certain components of Kirin in the future.</p>"},{"location":"blog/2024/11/11/kirins-mission/#why-not-use-jaxpr","title":"Why not use JAXPR?","text":"<p>JAX is a great project for automatic differentiation and scientific computing. I have been using it extensively for a few projects. While it is true that JAXPR covers a wide range of scientific computing tasks, it is not designed for more complicated tasks like quantum compilation, especially when you work at levels lower than quantum circuits. The limitation of JAX is intentionally designed to allow only tracing-based compilation, thus it does not support native Python control flows, and may not have clear function barriers in the traced program unless you use <code>jit</code> to separate them. The runtime value is restricted to JAX arrays, etc. These tradeoffs may not always be suitable for building a quantum program. The JAX compiler is designed for differentiable/machine-learning linear algebra programs afterall.</p>"},{"location":"blog/2024/11/11/kirins-mission/#how-would-kirin-be-different","title":"How would Kirin be different?","text":"<p>While Kirin draws inspiration from MLIR, xDSL, Julia compiler plugin, and JAXPR, we aim to build a more user-friendly compiler infrastructure for scientists to solve their specific problems. There are nothing fundamentally new in theory, but the combination is new. Here are some key differences:</p> <p>Composable Python Lowering, in our beer-lang example, the kernel decorator <code>@beer</code> is just a <code>DialectGroup</code> object that contains the <code>Dialect</code> objects you specified to include for the frontend. The Python syntax just maginally works! This is because Kirin features a composable lowering system that allows you to claim Python syntax from each separate dialect. When combining the dialects together, Kirin will be able to compile each Python syntax to the corresponding IR nodes, e.g</p> <ul> <li><code>func</code> dialect claims function related syntax: the <code>ast.FunctionDef</code>, nested <code>ast.FunctionDef</code> (as closures), <code>ast.Call</code>, <code>ast.Return</code>, etc.</li> <li><code>cf</code> (unstructured control flow) dialect claims control flow related syntax: <code>ast.If</code>, <code>assert</code>.</li> <li><code>math</code> dialect claims python builtin math functions</li> <li><code>py.stmts</code> claims miscellaneous other Python statements, e.g assignment, comparison, slice, range, etc.</li> </ul> <p>You can define your own lowering rules for new dialects, and compose with other dialects to build your own frontend.</p> <p>Abstract Interpretation, inspired by Julia abstract interpreter, Kirin features a simple abstract interpretation framework that allows you to define how to interpret your own dialects on a given lattice. This allows Kirin to perform analysis such as constant propagation and type inference on your program. For example, like Julia, Kirin can perform constant propagation interprocedurally, and infer the types of your program, and this is composable with new dialects.</p> <p>Python Type System, based on the abstract interpretation framework, the <code>py.types</code> dialect defines a Python type system as Kirin type attributes. This allows dynamic and generic definitions of dialects. This becomes quite useful defining high-level Python-like semantics, such as a statement taking a list of integers, or a statement taking a callable object. Taking the example from tests, you can just write the following in your frontend and let Kirin figure out the types</p> <pre><code>@basic\ndef foo(x: int):\n    if x &gt; 1:\n        return x + 1\n    else:\n        return x - 1.0\n\n\n@basic(typeinfer=True)\ndef main(x: int):\n    return foo(x)\n\n\n@basic(typeinfer=True)\ndef moo(x):\n    return foo(x)\n</code></pre> <p>prints the following</p> <pre><code>moo.print()\n</code></pre> <p></p> <p>while <code>py.types</code> supports generics, the type inference is still work-in-progress on generics.</p> <p>IR Declaration Decorators, like <code>xDSL</code>, Kirin also provides the <code>statement</code> decorator to declare a new IR statement. However, the difference is Kirin focus on reducing extra terminologies and concepts that are not familiar to scientists with the cost of being more entangled with Python. The <code>statement</code> decorator is designed to be <code>@dataclass</code>-like, which is what scientists are familiar with. This is the only decorator one needs to know. Fields declared with native Python types are automatically converted to Kirin attributes via the Python type system.</p> <p>Taking an example from xDSL, you would define <code>Func</code> as</p> <pre><code>@irdl_op_definition\nclass FuncOp(IRDLOperation):\n    name = \"func.func\"\n\n    body = region_def()\n    sym_name = prop_def(StringAttr)\n    function_type = prop_def(FunctionType)\n    sym_visibility = opt_prop_def(StringAttr)\n    arg_attrs = opt_prop_def(ArrayAttr[DictionaryAttr])\n    res_attrs = opt_prop_def(ArrayAttr[DictionaryAttr])\n\n    traits = traits_def(\n        IsolatedFromAbove(), SymbolOpInterface(), FuncOpCallableInterface()\n    )\n</code></pre> <p>and you will need to define <code>__init__</code> etc. in the following. In Kirin, you would define <code>Func</code> as</p> <pre><code>@statement(dialect=dialect)\nclass Function(Statement):\n    name = \"func\"\n    traits = frozenset(\n        {\n            IsolatedFromAbove(),\n            SymbolOpInterface(),\n            HasSignature(),\n            FuncOpCallableInterface(),\n            SSACFGRegion(),\n        }\n    )\n    sym_name: str = info.attribute(property=True)\n    signature: Signature = info.attribute()\n    body: Region = info.region(multi=True)\n</code></pre> <p>which is a more <code>@dataclass</code>-like definition, where fields with types are instance fields, and fields without types are (class) properties. The <code>@statement</code> also generates the corresponding <code>__init__</code> etc. just like a <code>@dataclass</code> (and your linter understands it!).</p>"},{"location":"blog/2024/11/11/kirins-mission/#conclusion","title":"Conclusion","text":"<p>When we start thinking about these scientific problems seriously, there seems not many in the software engineering community that would worry about the scientists. The scientists are living with a lot of workaround solutions, including but not limited to \"define the language as a string, where each character represents an operation/statement, then let a human perform the control-flow\" (the man in-the-loop). The compiler community are often excited about programming language for everything. However, for scientific community, especially nature science, there seems to be a big gap between the compiler community and the natural-science community (e.g a physicist like me) to make this come true.</p> <p>Kirin in its current form, may not be perfect (likely). However, we hope we can share this same vision for the scientific software community. So that Kirin, as a vision, can bridge this gap and help scientists to push the boundary of science with scientific software.</p> <ol> <li> <p>ZX diagrams can be seen as tensor networks too, but the implementation is usually different data structure.\u00a0\u21a9</p> </li> <li> <p>Aaronson's stabilizer table, stochastic series expansion's operator table, etc.\u00a0\u21a9</p> </li> <li> <p>Quon is a 3D representation of quantum operators.\u00a0\u21a9</p> </li> <li> <p>this does not mean the program execution has to be very slow, e.g we can generate a different set of high-level IR that can be interpreted quickly (via optimized instruction implementation, etc.).\u00a0\u21a9</p> </li> <li> <p>Kirin does not support multiple dispatch at the moment, this may be added in the future. I'm hesitating to add multiple dispatch because this turns out less useful for kernels because they can be embeded in host language abstraction most of the time.\u00a0\u21a9</p> </li> </ol>"},{"location":"cookbook/","title":"Index","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"dialects/cf/","title":"Control Flow","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"dialects/cf/#kirin.dialects.cf.stmts.Branch","title":"Branch  <code>krin-statement</code>","text":"<pre><code>Branch(*, successor: Block)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/cf/#kirin.dialects.cf.stmts.Branch.arguments","title":"arguments  <code>instance-attribute</code>","text":"<pre><code>arguments: tuple[SSAValue, ...]\n</code></pre>"},{"location":"dialects/cf/#kirin.dialects.cf.stmts.Branch.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'br'\n</code></pre>"},{"location":"dialects/cf/#kirin.dialects.cf.stmts.Branch.successor","title":"successor  <code>kirin-block</code> <code>kw-only</code>","text":"<pre><code>successor: Block = block()\n</code></pre>"},{"location":"dialects/cf/#kirin.dialects.cf.stmts.Branch.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({IsTerminator()})\n</code></pre>"},{"location":"dialects/cf/#kirin.dialects.cf.stmts.Branch.print_impl","title":"print_impl","text":"<pre><code>print_impl(printer: Printer) -&gt; None\n</code></pre> Source code in <code>src/kirin/dialects/cf/stmts.py</code> <pre><code>def print_impl(self, printer: Printer) -&gt; None:\n    with printer.rich(style=\"keyword\"):\n        printer.print_name(self)\n\n    printer.plain_print(\" \")\n    printer.plain_print(printer.state.block_id[self.successor])\n    printer.print_seq(\n        self.arguments,\n        delim=\", \",\n        prefix=\"(\",\n        suffix=\")\",\n    )\n</code></pre>"},{"location":"dialects/cf/#kirin.dialects.cf.stmts.Branch.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>run mandatory validation checks. This is not same as typecheck, which may be optional.</p> Source code in <code>src/kirin/dialects/cf/stmts.py</code> <pre><code>def verify(self) -&gt; None:\n    return\n</code></pre>"},{"location":"dialects/cf/#kirin.dialects.cf.stmts.ConditionalBranch","title":"ConditionalBranch  <code>krin-statement</code>","text":"<pre><code>ConditionalBranch(\n    cond: SSAValue,\n    *,\n    then_successor: Block,\n    else_successor: Block\n)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/cf/#kirin.dialects.cf.stmts.ConditionalBranch.cond","title":"cond  <code>kirin-argument</code>","text":"<pre><code>cond: SSAValue = argument(Bool)\n</code></pre>"},{"location":"dialects/cf/#kirin.dialects.cf.stmts.ConditionalBranch.else_arguments","title":"else_arguments  <code>instance-attribute</code>","text":"<pre><code>else_arguments: tuple[SSAValue, ...]\n</code></pre>"},{"location":"dialects/cf/#kirin.dialects.cf.stmts.ConditionalBranch.else_successor","title":"else_successor  <code>kirin-block</code> <code>kw-only</code>","text":"<pre><code>else_successor: Block = block()\n</code></pre>"},{"location":"dialects/cf/#kirin.dialects.cf.stmts.ConditionalBranch.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'cond_br'\n</code></pre>"},{"location":"dialects/cf/#kirin.dialects.cf.stmts.ConditionalBranch.then_arguments","title":"then_arguments  <code>instance-attribute</code>","text":"<pre><code>then_arguments: tuple[SSAValue, ...]\n</code></pre>"},{"location":"dialects/cf/#kirin.dialects.cf.stmts.ConditionalBranch.then_successor","title":"then_successor  <code>kirin-block</code> <code>kw-only</code>","text":"<pre><code>then_successor: Block = block()\n</code></pre>"},{"location":"dialects/cf/#kirin.dialects.cf.stmts.ConditionalBranch.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({IsTerminator()})\n</code></pre>"},{"location":"dialects/cf/#kirin.dialects.cf.stmts.ConditionalBranch.print_impl","title":"print_impl","text":"<pre><code>print_impl(printer: Printer) -&gt; None\n</code></pre> Source code in <code>src/kirin/dialects/cf/stmts.py</code> <pre><code>def print_impl(self, printer: Printer) -&gt; None:\n    with printer.rich(style=\"keyword\"):\n        printer.print_name(self)\n\n    printer.plain_print(\" \")\n    printer.print(self.cond)\n\n    with printer.rich(style=\"keyword\"):\n        printer.plain_print(\" goto \")\n\n    printer.plain_print(printer.state.block_id[self.then_successor])\n    printer.plain_print(\"(\")\n    printer.print_seq(self.then_arguments, delim=\", \")\n    printer.plain_print(\")\")\n\n    with printer.rich(style=\"keyword\"):\n        printer.plain_print(\" else \")\n\n    printer.plain_print(printer.state.block_id[self.else_successor])\n    printer.plain_print(\"(\")\n    printer.print_seq(self.else_arguments, delim=\", \")\n    printer.plain_print(\")\")\n</code></pre>"},{"location":"dialects/cf/#kirin.dialects.cf.stmts.ConditionalBranch.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>run mandatory validation checks. This is not same as typecheck, which may be optional.</p> Source code in <code>src/kirin/dialects/cf/stmts.py</code> <pre><code>def verify(self) -&gt; None:\n    return\n</code></pre>"},{"location":"dialects/func/","title":"Function","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Call","title":"Call  <code>krin-statement</code>","text":"<pre><code>Call(\n    callee: SSAValue,\n    inputs: tuple[SSAValue, ...],\n    *,\n    kwargs: tuple[str, ...] = ()\n)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Call.callee","title":"callee  <code>kirin-argument</code>","text":"<pre><code>callee: SSAValue = argument()\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Call.inputs","title":"inputs  <code>kirin-argument</code>","text":"<pre><code>inputs: tuple[SSAValue, ...] = argument()\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Call.kwargs","title":"kwargs  <code>kirin-property</code> <code>kw-only</code>","text":"<pre><code>kwargs: tuple[str, ...] = attribute(\n    default_factory=lambda: (), property=True\n)\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Call.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'call'\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Call.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result()\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Call.print_impl","title":"print_impl","text":"<pre><code>print_impl(printer: Printer) -&gt; None\n</code></pre> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>def print_impl(self, printer: Printer) -&gt; None:\n    pprint_calllike(self, printer.state.ssa_id[self.callee], printer)\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.ConstantNone","title":"ConstantNone  <code>krin-statement</code>","text":"<pre><code>ConstantNone()\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>A constant None value.</p> <p>This is mainly used to represent the None return value of a function to match Python semantics.</p>"},{"location":"dialects/func/#kirin.dialects.func.stmts.ConstantNone.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'const.none'\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.ConstantNone.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(NoneType)\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.ConstantNone.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({Pure(), ConstantLike()})\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.FuncOpCallableInterface","title":"FuncOpCallableInterface  <code>dataclass</code>","text":"<pre><code>FuncOpCallableInterface()\n</code></pre> <p>               Bases: <code>CallableStmtInterface['Function']</code></p>"},{"location":"dialects/func/#kirin.dialects.func.stmts.FuncOpCallableInterface.get_callable_region","title":"get_callable_region  <code>classmethod</code>","text":"<pre><code>get_callable_region(stmt: Function) -&gt; Region\n</code></pre> <p>Returns the body of the callable region</p> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>@classmethod\ndef get_callable_region(cls, stmt: \"Function\") -&gt; Region:\n    return stmt.body\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Function","title":"Function  <code>krin-statement</code>","text":"<pre><code>Function(\n    *, sym_name: str, signature: Signature, body: Region\n)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Function.body","title":"body  <code>kirin-region</code> <code>kw-only</code>","text":"<pre><code>body: Region = region(multi=True)\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Function.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'func'\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Function.signature","title":"signature  <code>kirin-attribute</code> <code>kw-only</code>","text":"<pre><code>signature: Signature = attribute()\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Function.sym_name","title":"sym_name  <code>kirin-property</code> <code>kw-only</code>","text":"<pre><code>sym_name: str = attribute(property=True)\n</code></pre> <p>The symbol name of the function.</p>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Function.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset(\n    {\n        IsolatedFromAbove(),\n        SymbolOpInterface(),\n        HasSignature(),\n        FuncOpCallableInterface(),\n        SSACFGRegion(),\n    }\n)\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Function.print_impl","title":"print_impl","text":"<pre><code>print_impl(printer: Printer) -&gt; None\n</code></pre> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>def print_impl(self, printer: Printer) -&gt; None:\n    with printer.rich(style=\"keyword\"):\n        printer.print_name(self)\n        printer.plain_print(\" \")\n\n    with printer.rich(style=\"symbol\"):\n        printer.plain_print(self.sym_name)\n\n    printer.print_seq(self.signature.inputs, prefix=\"(\", suffix=\")\", delim=\", \")\n\n    with printer.rich(style=\"comment\"):\n        printer.plain_print(\" -&gt; \")\n        printer.print(self.signature.output)\n        printer.plain_print(\" \")\n\n    printer.print(self.body)\n\n    with printer.rich(style=\"comment\"):\n        printer.plain_print(f\" // func.func {self.sym_name}\")\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.GetField","title":"GetField  <code>krin-statement</code>","text":"<pre><code>GetField(obj: SSAValue, *, field: int)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/func/#kirin.dialects.func.stmts.GetField.field","title":"field  <code>kirin-property</code> <code>kw-only</code>","text":"<pre><code>field: int = attribute(property=True)\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.GetField.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'getfield'\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.GetField.obj","title":"obj  <code>kirin-argument</code>","text":"<pre><code>obj: SSAValue = argument(MethodType)\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.GetField.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(init=False)\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.GetField.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({Pure()})\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.GetField.print_impl","title":"print_impl","text":"<pre><code>print_impl(printer: Printer) -&gt; None\n</code></pre> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>def print_impl(self, printer: Printer) -&gt; None:\n    printer.print_name(self)\n    printer.plain_print(\n        \"(\", printer.state.ssa_id[self.obj], \", \", str(self.field), \")\"\n    )\n    with printer.rich(style=\"black\"):\n        printer.plain_print(\" : \")\n        printer.print(self.result.type)\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Invoke","title":"Invoke  <code>krin-statement</code>","text":"<pre><code>Invoke(\n    inputs: tuple[SSAValue, ...],\n    *,\n    callee: Method,\n    kwargs: tuple[str, ...]\n)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Invoke.callee","title":"callee  <code>kirin-property</code> <code>kw-only</code>","text":"<pre><code>callee: Method = attribute(property=True)\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Invoke.inputs","title":"inputs  <code>kirin-argument</code>","text":"<pre><code>inputs: tuple[SSAValue, ...] = argument()\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Invoke.kwargs","title":"kwargs  <code>kirin-property</code> <code>kw-only</code>","text":"<pre><code>kwargs: tuple[str, ...] = attribute(property=True)\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Invoke.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'invoke'\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Invoke.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result()\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Invoke.print_impl","title":"print_impl","text":"<pre><code>print_impl(printer: Printer) -&gt; None\n</code></pre> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>def print_impl(self, printer: Printer) -&gt; None:\n    pprint_calllike(self, self.callee.sym_name, printer)\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Invoke.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>run mandatory validation checks. This is not same as typecheck, which may be optional.</p> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>def verify(self) -&gt; None:\n    if self.kwargs:\n        for name in self.kwargs:\n            if name not in self.callee.arg_names:\n                raise VerificationError(\n                    self,\n                    f\"method {self.callee.sym_name} does not have argument {name}\",\n                )\n    elif len(self.callee.arg_names) - 1 != len(self.args):\n        raise VerificationError(\n            self,\n            f\"expected {len(self.callee.arg_names)} arguments, got {len(self.args)}\",\n        )\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Lambda","title":"Lambda  <code>krin-statement</code>","text":"<pre><code>Lambda(\n    captured: tuple[SSAValue, ...],\n    *,\n    sym_name: str,\n    signature: Signature,\n    body: Region\n)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Lambda.body","title":"body  <code>kirin-region</code> <code>kw-only</code>","text":"<pre><code>body: Region = region(multi=True)\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Lambda.captured","title":"captured  <code>kirin-argument</code>","text":"<pre><code>captured: tuple[SSAValue, ...] = argument()\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Lambda.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'lambda'\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Lambda.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(MethodType)\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Lambda.signature","title":"signature  <code>kirin-attribute</code> <code>kw-only</code>","text":"<pre><code>signature: Signature = attribute()\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Lambda.sym_name","title":"sym_name  <code>kirin-property</code> <code>kw-only</code>","text":"<pre><code>sym_name: str = attribute(property=True)\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Lambda.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset(\n    {\n        Pure(),\n        SymbolOpInterface(),\n        FuncOpCallableInterface(),\n        SSACFGRegion(),\n    }\n)\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Lambda.print_impl","title":"print_impl","text":"<pre><code>print_impl(printer: Printer) -&gt; None\n</code></pre> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>def print_impl(self, printer: Printer) -&gt; None:\n    with printer.rich(style=\"keyword\"):\n        printer.print_name(self)\n    printer.plain_print(\" \")\n\n    with printer.rich(style=\"symbol\"):\n        printer.plain_print(self.sym_name)\n\n    printer.print_seq(self.captured, prefix=\"(\", suffix=\")\", delim=\", \")\n\n    with printer.rich(style=\"bright_black\"):\n        printer.plain_print(\" -&gt; \")\n        printer.print(self.signature.output)\n\n    printer.plain_print(\" \")\n    printer.print(self.body)\n\n    with printer.rich(style=\"black\"):\n        printer.plain_print(f\" // func.lambda {self.sym_name}\")\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Lambda.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>run mandatory validation checks. This is not same as typecheck, which may be optional.</p> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>def verify(self) -&gt; None:\n    if self.body.blocks.isempty():\n        raise VerificationError(self, \"lambda body must not be empty\")\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Return","title":"Return  <code>krin-statement</code>","text":"<pre><code>Return(value_or_stmt: SSAValue | Statement | None = None)\n</code></pre> <p>               Bases: <code>Statement</code></p> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>def __init__(self, value_or_stmt: SSAValue | Statement | None = None) -&gt; None:\n    if isinstance(value_or_stmt, SSAValue):\n        args = [value_or_stmt]\n    elif isinstance(value_or_stmt, Statement):\n        if len(value_or_stmt._results) == 1:\n            args = [value_or_stmt._results[0]]\n        else:\n            raise ValueError(\n                f\"expected a single result, got {len(value_or_stmt._results)} results from {value_or_stmt.name}\"\n            )\n    elif value_or_stmt is None:\n        args = []\n    else:\n        raise ValueError(f\"expected SSAValue or Statement, got {value_or_stmt}\")\n\n    super().__init__(args=args, args_slice={\"value\": 0})\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Return.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'return'\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Return.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({IsTerminator(), HasParent((Function))})\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Return.value","title":"value  <code>kirin-argument</code>","text":"<pre><code>value: SSAValue = argument()\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Return.print_impl","title":"print_impl","text":"<pre><code>print_impl(printer: Printer) -&gt; None\n</code></pre> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>def print_impl(self, printer: Printer) -&gt; None:\n    with printer.rich(style=\"keyword\"):\n        printer.print_name(self)\n\n    if self.args:\n        printer.plain_print(\" \")\n        printer.print_seq(self.args, delim=\", \")\n</code></pre>"},{"location":"dialects/func/#kirin.dialects.func.stmts.Return.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>run mandatory validation checks. This is not same as typecheck, which may be optional.</p> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>def verify(self) -&gt; None:\n    if not self.args:\n        raise VerificationError(\n            self, \"return statement must have at least one value\"\n        )\n\n    if len(self.args) &gt; 1:\n        raise VerificationError(\n            self,\n            \"return statement must have at most one value\"\n            \", wrap multiple values in a tuple\",\n        )\n</code></pre>"},{"location":"dialects/ilist/","title":"Immutable List","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.CarryT","title":"CarryT  <code>module-attribute</code>","text":"<pre><code>CarryT = TypeVar('CarryT')\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.ElemT","title":"ElemT  <code>module-attribute</code>","text":"<pre><code>ElemT = TypeVar('ElemT')\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.IListType","title":"IListType  <code>module-attribute</code>","text":"<pre><code>IListType = Generic(IList, ElemT, ListLen)\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.ListLen","title":"ListLen  <code>module-attribute</code>","text":"<pre><code>ListLen = TypeVar('ListLen')\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.OutElemT","title":"OutElemT  <code>module-attribute</code>","text":"<pre><code>OutElemT = TypeVar('OutElemT')\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.ResultT","title":"ResultT  <code>module-attribute</code>","text":"<pre><code>ResultT = TypeVar('ResultT')\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Foldl","title":"Foldl  <code>krin-statement</code>","text":"<pre><code>Foldl(\n    fn: ir.SSAValue,\n    collection: ir.SSAValue,\n    init: ir.SSAValue,\n)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Foldl.collection","title":"collection  <code>kirin-argument</code>","text":"<pre><code>collection: SSAValue = argument(IListType[ElemT])\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Foldl.fn","title":"fn  <code>kirin-argument</code>","text":"<pre><code>fn: SSAValue = argument(\n    Generic(Method, [OutElemT, ElemT], OutElemT)\n)\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Foldl.init","title":"init  <code>kirin-argument</code>","text":"<pre><code>init: SSAValue = argument(OutElemT)\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Foldl.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(OutElemT)\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Foldl.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({FromPythonCall()})\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Foldr","title":"Foldr  <code>krin-statement</code>","text":"<pre><code>Foldr(\n    fn: ir.SSAValue,\n    collection: ir.SSAValue,\n    init: ir.SSAValue,\n)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Foldr.collection","title":"collection  <code>kirin-argument</code>","text":"<pre><code>collection: SSAValue = argument(IListType[ElemT])\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Foldr.fn","title":"fn  <code>kirin-argument</code>","text":"<pre><code>fn: SSAValue = argument(\n    Generic(Method, [ElemT, OutElemT], OutElemT)\n)\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Foldr.init","title":"init  <code>kirin-argument</code>","text":"<pre><code>init: SSAValue = argument(OutElemT)\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Foldr.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(OutElemT)\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Foldr.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({FromPythonCall()})\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.ForEach","title":"ForEach  <code>krin-statement</code>","text":"<pre><code>ForEach(fn: ir.SSAValue, collection: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.ForEach.collection","title":"collection  <code>kirin-argument</code>","text":"<pre><code>collection: SSAValue = argument(IListType[ElemT])\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.ForEach.fn","title":"fn  <code>kirin-argument</code>","text":"<pre><code>fn: SSAValue = argument(Generic(Method, [ElemT], NoneType))\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.ForEach.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({FromPythonCall()})\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Map","title":"Map  <code>krin-statement</code>","text":"<pre><code>Map(fn: ir.SSAValue, collection: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Map.collection","title":"collection  <code>kirin-argument</code>","text":"<pre><code>collection: SSAValue = argument(IListType[ElemT, ListLen])\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Map.fn","title":"fn  <code>kirin-argument</code>","text":"<pre><code>fn: SSAValue = argument(Generic(Method, [ElemT], OutElemT))\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Map.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(IListType[OutElemT, ListLen])\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Map.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({FromPythonCall()})\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.New","title":"New  <code>krin-statement</code>","text":"<pre><code>New(values: Sequence[ir.SSAValue])\n</code></pre> <p>               Bases: <code>Statement</code></p> Source code in <code>src/kirin/dialects/ilist/stmts.py</code> <pre><code>def __init__(\n    self,\n    values: Sequence[ir.SSAValue],\n) -&gt; None:\n    # get elem type\n    if not values:\n        elem_type = ir.types.Any\n    else:\n        elem_type = values[0].type\n        for v in values:\n            elem_type = elem_type.join(v.type)\n\n    result_type = IListType[elem_type, ir.types.Literal(len(values))]\n    super().__init__(\n        args=values,\n        result_types=(result_type,),\n        args_slice={\"values\": slice(0, len(values))},\n    )\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.New.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(IListType[ElemT])\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.New.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({Pure(), FromPythonCall()})\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.New.values","title":"values  <code>kirin-argument</code>","text":"<pre><code>values: tuple[SSAValue, ...] = argument(ElemT)\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Push","title":"Push  <code>krin-statement</code>","text":"<pre><code>Push(lst: ir.SSAValue, value: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Push.lst","title":"lst  <code>kirin-argument</code>","text":"<pre><code>lst: SSAValue = argument(IListType[ElemT])\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Push.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(IListType[ElemT])\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Push.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({FromPythonCall()})\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Push.value","title":"value  <code>kirin-argument</code>","text":"<pre><code>value: SSAValue = argument(IListType[ElemT])\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Scan","title":"Scan  <code>krin-statement</code>","text":"<pre><code>Scan(\n    fn: ir.SSAValue,\n    collection: ir.SSAValue,\n    init: ir.SSAValue,\n)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Scan.collection","title":"collection  <code>kirin-argument</code>","text":"<pre><code>collection: SSAValue = argument(IListType[ElemT, ListLen])\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Scan.fn","title":"fn  <code>kirin-argument</code>","text":"<pre><code>fn: SSAValue = argument(\n    Generic(\n        Method, [OutElemT, ElemT], Tuple[OutElemT, ResultT]\n    )\n)\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Scan.init","title":"init  <code>kirin-argument</code>","text":"<pre><code>init: SSAValue = argument(OutElemT)\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Scan.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(\n    Tuple[OutElemT, IListType[ResultT, ListLen]]\n)\n</code></pre>"},{"location":"dialects/ilist/#kirin.dialects.ilist.stmts.Scan.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({FromPythonCall()})\n</code></pre>"},{"location":"dialects/scf/","title":"Structural Control Flow","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"dialects/scf/#scf-dialects","title":"SCF Dialects","text":""},{"location":"dialects/scf/#reference","title":"Reference","text":""},{"location":"dialects/scf/#kirin.dialects.scf.stmts.For","title":"For  <code>krin-statement</code>","text":"<pre><code>For(\n    iterable: ir.SSAValue,\n    body: ir.Region,\n    *initializers: ir.SSAValue\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> Source code in <code>src/kirin/dialects/scf/stmts.py</code> <pre><code>def __init__(\n    self,\n    iterable: ir.SSAValue,\n    body: ir.Region,\n    *initializers: ir.SSAValue,\n):\n    stmt = body.blocks[0].last_stmt\n    if stmt is None or not isinstance(stmt, Yield):\n        raise DialectLoweringError(\"for loop body must terminate with a yield\")\n\n    if len(body.blocks) != 1:\n        raise DialectLoweringError(\"for loop body must have a single block\")\n\n    if len(body.blocks[0].args) != len(initializers) + 1:\n        raise DialectLoweringError(\n            \"for loop body must have arguments for all initializers and the loop variable\"\n        )\n\n    super().__init__(\n        args=(iterable, *initializers),\n        regions=(body,),\n        result_types=tuple(value.type for value in stmt.values),\n        args_slice={\"iterable\": 0, \"initializers\": slice(1, None)},\n    )\n</code></pre>"},{"location":"dialects/scf/#kirin.dialects.scf.stmts.For.body","title":"body  <code>kirin-region</code> <code>kw-only</code>","text":"<pre><code>body: Region = region(multi=False)\n</code></pre>"},{"location":"dialects/scf/#kirin.dialects.scf.stmts.For.initializers","title":"initializers  <code>kirin-argument</code>","text":"<pre><code>initializers: tuple[SSAValue, ...] = argument(Any)\n</code></pre>"},{"location":"dialects/scf/#kirin.dialects.scf.stmts.For.iterable","title":"iterable  <code>kirin-argument</code>","text":"<pre><code>iterable: SSAValue = argument(Any)\n</code></pre>"},{"location":"dialects/scf/#kirin.dialects.scf.stmts.For.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'for'\n</code></pre>"},{"location":"dialects/scf/#kirin.dialects.scf.stmts.For.print_impl","title":"print_impl","text":"<pre><code>print_impl(printer: Printer) -&gt; None\n</code></pre> Source code in <code>src/kirin/dialects/scf/stmts.py</code> <pre><code>def print_impl(self, printer: Printer) -&gt; None:\n    printer.print_name(self)\n    printer.plain_print(\" \")\n    block = self.body.blocks[0]\n    printer.print(block.args[0])\n    printer.plain_print(\" in \", style=\"keyword\")\n    printer.print(self.iterable)\n    with printer.indent():\n        printer.print_newline()\n        printer.plain_print(\"iter_args(\")\n        for idx, (arg, val) in enumerate(zip(block.args[1:], self.initializers)):\n            printer.print(arg)\n            printer.plain_print(\" = \")\n            printer.print(val)\n            if idx &lt; len(self.initializers) - 1:\n                printer.plain_print(\", \")\n        printer.plain_print(\") {\")\n\n        with printer.align(printer.result_width(block.stmts)):\n            for stmt in block.stmts:\n                printer.print_newline()\n                printer.print_stmt(stmt)\n    printer.print_newline()\n    printer.plain_print(\"}\")\n</code></pre>"},{"location":"dialects/scf/#kirin.dialects.scf.stmts.For.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>run mandatory validation checks. This is not same as typecheck, which may be optional.</p> Source code in <code>src/kirin/dialects/scf/stmts.py</code> <pre><code>def verify(self) -&gt; None:\n    stmt = self.body.blocks[0].last_stmt\n    if stmt is None or not isinstance(stmt, Yield):\n        raise VerificationError(self, \"for loop body must terminate with a yield\")\n    if len(stmt.values) != len(self.initializers):\n        raise VerificationError(\n            self,\n            \"for loop body must have the same number of results as initializers\",\n        )\n    if len(self.results) != len(stmt.values):\n        raise VerificationError(\n            self,\n            \"for loop must have the same number of results as the yield in the body\",\n        )\n</code></pre>"},{"location":"dialects/scf/#kirin.dialects.scf.stmts.IfElse","title":"IfElse  <code>krin-statement</code>","text":"<pre><code>IfElse(\n    cond: ir.SSAValue,\n    then_body: ir.Region | ir.Block,\n    else_body: ir.Region | ir.Block | None = None,\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>Python-like if-else statement.</p> <p>This statement has a condition, then body, and else body.</p> <p>Then body either terminates with a yield statement or <code>scf.return</code>.</p> Source code in <code>src/kirin/dialects/scf/stmts.py</code> <pre><code>def __init__(\n    self,\n    cond: ir.SSAValue,\n    then_body: ir.Region | ir.Block,\n    else_body: ir.Region | ir.Block | None = None,\n):\n    if isinstance(then_body, ir.Region):\n        if len(then_body.blocks) != 1:\n            raise DialectLoweringError(\n                \"if-else statement must have a single block in the then region\"\n            )\n        then_body_region = then_body\n        then_body = then_body_region.blocks[0]\n    elif isinstance(then_body, ir.Block):\n        then_body_region = ir.Region(then_body)\n\n    if isinstance(else_body, ir.Region):\n        if not else_body.blocks:  # empty region\n            else_body_region = else_body\n            else_body = None\n        elif len(else_body.blocks) != 1:\n            raise DialectLoweringError(\n                \"if-else statement must have a single block in the else region\"\n            )\n        else:\n            else_body_region = else_body\n            else_body = else_body_region.blocks[0]\n    elif isinstance(else_body, ir.Block):\n        else_body_region = ir.Region(else_body)\n    else:\n        else_body_region = ir.Region()\n\n    # if either then or else body has yield, we generate results\n    # we assume if both have yields, they have the same number of results\n    then_yield = then_body.last_stmt\n    else_yield = else_body.last_stmt if else_body is not None else None\n    if then_yield is not None and isinstance(then_yield, Yield):\n        results = then_yield.values\n    elif else_yield is not None and isinstance(else_yield, Yield):\n        results = else_yield.values\n    else:\n        results = ()\n\n    result_types = tuple(value.type for value in results)\n    super().__init__(\n        args=(cond,),\n        regions=(then_body_region, else_body_region),\n        result_types=result_types,\n        args_slice={\"cond\": 0},\n    )\n</code></pre>"},{"location":"dialects/scf/#kirin.dialects.scf.stmts.IfElse.cond","title":"cond  <code>kirin-argument</code>","text":"<pre><code>cond: SSAValue = argument(Any)\n</code></pre>"},{"location":"dialects/scf/#kirin.dialects.scf.stmts.IfElse.else_body","title":"else_body  <code>kirin-region</code> <code>kw-only</code>","text":"<pre><code>else_body: Region = region(\n    multi=False, default_factory=Region\n)\n</code></pre>"},{"location":"dialects/scf/#kirin.dialects.scf.stmts.IfElse.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'if'\n</code></pre>"},{"location":"dialects/scf/#kirin.dialects.scf.stmts.IfElse.then_body","title":"then_body  <code>kirin-region</code> <code>kw-only</code>","text":"<pre><code>then_body: Region = region(multi=False)\n</code></pre>"},{"location":"dialects/scf/#kirin.dialects.scf.stmts.IfElse.print_impl","title":"print_impl","text":"<pre><code>print_impl(printer: Printer) -&gt; None\n</code></pre> Source code in <code>src/kirin/dialects/scf/stmts.py</code> <pre><code>def print_impl(self, printer: Printer) -&gt; None:\n    printer.print_name(self)\n    printer.plain_print(\" \")\n    printer.print(self.cond)\n    printer.plain_print(\" \")\n    printer.print(self.then_body)\n    if self.else_body.blocks:\n        printer.plain_print(\" else \", style=\"keyword\")\n        printer.print(self.else_body)\n</code></pre>"},{"location":"dialects/scf/#kirin.dialects.scf.stmts.Yield","title":"Yield  <code>krin-statement</code>","text":"<pre><code>Yield(*values: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> Source code in <code>src/kirin/dialects/scf/stmts.py</code> <pre><code>def __init__(self, *values: ir.SSAValue):\n    super().__init__(args=values, args_slice={\"values\": slice(None)})\n</code></pre>"},{"location":"dialects/scf/#kirin.dialects.scf.stmts.Yield.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'yield'\n</code></pre>"},{"location":"dialects/scf/#kirin.dialects.scf.stmts.Yield.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({IsTerminator()})\n</code></pre>"},{"location":"dialects/scf/#kirin.dialects.scf.stmts.Yield.values","title":"values  <code>kirin-argument</code>","text":"<pre><code>values: tuple[SSAValue, ...] = argument(Any)\n</code></pre>"},{"location":"dialects/scf/#kirin.dialects.scf.stmts.Yield.print_impl","title":"print_impl","text":"<pre><code>print_impl(printer: Printer) -&gt; None\n</code></pre> Source code in <code>src/kirin/dialects/scf/stmts.py</code> <pre><code>def print_impl(self, printer: Printer) -&gt; None:\n    printer.print_name(self)\n    printer.print_seq(self.values, prefix=\" \", delim=\", \")\n</code></pre>"},{"location":"dialects/python/","title":"Index","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"dialects/python/#python-dialects","title":"Python Dialects","text":"<p>Kirin provides a set of dialects that represents fractions of Python semantics. We will describe each dialect in this page. The general design principle of these dialects is to provide a composable set of Python semantics that can be used to build different embedded DSLs inside Python.</p>"},{"location":"dialects/python/core/","title":"Core","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"dialects/python/core/#core-python-dialects","title":"Core Python Dialects","text":"<p>This page contains the core Python dialects that are used most frequently when designing an embedded DSL in Python.</p>"},{"location":"dialects/python/core/#reference","title":"Reference","text":""},{"location":"dialects/python/core/#base","title":"Base","text":""},{"location":"dialects/python/core/#kirin.dialects.py.base","title":"kirin.dialects.py.base","text":"<p>Base dialect for Python.</p> <p>This dialect does not contain statements. It only contains lowering rules for <code>ast.Name</code> and <code>ast.Expr</code>.</p>"},{"location":"dialects/python/core/#kirin.dialects.py.base.dialect","title":"dialect  <code>module-attribute</code>","text":"<pre><code>dialect = Dialect('py.base')\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.base.PythonLowering","title":"PythonLowering","text":"<p>               Bases: <code>FromPythonAST</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.base.PythonLowering.lower_Expr","title":"lower_Expr","text":"<pre><code>lower_Expr(\n    state: lowering.LoweringState, node: ast.Expr\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/base.py</code> <pre><code>def lower_Expr(\n    self, state: lowering.LoweringState, node: ast.Expr\n) -&gt; lowering.Result:\n    return state.visit(node.value)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.base.PythonLowering.lower_Name","title":"lower_Name","text":"<pre><code>lower_Name(\n    state: lowering.LoweringState, node: ast.Name\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/base.py</code> <pre><code>def lower_Name(\n    self, state: lowering.LoweringState, node: ast.Name\n) -&gt; lowering.Result:\n    name = node.id\n    if isinstance(node.ctx, ast.Load):\n        value = state.current_frame.get(name)\n        if value is None:\n            raise exceptions.DialectLoweringError(f\"{name} is not defined\")\n        return lowering.Result(value)\n    elif isinstance(node.ctx, ast.Store):\n        raise exceptions.DialectLoweringError(\"unhandled store operation\")\n    else:  # Del\n        raise exceptions.DialectLoweringError(\"unhandled del operation\")\n</code></pre>"},{"location":"dialects/python/core/#constant","title":"Constant","text":""},{"location":"dialects/python/core/#kirin.dialects.py.constant","title":"kirin.dialects.py.constant","text":"<p>Constant statement for Python dialect.</p> <p>This module contains the dialect for the Python <code>constant</code> statement, including:</p> <ul> <li>The <code>Constant</code> statement class.</li> <li>The lowering pass for the <code>constant</code> statement.</li> <li>The concrete implementation of the <code>constant</code> statement.</li> <li>The Julia emitter for the <code>constant</code> statement.</li> </ul> <p>This dialect maps <code>ast.Constant</code> nodes to the <code>Constant</code> statement.</p>"},{"location":"dialects/python/core/#kirin.dialects.py.constant.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T', covariant=True)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.constant.dialect","title":"dialect  <code>module-attribute</code>","text":"<pre><code>dialect = Dialect('py.constant')\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.constant.Concrete","title":"Concrete  <code>dataclass</code>","text":"<pre><code>Concrete()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.constant.Concrete.constant","title":"constant","text":"<pre><code>constant(interp, frame: interp.Frame, stmt: Constant)\n</code></pre> Source code in <code>src/kirin/dialects/py/constant.py</code> <pre><code>@interp.impl(Constant)\ndef constant(self, interp, frame: interp.Frame, stmt: Constant):\n    return (stmt.value,)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.constant.Constant","title":"Constant  <code>krin-statement</code>","text":"<pre><code>Constant(value: T | ir.PyAttr[T])\n</code></pre> <p>               Bases: <code>Statement</code>, <code>Generic[T]</code></p> Source code in <code>src/kirin/dialects/py/constant.py</code> <pre><code>def __init__(self, value: T | ir.PyAttr[T]) -&gt; None:\n    if not isinstance(value, ir.PyAttr):\n        value = ir.PyAttr(value)\n    super().__init__(\n        properties={\"value\": value},\n        result_types=(value.type,),\n    )\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.constant.Constant.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'constant'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.constant.Constant.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result()\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.constant.Constant.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset(\n    {Pure(), ConstantLike(), FromPythonCall()}\n)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.constant.Constant.value","title":"value  <code>kirin-property</code> <code>kw-only</code>","text":"<pre><code>value: T = attribute(property=True)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.constant.Constant.print_impl","title":"print_impl","text":"<pre><code>print_impl(printer: Printer) -&gt; None\n</code></pre> Source code in <code>src/kirin/dialects/py/constant.py</code> <pre><code>def print_impl(self, printer: Printer) -&gt; None:\n    printer.print_name(self)\n    printer.plain_print(\" \")\n    printer.plain_print(repr(self.value))\n    with printer.rich(style=\"comment\"):\n        printer.plain_print(\" : \")\n        printer.print(self.result.type)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.constant.Constant.typecheck","title":"typecheck","text":"<pre><code>typecheck() -&gt; None\n</code></pre> <p>check the type of the statement.</p> Note <ol> <li>Statement should implement typecheck. this is done automatically via @statement, but in the case manualy implementation is needed, it should be implemented here.</li> <li>This API should be called after all the types are figured out (by typeinfer)</li> </ol> Source code in <code>src/kirin/dialects/py/constant.py</code> <pre><code>def typecheck(self) -&gt; None:\n    if not isinstance(self.result.type, ir.types.TypeAttribute):\n        raise exceptions.VerificationError(\n            self, f\"Expected result type to be PyType, got {self.result.type}\"\n        )\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.constant.JuliaTable","title":"JuliaTable  <code>dataclass</code>","text":"<pre><code>JuliaTable()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.constant.JuliaTable.emit_Constant","title":"emit_Constant","text":"<pre><code>emit_Constant(\n    emit: EmitJulia, frame: EmitStrFrame, stmt: Constant\n)\n</code></pre> Source code in <code>src/kirin/dialects/py/constant.py</code> <pre><code>@interp.impl(Constant)\ndef emit_Constant(self, emit: EmitJulia, frame: EmitStrFrame, stmt: Constant):\n    return (emit.emit_attribute(ir.PyAttr(stmt.value)),)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.constant.Lowering","title":"Lowering","text":"<p>               Bases: <code>FromPythonAST</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.constant.Lowering.lower_Constant","title":"lower_Constant","text":"<pre><code>lower_Constant(\n    state: lowering.LoweringState, node: ast.Constant\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/constant.py</code> <pre><code>def lower_Constant(\n    self, state: lowering.LoweringState, node: ast.Constant\n) -&gt; lowering.Result:\n    return lowering.Result(state.append_stmt(Constant(node.value)))\n</code></pre>"},{"location":"dialects/python/core/#unaryop","title":"UnaryOp","text":""},{"location":"dialects/python/core/#kirin.dialects.py.unary.stmts","title":"kirin.dialects.py.unary.stmts","text":""},{"location":"dialects/python/core/#kirin.dialects.py.unary.stmts.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T')\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.unary.stmts.Invert","title":"Invert  <code>kirin-statement</code> <code>krin-statement</code>","text":"<pre><code>Invert(value: ir.SSAValue)\n</code></pre> <p>               Bases: <code>UnaryOp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.unary.stmts.Invert.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'invert'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.unary.stmts.Not","title":"Not  <code>kirin-statement</code> <code>krin-statement</code>","text":"<pre><code>Not(value: ir.SSAValue)\n</code></pre> <p>               Bases: <code>UnaryOp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.unary.stmts.Not.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'not'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.unary.stmts.UAdd","title":"UAdd  <code>kirin-statement</code> <code>krin-statement</code>","text":"<pre><code>UAdd(value: ir.SSAValue)\n</code></pre> <p>               Bases: <code>UnaryOp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.unary.stmts.UAdd.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'uadd'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.unary.stmts.USub","title":"USub  <code>kirin-statement</code> <code>krin-statement</code>","text":"<pre><code>USub(value: ir.SSAValue)\n</code></pre> <p>               Bases: <code>UnaryOp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.unary.stmts.USub.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'usub'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.unary.stmts.UnaryOp","title":"UnaryOp  <code>krin-statement</code>","text":"<pre><code>UnaryOp(value: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.unary.stmts.UnaryOp.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(T)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.unary.stmts.UnaryOp.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({Pure(), FromPythonCall()})\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.unary.stmts.UnaryOp.value","title":"value  <code>kirin-argument</code>","text":"<pre><code>value: SSAValue = argument(T, print=False)\n</code></pre>"},{"location":"dialects/python/core/#binop","title":"BinOp","text":""},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts","title":"kirin.dialects.py.binop.stmts","text":""},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T')\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.Add","title":"Add  <code>kirin-statement</code> <code>krin-statement</code>","text":"<pre><code>Add(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>BinOp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.Add.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'add'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.BinOp","title":"BinOp  <code>krin-statement</code>","text":"<pre><code>BinOp(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.BinOp.lhs","title":"lhs  <code>kirin-argument</code>","text":"<pre><code>lhs: SSAValue = argument(T, print=False)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.BinOp.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(T)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.BinOp.rhs","title":"rhs  <code>kirin-argument</code>","text":"<pre><code>rhs: SSAValue = argument(T, print=False)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.BinOp.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({Pure(), FromPythonCall()})\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.BitAnd","title":"BitAnd  <code>kirin-statement</code> <code>krin-statement</code>","text":"<pre><code>BitAnd(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>BinOp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.BitAnd.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'bitand'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.BitOr","title":"BitOr  <code>kirin-statement</code> <code>krin-statement</code>","text":"<pre><code>BitOr(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>BinOp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.BitOr.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'bitor'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.BitXor","title":"BitXor  <code>kirin-statement</code> <code>krin-statement</code>","text":"<pre><code>BitXor(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>BinOp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.BitXor.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'bitxor'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.Div","title":"Div  <code>kirin-statement</code> <code>krin-statement</code>","text":"<pre><code>Div(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>BinOp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.Div.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'div'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.FloorDiv","title":"FloorDiv  <code>kirin-statement</code> <code>krin-statement</code>","text":"<pre><code>FloorDiv(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>BinOp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.FloorDiv.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'floordiv'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.LShift","title":"LShift  <code>kirin-statement</code> <code>krin-statement</code>","text":"<pre><code>LShift(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>BinOp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.LShift.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'lshift'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.MatMult","title":"MatMult  <code>kirin-statement</code> <code>krin-statement</code>","text":"<pre><code>MatMult(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>BinOp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.MatMult.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'matmult'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.Mod","title":"Mod  <code>kirin-statement</code> <code>krin-statement</code>","text":"<pre><code>Mod(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>BinOp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.Mod.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'mod'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.Mult","title":"Mult  <code>kirin-statement</code> <code>krin-statement</code>","text":"<pre><code>Mult(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>BinOp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.Mult.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'mult'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.Pow","title":"Pow  <code>kirin-statement</code> <code>krin-statement</code>","text":"<pre><code>Pow(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>BinOp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.Pow.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'pow'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.RShift","title":"RShift  <code>kirin-statement</code> <code>krin-statement</code>","text":"<pre><code>RShift(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>BinOp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.RShift.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'rshift'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.Sub","title":"Sub  <code>kirin-statement</code> <code>krin-statement</code>","text":"<pre><code>Sub(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>BinOp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.binop.stmts.Sub.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'sub'\n</code></pre>"},{"location":"dialects/python/core/#assertion","title":"Assertion","text":""},{"location":"dialects/python/core/#kirin.dialects.py.assertion","title":"kirin.dialects.py.assertion","text":"<p>Assertion dialect for Python.</p> <p>This module contains the dialect for the Python <code>assert</code> statement, including:</p> <ul> <li>The <code>Assert</code> statement class.</li> <li>The lowering pass for the <code>assert</code> statement.</li> <li>The concrete implementation of the <code>assert</code> statement.</li> <li>The type inference implementation of the <code>assert</code> statement.</li> <li>The Julia emitter for the <code>assert</code> statement.</li> </ul> <p>This dialect maps <code>ast.Assert</code> nodes to the <code>Assert</code> statement.</p>"},{"location":"dialects/python/core/#kirin.dialects.py.assertion.dialect","title":"dialect  <code>module-attribute</code>","text":"<pre><code>dialect = Dialect('py.assert')\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assertion.Assert","title":"Assert  <code>krin-statement</code>","text":"<pre><code>Assert(message: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.assertion.Assert.condition","title":"condition  <code>instance-attribute</code>","text":"<pre><code>condition: SSAValue\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assertion.Assert.message","title":"message  <code>kirin-argument</code>","text":"<pre><code>message: SSAValue = argument(String)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assertion.Assert.print_impl","title":"print_impl","text":"<pre><code>print_impl(printer: Printer) -&gt; None\n</code></pre> Source code in <code>src/kirin/dialects/py/assertion.py</code> <pre><code>def print_impl(self, printer: Printer) -&gt; None:\n    with printer.rich(style=\"keyword\"):\n        printer.print_name(self)\n\n    printer.plain_print(\" \")\n    printer.print(self.condition)\n\n    if self.message:\n        printer.plain_print(\", \")\n        printer.print(self.message)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assertion.Concrete","title":"Concrete  <code>dataclass</code>","text":"<pre><code>Concrete()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.assertion.Concrete.assert_stmt","title":"assert_stmt","text":"<pre><code>assert_stmt(\n    interp_: interp.Interpreter,\n    frame: interp.Frame,\n    stmt: Assert,\n)\n</code></pre> Source code in <code>src/kirin/dialects/py/assertion.py</code> <pre><code>@interp.impl(Assert)\ndef assert_stmt(\n    self, interp_: interp.Interpreter, frame: interp.Frame, stmt: Assert\n):\n    if frame.get(stmt.condition) is True:\n        return ()\n\n    if stmt.message:\n        raise interp.WrapException(AssertionError(frame.get(stmt.message)))\n    else:\n        raise interp.WrapException(AssertionError(\"Assertion failed\"))\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assertion.EmitJulia","title":"EmitJulia  <code>dataclass</code>","text":"<pre><code>EmitJulia()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.assertion.EmitJulia.emit_assert","title":"emit_assert","text":"<pre><code>emit_assert(\n    interp: julia.EmitJulia,\n    frame: EmitStrFrame,\n    stmt: Assert,\n)\n</code></pre> Source code in <code>src/kirin/dialects/py/assertion.py</code> <pre><code>@interp.impl(Assert)\ndef emit_assert(self, interp: julia.EmitJulia, frame: EmitStrFrame, stmt: Assert):\n    interp.writeln(\n        frame, f\"@assert {frame.get(stmt.condition)} {frame.get(stmt.message)}\"\n    )\n    return ()\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assertion.Lowering","title":"Lowering","text":"<p>               Bases: <code>FromPythonAST</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.assertion.Lowering.lower_Assert","title":"lower_Assert","text":"<pre><code>lower_Assert(\n    state: lowering.LoweringState, node: ast.Assert\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/assertion.py</code> <pre><code>def lower_Assert(\n    self, state: lowering.LoweringState, node: ast.Assert\n) -&gt; lowering.Result:\n    from kirin.dialects.py.constant import Constant\n\n    cond = state.visit(node.test).expect_one()\n    if node.msg:\n        message = state.visit(node.msg).expect_one()\n        state.append_stmt(Assert(condition=cond, message=message))\n    else:\n        message_stmt = state.append_stmt(Constant(\"\"))\n        state.append_stmt(Assert(condition=cond, message=message_stmt.result))\n    return lowering.Result()\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assertion.TypeInfer","title":"TypeInfer  <code>dataclass</code>","text":"<pre><code>TypeInfer()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.assertion.TypeInfer.assert_stmt","title":"assert_stmt","text":"<pre><code>assert_stmt(interp, frame, stmt: Assert)\n</code></pre> Source code in <code>src/kirin/dialects/py/assertion.py</code> <pre><code>@interp.impl(Assert)\ndef assert_stmt(self, interp, frame, stmt: Assert):\n    return (types.Bottom,)\n</code></pre>"},{"location":"dialects/python/core/#assignment","title":"Assignment","text":""},{"location":"dialects/python/core/#kirin.dialects.py.assign","title":"kirin.dialects.py.assign","text":"<p>Assignment dialect for Python.</p> <p>This module contains the dialect for the Python assignment statement, including:</p> <ul> <li>Statements: <code>Alias</code>, <code>SetItem</code>.</li> <li>The lowering pass for the assignments.</li> <li>The concrete implementation of the assignment statements.</li> </ul> <p>This dialects maps Python assignment syntax.</p>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T')\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.dialect","title":"dialect  <code>module-attribute</code>","text":"<pre><code>dialect = Dialect('py.assign')\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.Alias","title":"Alias  <code>krin-statement</code>","text":"<pre><code>Alias(value: ir.SSAValue, *, target: ir.PyAttr[str])\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.Alias.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'alias'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.Alias.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(T)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.Alias.target","title":"target  <code>kirin-property</code> <code>kw-only</code>","text":"<pre><code>target: PyAttr[str] = attribute(property=True)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.Alias.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({Pure(), FromPythonCall()})\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.Alias.value","title":"value  <code>kirin-argument</code>","text":"<pre><code>value: SSAValue = argument(T)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.Alias.print_impl","title":"print_impl","text":"<pre><code>print_impl(printer: Printer) -&gt; None\n</code></pre> Source code in <code>src/kirin/dialects/py/assign.py</code> <pre><code>def print_impl(self, printer: Printer) -&gt; None:\n    printer.print_name(self)\n    printer.plain_print(\" \")\n    with printer.rich(style=\"symbol\"):\n        printer.plain_print(self.target.data)\n\n    with printer.rich(style=\"keyword\"):\n        printer.plain_print(\" = \")\n\n    printer.print(self.value)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.Concrete","title":"Concrete  <code>dataclass</code>","text":"<pre><code>Concrete()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.Concrete.alias","title":"alias","text":"<pre><code>alias(interp, frame: interp.Frame, stmt: Alias)\n</code></pre> Source code in <code>src/kirin/dialects/py/assign.py</code> <pre><code>@interp.impl(Alias)\ndef alias(self, interp, frame: interp.Frame, stmt: Alias):\n    return (frame.get(stmt.value),)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.Concrete.setindex","title":"setindex","text":"<pre><code>setindex(interp, frame: interp.Frame, stmt: SetItem)\n</code></pre> Source code in <code>src/kirin/dialects/py/assign.py</code> <pre><code>@interp.impl(SetItem)\ndef setindex(self, interp, frame: interp.Frame, stmt: SetItem):\n    frame.get(stmt.obj)[frame.get(stmt.index)] = frame.get(stmt.value)\n    return (None,)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.Lowering","title":"Lowering","text":"<p>               Bases: <code>FromPythonAST</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.Lowering.lower_Assign","title":"lower_Assign","text":"<pre><code>lower_Assign(\n    state: lowering.LoweringState, node: ast.Assign\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/assign.py</code> <pre><code>def lower_Assign(\n    self, state: lowering.LoweringState, node: ast.Assign\n) -&gt; lowering.Result:\n    results: lowering.Result = state.visit(node.value)\n    assert len(node.targets) == len(\n        results\n    ), \"number of targets and results do not match\"\n\n    current_frame = state.current_frame\n    match node:\n        case ast.Assign(\n            targets=[ast.Name(lhs_name, ast.Store())], value=ast.Name(_, ast.Load())\n        ):\n            stmt = Alias(\n                value=results[0], target=ir.PyAttr(lhs_name)\n            )  # NOTE: this is guaranteed to be one result\n            stmt.result.name = lhs_name\n            current_frame.defs[lhs_name] = state.append_stmt(stmt).result\n        case _:\n            for target, value in zip(node.targets, results.values):\n                match target:\n                    # NOTE: if the name exists new ssa value will be\n                    # used in the future to shadow the old one\n                    case ast.Name(name, ast.Store()):\n                        value.name = name\n                        current_frame.defs[name] = value\n                    case ast.Subscript(obj, slice):\n                        obj = state.visit(obj).expect_one()\n                        slice = state.visit(slice).expect_one()\n                        stmt = SetItem(obj=obj, index=slice, value=value)\n                        state.append_stmt(stmt)\n                    case _:\n                        raise exceptions.DialectLoweringError(\n                            f\"unsupported target {target}\"\n                        )\n    return lowering.Result()  # python assign does not have value\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.SetItem","title":"SetItem  <code>krin-statement</code>","text":"<pre><code>SetItem(\n    obj: ir.SSAValue, value: ir.SSAValue, index: ir.SSAValue\n)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.SetItem.index","title":"index  <code>kirin-argument</code>","text":"<pre><code>index: SSAValue = argument(print=False)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.SetItem.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'setitem'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.SetItem.obj","title":"obj  <code>kirin-argument</code>","text":"<pre><code>obj: SSAValue = argument(print=False)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.SetItem.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({FromPythonCall()})\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.assign.SetItem.value","title":"value  <code>kirin-argument</code>","text":"<pre><code>value: SSAValue = argument(print=False)\n</code></pre>"},{"location":"dialects/python/core/#unpack","title":"Unpack","text":""},{"location":"dialects/python/core/#kirin.dialects.py.unpack","title":"kirin.dialects.py.unpack","text":"<p>The unpack dialect for Python.</p> <p>This module contains the dialect for the Python unpack semantics, including:</p> <ul> <li>The <code>Unpack</code> statement class.</li> <li>The lowering pass for the unpack statement.</li> <li>The concrete implementation of the unpack statement.</li> <li>The type inference implementation of the unpack statement.</li> <li>A helper function <code>unpacking</code> for unpacking Python AST nodes during lowering.</li> </ul>"},{"location":"dialects/python/core/#kirin.dialects.py.unpack.dialect","title":"dialect  <code>module-attribute</code>","text":"<pre><code>dialect = Dialect('py.unpack')\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.unpack.Concrete","title":"Concrete  <code>dataclass</code>","text":"<pre><code>Concrete()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.unpack.Concrete.unpack","title":"unpack","text":"<pre><code>unpack(\n    interp: interp.Interpreter,\n    frame: interp.Frame,\n    stmt: Unpack,\n)\n</code></pre> Source code in <code>src/kirin/dialects/py/unpack.py</code> <pre><code>@interp.impl(Unpack)\ndef unpack(self, interp: interp.Interpreter, frame: interp.Frame, stmt: Unpack):\n    return tuple(frame.get(stmt.value))\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.unpack.TypeInfer","title":"TypeInfer  <code>dataclass</code>","text":"<pre><code>TypeInfer()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.unpack.TypeInfer.unpack","title":"unpack","text":"<pre><code>unpack(\n    interp,\n    frame: interp.Frame[ir.types.TypeAttribute],\n    stmt: Unpack,\n)\n</code></pre> Source code in <code>src/kirin/dialects/py/unpack.py</code> <pre><code>@interp.impl(Unpack)\ndef unpack(self, interp, frame: interp.Frame[ir.types.TypeAttribute], stmt: Unpack):\n    value = frame.get(stmt.value)\n    if isinstance(value, ir.types.Generic) and value.is_subseteq(ir.types.Tuple):\n        if value.vararg:\n            rest = tuple(value.vararg.typ for _ in stmt.names[len(value.vars) :])\n            return tuple(value.vars) + rest\n        else:\n            return value.vars\n    # TODO: support unpacking other types\n    return tuple(ir.types.Any for _ in stmt.names)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.unpack.Unpack","title":"Unpack  <code>krin-statement</code>","text":"<pre><code>Unpack(value: ir.SSAValue, names: tuple[str | None, ...])\n</code></pre> <p>               Bases: <code>Statement</code></p> Source code in <code>src/kirin/dialects/py/unpack.py</code> <pre><code>def __init__(self, value: ir.SSAValue, names: tuple[str | None, ...]):\n    result_types = [ir.types.Any] * len(names)\n    super().__init__(\n        args=(value,),\n        result_types=result_types,\n        args_slice={\"value\": 0},\n        properties={\"names\": ir.PyAttr(names)},\n    )\n    for result, name in zip(self.results, names):\n        result.name = name\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.unpack.Unpack.names","title":"names  <code>kirin-property</code> <code>kw-only</code>","text":"<pre><code>names: tuple[str | None, ...] = attribute(property=True)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.unpack.Unpack.value","title":"value  <code>kirin-argument</code>","text":"<pre><code>value: SSAValue = argument(Any)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.unpack.Unpack.print_impl","title":"print_impl","text":"<pre><code>print_impl(printer: Printer) -&gt; None\n</code></pre> Source code in <code>src/kirin/dialects/py/unpack.py</code> <pre><code>def print_impl(self, printer: Printer) -&gt; None:\n    printer.print_name(self)\n    printer.plain_print(\" \")\n    printer.print(self.value)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.unpack.unpacking","title":"unpacking","text":"<pre><code>unpacking(\n    state: lowering.LoweringState,\n    node: ast.expr,\n    value: ir.SSAValue,\n)\n</code></pre> Source code in <code>src/kirin/dialects/py/unpack.py</code> <pre><code>def unpacking(state: lowering.LoweringState, node: ast.expr, value: ir.SSAValue):\n    if isinstance(node, ast.Name):\n        state.current_frame.defs[node.id] = value\n        value.name = node.id\n        return\n    elif not isinstance(node, ast.Tuple):\n        raise DialectLoweringError(f\"unsupported unpack node {node}\")\n\n    names: list[str | None] = []\n    continue_unpack: list[int] = []\n    for idx, item in enumerate(node.elts):\n        if isinstance(item, ast.Name):\n            names.append(item.id)\n        else:\n            names.append(None)\n            continue_unpack.append(idx)\n    stmt = state.append_stmt(Unpack(value, tuple(names)))\n    for name, result in zip(names, stmt.results):\n        if name is not None:\n            state.current_frame.defs[name] = result\n\n    for idx in continue_unpack:\n        unpacking(state, node.elts[idx], stmt.results[idx])\n</code></pre>"},{"location":"dialects/python/core/#boolean-operation","title":"Boolean Operation","text":""},{"location":"dialects/python/core/#kirin.dialects.py.boolop","title":"kirin.dialects.py.boolop","text":"<p>Boolean operators for Python dialect.</p> <p>This module contains the dialect for the Python boolean operators, including:</p> <ul> <li>The <code>And</code> and <code>Or</code> statement classes.</li> <li>The lowering pass for the boolean operators.</li> <li>The concrete implementation of the boolean operators.</li> <li>The Julia emitter for the boolean operators.</li> </ul> <p>This dialect maps <code>ast.BoolOp</code> nodes to the <code>And</code> and <code>Or</code> statements.</p>"},{"location":"dialects/python/core/#kirin.dialects.py.boolop.dialect","title":"dialect  <code>module-attribute</code>","text":"<pre><code>dialect = Dialect('py.boolop')\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.boolop.And","title":"And  <code>kirin-statement</code> <code>krin-statement</code>","text":"<pre><code>And(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>BoolOp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.boolop.And.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'and'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.boolop.BoolOp","title":"BoolOp  <code>krin-statement</code>","text":"<pre><code>BoolOp(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.boolop.BoolOp.lhs","title":"lhs  <code>kirin-argument</code>","text":"<pre><code>lhs: SSAValue = argument(print=False)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.boolop.BoolOp.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(Bool)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.boolop.BoolOp.rhs","title":"rhs  <code>kirin-argument</code>","text":"<pre><code>rhs: SSAValue = argument(print=False)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.boolop.BoolOp.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({Pure(), FromPythonCall()})\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.boolop.BoolOpMethod","title":"BoolOpMethod  <code>dataclass</code>","text":"<pre><code>BoolOpMethod()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.boolop.BoolOpMethod.and_","title":"and_","text":"<pre><code>and_(interp, frame: interp.Frame, stmt: And)\n</code></pre> Source code in <code>src/kirin/dialects/py/boolop.py</code> <pre><code>@interp.impl(And)\ndef and_(self, interp, frame: interp.Frame, stmt: And):\n    return (frame.get(stmt.lhs) and frame.get(stmt.rhs),)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.boolop.BoolOpMethod.or_","title":"or_","text":"<pre><code>or_(interp, frame: interp.Frame, stmt: Or)\n</code></pre> Source code in <code>src/kirin/dialects/py/boolop.py</code> <pre><code>@interp.impl(Or)\ndef or_(self, interp, frame: interp.Frame, stmt: Or):\n    return (frame.get(stmt.lhs) or frame.get(stmt.rhs),)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.boolop.JuliaTable","title":"JuliaTable  <code>dataclass</code>","text":"<pre><code>JuliaTable()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.boolop.JuliaTable.emit_And","title":"emit_And","text":"<pre><code>emit_And(emit: EmitJulia, frame: EmitStrFrame, stmt: And)\n</code></pre> Source code in <code>src/kirin/dialects/py/boolop.py</code> <pre><code>@interp.impl(And)\ndef emit_And(self, emit: EmitJulia, frame: EmitStrFrame, stmt: And):\n    return emit.emit_binaryop(frame, \"&amp;&amp;\", stmt.lhs, stmt.rhs, stmt.result)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.boolop.JuliaTable.emit_Or","title":"emit_Or","text":"<pre><code>emit_Or(emit: EmitJulia, frame: EmitStrFrame, stmt: Or)\n</code></pre> Source code in <code>src/kirin/dialects/py/boolop.py</code> <pre><code>@interp.impl(Or)\ndef emit_Or(self, emit: EmitJulia, frame: EmitStrFrame, stmt: Or):\n    return emit.emit_binaryop(frame, \"||\", stmt.lhs, stmt.rhs, stmt.result)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.boolop.Or","title":"Or  <code>kirin-statement</code> <code>krin-statement</code>","text":"<pre><code>Or(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>BoolOp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.boolop.Or.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'or'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.boolop.PythonLowering","title":"PythonLowering","text":"<p>               Bases: <code>FromPythonAST</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.boolop.PythonLowering.lower_BoolOp","title":"lower_BoolOp","text":"<pre><code>lower_BoolOp(\n    state: lowering.LoweringState, node: ast.BoolOp\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/boolop.py</code> <pre><code>def lower_BoolOp(\n    self, state: lowering.LoweringState, node: ast.BoolOp\n) -&gt; lowering.Result:\n    lhs = state.visit(node.values[0]).expect_one()\n    match node.op:\n        case ast.And():\n            boolop = And\n        case ast.Or():\n            boolop = Or\n        case _:\n            raise DialectLoweringError(f\"unsupported boolop {node.op}\")\n\n    for value in node.values[1:]:\n        lhs = state.append_stmt(\n            boolop(lhs=lhs, rhs=state.visit(value).expect_one())\n        ).result\n    return lowering.Result(lhs)\n</code></pre>"},{"location":"dialects/python/core/#comparison","title":"Comparison","text":""},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts","title":"kirin.dialects.py.cmp.stmts","text":""},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.Cmp","title":"Cmp  <code>krin-statement</code>","text":"<pre><code>Cmp(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.Cmp.lhs","title":"lhs  <code>kirin-argument</code>","text":"<pre><code>lhs: SSAValue = argument()\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.Cmp.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(Bool)\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.Cmp.rhs","title":"rhs  <code>kirin-argument</code>","text":"<pre><code>rhs: SSAValue = argument()\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.Cmp.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({Pure(), FromPythonCall()})\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.Eq","title":"Eq  <code>kirin-statement</code> <code>krin-statement</code>","text":"<pre><code>Eq(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Cmp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.Eq.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'eq'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.Gt","title":"Gt  <code>kirin-statement</code> <code>krin-statement</code>","text":"<pre><code>Gt(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Cmp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.Gt.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'gt'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.GtE","title":"GtE  <code>kirin-statement</code> <code>krin-statement</code>","text":"<pre><code>GtE(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Cmp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.GtE.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'gte'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.In","title":"In  <code>kirin-statement</code> <code>krin-statement</code>","text":"<pre><code>In(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Cmp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.In.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'in'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.Is","title":"Is  <code>kirin-statement</code> <code>krin-statement</code>","text":"<pre><code>Is(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Cmp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.Is.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'is'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.IsNot","title":"IsNot  <code>kirin-statement</code> <code>krin-statement</code>","text":"<pre><code>IsNot(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Cmp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.IsNot.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'is_not'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.Lt","title":"Lt  <code>kirin-statement</code> <code>krin-statement</code>","text":"<pre><code>Lt(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Cmp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.Lt.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'lt'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.LtE","title":"LtE  <code>kirin-statement</code> <code>krin-statement</code>","text":"<pre><code>LtE(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Cmp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.LtE.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'lte'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.NotEq","title":"NotEq  <code>kirin-statement</code> <code>krin-statement</code>","text":"<pre><code>NotEq(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Cmp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.NotEq.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'ne'\n</code></pre>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.NotIn","title":"NotIn  <code>kirin-statement</code> <code>krin-statement</code>","text":"<pre><code>NotIn(lhs: ir.SSAValue, rhs: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Cmp</code></p>"},{"location":"dialects/python/core/#kirin.dialects.py.cmp.stmts.NotIn.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'not_in'\n</code></pre>"},{"location":"dialects/python/data/","title":"Data","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"dialects/python/data/#dialects-that-brings-in-common-python-data-types","title":"Dialects that brings in common Python data types","text":"<p>This page provides a reference for dialects that bring in semantics for common Python data types.</p> <p>Note</p> <p>While it is worth noting that using Python semantics can be very convenient, it is also important to remember that the Python semantics are not designed for compilation. Therefore, it is important to be aware of the limitations of using Python semantics in a compilation context especially when it comes to data types. An example of this is the <code>list</code> data type in Python which is a dynamic mutable array. When the low-level code is not expecting a dynamic mutable array, it can lead to extra complexity for compilation. An immutable array or a fixed-size array can be a better choice in such cases (see <code>ilist</code> dialect).</p>"},{"location":"dialects/python/data/#references","title":"References","text":""},{"location":"dialects/python/data/#tuple","title":"Tuple","text":""},{"location":"dialects/python/data/#kirin.dialects.py.tuple","title":"kirin.dialects.py.tuple","text":"<p>The tuple dialect for Python.</p> <p>This dialect provides a way to work with Python tuples in the IR, including:</p> <ul> <li>The <code>New</code> statement class.</li> <li>The lowering pass for the tuple statement.</li> <li>The concrete implementation of the tuple statement.</li> <li>The type inference implementation of the tuple addition with <code>py.binop.Add</code>.</li> <li>The constant propagation implementation of the tuple statement.</li> <li>The Julia emitter for the tuple statement.</li> </ul> <p>This dialect maps <code>ast.Tuple</code> nodes to the <code>New</code> statement.</p>"},{"location":"dialects/python/data/#kirin.dialects.py.tuple.dialect","title":"dialect  <code>module-attribute</code>","text":"<pre><code>dialect = Dialect('py.tuple')\n</code></pre>"},{"location":"dialects/python/data/#kirin.dialects.py.tuple.Concrete","title":"Concrete  <code>dataclass</code>","text":"<pre><code>Concrete()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/data/#kirin.dialects.py.tuple.Concrete.new","title":"new","text":"<pre><code>new(\n    interp: interp.Interpreter,\n    frame: interp.Frame,\n    stmt: New,\n)\n</code></pre> Source code in <code>src/kirin/dialects/py/tuple.py</code> <pre><code>@interp.impl(New)\ndef new(self, interp: interp.Interpreter, frame: interp.Frame, stmt: New):\n    return (frame.get_values(stmt.args),)\n</code></pre>"},{"location":"dialects/python/data/#kirin.dialects.py.tuple.ConstPropTable","title":"ConstPropTable  <code>dataclass</code>","text":"<pre><code>ConstPropTable()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/data/#kirin.dialects.py.tuple.ConstPropTable.new_tuple","title":"new_tuple","text":"<pre><code>new_tuple(\n    _: const.Propagate,\n    frame: interp.Frame[const.JointResult],\n    stmt: New,\n) -&gt; interp.StatementResult[const.JointResult]\n</code></pre> Source code in <code>src/kirin/dialects/py/tuple.py</code> <pre><code>@interp.impl(New)\ndef new_tuple(\n    self,\n    _: const.Propagate,\n    frame: interp.Frame[const.JointResult],\n    stmt: New,\n) -&gt; interp.StatementResult[const.JointResult]:\n    return (\n        const.JointResult(\n            const.PartialTuple(tuple(x.const for x in frame.get_values(stmt.args))),\n            const.Pure(),\n        ),\n    )\n</code></pre>"},{"location":"dialects/python/data/#kirin.dialects.py.tuple.JuliaTable","title":"JuliaTable  <code>dataclass</code>","text":"<pre><code>JuliaTable()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/data/#kirin.dialects.py.tuple.JuliaTable.emit_NewTuple","title":"emit_NewTuple","text":"<pre><code>emit_NewTuple(\n    emit: EmitJulia, frame: EmitStrFrame, stmt: New\n)\n</code></pre> Source code in <code>src/kirin/dialects/py/tuple.py</code> <pre><code>@interp.impl(New)\ndef emit_NewTuple(self, emit: EmitJulia, frame: EmitStrFrame, stmt: New):\n    return (\n        emit.write_assign(\n            frame, stmt.result, \"(\" + \", \".join(frame.get_values(stmt.args)) + \")\"\n        ),\n    )\n</code></pre>"},{"location":"dialects/python/data/#kirin.dialects.py.tuple.Lowering","title":"Lowering","text":"<p>               Bases: <code>FromPythonAST</code></p>"},{"location":"dialects/python/data/#kirin.dialects.py.tuple.Lowering.lower_Tuple","title":"lower_Tuple","text":"<pre><code>lower_Tuple(\n    state: lowering.LoweringState, node: ast.Tuple\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/tuple.py</code> <pre><code>def lower_Tuple(\n    self, state: lowering.LoweringState, node: ast.Tuple\n) -&gt; lowering.Result:\n    return lowering.Result(\n        state.append_stmt(\n            stmt=New(tuple(state.visit(elem).expect_one() for elem in node.elts))\n        )\n    )\n</code></pre>"},{"location":"dialects/python/data/#kirin.dialects.py.tuple.New","title":"New  <code>krin-statement</code>","text":"<pre><code>New(values: tuple[ir.SSAValue, ...])\n</code></pre> <p>               Bases: <code>Statement</code></p> Source code in <code>src/kirin/dialects/py/tuple.py</code> <pre><code>def __init__(self, values: tuple[ir.SSAValue, ...]) -&gt; None:\n    result_type = ir.types.Generic(tuple, *tuple(value.type for value in values))\n    super().__init__(\n        args=values,\n        result_types=[\n            result_type,\n        ],\n    )\n</code></pre>"},{"location":"dialects/python/data/#kirin.dialects.py.tuple.New.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result()\n</code></pre>"},{"location":"dialects/python/data/#kirin.dialects.py.tuple.New.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({Pure(), FromPythonCall()})\n</code></pre>"},{"location":"dialects/python/data/#kirin.dialects.py.tuple.TypeInfer","title":"TypeInfer  <code>dataclass</code>","text":"<pre><code>TypeInfer()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/data/#kirin.dialects.py.tuple.TypeInfer.add","title":"add","text":"<pre><code>add(\n    interp,\n    frame: interp.Frame[ir.types.TypeAttribute],\n    stmt,\n)\n</code></pre> Source code in <code>src/kirin/dialects/py/tuple.py</code> <pre><code>@interp.impl(Add, ir.types.PyClass(tuple), ir.types.PyClass(tuple))\ndef add(self, interp, frame: interp.Frame[ir.types.TypeAttribute], stmt):\n    lhs = frame.get(stmt.lhs)\n    rhs = frame.get(stmt.rhs)\n    if isinstance(lhs, ir.types.Generic) and isinstance(rhs, ir.types.Generic):\n        return (ir.types.Generic(tuple, *(lhs.vars + rhs.vars)),)\n    else:\n        return (ir.types.PyClass(tuple),)  # no type param, so unknown\n</code></pre>"},{"location":"dialects/python/data/#list","title":"List","text":""},{"location":"dialects/python/data/#kirin.dialects.py.list","title":"kirin.dialects.py.list","text":"<p>The list dialect for Python.</p> <p>This module contains the dialect for list semantics in Python, including:</p> <ul> <li>The <code>New</code> and <code>Append</code> statement classes.</li> <li>The lowering pass for list operations.</li> <li>The concrete implementation of list operations.</li> <li>The type inference implementation of list operations.</li> </ul> <p>This dialect maps <code>list()</code>, <code>ast.List</code> and <code>append()</code> calls to the <code>New</code> and <code>Append</code> statements.</p>"},{"location":"dialects/python/sfunc/","title":"Special Functions","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"dialects/python/sfunc/#dialects-for-special-python-functions","title":"Dialects for special Python functions","text":"<p>There are some special built-in Python functions that does not necessarily provide new data types when using them as Kirin dialects.</p> <p>For example, the <code>py.range</code> dialect may not use a Python <code>range</code> type, the actual type can be decided by another dialect that implements the type inference method for <code>Range</code> statement, e.g <code>ilist</code> dialect provides an <code>IList</code> implementation for <code>Range</code> statement.</p> <p>The reason for this is that in many cases, eDSLs are not interested in the actual data type of the result, but rather the semantics of the operation. For <code>ilist</code> dialect, the <code>Range</code> statement is just a syntax sugar for creating a list of integers. The compiler will decide what the actual implementation (such as the memory layout) of the list should be.</p>"},{"location":"dialects/python/sfunc/#references","title":"References","text":""},{"location":"dialects/python/sfunc/#iterable","title":"Iterable","text":""},{"location":"dialects/python/sfunc/#kirin.dialects.py.iterable","title":"kirin.dialects.py.iterable","text":"<p>This module provides access to Python iterables.</p> <p>This is used to lower Python loops into <code>cf</code> dialect.</p> <p>This module contains the common methods for the Python iterable:</p> <ul> <li>The <code>Iter</code> statement class.</li> <li>The <code>Next</code> statement class.</li> <li>The lowering pass for the iterable.</li> <li>The concrete implementation of the iterable.</li> </ul> <p>This dialect maps <code>iter()</code> and <code>next()</code> calls to the <code>Iter</code> and <code>Next</code> statements.</p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.iterable.PyRangeIterType","title":"PyRangeIterType  <code>module-attribute</code>","text":"<pre><code>PyRangeIterType = PyClass(type(iter(range(0))))\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.iterable.dialect","title":"dialect  <code>module-attribute</code>","text":"<pre><code>dialect = Dialect('py.iterable')\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.iterable.Concrete","title":"Concrete  <code>dataclass</code>","text":"<pre><code>Concrete()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.iterable.Concrete.iter_","title":"iter_","text":"<pre><code>iter_(interp, frame: interp.Frame, stmt: Iter)\n</code></pre> Source code in <code>src/kirin/dialects/py/iterable.py</code> <pre><code>@interp.impl(Iter)\ndef iter_(self, interp, frame: interp.Frame, stmt: Iter):\n    return (iter(frame.get(stmt.value)),)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.iterable.Concrete.next_","title":"next_","text":"<pre><code>next_(interp, frame: interp.Frame, stmt: Next)\n</code></pre> Source code in <code>src/kirin/dialects/py/iterable.py</code> <pre><code>@interp.impl(Next)\ndef next_(self, interp, frame: interp.Frame, stmt: Next):\n    return (next(frame.get(stmt.iter), None),)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.iterable.Iter","title":"Iter  <code>krin-statement</code>","text":"<pre><code>Iter(value: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>This is equivalent to <code>iter(value)</code> in Python.</p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.iterable.Iter.iter","title":"iter  <code>kirin-result</code>","text":"<pre><code>iter: ResultValue = result(Any)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.iterable.Iter.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({Pure()})\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.iterable.Iter.value","title":"value  <code>kirin-argument</code>","text":"<pre><code>value: SSAValue = argument(Any)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.iterable.Lowering","title":"Lowering","text":"<p>               Bases: <code>FromPythonAST</code></p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.iterable.Lowering.lower_Call_iter","title":"lower_Call_iter","text":"<pre><code>lower_Call_iter(\n    state: lowering.LoweringState, node: Call\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/iterable.py</code> <pre><code>def lower_Call_iter(\n    self, state: lowering.LoweringState, node: Call\n) -&gt; lowering.Result:\n    if len(node.args) != 1:\n        raise DialectLoweringError(\"iter() takes exactly 1 argument\")\n    return lowering.Result(\n        state.append_stmt(Iter(state.visit(node.args[0]).expect_one()))\n    )\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.iterable.Lowering.lower_Call_next","title":"lower_Call_next","text":"<pre><code>lower_Call_next(\n    state: lowering.LoweringState, node: Call\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/iterable.py</code> <pre><code>def lower_Call_next(\n    self, state: lowering.LoweringState, node: Call\n) -&gt; lowering.Result:\n    if len(node.args) == 2:\n        raise DialectLoweringError(\n            \"next() does not throw StopIteration inside kernel\"\n        )\n    if len(node.args) != 1:\n        raise DialectLoweringError(\"next() takes exactly 1 argument\")\n    return lowering.Result(\n        state.append_stmt(Next(state.visit(node.args[0]).expect_one()))\n    )\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.iterable.Next","title":"Next  <code>krin-statement</code>","text":"<pre><code>Next(iter: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>This is equivalent to <code>next(iterable, None)</code> in Python.</p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.iterable.Next.iter","title":"iter  <code>kirin-argument</code>","text":"<pre><code>iter: SSAValue = argument(Any)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.iterable.Next.value","title":"value  <code>kirin-result</code>","text":"<pre><code>value: ResultValue = result(Any)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.iterable.TypeInfer","title":"TypeInfer  <code>dataclass</code>","text":"<pre><code>TypeInfer()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.iterable.TypeInfer.iter_","title":"iter_","text":"<pre><code>iter_(interp, frame: interp.Frame, stmt: Iter)\n</code></pre> Source code in <code>src/kirin/dialects/py/iterable.py</code> <pre><code>@interp.impl(Iter, ir.types.PyClass(range))\ndef iter_(self, interp, frame: interp.Frame, stmt: Iter):\n    return (PyRangeIterType,)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.iterable.TypeInfer.next_","title":"next_","text":"<pre><code>next_(interp, frame: interp.Frame, stmt: Next)\n</code></pre> Source code in <code>src/kirin/dialects/py/iterable.py</code> <pre><code>@interp.impl(Next, PyRangeIterType)\ndef next_(self, interp, frame: interp.Frame, stmt: Next):\n    return (ir.types.Int,)\n</code></pre>"},{"location":"dialects/python/sfunc/#len","title":"Len","text":""},{"location":"dialects/python/sfunc/#kirin.dialects.py.len","title":"kirin.dialects.py.len","text":"<p>The <code>Len</code> dialect.</p> <p>This dialect maps the <code>len()</code> call to the <code>Len</code> statement:</p> <ul> <li>The <code>Len</code> statement class.</li> <li>The lowering pass for the <code>len()</code> call.</li> <li>The concrete implementation of the <code>len()</code> call.</li> </ul>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.len.dialect","title":"dialect  <code>module-attribute</code>","text":"<pre><code>dialect = Dialect('py.len')\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.len.Concrete","title":"Concrete  <code>dataclass</code>","text":"<pre><code>Concrete()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.len.Concrete.len","title":"len","text":"<pre><code>len(interp, frame: interp.Frame, stmt: Len)\n</code></pre> Source code in <code>src/kirin/dialects/py/len.py</code> <pre><code>@interp.impl(Len)\ndef len(self, interp, frame: interp.Frame, stmt: Len):\n    return (len(frame.get(stmt.value)),)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.len.Len","title":"Len  <code>krin-statement</code>","text":"<pre><code>Len(value: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.len.Len.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'len'\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.len.Len.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(Int)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.len.Len.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({Pure(), FromPythonCall()})\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.len.Len.value","title":"value  <code>kirin-argument</code>","text":"<pre><code>value: SSAValue = argument(Any)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.len.Lowering","title":"Lowering","text":"<p>               Bases: <code>FromPythonAST</code></p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.len.Lowering.lower_Call_len","title":"lower_Call_len","text":"<pre><code>lower_Call_len(\n    state: lowering.LoweringState, node: ast.Call\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/len.py</code> <pre><code>def lower_Call_len(\n    self, state: lowering.LoweringState, node: ast.Call\n) -&gt; lowering.Result:\n    return lowering.Result(\n        state.append_stmt(Len(value=state.visit(node.args[0]).expect_one()))\n    )\n</code></pre>"},{"location":"dialects/python/sfunc/#range","title":"Range","text":""},{"location":"dialects/python/sfunc/#kirin.dialects.py.range","title":"kirin.dialects.py.range","text":"<p>The range dialect for Python.</p> <p>This dialect models the builtin <code>range()</code> function in Python.</p> <p>The dialect includes: - The <code>Range</code> statement class. - The lowering pass for the <code>range()</code> function.</p> <p>This dialect does not include a concrete implementation or type inference for the <code>range()</code> function. One needs to use other dialect for the concrete implementation and type inference, e.g., <code>ilist</code> dialect.</p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.range.dialect","title":"dialect  <code>module-attribute</code>","text":"<pre><code>dialect = Dialect('py.range')\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.range.Lowering","title":"Lowering","text":"<p>               Bases: <code>FromPythonAST</code></p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.range.Lowering.lower_Call_range","title":"lower_Call_range","text":"<pre><code>lower_Call_range(\n    state: lowering.LoweringState, node: ast.Call\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/range.py</code> <pre><code>def lower_Call_range(\n    self, state: lowering.LoweringState, node: ast.Call\n) -&gt; lowering.Result:\n    return _lower_range(state, node)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.range.Range","title":"Range  <code>krin-statement</code>","text":"<pre><code>Range(\n    start: ir.SSAValue, stop: ir.SSAValue, step: ir.SSAValue\n)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.range.Range.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'range'\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.range.Range.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(PyClass(range))\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.range.Range.start","title":"start  <code>kirin-argument</code>","text":"<pre><code>start: SSAValue = argument(Int)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.range.Range.step","title":"step  <code>kirin-argument</code>","text":"<pre><code>step: SSAValue = argument(Int)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.range.Range.stop","title":"stop  <code>kirin-argument</code>","text":"<pre><code>stop: SSAValue = argument(Int)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.range.Range.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({Pure(), RangeLowering()})\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.range.RangeLowering","title":"RangeLowering  <code>dataclass</code>","text":"<pre><code>RangeLowering()\n</code></pre> <p>               Bases: <code>FromPythonCall['Range']</code></p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.range.RangeLowering.lower","title":"lower","text":"<pre><code>lower(\n    stmt: type[Range],\n    state: lowering.LoweringState,\n    node: ast.Call,\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/range.py</code> <pre><code>def lower(\n    self, stmt: type[\"Range\"], state: lowering.LoweringState, node: ast.Call\n) -&gt; lowering.Result:\n    return _lower_range(state, node)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.range._lower_range","title":"_lower_range","text":"<pre><code>_lower_range(\n    state: lowering.LoweringState, node: ast.Call\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/range.py</code> <pre><code>def _lower_range(state: lowering.LoweringState, node: ast.Call) -&gt; lowering.Result:\n    if len(node.args) == 1:\n        start = state.visit(ast.Constant(0)).expect_one()\n        stop = state.visit(node.args[0]).expect_one()\n        step = state.visit(ast.Constant(1)).expect_one()\n    elif len(node.args) == 2:\n        start = state.visit(node.args[0]).expect_one()\n        stop = state.visit(node.args[1]).expect_one()\n        step = state.visit(ast.Constant(1)).expect_one()\n    elif len(node.args) == 3:\n        start = state.visit(node.args[0]).expect_one()\n        stop = state.visit(node.args[1]).expect_one()\n        step = state.visit(node.args[2]).expect_one()\n    else:\n        raise exceptions.DialectLoweringError(\"range() takes 1-3 arguments\")\n\n    return lowering.Result(state.append_stmt(Range(start, stop, step)))\n</code></pre>"},{"location":"dialects/python/sfunc/#slice","title":"Slice","text":""},{"location":"dialects/python/sfunc/#kirin.dialects.py.slice","title":"kirin.dialects.py.slice","text":"<p>The slice dialect for Python.</p> <p>This dialect provides a <code>Slice</code> statement that represents a slice object in Python:</p> <ul> <li>The <code>Slice</code> statement class.</li> <li>The lowering pass for the <code>slice</code> call.</li> <li>The concrete implementation of the <code>slice</code> call.</li> <li>The type inference implementation of the <code>slice</code> call.</li> </ul>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.slice.dialect","title":"dialect  <code>module-attribute</code>","text":"<pre><code>dialect = Dialect('py.slice')\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.slice.Concrete","title":"Concrete  <code>dataclass</code>","text":"<pre><code>Concrete()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.slice.Concrete._slice","title":"_slice","text":"<pre><code>_slice(interp, frame: interp.Frame, stmt: Slice)\n</code></pre> Source code in <code>src/kirin/dialects/py/slice.py</code> <pre><code>@interp.impl(Slice)\ndef _slice(self, interp, frame: interp.Frame, stmt: Slice):\n    start, stop, step = frame.get_values(stmt.args)\n    if start is None and step is None:\n        return (slice(stop),)\n    elif step is None:\n        return (slice(start, stop),)\n    else:\n        return (slice(start, stop, step),)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.slice.Lowering","title":"Lowering","text":"<p>               Bases: <code>FromPythonAST</code></p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.slice.Lowering.lower_Call_slice","title":"lower_Call_slice","text":"<pre><code>lower_Call_slice(\n    state: lowering.LoweringState, node: ast.Call\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/slice.py</code> <pre><code>def lower_Call_slice(\n    self, state: lowering.LoweringState, node: ast.Call\n) -&gt; lowering.Result:\n    return _lower_slice(state, node)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.slice.Lowering.lower_Slice","title":"lower_Slice","text":"<pre><code>lower_Slice(\n    state: lowering.LoweringState, node: ast.Slice\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/slice.py</code> <pre><code>def lower_Slice(\n    self, state: lowering.LoweringState, node: ast.Slice\n) -&gt; lowering.Result:\n    def value_or_none(expr: ast.expr | None) -&gt; ir.SSAValue:\n        if expr is not None:\n            return state.visit(expr).expect_one()\n        else:\n            return state.append_stmt(Constant(None)).result\n\n    lower = value_or_none(node.lower)\n    upper = value_or_none(node.upper)\n    step = value_or_none(node.step)\n    return lowering.Result(\n        state.append_stmt(Slice(start=lower, stop=upper, step=step))\n    )\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.slice.Slice","title":"Slice  <code>krin-statement</code>","text":"<pre><code>Slice(\n    start: ir.SSAValue, stop: ir.SSAValue, step: ir.SSAValue\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> Source code in <code>src/kirin/dialects/py/slice.py</code> <pre><code>def __init__(\n    self, start: ir.SSAValue, stop: ir.SSAValue, step: ir.SSAValue\n) -&gt; None:\n    if not (\n        isinstance(stop.type, types.TypeAttribute)\n        and isinstance(start.type, types.TypeAttribute)\n    ):\n        result_type = types.Bottom\n    elif start.type.is_subseteq(types.NoneType):\n        if stop.type.is_subseteq(types.NoneType):\n            result_type = types.Bottom\n        else:\n            result_type = types.Slice[types.unwrap_hinted(stop.type)]\n    else:\n        result_type = types.Slice[types.unwrap_hinted(start.type)]\n\n    super().__init__(\n        args=(start, stop, step),\n        result_types=[result_type],\n        args_slice={\"start\": 0, \"stop\": 1, \"step\": 2},\n    )\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.slice.Slice.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'slice'\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.slice.Slice.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(Slice)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.slice.Slice.start","title":"start  <code>kirin-argument</code>","text":"<pre><code>start: SSAValue = argument(Any)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.slice.Slice.step","title":"step  <code>kirin-argument</code>","text":"<pre><code>step: SSAValue = argument(Any)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.slice.Slice.stop","title":"stop  <code>kirin-argument</code>","text":"<pre><code>stop: SSAValue = argument(Any)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.slice.Slice.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({Pure(), SliceLowering()})\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.slice.SliceLowering","title":"SliceLowering  <code>dataclass</code>","text":"<pre><code>SliceLowering()\n</code></pre> <p>               Bases: <code>FromPythonCall['Slice']</code></p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.slice.SliceLowering.lower","title":"lower","text":"<pre><code>lower(\n    stmt: type[Slice],\n    state: lowering.LoweringState,\n    node: ast.Call,\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/slice.py</code> <pre><code>def lower(\n    self, stmt: type[\"Slice\"], state: lowering.LoweringState, node: ast.Call\n) -&gt; lowering.Result:\n    return _lower_slice(state, node)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.slice.TypeInfer","title":"TypeInfer  <code>dataclass</code>","text":"<pre><code>TypeInfer()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.slice.TypeInfer.slice","title":"slice","text":"<pre><code>slice(\n    interp: TypeInference,\n    frame: interp.Frame[types.TypeAttribute],\n    stmt: Slice,\n)\n</code></pre> Source code in <code>src/kirin/dialects/py/slice.py</code> <pre><code>@interp.impl(Slice)\ndef slice(\n    self,\n    interp: TypeInference,\n    frame: interp.Frame[types.TypeAttribute],\n    stmt: Slice,\n):\n    start, stop, step = frame.get_values(stmt.args)\n    if interp.is_const(start) and interp.is_const(stop) and interp.is_const(step):\n        return (\n            types.Hinted(\n                stmt.result.type,\n                slice(start.data.data, stop.data.data, step.data.data),\n            ),\n        )\n\n    return (stmt.result.type,)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.slice._lower_slice","title":"_lower_slice","text":"<pre><code>_lower_slice(\n    state: lowering.LoweringState, node: ast.Call\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/slice.py</code> <pre><code>def _lower_slice(state: lowering.LoweringState, node: ast.Call) -&gt; lowering.Result:\n    if len(node.args) == 1:\n        start = state.visit(ast.Constant(None)).expect_one()\n        stop = state.visit(node.args[0]).expect_one()\n        step = state.visit(ast.Constant(None)).expect_one()\n    elif len(node.args) == 2:\n        start = state.visit(node.args[0]).expect_one()\n        stop = state.visit(node.args[1]).expect_one()\n        step = state.visit(ast.Constant(None)).expect_one()\n    elif len(node.args) == 3:\n        start = state.visit(node.args[0]).expect_one()\n        stop = state.visit(node.args[1]).expect_one()\n        step = state.visit(node.args[2]).expect_one()\n    else:\n        raise exceptions.DialectLoweringError(\"slice() takes 1-3 arguments\")\n\n    return lowering.Result(state.append_stmt(Slice(start, stop, step)))\n</code></pre>"},{"location":"dialects/python/sfunc/#built-in-function","title":"Built-in Function","text":""},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin","title":"kirin.dialects.py.builtin","text":"<p>builtin dialect for python builtins</p> <p>This dialect provides implementations for builtin functions like abs and sum.</p> <ul> <li>Statements: <code>Abs</code>, <code>Sum</code>.</li> <li>The lowering pass for the builtin functions.</li> <li>The concrete implementation of the builtin functions.</li> <li>The type inference implementation of the builtin functions.</li> </ul> <p>This dialect maps <code>ast.Call</code> nodes of builtin functions to the <code>Abs</code> and <code>Sum</code> statements.</p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.T","title":"T  <code>module-attribute</code>","text":"<pre><code>T = TypeVar('T', bound=Int | Float)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.dialect","title":"dialect  <code>module-attribute</code>","text":"<pre><code>dialect = Dialect('py.builtin')\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.Abs","title":"Abs  <code>krin-statement</code>","text":"<pre><code>Abs(value: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.Abs.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'abs'\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.Abs.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(T)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.Abs.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({Pure(), FromPythonCall()})\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.Abs.value","title":"value  <code>kirin-argument</code>","text":"<pre><code>value: SSAValue = argument(T, print=False)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.Concrete","title":"Concrete  <code>dataclass</code>","text":"<pre><code>Concrete()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.Concrete._sum","title":"_sum","text":"<pre><code>_sum(interp, frame: interp.Frame, stmt: Sum)\n</code></pre> Source code in <code>src/kirin/dialects/py/builtin.py</code> <pre><code>@interp.impl(Sum)\ndef _sum(self, interp, frame: interp.Frame, stmt: Sum):\n    return (sum(frame.get(stmt.value)),)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.Concrete.abs","title":"abs","text":"<pre><code>abs(interp, frame: interp.Frame, stmt: Abs)\n</code></pre> Source code in <code>src/kirin/dialects/py/builtin.py</code> <pre><code>@interp.impl(Abs)\ndef abs(self, interp, frame: interp.Frame, stmt: Abs):\n    return (abs(frame.get(stmt.value)),)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.Lowering","title":"Lowering","text":"<p>               Bases: <code>FromPythonAST</code></p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.Lowering.lower_Call_abs","title":"lower_Call_abs","text":"<pre><code>lower_Call_abs(\n    state: lowering.LoweringState, node: Call\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/builtin.py</code> <pre><code>def lower_Call_abs(\n    self, state: lowering.LoweringState, node: Call\n) -&gt; lowering.Result:\n    return lowering.Result(\n        state.append_stmt(Abs(state.visit(node.args[0]).expect_one()))\n    )\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.Lowering.lower_Call_sum","title":"lower_Call_sum","text":"<pre><code>lower_Call_sum(\n    state: lowering.LoweringState, node: Call\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/builtin.py</code> <pre><code>def lower_Call_sum(\n    self, state: lowering.LoweringState, node: Call\n) -&gt; lowering.Result:\n    return lowering.Result(\n        state.append_stmt(Sum(state.visit(node.args[0]).expect_one()))\n    )\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.Sum","title":"Sum  <code>krin-statement</code>","text":"<pre><code>Sum(value: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.Sum.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'sum'\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.Sum.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(Any)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.Sum.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({Pure(), FromPythonCall()})\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.Sum.value","title":"value  <code>kirin-argument</code>","text":"<pre><code>value: SSAValue = argument(Any, print=False)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.TypeInfer","title":"TypeInfer  <code>dataclass</code>","text":"<pre><code>TypeInfer()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.TypeInfer.absf","title":"absf","text":"<pre><code>absf(interp, frame, stmt)\n</code></pre> Source code in <code>src/kirin/dialects/py/builtin.py</code> <pre><code>@interp.impl(Abs, types.Float)\ndef absf(self, interp, frame, stmt):\n    return (types.Float,)\n</code></pre>"},{"location":"dialects/python/sfunc/#kirin.dialects.py.builtin.TypeInfer.absi","title":"absi","text":"<pre><code>absi(interp, frame, stmt)\n</code></pre> Source code in <code>src/kirin/dialects/py/builtin.py</code> <pre><code>@interp.impl(Abs, types.Int)\ndef absi(self, interp, frame, stmt):\n    return (types.Int,)\n</code></pre>"},{"location":"dialects/python/sugar/","title":"Syntax Sugar","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"dialects/python/sugar/#dialects-for-python-syntax-sugar","title":"Dialects for Python Syntax Sugar","text":"<p>This page contains the dialects designed to represent Python syntax sugar. They provide an implementation of lowering transform from the corresponding Python AST to the dialects' statements. All the statements are typed <code>Any</code> thus one can always use a custom rewrite pass after type inference to support the desired syntax sugar.</p>"},{"location":"dialects/python/sugar/#reference","title":"Reference","text":""},{"location":"dialects/python/sugar/#indexing","title":"Indexing","text":""},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing","title":"kirin.dialects.py.indexing","text":"<p>The indexing dialect for Python.</p> <p>This module contains the dialect for the Python indexing syntax, including:</p> <ul> <li>The <code>GetItem</code> statement class.</li> <li>A base class <code>Subscript</code> for indexing statements.</li> <li>A trait <code>GetItemLike</code> for indexing statements.</li> <li>The lowering pass for the indexing statement.</li> <li>The concrete implementation of the indexing statement.</li> <li>The constant propagation implementation (special case) of the indexing statement.</li> <li>The type inference implementation of the indexing statement.</li> <li>A canonical rewrite rule for the rewriting of a given getitem-like     statement to another getitem-like statement.</li> </ul>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.GetItemLikeStmt","title":"GetItemLikeStmt  <code>module-attribute</code>","text":"<pre><code>GetItemLikeStmt = TypeVar(\n    \"GetItemLikeStmt\", bound=Statement\n)\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.PyGetItemLikeStmt","title":"PyGetItemLikeStmt  <code>module-attribute</code>","text":"<pre><code>PyGetItemLikeStmt = TypeVar(\n    \"PyGetItemLikeStmt\", bound=\"GetItem\"\n)\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.dialect","title":"dialect  <code>module-attribute</code>","text":"<pre><code>dialect = Dialect('py.indexing')\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.Concrete","title":"Concrete  <code>dataclass</code>","text":"<pre><code>Concrete()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.Concrete.getindex","title":"getindex","text":"<pre><code>getindex(interp, frame: interp.Frame, stmt: GetItem)\n</code></pre> Source code in <code>src/kirin/dialects/py/indexing.py</code> <pre><code>@interp.impl(GetItem)\ndef getindex(self, interp, frame: interp.Frame, stmt: GetItem):\n    return (frame.get(stmt.obj)[frame.get(stmt.index)],)\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.ConstProp","title":"ConstProp  <code>dataclass</code>","text":"<pre><code>ConstProp()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.ConstProp.getitem","title":"getitem","text":"<pre><code>getitem(\n    _: const.Propagate,\n    frame: interp.Frame[const.JointResult],\n    stmt: GetItem,\n) -&gt; interp.StatementResult[const.JointResult]\n</code></pre> Source code in <code>src/kirin/dialects/py/indexing.py</code> <pre><code>@interp.impl(GetItem)\ndef getitem(\n    self,\n    _: const.Propagate,\n    frame: interp.Frame[const.JointResult],\n    stmt: GetItem,\n) -&gt; interp.StatementResult[const.JointResult]:\n    obj = frame.get(stmt.obj).const\n    index = frame.get(stmt.index).const\n    if not isinstance(index, const.Value):\n        return (const.JointResult(const.Unknown(), const.Pure()),)\n\n    if isinstance(obj, const.PartialTuple):\n        obj = obj.data\n        if isinstance(index.data, int) and 0 &lt;= index.data &lt; len(obj):\n            return (const.JointResult(obj[index.data], const.Pure()),)\n        elif isinstance(index.data, slice):\n            start, stop, step = index.data.indices(len(obj))\n            return (\n                const.JointResult(\n                    const.PartialTuple(obj[start:stop:step]), const.Pure()\n                ),\n            )\n    return (const.JointResult(const.Unknown(), const.Pure()),)\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.GetItem","title":"GetItem  <code>kirin-statement</code> <code>krin-statement</code>","text":"<pre><code>GetItem(obj: ir.SSAValue, index: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Subscript</code></p>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.GetItem.index","title":"index  <code>kirin-argument</code>","text":"<pre><code>index: SSAValue = argument(print=False)\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.GetItem.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'getitem'\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.GetItem.obj","title":"obj  <code>kirin-argument</code>","text":"<pre><code>obj: SSAValue = argument(print=False)\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.GetItem.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result(Any)\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.GetItem.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset(\n    {Pure(), PyGetItemLike(), FromPythonCall()}\n)\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.GetItemLike","title":"GetItemLike  <code>dataclass</code>","text":"<pre><code>GetItemLike()\n</code></pre> <p>               Bases: <code>StmtTrait</code>, <code>Generic[GetItemLikeStmt]</code></p>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.GetItemLike.get_index","title":"get_index  <code>abstractmethod</code>","text":"<pre><code>get_index(stmt: GetItemLikeStmt) -&gt; ir.SSAValue\n</code></pre> Source code in <code>src/kirin/dialects/py/indexing.py</code> <pre><code>@abstractmethod\ndef get_index(self, stmt: GetItemLikeStmt) -&gt; ir.SSAValue: ...\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.GetItemLike.get_object","title":"get_object  <code>abstractmethod</code>","text":"<pre><code>get_object(stmt: GetItemLikeStmt) -&gt; ir.SSAValue\n</code></pre> Source code in <code>src/kirin/dialects/py/indexing.py</code> <pre><code>@abstractmethod\ndef get_object(self, stmt: GetItemLikeStmt) -&gt; ir.SSAValue: ...\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.GetItemLike.new","title":"new  <code>abstractmethod</code>","text":"<pre><code>new(\n    stmt_type: type[GetItemLikeStmt],\n    obj: ir.SSAValue,\n    index: ir.SSAValue,\n) -&gt; GetItemLikeStmt\n</code></pre> Source code in <code>src/kirin/dialects/py/indexing.py</code> <pre><code>@abstractmethod\ndef new(\n    self, stmt_type: type[GetItemLikeStmt], obj: ir.SSAValue, index: ir.SSAValue\n) -&gt; GetItemLikeStmt: ...\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.Lowering","title":"Lowering","text":"<p>               Bases: <code>FromPythonAST</code></p>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.Lowering.lower_Subscript","title":"lower_Subscript","text":"<pre><code>lower_Subscript(\n    state: lowering.LoweringState, node: ast.Subscript\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/indexing.py</code> <pre><code>def lower_Subscript(\n    self, state: lowering.LoweringState, node: ast.Subscript\n) -&gt; lowering.Result:\n    value = state.visit(node.value).expect_one()\n    slice = state.visit(node.slice).expect_one()\n    if isinstance(node.ctx, ast.Load):\n        stmt = GetItem(obj=value, index=slice)\n    else:\n        raise exceptions.DialectLoweringError(\n            f\"unsupported subscript context {node.ctx}\"\n        )\n    state.append_stmt(stmt)\n    return lowering.Result(stmt)\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.PyGetItemLike","title":"PyGetItemLike  <code>dataclass</code>","text":"<pre><code>PyGetItemLike()\n</code></pre> <p>               Bases: <code>GetItemLike[PyGetItemLikeStmt]</code></p>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.PyGetItemLike.get_index","title":"get_index","text":"<pre><code>get_index(stmt: PyGetItemLikeStmt) -&gt; ir.SSAValue\n</code></pre> Source code in <code>src/kirin/dialects/py/indexing.py</code> <pre><code>def get_index(self, stmt: PyGetItemLikeStmt) -&gt; ir.SSAValue:\n    return stmt.index\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.PyGetItemLike.get_object","title":"get_object","text":"<pre><code>get_object(stmt: PyGetItemLikeStmt) -&gt; ir.SSAValue\n</code></pre> Source code in <code>src/kirin/dialects/py/indexing.py</code> <pre><code>def get_object(self, stmt: PyGetItemLikeStmt) -&gt; ir.SSAValue:\n    return stmt.obj\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.PyGetItemLike.new","title":"new","text":"<pre><code>new(\n    stmt_type: type[PyGetItemLikeStmt],\n    obj: ir.SSAValue,\n    index: ir.SSAValue,\n) -&gt; PyGetItemLikeStmt\n</code></pre> Source code in <code>src/kirin/dialects/py/indexing.py</code> <pre><code>def new(\n    self, stmt_type: type[PyGetItemLikeStmt], obj: ir.SSAValue, index: ir.SSAValue\n) -&gt; PyGetItemLikeStmt:\n    return stmt_type(obj=obj, index=index)\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.RewriteGetItem","title":"RewriteGetItem  <code>dataclass</code>","text":"<pre><code>RewriteGetItem(\n    stmt_type: type[GetItemLikeStmt],\n    obj_type: ir.types.TypeAttribute,\n)\n</code></pre> <p>               Bases: <code>RewriteRule</code>, <code>Generic[GetItemLikeStmt]</code></p> Source code in <code>src/kirin/dialects/py/indexing.py</code> <pre><code>def __init__(\n    self, stmt_type: type[GetItemLikeStmt], obj_type: ir.types.TypeAttribute\n):\n    trait = stmt_type.get_trait(GetItemLike)\n    if trait is None:\n        raise ValueError(f\"{stmt_type} does not have GetItemLike trait\")\n\n    self.obj_type = obj_type\n    self.target_stmt_type = stmt_type\n    self.getitem_like = trait\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.RewriteGetItem.getitem_like","title":"getitem_like  <code>instance-attribute</code>","text":"<pre><code>getitem_like: GetItemLike[GetItemLikeStmt] = trait\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.RewriteGetItem.obj_type","title":"obj_type  <code>instance-attribute</code>","text":"<pre><code>obj_type: TypeAttribute = obj_type\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.RewriteGetItem.target_stmt_type","title":"target_stmt_type  <code>instance-attribute</code>","text":"<pre><code>target_stmt_type: type[GetItemLikeStmt] = stmt_type\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.RewriteGetItem.rewrite_Statement","title":"rewrite_Statement","text":"<pre><code>rewrite_Statement(node: ir.Statement) -&gt; RewriteResult\n</code></pre> Source code in <code>src/kirin/dialects/py/indexing.py</code> <pre><code>def rewrite_Statement(self, node: ir.Statement) -&gt; RewriteResult:\n    if not isinstance(node, GetItem):\n        return RewriteResult()\n\n    if not node.obj.type.is_subseteq(self.obj_type):\n        return RewriteResult()\n\n    node.replace_by(\n        self.getitem_like.new(self.target_stmt_type, node.obj, node.index)\n    )\n    return RewriteResult(has_done_something=True)\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.Subscript","title":"Subscript  <code>krin-statement</code>","text":"<pre><code>Subscript()\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.TypeInfer","title":"TypeInfer  <code>dataclass</code>","text":"<pre><code>TypeInfer()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.TypeInfer.getitem","title":"getitem","text":"<pre><code>getitem(\n    interp: TypeInference,\n    frame: interp.Frame[ir.types.TypeAttribute],\n    stmt: GetItem,\n)\n</code></pre> Source code in <code>src/kirin/dialects/py/indexing.py</code> <pre><code>@interp.impl(GetItem)\ndef getitem(\n    self,\n    interp: TypeInference,\n    frame: interp.Frame[ir.types.TypeAttribute],\n    stmt: GetItem,\n):\n    obj = frame.get(stmt.obj)\n    if interp.is_const(obj):  # unwrap const\n        obj = obj.type\n    index: ir.types.TypeAttribute = frame.get(stmt.index)\n    # TODO: replace this when we can multiple dispatch\n    if obj.is_subseteq(ir.types.Tuple):\n        return self.getitem_tuple(interp, stmt, obj, index)\n    else:\n        return (ir.types.Any,)\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.TypeInfer.getitem_tuple","title":"getitem_tuple","text":"<pre><code>getitem_tuple(\n    interp,\n    stmt: GetItem,\n    obj: ir.types.TypeAttribute,\n    index: ir.types.TypeAttribute,\n)\n</code></pre> Source code in <code>src/kirin/dialects/py/indexing.py</code> <pre><code>def getitem_tuple(\n    self,\n    interp,\n    stmt: GetItem,\n    obj: ir.types.TypeAttribute,\n    index: ir.types.TypeAttribute,\n):\n    if isinstance(obj, ir.types.Generic):\n        if index.is_subseteq(ir.types.Int):\n            return self.getitem_tuple_index(interp, stmt, obj, index)\n        elif index.is_subseteq(ir.types.Slice):\n            return self.getitem_tuple_slice(interp, stmt, obj, index)\n        else:\n            return (ir.types.Bottom,)\n    elif isinstance(obj, ir.types.PyClass):\n        return (ir.types.Any,)\n    else:\n        return (ir.types.Bottom,)\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.TypeInfer.getitem_tuple_index","title":"getitem_tuple_index","text":"<pre><code>getitem_tuple_index(\n    interp: TypeInference,\n    stmt: GetItem,\n    obj: ir.types.Generic,\n    index: ir.types.TypeAttribute,\n)\n</code></pre> Source code in <code>src/kirin/dialects/py/indexing.py</code> <pre><code>def getitem_tuple_index(\n    self,\n    interp: TypeInference,\n    stmt: GetItem,\n    obj: ir.types.Generic,\n    index: ir.types.TypeAttribute,\n):\n    if interp.is_const(index) and index.type.is_subseteq(ir.types.Int):\n        index_: int = index.data.data\n        if obj.vararg and index_ &gt;= len(obj.vars):\n            return (obj.vararg.typ,)\n        elif index_ &lt; len(obj.vars):\n            return (obj.vars[index_],)\n        else:\n            return (ir.types.Bottom,)\n    else:\n        return (self.getitem_tuple_union(obj),)\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.TypeInfer.getitem_tuple_slice","title":"getitem_tuple_slice","text":"<pre><code>getitem_tuple_slice(\n    interp: TypeInference,\n    stmt: GetItem,\n    obj: ir.types.Generic,\n    index: ir.types.TypeAttribute,\n)\n</code></pre> Source code in <code>src/kirin/dialects/py/indexing.py</code> <pre><code>def getitem_tuple_slice(\n    self,\n    interp: TypeInference,\n    stmt: GetItem,\n    obj: ir.types.Generic,\n    index: ir.types.TypeAttribute,\n):\n    if interp.is_const(index):\n        data: slice = index.data.data\n        if obj.vararg and data.stop &gt;= len(obj.vars):\n            return (\n                ir.types.Union(\n                    *obj.vars[slice(data.start, len(obj.vars), data.step)],\n                    obj.vararg.typ,\n                ),\n            )\n        elif data.stop is None or data.stop &lt; len(obj.vars):\n            return (\n                ir.types.Tuple.where(\n                    obj.vars[slice(data.start, data.stop, data.step)]\n                ),\n            )\n        else:  # out of bounds\n            return (ir.types.Bottom,)\n    else:\n        return (ir.types.Tuple[ir.types.Vararg(self.getitem_tuple_union(obj))],)\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.indexing.TypeInfer.getitem_tuple_union","title":"getitem_tuple_union","text":"<pre><code>getitem_tuple_union(obj: ir.types.Generic)\n</code></pre> Source code in <code>src/kirin/dialects/py/indexing.py</code> <pre><code>def getitem_tuple_union(self, obj: ir.types.Generic):\n    if obj.vararg:\n        return ir.types.Union(*obj.vars, obj.vararg.typ)\n    else:\n        return ir.types.Union(*obj.vars)\n</code></pre>"},{"location":"dialects/python/sugar/#attribute","title":"Attribute","text":""},{"location":"dialects/python/sugar/#kirin.dialects.py.attr","title":"kirin.dialects.py.attr","text":"<p>Attribute access dialect for Python.</p> <p>This module contains the dialect for the Python attribute access statement, including:</p> <ul> <li>The <code>GetAttr</code> statement class.</li> <li>The lowering pass for the attribute access statement.</li> <li>The concrete implementation of the attribute access statement.</li> </ul> <p>This dialect maps <code>ast.Attribute</code> nodes to the <code>GetAttr</code> statement.</p>"},{"location":"dialects/python/sugar/#kirin.dialects.py.attr.dialect","title":"dialect  <code>module-attribute</code>","text":"<pre><code>dialect = Dialect('py.attr')\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.attr.Concrete","title":"Concrete  <code>dataclass</code>","text":"<pre><code>Concrete()\n</code></pre> <p>               Bases: <code>MethodTable</code></p>"},{"location":"dialects/python/sugar/#kirin.dialects.py.attr.Concrete.getattr","title":"getattr","text":"<pre><code>getattr(\n    interp: interp.Interpreter,\n    frame: interp.Frame,\n    stmt: GetAttr,\n)\n</code></pre> Source code in <code>src/kirin/dialects/py/attr.py</code> <pre><code>@interp.impl(GetAttr)\ndef getattr(self, interp: interp.Interpreter, frame: interp.Frame, stmt: GetAttr):\n    return (getattr(frame.get(stmt.obj), stmt.attrname),)\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.attr.GetAttr","title":"GetAttr  <code>krin-statement</code>","text":"<pre><code>GetAttr(obj: ir.SSAValue, *, attrname: str)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"dialects/python/sugar/#kirin.dialects.py.attr.GetAttr.attrname","title":"attrname  <code>kirin-property</code> <code>kw-only</code>","text":"<pre><code>attrname: str = attribute(property=True)\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.attr.GetAttr.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'getattr'\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.attr.GetAttr.obj","title":"obj  <code>kirin-argument</code>","text":"<pre><code>obj: SSAValue = argument(print=False)\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.attr.GetAttr.result","title":"result  <code>kirin-result</code>","text":"<pre><code>result: ResultValue = result()\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.attr.GetAttr.traits","title":"traits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traits = frozenset({FromPythonCall()})\n</code></pre>"},{"location":"dialects/python/sugar/#kirin.dialects.py.attr.Lowering","title":"Lowering","text":"<p>               Bases: <code>FromPythonAST</code></p>"},{"location":"dialects/python/sugar/#kirin.dialects.py.attr.Lowering.lower_Attribute","title":"lower_Attribute","text":"<pre><code>lower_Attribute(\n    state: lowering.LoweringState, node: ast.Attribute\n) -&gt; lowering.Result\n</code></pre> Source code in <code>src/kirin/dialects/py/attr.py</code> <pre><code>def lower_Attribute(\n    self, state: lowering.LoweringState, node: ast.Attribute\n) -&gt; lowering.Result:\n    if not isinstance(node.ctx, ast.Load):\n        raise exceptions.DialectLoweringError(\n            f\"unsupported attribute context {node.ctx}\"\n        )\n    value = state.visit(node.value).expect_one()\n    stmt = GetAttr(obj=value, attrname=node.attr)\n    state.append_stmt(stmt)\n    return lowering.Result(stmt)\n</code></pre>"},{"location":"reference/kirin/","title":"Index","text":""},{"location":"reference/kirin/#kirin.statement","title":"statement","text":"<pre><code>statement(\n    cls=None, **kwargs: Unpack[StatementOptions]\n) -&gt; Callable[[type[StmtType]], type[StmtType]]\n</code></pre> <p>Declare a new statement class.</p> <p>This decorator is used to declare a new statement class. It is used to generate the necessary boilerplate code for the class. The class should inherit from <code>kirin.ir.Statement</code>.</p> <p>Parameters:</p> Name Type Description Default <code>init(bool)</code> <p>Whether to generate an <code>__init__</code> method.</p> required <code>repr(bool)</code> <p>Whether to generate a <code>__repr__</code> method.</p> required <code>kw_only(bool)</code> <p>Whether to use keyword-only arguments in the <code>__init__</code> method.</p> required <code>dialect(Optional[Dialect])</code> <p>The dialect of the statement.</p> required <code>property(bool)</code> <p>Whether to generate property methods for attributes.</p> required Example <p>The following is an example of how to use the <code>statement</code> decorator.</p> <pre><code>@statement\nclass MyStatement(ir.Statement):\n    name = \"some_name\"\n    traits = frozenset({TraitA(), TraitB()})\n    some_input: ir.SSAValue = info.argument()\n    some_output: ir.ResultValue = info.result()\n    body: ir.Region = info.region()\n    successor: ir.Block = info.block()\n</code></pre> <p>If the <code>name</code> field is not specified, a lowercase name field will be auto generated.</p> <p>In addition, one can optionally register the statement to a dialect by providing the <code>dialect</code> argument to the decorator.</p> <p>The following example register the statement to a dialect <code>my_dialect_object</code>, and <code>name = \"myfoo\"</code> field is autogenerated</p> <pre><code>@statement(dialect=my_dialect_object)\nclass MyFoo(ir.Statement):\n    traits = frozenset({ir.FromPythonCall()})\n    value: str = info.attribute()\n</code></pre> Source code in <code>src/kirin/decl/__init__.py</code> <pre><code>@dataclass_transform(\n    field_specifiers=(\n        info.attribute,\n        info.argument,\n        info.region,\n        info.result,\n        info.block,\n    )\n)\ndef statement(\n    cls=None,\n    **kwargs: Unpack[StatementOptions],\n) -&gt; Callable[[type[StmtType]], type[StmtType]]:\n    \"\"\"Declare a new statement class.\n\n    This decorator is used to declare a new statement class. It is used to\n    generate the necessary boilerplate code for the class. The class should\n    inherit from `kirin.ir.Statement`.\n\n    Args:\n        init(bool): Whether to generate an `__init__` method.\n        repr(bool): Whether to generate a `__repr__` method.\n        kw_only(bool): Whether to use keyword-only arguments in the `__init__`\n            method.\n        dialect(Optional[Dialect]): The dialect of the statement.\n        property(bool): Whether to generate property methods for attributes.\n\n    Example:\n        The following is an example of how to use the `statement` decorator.\n\n        ```python\n        @statement\n        class MyStatement(ir.Statement):\n            name = \"some_name\"\n            traits = frozenset({TraitA(), TraitB()})\n            some_input: ir.SSAValue = info.argument()\n            some_output: ir.ResultValue = info.result()\n            body: ir.Region = info.region()\n            successor: ir.Block = info.block()\n        ```\n\n        If the `name` field is not specified, a lowercase name field will be auto generated.\n\n        In addition, one can optionally register the statement to a dialect\n        by providing the `dialect` argument to the decorator.\n\n        The following example register the statement to a dialect `my_dialect_object`, and `name = \"myfoo\"` field is autogenerated\n\n        ```python\n        @statement(dialect=my_dialect_object)\n        class MyFoo(ir.Statement):\n            traits = frozenset({ir.FromPythonCall()})\n            value: str = info.attribute()\n        ```\n    \"\"\"\n\n    def wrap(cls):\n        decl = StatementDecl(cls, **kwargs)\n        decl.scan_fields()\n        decl.verify()\n        decl.emit()\n        decl.register()\n        return cls\n\n    if cls is None:\n        return wrap\n    return wrap(cls)\n</code></pre>"},{"location":"reference/kirin/exceptions/","title":"Exceptions","text":""},{"location":"reference/kirin/graph/","title":"Graph","text":""},{"location":"reference/kirin/graph/#kirin.graph.Graph","title":"Graph","text":"<p>               Bases: <code>Protocol</code>, <code>Generic[Node]</code></p> <p>The graph interface.</p> <p>This interface defines the methods that a graph object must implement. The graph interface is mainly for compatibility reasons so that one can use multiple graph implementations interchangeably.</p>"},{"location":"reference/kirin/graph/#kirin.graph.Graph.get_edges","title":"get_edges","text":"<pre><code>get_edges() -&gt; Iterable[tuple[Node, Node]]\n</code></pre> <p>Get all the edges in the graph.</p> Source code in <code>src/kirin/graph.py</code> <pre><code>def get_edges(self) -&gt; Iterable[tuple[Node, Node]]:\n    \"\"\"Get all the edges in the graph.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/graph/#kirin.graph.Graph.get_neighbors","title":"get_neighbors","text":"<pre><code>get_neighbors(node: Node) -&gt; Iterable[Node]\n</code></pre> <p>Get the neighbors of a node.</p> Source code in <code>src/kirin/graph.py</code> <pre><code>def get_neighbors(self, node: Node) -&gt; Iterable[Node]:\n    \"\"\"Get the neighbors of a node.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/graph/#kirin.graph.Graph.get_nodes","title":"get_nodes","text":"<pre><code>get_nodes() -&gt; Iterable[Node]\n</code></pre> <p>Get all the nodes in the graph.</p> Source code in <code>src/kirin/graph.py</code> <pre><code>def get_nodes(self) -&gt; Iterable[Node]:\n    \"\"\"Get all the nodes in the graph.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/idtable/","title":"IdTable","text":""},{"location":"reference/kirin/idtable/#kirin.idtable.IdTable","title":"IdTable  <code>dataclass</code>","text":"<pre><code>IdTable(\n    prefix: str = \"%\",\n    table: dict[T, str] = dict(),\n    name_count: dict[str, int] = dict(),\n    next_id: int = 0,\n    prefix_if_none: str = \"\",\n)\n</code></pre> <p>               Bases: <code>Generic[T]</code></p> <p>A table that maps values to \"human readable\" unique names. This is used for IR printing and code generation of SSA values and basic blocks, or anything else required to have a unique name.</p>"},{"location":"reference/kirin/idtable/#kirin.idtable.IdTable--example","title":"Example","text":"<pre><code>from kirin import ir\nfrom kirin.idtable import IdTable\ntable = IdTable()\nx = ir.TestValue()\ntable[x] # \"%0\"\ntable[x] # \"%0\"\ny = ir.TestValue()\ntable[y] # \"%1\"\n</code></pre>"},{"location":"reference/kirin/idtable/#kirin.idtable.IdTable.name_count","title":"name_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name_count: dict[str, int] = field(default_factory=dict)\n</code></pre> <p>The count of names that have been generated.</p>"},{"location":"reference/kirin/idtable/#kirin.idtable.IdTable.next_id","title":"next_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next_id: int = 0\n</code></pre> <p>The next ID to use for generating names.</p>"},{"location":"reference/kirin/idtable/#kirin.idtable.IdTable.prefix","title":"prefix  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>prefix: str = '%'\n</code></pre> <p>The prefix to use for generated names.</p>"},{"location":"reference/kirin/idtable/#kirin.idtable.IdTable.prefix_if_none","title":"prefix_if_none  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>prefix_if_none: str = ''\n</code></pre> <p>An alternate prefix to use when the name is None.</p>"},{"location":"reference/kirin/idtable/#kirin.idtable.IdTable.table","title":"table  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>table: dict[T, str] = field(default_factory=dict)\n</code></pre> <p>The table that maps values to names.</p>"},{"location":"reference/kirin/idtable/#kirin.idtable.IdTable.add","title":"add","text":"<pre><code>add(value: T) -&gt; str\n</code></pre> <p>Add a value to the table and return the name.</p> Source code in <code>src/kirin/idtable.py</code> <pre><code>def add(self, value: T) -&gt; str:\n    \"\"\"Add a value to the table and return the name.\"\"\"\n    id = self.next_id\n    if (value_name := getattr(value, \"name\", None)) is not None:\n        curr_ind = self.name_count.get(value_name, 0)\n        suffix = f\"_{curr_ind}\" if curr_ind != 0 else \"\"\n        self.name_count[value_name] = curr_ind + 1\n        name = self.prefix + value_name + suffix\n        self.table[value] = name\n    else:\n        name = f\"{self.prefix}{self.prefix_if_none}{id}\"\n        self.next_id += 1\n        self.table[value] = name\n    return name\n</code></pre>"},{"location":"reference/kirin/prelude/","title":"Prelude","text":"<p>This module contains some common eDSLs that can be used to build more complex eDSLs. The eDSLs in this module are built on top of the basic dialects provided by the <code>kirin.dialects</code> module.</p>"},{"location":"reference/kirin/prelude/#kirin.prelude.basic","title":"basic","text":"<pre><code>basic(self)\n</code></pre> <p>The basic kernel.</p> <p>This eDSL includes the basic dialects and the basic optimization passes. Other eDSL can usually be built on top of this eDSL by utilizing the <code>basic.add</code> method to add more dialects and optimization passes.</p> <p>See also <code>basic_no_opt</code> for the basic kernel without optimization passes.</p>"},{"location":"reference/kirin/prelude/#kirin.prelude.basic--example","title":"Example","text":"<pre><code>from kirin.prelude import basic\n\n@basic(typeinfer=True)\ndef main(x: int) -&gt; int:\n    return x + 1 + 1\n\nmain.print() # main is a Method!\n</code></pre> Source code in <code>src/kirin/prelude.py</code> <pre><code>@dialect_group(basic_no_opt)\ndef basic(self):\n    \"\"\"The basic kernel.\n\n    This eDSL includes the basic dialects and the basic optimization passes.\n    Other eDSL can usually be built on top of this eDSL by utilizing the\n    `basic.add` method to add more dialects and optimization passes.\n\n    See also [`basic_no_opt`][kirin.prelude.basic_no_opt] for the basic kernel without optimization passes.\n\n    ## Example\n\n    ```python\n    from kirin.prelude import basic\n\n    @basic(typeinfer=True)\n    def main(x: int) -&gt; int:\n        return x + 1 + 1\n\n    main.print() # main is a Method!\n    ```\n    \"\"\"\n    fold_pass = Fold(self)\n    ilist_desugar = ilist.IListDesugar(self)\n    aggressive_fold_pass = aggressive.Fold(self)\n    typeinfer_pass = TypeInfer(self)\n\n    def run_pass(\n        mt: Annotated[Method, Doc(\"The method to run pass on.\")],\n        *,\n        verify: Annotated[\n            bool, Doc(\"run `verify` before running passes, default is `True`\")\n        ] = True,\n        typeinfer: Annotated[\n            bool,\n            Doc(\n                \"run type inference and apply the inferred type to IR, default `False`\"\n            ),\n        ] = False,\n        fold: Annotated[bool, Doc(\"run folding passes\")] = True,\n        aggressive: Annotated[\n            bool, Doc(\"run aggressive folding passes if `fold=True`\")\n        ] = False,\n    ) -&gt; None:\n        if verify:\n            mt.verify()\n\n        ilist_desugar.fixpoint(mt)\n\n        if fold:\n            if aggressive:\n                aggressive_fold_pass.fixpoint(mt)\n            else:\n                fold_pass(mt)\n\n        if typeinfer:\n            typeinfer_pass(mt)\n\n    return run_pass\n</code></pre>"},{"location":"reference/kirin/prelude/#kirin.prelude.basic_no_opt","title":"basic_no_opt","text":"<pre><code>basic_no_opt(self)\n</code></pre> <p>The basic kernel without optimization passes. This is a builtin eDSL that includes the basic dialects that are commonly used in Python-like eDSLs.</p> <p>This eDSL includes the basic dialects without any optimization passes. Other eDSL can usually be built on top of this eDSL by utilizing the <code>basic_no_opt.add</code> method to add more dialects and optimization passes.</p> <p>Note that unlike Python, list in this eDSL is immutable, and the <code>append</code> method is not available. Use <code>+</code> operator to concatenate lists instead. Immutable list is easier to optimize and reason about.</p> <p>See also <code>basic</code> for the basic kernel with optimization passes. See also <code>ilist</code> for the immutable list dialect.</p> Source code in <code>src/kirin/prelude.py</code> <pre><code>@dialect_group(\n    python_basic.union(\n        [ilist, range, slice, cf, func, math, lowering.cf, lowering.func, lowering.call]\n    )\n)\ndef basic_no_opt(self):\n    \"\"\"The basic kernel without optimization passes. This is a builtin\n    eDSL that includes the basic dialects that are commonly used in\n    Python-like eDSLs.\n\n    This eDSL includes the basic dialects without any optimization passes.\n    Other eDSL can usually be built on top of this eDSL by utilizing the\n    `basic_no_opt.add` method to add more dialects and optimization passes.\n\n    Note that unlike Python, list in this eDSL is immutable, and the\n    `append` method is not available. Use `+` operator to concatenate lists\n    instead. Immutable list is easier to optimize and reason about.\n\n    See also [`basic`][kirin.prelude.basic] for the basic kernel with optimization passes.\n    See also [`ilist`][kirin.dialects.ilist] for the immutable list dialect.\n    \"\"\"\n    ilist_desugar = ilist.IListDesugar(self)\n\n    def run_pass(mt: Method) -&gt; None:\n        ilist_desugar.fixpoint(mt)\n\n    return run_pass\n</code></pre>"},{"location":"reference/kirin/prelude/#kirin.prelude.python_basic","title":"python_basic","text":"<pre><code>python_basic(self)\n</code></pre> <p>The basic Python dialect without list, range, and slice.</p> Source code in <code>src/kirin/prelude.py</code> <pre><code>@dialect_group(\n    [\n        base,\n        binop,\n        cmp,\n        unary,\n        assign,\n        attr,\n        boolop,\n        builtin,\n        constant,\n        indexing,\n        len,\n        tuple,\n        assertion,\n        iterable,\n    ]\n)\ndef python_basic(self):\n    \"\"\"The basic Python dialect without list, range, and slice.\"\"\"\n\n    def run_pass(mt: Method) -&gt; None:\n        pass\n\n    return run_pass\n</code></pre>"},{"location":"reference/kirin/prelude/#kirin.prelude.python_no_opt","title":"python_no_opt","text":"<pre><code>python_no_opt(self)\n</code></pre> <p>The Python dialect without optimization passes.</p> Source code in <code>src/kirin/prelude.py</code> <pre><code>@dialect_group(\n    python_basic.union(\n        [list, range, slice, cf, func, lowering.cf, lowering.func, lowering.call, math]\n    )\n)\ndef python_no_opt(self):\n    \"\"\"The Python dialect without optimization passes.\"\"\"\n\n    def run_pass(mt: Method) -&gt; None:\n        pass\n\n    return run_pass\n</code></pre>"},{"location":"reference/kirin/registry/","title":"Registry","text":""},{"location":"reference/kirin/registry/#kirin.registry.StatementResult","title":"StatementResult  <code>module-attribute</code>","text":"<pre><code>StatementResult: TypeAlias = (\n    tuple[ValueType, ...] | SpecialValue[ValueType]\n)\n</code></pre> <p>Type alias for the result of a statement evaluation.</p>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter","title":"BaseInterpreter  <code>dataclass</code>","text":"<pre><code>BaseInterpreter(\n    dialects: DialectGroup,\n    *,\n    fuel: int | None = None,\n    debug: bool = False,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192\n)\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[FrameType, ValueType]</code></p> <p>A base class for interpreters.</p> <p>This class defines the basic structure of an interpreter. It is designed to be subclassed to provide the actual implementation of the interpreter.</p>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter--required-overrides","title":"Required Overrides","text":"<p>When subclassing, if the subclass does not contain <code>ABC</code>, the subclass must define the following attributes:</p> <ul> <li><code>keys</code>: a list of strings that defines the order of dialects to select from.</li> <li><code>void</code>: the value to return when the interpreter evaluates nothing.</li> </ul>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.debug","title":"debug  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug: bool = field(default=False, kw_only=True)\n</code></pre> <p>Whether to enable debug mode.</p>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.dialects","title":"dialects  <code>instance-attribute</code>","text":"<pre><code>dialects: DialectGroup\n</code></pre> <p>The dialects to interpret.</p>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.fuel","title":"fuel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fuel: int | None = field(default=None, kw_only=True)\n</code></pre> <p>The fuel limit for the interpreter.</p>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.keys","title":"keys  <code>class-attribute</code>","text":"<pre><code>keys: list[str]\n</code></pre> <p>The name of the interpreter to select from dialects by order.</p>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.max_depth","title":"max_depth  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_depth: int = field(default=128, kw_only=True)\n</code></pre> <p>The maximum depth of the interpreter stack.</p>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.max_python_recursion_depth","title":"max_python_recursion_depth  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_python_recursion_depth: int = field(\n    default=8192, kw_only=True\n)\n</code></pre> <p>The maximum recursion depth of the Python interpreter.</p>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.registry","title":"registry  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>registry: InterpreterRegistry = field(\n    init=False, compare=False\n)\n</code></pre> <p>The interpreter registry.</p>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.state","title":"state  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>state: InterpreterState[FrameType] = field(\n    init=False, compare=False\n)\n</code></pre> <p>The interpreter state.</p>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.symbol_table","title":"symbol_table  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol_table: dict[str, Statement] = field(\n    init=False, compare=False\n)\n</code></pre> <p>The symbol table.</p>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.void","title":"void  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>void: ValueType = field(init=False)\n</code></pre> <p>What to return when the interpreter evaluates nothing.</p>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.build_signature","title":"build_signature","text":"<pre><code>build_signature(\n    frame: FrameType, stmt: Statement\n) -&gt; Signature\n</code></pre> <p>build signature for querying the statement implementation.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def build_signature(self, frame: FrameType, stmt: Statement) -&gt; \"Signature\":\n    \"\"\"build signature for querying the statement implementation.\"\"\"\n    return Signature(stmt.__class__, tuple(arg.type for arg in stmt.args))\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.eval_recursion_limit","title":"eval_recursion_limit","text":"<pre><code>eval_recursion_limit(frame: FrameType) -&gt; ValueType\n</code></pre> <p>Return the value of recursion exception, e.g in concrete interpreter, it will raise an exception if the limit is reached; in type inference, it will return a special value.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def eval_recursion_limit(self, frame: FrameType) -&gt; ValueType:\n    \"\"\"Return the value of recursion exception, e.g in concrete\n    interpreter, it will raise an exception if the limit is reached;\n    in type inference, it will return a special value.\n    \"\"\"\n    raise InterpreterError(\"maximum recursion depth exceeded\")\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.eval_stmt","title":"eval_stmt","text":"<pre><code>eval_stmt(\n    frame: FrameType, stmt: Statement\n) -&gt; StatementResult[ValueType]\n</code></pre> <p>Run a statement within the current frame. This is the entry point of running a statement. It will look up the statement implementation in the dialect registry, or optionally call a fallback implementation.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>FrameType</code> <p>the current frame</p> required <code>stmt</code> <code>Statement</code> <p>the statement to run</p> required <p>Returns:</p> Name Type Description <code>StatementResult</code> <code>StatementResult[ValueType]</code> <p>the result of running the statement</p> Note <p>Overload this method for the following reasons: - to change the source tracking information - to take control of how to run a statement - to change the implementation lookup behavior that cannot acheive     by overloading <code>lookup_registry</code></p> Example <ul> <li>implement an interpreter that only handles MyStmt: <pre><code>    class MyInterpreter(BaseInterpreter):\n        ...\n        def eval_stmt(self, frame: FrameType, stmt: Statement) -&gt; StatementResult[ValueType]:\n            if isinstance(stmt, MyStmt):\n                return self.run_my_stmt(frame, stmt)\n            else:\n                return ()\n</code></pre></li> </ul> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def eval_stmt(\n    self, frame: FrameType, stmt: Statement\n) -&gt; StatementResult[ValueType]:\n    \"\"\"Run a statement within the current frame. This is the entry\n    point of running a statement. It will look up the statement implementation\n    in the dialect registry, or optionally call a fallback implementation.\n\n    Args:\n        frame: the current frame\n        stmt: the statement to run\n\n    Returns:\n        StatementResult: the result of running the statement\n\n    Note:\n        Overload this method for the following reasons:\n        - to change the source tracking information\n        - to take control of how to run a statement\n        - to change the implementation lookup behavior that cannot acheive\n            by overloading [`lookup_registry`][kirin.interp.base.BaseInterpreter.lookup_registry]\n\n    Example:\n        * implement an interpreter that only handles MyStmt:\n        ```python\n            class MyInterpreter(BaseInterpreter):\n                ...\n                def eval_stmt(self, frame: FrameType, stmt: Statement) -&gt; StatementResult[ValueType]:\n                    if isinstance(stmt, MyStmt):\n                        return self.run_my_stmt(frame, stmt)\n                    else:\n                        return ()\n        ```\n\n    \"\"\"\n    # TODO: update tracking information\n    method = self.lookup_registry(frame, stmt)\n    if method is not None:\n        results = method(self, frame, stmt)\n        if self.debug and not isinstance(results, (tuple, SpecialValue)):\n            raise InterpreterError(\n                f\"method must return tuple or SpecialResult, got {results}\"\n            )\n        return results\n\n    return self.eval_stmt_fallback(frame, stmt)\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.eval_stmt_fallback","title":"eval_stmt_fallback","text":"<pre><code>eval_stmt_fallback(\n    frame: FrameType, stmt: Statement\n) -&gt; StatementResult[ValueType]\n</code></pre> <p>The fallback implementation of statements.</p> <p>This is called when no implementation is found for the statement.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>FrameType</code> <p>the current frame</p> required <code>stmt</code> <code>Statement</code> <p>the statement to run</p> required <p>Returns:</p> Name Type Description <code>StatementResult</code> <code>StatementResult[ValueType]</code> <p>the result of running the statement</p> Note <p>Overload this method to provide a fallback implementation for statements.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def eval_stmt_fallback(\n    self, frame: FrameType, stmt: Statement\n) -&gt; StatementResult[ValueType]:\n    \"\"\"The fallback implementation of statements.\n\n    This is called when no implementation is found for the statement.\n\n    Args:\n        frame: the current frame\n        stmt: the statement to run\n\n    Returns:\n        StatementResult: the result of running the statement\n\n    Note:\n        Overload this method to provide a fallback implementation for statements.\n    \"\"\"\n    # NOTE: not using f-string here because 3.10 and 3.11 have\n    #  parser bug that doesn't allow f-string in raise statement\n    raise InterpreterError(\n        \"no implementation for stmt \"\n        + stmt.print_str(end=\"\")\n        + \" from \"\n        + str(type(self))\n    )\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.finalize","title":"finalize","text":"<pre><code>finalize(frame: FrameType, results: ValueType) -&gt; ValueType\n</code></pre> <p>Postprocess a frame after it is popped from the stack. This is called after a method is evaluated and the frame is popped.</p> Note <p>Default implementation does nothing.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def finalize(self, frame: FrameType, results: ValueType) -&gt; ValueType:\n    \"\"\"Postprocess a frame after it is popped from the stack. This is\n    called after a method is evaluated and the frame is popped.\n\n    Note:\n        Default implementation does nothing.\n    \"\"\"\n    return results\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.initialize","title":"initialize","text":"<pre><code>initialize() -&gt; Self\n</code></pre> <p>Initialize the interpreter global states. This method is called right upon calling <code>run</code> to initialize the interpreter global states.</p> <p>Default Implementation</p> <p>This method provides default behavior but may be overridden by subclasses to customize or extend functionality.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def initialize(self) -&gt; Self:\n    \"\"\"Initialize the interpreter global states. This method is called right upon\n    calling [`run`][kirin.interp.base.BaseInterpreter.run] to initialize the\n    interpreter global states.\n\n    !!! note \"Default Implementation\"\n        This method provides default behavior but may be overridden by subclasses\n        to customize or extend functionality.\n    \"\"\"\n    self.symbol_table: dict[str, Statement] = {}\n    self.state: InterpreterState[FrameType] = InterpreterState()\n    return self\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.lookup_registry","title":"lookup_registry","text":"<pre><code>lookup_registry(\n    frame: FrameType, stmt: Statement\n) -&gt; Optional[StatementImpl[Self, FrameType]]\n</code></pre> <p>Lookup the statement implementation in the registry.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>FrameType</code> <p>the current frame</p> required <code>stmt</code> <code>Statement</code> <p>the statement to run</p> required <p>Returns:</p> Type Description <code>Optional[StatementImpl[Self, FrameType]]</code> <p>Optional[StatementImpl]: the statement implementation if found, None otherwise.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def lookup_registry(\n    self, frame: FrameType, stmt: Statement\n) -&gt; Optional[\"StatementImpl[Self, FrameType]\"]:\n    \"\"\"Lookup the statement implementation in the registry.\n\n    Args:\n        frame: the current frame\n        stmt: the statement to run\n\n    Returns:\n        Optional[StatementImpl]: the statement implementation if found, None otherwise.\n    \"\"\"\n    sig = self.build_signature(frame, stmt)\n    if sig in self.registry.statements:\n        return self.registry.statements[sig]\n    elif (class_sig := Signature(stmt.__class__)) in self.registry.statements:\n        return self.registry.statements[class_sig]\n    return\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.new_frame","title":"new_frame  <code>abstractmethod</code>","text":"<pre><code>new_frame(code: Statement) -&gt; FrameType\n</code></pre> <p>Create a new frame for the given method.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>@abstractmethod\ndef new_frame(self, code: Statement) -&gt; FrameType:\n    \"\"\"Create a new frame for the given method.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.permute_values","title":"permute_values  <code>staticmethod</code>","text":"<pre><code>permute_values(\n    arg_names: Sequence[str],\n    values: tuple[ValueType, ...],\n    kwarg_names: tuple[str, ...],\n) -&gt; tuple[ValueType, ...]\n</code></pre> <p>Permute the arguments according to the method signature and the given keyword arguments, where the keyword argument names refer to the last n arguments in the values tuple.</p> <p>Parameters:</p> Name Type Description Default <code>arg_names</code> <code>Sequence[str]</code> <p>the argument names</p> required <code>values</code> <code>tuple[ValueType, ...]</code> <p>the values tuple (should not contain method itself)</p> required <code>kwarg_names</code> <code>tuple[str, ...]</code> <p>the keyword argument names</p> required Source code in <code>src/kirin/interp/base.py</code> <pre><code>@staticmethod\ndef permute_values(\n    arg_names: Sequence[str],\n    values: tuple[ValueType, ...],\n    kwarg_names: tuple[str, ...],\n) -&gt; tuple[ValueType, ...]:\n    \"\"\"Permute the arguments according to the method signature and\n    the given keyword arguments, where the keyword argument names\n    refer to the last n arguments in the values tuple.\n\n    Args:\n        arg_names: the argument names\n        values: the values tuple (should not contain method itself)\n        kwarg_names: the keyword argument names\n    \"\"\"\n    n_total = len(values)\n    if kwarg_names:\n        kwargs = dict(zip(kwarg_names, values[n_total - len(kwarg_names) :]))\n    else:\n        kwargs = None\n\n    positionals = values[: n_total - len(kwarg_names)]\n    args = BaseInterpreter.get_args(\n        arg_names[len(positionals) + 1 :], positionals, kwargs\n    )\n    return args\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.run","title":"run","text":"<pre><code>run(\n    mt: Method,\n    args: tuple[ValueType, ...],\n    kwargs: dict[str, ValueType] | None = None,\n) -&gt; Result[ValueType]\n</code></pre> <p>Run a method. This is the main entry point of the interpreter.</p> <p>Parameters:</p> Name Type Description Default <code>mt</code> <code>Method</code> <p>the method to run.</p> required <code>args</code> <code>tuple[ValueType]</code> <p>the arguments to the method, does not include self.</p> required <code>kwargs</code> <code>dict[str, ValueType]</code> <p>the keyword arguments to the method.</p> <code>None</code> <p>Returns:</p> Type Description <code>Result[ValueType]</code> <p>Result[ValueType]: the result of the method.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def run(\n    self,\n    mt: Method,\n    args: tuple[ValueType, ...],\n    kwargs: dict[str, ValueType] | None = None,\n) -&gt; Result[ValueType]:\n    \"\"\"Run a method. This is the main entry point of the interpreter.\n\n    Args:\n        mt (Method): the method to run.\n        args (tuple[ValueType]): the arguments to the method, does not include self.\n        kwargs (dict[str, ValueType], optional): the keyword arguments to the method.\n\n    Returns:\n        Result[ValueType]: the result of the method.\n    \"\"\"\n    if self._eval_lock:\n        raise InterpreterError(\n            \"recursive eval is not allowed, use run_method instead\"\n        )\n\n    self._eval_lock = True\n    self.initialize()\n    current_recursion_limit = sys.getrecursionlimit()\n    sys.setrecursionlimit(self.max_python_recursion_depth)\n    args = self.get_args(mt.arg_names[len(args) + 1 :], args, kwargs)\n    try:\n        results = self.run_method(mt, args)\n    except InterpreterError as e:\n        # NOTE: initialize will create new State\n        # so we don't need to copy the frames.\n        return Err(e, self.state.frames)\n    finally:\n        self._eval_lock = False\n        sys.setrecursionlimit(current_recursion_limit)\n    return Ok(results)\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.run_block","title":"run_block","text":"<pre><code>run_block(\n    frame: FrameType, block: Block\n) -&gt; SpecialValue[ValueType]\n</code></pre> <p>Run a block within the current frame.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>FrameType</code> <p>the current frame.</p> required <code>block</code> <code>Block</code> <p>the block to run.</p> required <p>Returns:</p> Name Type Description <code>SpecialValue</code> <code>SpecialValue[ValueType]</code> <p>the result of running the block terminator.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def run_block(self, frame: FrameType, block: Block) -&gt; SpecialValue[ValueType]:\n    \"\"\"Run a block within the current frame.\n\n    Args:\n        frame: the current frame.\n        block: the block to run.\n\n    Returns:\n        SpecialValue: the result of running the block terminator.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.run_callable","title":"run_callable","text":"<pre><code>run_callable(\n    code: Statement, args: tuple[ValueType, ...]\n) -&gt; ValueType\n</code></pre> <p>Run a callable statement.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>Statement</code> <p>the statement to run.</p> required <code>args</code> <code>tuple[ValueType]</code> <p>the arguments to the statement, includes self if the corresponding callable region contains a self argument.</p> required <p>Returns:</p> Name Type Description <code>ValueType</code> <code>ValueType</code> <p>the result of the statement.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def run_callable(self, code: Statement, args: tuple[ValueType, ...]) -&gt; ValueType:\n    \"\"\"Run a callable statement.\n\n    Args:\n        code (Statement): the statement to run.\n        args (tuple[ValueType]): the arguments to the statement,\n            includes self if the corresponding callable region contains a self argument.\n\n    Returns:\n        ValueType: the result of the statement.\n    \"\"\"\n    if len(self.state.frames) &gt;= self.max_depth:\n        return self.eval_recursion_limit(self.state.current_frame())\n\n    interface = code.get_trait(traits.CallableStmtInterface)\n    if interface is None:\n        raise InterpreterError(f\"statement {code.name} is not callable\")\n\n    frame = self.new_frame(code)\n    self.state.push_frame(frame)\n    body = interface.get_callable_region(code)\n    if not body.blocks:\n        return self.finalize(self.state.pop_frame(), self.void)\n    frame.set_values(body.blocks[0].args, args)\n    results = self.run_callable_region(frame, code, body)\n    return self.finalize(self.state.pop_frame(), results)\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.run_callable_region","title":"run_callable_region","text":"<pre><code>run_callable_region(\n    frame: FrameType, code: Statement, region: Region\n) -&gt; ValueType\n</code></pre> <p>A hook defines how to run the callable region given the interpreter context. Frame should be pushed before calling this method and popped after calling this method.</p> <p>A callable region is a region that can be called as a function. Unlike a general region (or the MLIR convention), it always return a value to be compatible with the Python convention.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def run_callable_region(\n    self, frame: FrameType, code: Statement, region: Region\n) -&gt; ValueType:\n    \"\"\"A hook defines how to run the callable region given\n    the interpreter context. Frame should be pushed before calling\n    this method and popped after calling this method.\n\n    A callable region is a region that can be called as a function.\n    Unlike a general region (or the MLIR convention), it always return a value\n    to be compatible with the Python convention.\n    \"\"\"\n    results = self.run_ssacfg_region(frame, region)\n    if isinstance(results, ReturnValue):\n        return results.value\n    elif not results:  # empty result or None\n        return self.void\n    raise InterpreterError(\n        f\"callable region {code.name} does not return `ReturnValue`, got {results}\"\n    )\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.run_method","title":"run_method  <code>abstractmethod</code>","text":"<pre><code>run_method(\n    method: Method, args: tuple[ValueType, ...]\n) -&gt; ValueType\n</code></pre> <p>How to run a method.</p> <p>This is defined by subclasses to describe what's the corresponding value of a method during the interpretation.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Method</code> <p>the method to run.</p> required <code>args</code> <code>tuple[ValueType]</code> <p>the arguments to the method, does not include self.</p> required <p>Returns:</p> Name Type Description <code>ValueType</code> <code>ValueType</code> <p>the result of the method.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>@abstractmethod\ndef run_method(self, method: Method, args: tuple[ValueType, ...]) -&gt; ValueType:\n    \"\"\"How to run a method.\n\n    This is defined by subclasses to describe what's the corresponding\n    value of a method during the interpretation.\n\n    Args:\n        method (Method): the method to run.\n        args (tuple[ValueType]): the arguments to the method, does not include self.\n\n    Returns:\n        ValueType: the result of the method.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.run_ssacfg_region","title":"run_ssacfg_region  <code>abstractmethod</code>","text":"<pre><code>run_ssacfg_region(\n    frame: FrameType, region: Region\n) -&gt; tuple[ValueType, ...] | None | ReturnValue[ValueType]\n</code></pre> <p>This implements how to run a region with MLIR SSA CFG convention.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>FrameType</code> <p>the current frame.</p> required <code>region</code> <code>Region</code> <p>the region to run.</p> required <p>Returns:</p> Type Description <code>tuple[ValueType, ...] | None | ReturnValue[ValueType]</code> <p>tuple[ValueType, ...] | SpecialValue[ValueType]: the result of running the region.</p> <p>when region returns <code>tuple[ValueType, ...]</code>, it means the region terminates normally with <code>YieldValue</code>. When region returns <code>ReturnValue</code>, it means the region terminates and needs to pop the frame. Region cannot return <code>Successor</code> because reference to external region is not allowed.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>@abstractmethod\ndef run_ssacfg_region(\n    self, frame: FrameType, region: Region\n) -&gt; tuple[ValueType, ...] | None | ReturnValue[ValueType]:\n    \"\"\"This implements how to run a region with MLIR SSA CFG convention.\n\n    Args:\n        frame: the current frame.\n        region: the region to run.\n\n    Returns:\n        tuple[ValueType, ...] | SpecialValue[ValueType]: the result of running the region.\n\n    when region returns `tuple[ValueType, ...]`, it means the region terminates normally\n    with `YieldValue`. When region returns `ReturnValue`, it means the region terminates\n    and needs to pop the frame. Region cannot return `Successor` because reference to\n    external region is not allowed.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.BaseInterpreter.run_stmt","title":"run_stmt","text":"<pre><code>run_stmt(\n    stmt: Statement, args: tuple[ValueType, ...]\n) -&gt; StatementResult[ValueType]\n</code></pre> <p>execute a statement with arguments in a new frame.</p> <p>Parameters:</p> Name Type Description Default <code>stmt</code> <code>Statement</code> <p>the statement to run.</p> required <code>args</code> <code>tuple[ValueType]</code> <p>the arguments to the statement.</p> required <p>Returns:</p> Type Description <code>StatementResult[ValueType]</code> <p>StatementResult[ValueType]: the result of the statement.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def run_stmt(\n    self, stmt: Statement, args: tuple[ValueType, ...]\n) -&gt; StatementResult[ValueType]:\n    \"\"\"execute a statement with arguments in a new frame.\n\n    Args:\n        stmt (Statement): the statement to run.\n        args (tuple[ValueType]): the arguments to the statement.\n\n    Returns:\n        StatementResult[ValueType]: the result of the statement.\n    \"\"\"\n    frame = self.new_frame(stmt)\n    self.state.push_frame(frame)\n    frame.set_values(stmt.args, args)\n    results = self.eval_stmt(frame, stmt)\n    return results\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.FrameABC","title":"FrameABC  <code>dataclass</code>","text":"<pre><code>FrameABC(code: Statement)\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[ValueType]</code></p> <p>Abstract base class for interpreter frame.</p>"},{"location":"reference/kirin/registry/#kirin.registry.FrameABC.code","title":"code  <code>instance-attribute</code>","text":"<pre><code>code: Statement\n</code></pre> <p>func statement being interpreted.</p>"},{"location":"reference/kirin/registry/#kirin.registry.FrameABC.from_func_like","title":"from_func_like  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>from_func_like(code: Statement) -&gt; Self\n</code></pre> <p>Create a new frame for the given method.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>@classmethod\n@abstractmethod\ndef from_func_like(cls, code: Statement) -&gt; Self:\n    \"\"\"Create a new frame for the given method.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.FrameABC.get","title":"get  <code>abstractmethod</code>","text":"<pre><code>get(key: SSAValue) -&gt; ValueType\n</code></pre> <p>Get the value for the given <code>SSAValue</code> key. See also <code>get_values</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key(SSAValue)</code> <p>The key to get the value for.</p> required <p>Returns:</p> Name Type Description <code>ValueType</code> <code>ValueType</code> <p>The value.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>@abstractmethod\ndef get(self, key: SSAValue) -&gt; ValueType:\n    \"\"\"Get the value for the given [`SSAValue`][kirin.ir.SSAValue] key.\n    See also [`get_values`][kirin.interp.frame.Frame.get_values].\n\n    Args:\n        key(SSAValue): The key to get the value for.\n\n    Returns:\n        ValueType: The value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.FrameABC.get_values","title":"get_values","text":"<pre><code>get_values(\n    keys: Iterable[SSAValue],\n) -&gt; tuple[ValueType, ...]\n</code></pre> <p>Get the values of the given <code>SSAValue</code> keys. See also <code>get</code>.</p> <p>Parameters:</p> Name Type Description Default <code>keys(Iterable[SSAValue])</code> <p>The keys to get the values for.</p> required <p>Returns:</p> Type Description <code>tuple[ValueType, ...]</code> <p>tuple[ValueType, ...]: The values.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>def get_values(self, keys: Iterable[SSAValue]) -&gt; tuple[ValueType, ...]:\n    \"\"\"Get the values of the given [`SSAValue`][kirin.ir.SSAValue] keys.\n    See also [`get`][kirin.interp.frame.Frame.get].\n\n    Args:\n        keys(Iterable[SSAValue]): The keys to get the values for.\n\n    Returns:\n        tuple[ValueType, ...]: The values.\n    \"\"\"\n    return tuple(self.get(key) for key in keys)\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.FrameABC.set","title":"set  <code>abstractmethod</code>","text":"<pre><code>set(key: SSAValue, value: ValueType) -&gt; None\n</code></pre> <p>Set the value for the given <code>SSAValue</code> key. See also <code>set_values</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key(SSAValue)</code> <p>The key to set the value for.</p> required <code>value(ValueType)</code> <p>The value.</p> required Source code in <code>src/kirin/interp/frame.py</code> <pre><code>@abstractmethod\ndef set(self, key: SSAValue, value: ValueType) -&gt; None:\n    \"\"\"Set the value for the given [`SSAValue`][kirin.ir.SSAValue] key.\n    See also [`set_values`][kirin.interp.frame.Frame.set_values].\n\n    Args:\n        key(SSAValue): The key to set the value for.\n        value(ValueType): The value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.FrameABC.set_stmt","title":"set_stmt  <code>abstractmethod</code>","text":"<pre><code>set_stmt(stmt: Statement) -&gt; Self\n</code></pre> <p>Set the current statement.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>@abstractmethod\ndef set_stmt(self, stmt: Statement) -&gt; Self:\n    \"\"\"Set the current statement.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.FrameABC.set_values","title":"set_values","text":"<pre><code>set_values(\n    keys: Iterable[SSAValue], values: Iterable[ValueType]\n) -&gt; None\n</code></pre> <p>Set the values of the given <code>SSAValue</code> keys. This is a convenience method to set multiple values at once.</p> <p>Parameters:</p> Name Type Description Default <code>keys(Iterable[SSAValue])</code> <p>The keys to set the values for.</p> required <code>values(Iterable[ValueType])</code> <p>The values.</p> required Source code in <code>src/kirin/interp/frame.py</code> <pre><code>def set_values(self, keys: Iterable[SSAValue], values: Iterable[ValueType]) -&gt; None:\n    \"\"\"Set the values of the given [`SSAValue`][kirin.ir.SSAValue] keys.\n    This is a convenience method to set multiple values at once.\n\n    Args:\n        keys(Iterable[SSAValue]): The keys to set the values for.\n        values(Iterable[ValueType]): The values.\n    \"\"\"\n    for key, value in zip(keys, values):\n        self.set(key, value)\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.Registry","title":"Registry  <code>dataclass</code>","text":"<pre><code>Registry(dialects: DialectGroup)\n</code></pre> <p>Proxy class to build different registries from a dialect group.</p>"},{"location":"reference/kirin/registry/#kirin.registry.Registry.dialects","title":"dialects  <code>instance-attribute</code>","text":"<pre><code>dialects: DialectGroup\n</code></pre> <p>The dialect group to build the registry from.</p>"},{"location":"reference/kirin/registry/#kirin.registry.Registry.ast","title":"ast","text":"<pre><code>ast(keys: Iterable[str]) -&gt; dict[str, FromPythonAST]\n</code></pre> <p>select the dialect lowering interpreters for the given key.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>Iterable[str]</code> <p>the keys to search for in the dialects</p> required <p>Returns:</p> Type Description <code>dict[str, FromPythonAST]</code> <p>a map of dialects to their lowering interpreters</p> Source code in <code>src/kirin/registry.py</code> <pre><code>def ast(self, keys: Iterable[str]) -&gt; dict[str, \"FromPythonAST\"]:\n    \"\"\"select the dialect lowering interpreters for the given key.\n\n    Args:\n        keys (Iterable[str]): the keys to search for in the dialects\n\n    Returns:\n        a map of dialects to their lowering interpreters\n    \"\"\"\n    ret: dict[str, \"FromPythonAST\"] = {}\n    from_ast = None\n    for dialect in self.dialects.data:\n        for key in keys:\n            if key in dialect.lowering:\n                from_ast = dialect.lowering[key]\n                break\n\n        if from_ast is None:\n            msg = \",\".join(keys)\n            raise KeyError(f\"Lowering not found for {msg}\")\n\n        for name in from_ast.names:\n            if name in ret:\n                raise KeyError(f\"Lowering {name} already exists\")\n\n            ret[name] = from_ast\n    return ret\n</code></pre>"},{"location":"reference/kirin/registry/#kirin.registry.Registry.interpreter","title":"interpreter","text":"<pre><code>interpreter(keys: Iterable[str]) -&gt; InterpreterRegistry\n</code></pre> <p>select the dialect interpreter for the given key.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>Iterable[str]</code> <p>the keys to search for in the dialects</p> required <p>Returns:</p> Type Description <code>InterpreterRegistry</code> <p>a map of statement signatures to their interpretation functions,</p> <code>InterpreterRegistry</code> <p>and a map of dialects to their fallback interpreters.</p> Source code in <code>src/kirin/registry.py</code> <pre><code>def interpreter(self, keys: Iterable[str]):\n    \"\"\"select the dialect interpreter for the given key.\n\n    Args:\n        keys (Iterable[str]): the keys to search for in the dialects\n\n    Returns:\n        a map of statement signatures to their interpretation functions,\n        and a map of dialects to their fallback interpreters.\n    \"\"\"\n    attributes: dict[type[\"Attribute\"], \"AttributeImpl\"] = {}\n    table: dict[\"Signature\", \"StatementImpl\"] = {}\n    for dialect in self.dialects.data:\n        dialect_table = None\n        for key in keys:\n            if key not in dialect.interps:\n                continue\n\n            dialect_table = dialect.interps[key]\n            for sig, func in dialect_table.attribute.items():\n                if sig not in attributes:\n                    attributes[sig] = AttributeImpl(dialect_table, func)\n\n            for sig, func in dialect_table.table.items():\n                if sig not in table:\n                    table[sig] = StatementImpl(dialect_table, func)\n\n    return InterpreterRegistry(attributes, table)\n</code></pre>"},{"location":"reference/kirin/source/","title":"Source","text":""},{"location":"reference/kirin/symbol_table/","title":"Symbol table","text":""},{"location":"reference/kirin/symbol_table/#kirin.symbol_table.SymbolTable","title":"SymbolTable  <code>dataclass</code>","text":"<pre><code>SymbolTable(\n    names: dict[str, T] = dict(),\n    *,\n    prefix: str = \"\",\n    name_count: dict[str, int] = dict()\n)\n</code></pre> <p>               Bases: <code>Generic[T]</code></p>"},{"location":"reference/kirin/symbol_table/#kirin.symbol_table.SymbolTable.name_count","title":"name_count  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name_count: dict[str, int] = field(\n    default_factory=dict, kw_only=True\n)\n</code></pre> <p>The count of names that have been requested.</p>"},{"location":"reference/kirin/symbol_table/#kirin.symbol_table.SymbolTable.names","title":"names  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>names: dict[str, T] = field(default_factory=dict)\n</code></pre> <p>The table that maps names to values.</p>"},{"location":"reference/kirin/worklist/","title":"WorkList","text":""},{"location":"reference/kirin/worklist/#kirin.worklist.WorkList","title":"WorkList  <code>dataclass</code>","text":"<pre><code>WorkList()\n</code></pre> <p>               Bases: <code>Generic[ElemType]</code></p> <p>The worklist data structure.</p> <p>The worklist is a stack that allows for O(1) removal of elements from the stack.</p>"},{"location":"reference/kirin/analysis/","title":"Index","text":"<p>Analysis module for kirin.</p> <p>This module contains the analysis framework for kirin. The analysis framework is built on top of the interpreter framework. This module provides a set of base classes and frameworks for implementing compiler analysis passes on the IR.</p> <p>The analysis framework contains the following modules:</p> <ul> <li><code>cfg</code>: Control flow graph for a given IR.</li> <li><code>forward</code>: Forward dataflow analysis.</li> <li><code>callgraph</code>: Call graph for a given IR.</li> <li><code>typeinfer</code>: Type inference analysis.</li> <li><code>const</code>: Constants used in the analysis framework.</li> </ul>"},{"location":"reference/kirin/analysis/callgraph/","title":"Call Graph","text":""},{"location":"reference/kirin/analysis/callgraph/#kirin.analysis.callgraph.CallGraph","title":"CallGraph  <code>dataclass</code>","text":"<pre><code>CallGraph(mt: ir.Method)\n</code></pre> <p>               Bases: <code>Printable</code></p> <p>Call graph for a given <code>ir.Method</code>.</p> <p>This class implements the <code>kirin.graph.Graph</code> protocol.</p> <p>Pretty Printing</p> <p>This object is pretty printable via <code>.print()</code> method.</p> Source code in <code>src/kirin/analysis/callgraph.py</code> <pre><code>def __init__(self, mt: ir.Method):\n    self.defs = {}\n    self.backedges = {}\n    self.__build(mt)\n</code></pre>"},{"location":"reference/kirin/analysis/callgraph/#kirin.analysis.callgraph.CallGraph.backedges","title":"backedges  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>backedges: dict[str, set[str]] = {}\n</code></pre> <p>Mapping from symbol names to backedges.</p>"},{"location":"reference/kirin/analysis/callgraph/#kirin.analysis.callgraph.CallGraph.defs","title":"defs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>defs: dict[str, Method] = {}\n</code></pre> <p>Mapping from symbol names to methods.</p>"},{"location":"reference/kirin/analysis/callgraph/#kirin.analysis.callgraph.CallGraph.get_edges","title":"get_edges","text":"<pre><code>get_edges() -&gt; Iterable[tuple[str, str]]\n</code></pre> <p>Get the edges of the call graph.</p> Source code in <code>src/kirin/analysis/callgraph.py</code> <pre><code>def get_edges(self) -&gt; Iterable[tuple[str, str]]:\n    \"\"\"Get the edges of the call graph.\"\"\"\n    for node, neighbors in self.backedges.items():\n        for neighbor in neighbors:\n            yield node, neighbor\n</code></pre>"},{"location":"reference/kirin/analysis/callgraph/#kirin.analysis.callgraph.CallGraph.get_neighbors","title":"get_neighbors","text":"<pre><code>get_neighbors(node: str) -&gt; Iterable[str]\n</code></pre> <p>Get the neighbors of a node in the call graph.</p> Source code in <code>src/kirin/analysis/callgraph.py</code> <pre><code>def get_neighbors(self, node: str) -&gt; Iterable[str]:\n    \"\"\"Get the neighbors of a node in the call graph.\"\"\"\n    return self.backedges.get(node, ())\n</code></pre>"},{"location":"reference/kirin/analysis/callgraph/#kirin.analysis.callgraph.CallGraph.get_nodes","title":"get_nodes","text":"<pre><code>get_nodes() -&gt; Iterable[str]\n</code></pre> <p>Get the nodes of the call graph.</p> Source code in <code>src/kirin/analysis/callgraph.py</code> <pre><code>def get_nodes(self) -&gt; Iterable[str]:\n    \"\"\"Get the nodes of the call graph.\"\"\"\n    return self.defs.keys()\n</code></pre>"},{"location":"reference/kirin/analysis/cfg/","title":"CFG","text":""},{"location":"reference/kirin/analysis/cfg/#kirin.analysis.cfg.CFG","title":"CFG  <code>dataclass</code>","text":"<pre><code>CFG(parent: ir.Region, entry: ir.Block | None = None)\n</code></pre> <p>               Bases: <code>Printable</code></p> <p>Control Flow Graph of a given IR statement.</p> <p>This class implements the <code>kirin.graph.Graph</code> protocol.</p> <p>Pretty Printing</p> <p>This object is pretty printable via <code>.print()</code> method.</p>"},{"location":"reference/kirin/analysis/cfg/#kirin.analysis.cfg.CFG.entry","title":"entry  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>entry: Block | None = None\n</code></pre> <p>Entry block of the CFG.</p>"},{"location":"reference/kirin/analysis/cfg/#kirin.analysis.cfg.CFG.parent","title":"parent  <code>instance-attribute</code>","text":"<pre><code>parent: Region\n</code></pre> <p>Parent IR statement.</p>"},{"location":"reference/kirin/analysis/cfg/#kirin.analysis.cfg.CFG.predecessors","title":"predecessors  <code>cached</code> <code>property</code>","text":"<pre><code>predecessors\n</code></pre> <p>CFG data, mapping a block to its predecessors.</p>"},{"location":"reference/kirin/analysis/cfg/#kirin.analysis.cfg.CFG.successors","title":"successors  <code>cached</code> <code>property</code>","text":"<pre><code>successors\n</code></pre> <p>CFG data, mapping a block to its neighbors.</p>"},{"location":"reference/kirin/analysis/forward/","title":"Forward Dataflow","text":""},{"location":"reference/kirin/analysis/forward/#kirin.analysis.forward.Forward","title":"Forward  <code>dataclass</code>","text":"<pre><code>Forward(\n    dialects: DialectGroup,\n    *,\n    fuel: int | None = None,\n    debug: bool = False,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192,\n    save_all_ssa: bool = False\n)\n</code></pre> <p>               Bases: <code>ForwardExtra[LatticeElemType, None]</code>, <code>ABC</code></p> <p>Forward dataflow analysis.</p> <p>This is the base class for forward dataflow analysis. If your analysis requires extra information per frame, you should subclass <code>ForwardExtra</code> instead.</p>"},{"location":"reference/kirin/analysis/forward/#kirin.analysis.forward.ForwardExtra","title":"ForwardExtra  <code>dataclass</code>","text":"<pre><code>ForwardExtra(\n    dialects: DialectGroup,\n    *,\n    fuel: int | None = None,\n    debug: bool = False,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192,\n    save_all_ssa: bool = False\n)\n</code></pre> <p>               Bases: <code>AbstractInterpreter[ForwardFrame[LatticeElemType, ExtraType], LatticeElemType]</code>, <code>ABC</code></p> <p>Abstract interpreter but record results for each SSA value.</p> <p>Parameters:</p> Name Type Description Default <code>LatticeElemType</code> <p>The lattice element type.</p> required <code>ExtraType</code> <p>The type of extra information to be stored in the frame.</p> required"},{"location":"reference/kirin/analysis/forward/#kirin.analysis.forward.ForwardExtra.finalize","title":"finalize","text":"<pre><code>finalize(\n    frame: ForwardFrame[LatticeElemType, ExtraType],\n    results: LatticeElemType,\n) -&gt; LatticeElemType\n</code></pre> <p>Postprocess a frame after it is popped from the stack. This is called after a method is evaluated and the frame is popped.</p> Note <p>Default implementation does nothing.</p> Source code in <code>src/kirin/analysis/forward.py</code> <pre><code>def finalize(\n    self,\n    frame: ForwardFrame[LatticeElemType, ExtraType],\n    results: LatticeElemType,\n) -&gt; LatticeElemType:\n    if self.save_all_ssa:\n        self.results.update(frame.entries)\n    else:\n        self.results = frame.entries\n    return results\n</code></pre>"},{"location":"reference/kirin/analysis/forward/#kirin.analysis.forward.ForwardExtra.initialize","title":"initialize","text":"<pre><code>initialize()\n</code></pre> <p>Initialize the interpreter global states. This method is called right upon calling <code>run</code> to initialize the interpreter global states.</p> <p>Default Implementation</p> <p>This method provides default behavior but may be overridden by subclasses to customize or extend functionality.</p> Source code in <code>src/kirin/analysis/forward.py</code> <pre><code>def initialize(self):\n    super().initialize()\n    self.results: dict[ir.SSAValue, LatticeElemType] = {}\n    return self\n</code></pre>"},{"location":"reference/kirin/analysis/forward/#kirin.analysis.forward.ForwardExtra.new_frame","title":"new_frame","text":"<pre><code>new_frame(\n    code: ir.Statement,\n) -&gt; ForwardFrame[LatticeElemType, ExtraType]\n</code></pre> <p>Create a new frame for the given method.</p> Source code in <code>src/kirin/analysis/forward.py</code> <pre><code>def new_frame(self, code: ir.Statement) -&gt; ForwardFrame[LatticeElemType, ExtraType]:\n    return ForwardFrame.from_func_like(code)\n</code></pre>"},{"location":"reference/kirin/analysis/forward/#kirin.analysis.forward.ForwardExtra.run_analysis","title":"run_analysis","text":"<pre><code>run_analysis(\n    method: ir.Method,\n    args: tuple[LatticeElemType, ...] | None = None,\n) -&gt; tuple[\n    dict[ir.SSAValue, LatticeElemType], LatticeElemType\n]\n</code></pre> <p>Run the forward dataflow analysis.</p> <p>Parameters:</p> Name Type Description Default <code>method(ir.Method)</code> <p>The method to analyze.</p> required <code>args(tuple[LatticeElemType])</code> <p>The arguments to the method. Defaults to tuple of top values.</p> required <p>Other Parameters:</p> Name Type Description <code>save_all_ssa(bool)</code> <p>If True, save all SSA values in the results.</p> <p>Returns:</p> Name Type Description <code>dict[SSAValue, LatticeElemType]</code> <p>dict[ir.SSAValue, LatticeElemType]: The results of the analysis for each SSA value.</p> <code>LatticeElemType</code> <code>LatticeElemType</code> <p>The result of the analysis for the method return value.</p> Source code in <code>src/kirin/analysis/forward.py</code> <pre><code>def run_analysis(\n    self,\n    method: ir.Method,\n    args: tuple[LatticeElemType, ...] | None = None,\n) -&gt; tuple[dict[ir.SSAValue, LatticeElemType], LatticeElemType]:\n    \"\"\"Run the forward dataflow analysis.\n\n    Args:\n        method(ir.Method): The method to analyze.\n        args(tuple[LatticeElemType]): The arguments to the method. Defaults to tuple of top values.\n\n    Keyword Args:\n        save_all_ssa(bool): If True, save all SSA values in the results.\n\n    Returns:\n        dict[ir.SSAValue, LatticeElemType]: The results of the analysis for each SSA value.\n        LatticeElemType: The result of the analysis for the method return value.\n    \"\"\"\n    args = args or tuple(self.lattice.top() for _ in method.args)\n    result = self.run(method, args)\n    if isinstance(result, interp.result.Err):\n        return self.results, self.lattice.bottom()\n    return self.results, result.expect()\n</code></pre>"},{"location":"reference/kirin/analysis/forward/#kirin.analysis.forward.ForwardExtra.set_values","title":"set_values","text":"<pre><code>set_values(\n    frame: AbstractFrame[LatticeElemType],\n    ssa: Iterable[ir.SSAValue],\n    results: Iterable[LatticeElemType],\n)\n</code></pre> <p>Set the abstract values for the given SSA values in the frame.</p> <p>This method is used to customize how the abstract values are set in the frame. By default, the abstract values are set directly in the frame. This method is overridden to join the results if the SSA value already exists in the frame.</p> Source code in <code>src/kirin/analysis/forward.py</code> <pre><code>def set_values(\n    self,\n    frame: AbstractFrame[LatticeElemType],\n    ssa: Iterable[ir.SSAValue],\n    results: Iterable[LatticeElemType],\n):\n    \"\"\"Set the abstract values for the given SSA values in the frame.\n\n    This method is used to customize how the abstract values are set in\n    the frame. By default, the abstract values are set directly in the\n    frame. This method is overridden to join the results if the SSA value\n    already exists in the frame.\n    \"\"\"\n    for ssa_value, result in zip(ssa, results):\n        if ssa_value in frame.entries:\n            frame.entries[ssa_value] = frame.entries[ssa_value].join(result)\n        else:\n            frame.entries[ssa_value] = result\n</code></pre>"},{"location":"reference/kirin/analysis/const/","title":"Index","text":"<p>Const analysis module.</p> <p>This module contains the constant analysis framework for kirin. The constant analysis framework is built on top of the interpreter framework.</p> <p>This module provides a lattice for constant propagation analysis and a propagation algorithm for computing the constant values for each SSA value in the IR.</p>"},{"location":"reference/kirin/analysis/const/lattice/","title":"Lattice","text":"<p>Lattice for constant analysis.</p>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.Bottom","title":"Bottom  <code>dataclass</code>","text":"<pre><code>Bottom()\n</code></pre> <p>               Bases: <code>Result</code></p> <p>Bottom element of the lattice.</p>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.Bottom.is_subseteq","title":"is_subseteq","text":"<pre><code>is_subseteq(other: Result) -&gt; bool\n</code></pre> <p>Subseteq operation.</p> Source code in <code>src/kirin/analysis/const/lattice.py</code> <pre><code>def is_subseteq(self, other: Result) -&gt; bool:\n    return True\n</code></pre>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.JointResult","title":"JointResult  <code>dataclass</code>","text":"<pre><code>JointResult(const: Result, purity: Purity = Purity.top())\n</code></pre> <p>               Bases: <code>BoundedLattice['JointResult']</code></p> <p>Joint result of constant value and purity.</p> <p>This lattice is used to join the constant value and purity of a function during constant propagation analysis. This allows the analysis to track both the constant value and the purity of the function, so that the analysis can propagate constant values through function calls even if the function is only partially pure.</p>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.JointResult.const","title":"const  <code>instance-attribute</code>","text":"<pre><code>const: Result\n</code></pre> <p>The constant value of the result.</p>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.JointResult.purity","title":"purity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>purity: Purity = field(default_factory=top)\n</code></pre> <p>The purity of statement that produces the result.</p>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.JointResult.is_subseteq","title":"is_subseteq","text":"<pre><code>is_subseteq(other: JointResult) -&gt; bool\n</code></pre> <p>Subseteq operation.</p> Source code in <code>src/kirin/analysis/const/lattice.py</code> <pre><code>def is_subseteq(self, other: \"JointResult\") -&gt; bool:\n    return self.const.is_subseteq(other.const) and self.purity.is_subseteq(\n        other.purity\n    )\n</code></pre>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.JointResult.join","title":"join","text":"<pre><code>join(other: JointResult) -&gt; JointResult\n</code></pre> <p>Join operation.</p> Source code in <code>src/kirin/analysis/const/lattice.py</code> <pre><code>def join(self, other: \"JointResult\") -&gt; \"JointResult\":\n    return JointResult(self.const.join(other.const), self.purity.join(other.purity))\n</code></pre>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.JointResult.meet","title":"meet","text":"<pre><code>meet(other: JointResult) -&gt; JointResult\n</code></pre> <p>Meet operation.</p> Source code in <code>src/kirin/analysis/const/lattice.py</code> <pre><code>def meet(self, other: \"JointResult\") -&gt; \"JointResult\":\n    return JointResult(self.const.meet(other.const), self.purity.join(other.purity))\n</code></pre>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.NotPure","title":"NotPure  <code>dataclass</code>","text":"<pre><code>NotPure()\n</code></pre> <p>               Bases: <code>Purity</code></p> <p>The result is from an impure function.</p>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.NotPure.is_subseteq","title":"is_subseteq","text":"<pre><code>is_subseteq(other: Purity) -&gt; bool\n</code></pre> <p>Subseteq operation.</p> Source code in <code>src/kirin/analysis/const/lattice.py</code> <pre><code>def is_subseteq(self, other: Purity) -&gt; bool:\n    return isinstance(other, NotPure)\n</code></pre>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.PartialConst","title":"PartialConst  <code>dataclass</code>","text":"<pre><code>PartialConst()\n</code></pre> <p>               Bases: <code>Result</code></p> <p>Base class for partial constant values.</p>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.PartialLambda","title":"PartialLambda  <code>dataclass</code>","text":"<pre><code>PartialLambda(\n    argnames: list[str],\n    code: ir.Statement,\n    captured: tuple[Result, ...],\n)\n</code></pre> <p>               Bases: <code>PartialConst</code></p> <p>Partial lambda constant value.</p> <p>This represents a closure with captured variables.</p>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.PartialLambda.join","title":"join","text":"<pre><code>join(other: Result) -&gt; Result\n</code></pre> <p>Join operation.</p> Source code in <code>src/kirin/analysis/const/lattice.py</code> <pre><code>def join(self, other: Result) -&gt; Result:\n    if other is other.bottom():\n        return self\n\n    if not isinstance(other, PartialLambda):\n        return Unknown().join(other)  # widen self\n\n    if self.code is not other.code:\n        return Unknown()  # lambda stmt is pure\n\n    if len(self.captured) != len(other.captured):\n        return self.bottom()  # err\n\n    return PartialLambda(\n        self.argnames,\n        self.code,\n        tuple(x.join(y) for x, y in zip(self.captured, other.captured)),\n    )\n</code></pre>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.PartialLambda.meet","title":"meet","text":"<pre><code>meet(other: Result) -&gt; Result\n</code></pre> <p>Meet operation.</p> Source code in <code>src/kirin/analysis/const/lattice.py</code> <pre><code>def meet(self, other: Result) -&gt; Result:\n    if not isinstance(other, PartialLambda):\n        return Unknown().meet(other)\n\n    if self.code is not other.code:\n        return self.bottom()\n\n    if len(self.captured) != len(other.captured):\n        return Unknown()\n\n    return PartialLambda(\n        self.argnames,\n        self.code,\n        tuple(x.meet(y) for x, y in zip(self.captured, other.captured)),\n    )\n</code></pre>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.PartialTuple","title":"PartialTuple  <code>dataclass</code>","text":"<pre><code>PartialTuple(data: tuple[Result, ...])\n</code></pre> <p>               Bases: <code>PartialConst</code></p> <p>Partial tuple constant value.</p>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.PartialTuple.is_equal","title":"is_equal","text":"<pre><code>is_equal(other: Result) -&gt; bool\n</code></pre> <p>Check if two lattices are equal.</p> Source code in <code>src/kirin/analysis/const/lattice.py</code> <pre><code>def is_equal(self, other: Result) -&gt; bool:\n    if isinstance(other, PartialTuple):\n        return all(x.is_equal(y) for x, y in zip(self.data, other.data))\n    elif isinstance(other, Value) and isinstance(other.data, tuple):\n        return all(x.is_equal(Value(y)) for x, y in zip(self.data, other.data))\n    return False\n</code></pre>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.PartialTuple.join","title":"join","text":"<pre><code>join(other: Result) -&gt; Result\n</code></pre> <p>Join operation.</p> Source code in <code>src/kirin/analysis/const/lattice.py</code> <pre><code>def join(self, other: Result) -&gt; Result:\n    if other.is_subseteq(self):\n        return self\n    elif self.is_subseteq(other):\n        return other\n    elif isinstance(other, PartialTuple):\n        return PartialTuple(tuple(x.join(y) for x, y in zip(self.data, other.data)))\n    elif isinstance(other, Value) and isinstance(other.data, tuple):\n        return PartialTuple(\n            tuple(x.join(Value(y)) for x, y in zip(self.data, other.data))\n        )\n    return Unknown()\n</code></pre>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.PartialTuple.meet","title":"meet","text":"<pre><code>meet(other: Result) -&gt; Result\n</code></pre> <p>Meet operation.</p> Source code in <code>src/kirin/analysis/const/lattice.py</code> <pre><code>def meet(self, other: Result) -&gt; Result:\n    if self.is_subseteq(other):\n        return self\n    elif other.is_subseteq(self):\n        return other\n    elif isinstance(other, PartialTuple):\n        return PartialTuple(tuple(x.meet(y) for x, y in zip(self.data, other.data)))\n    elif isinstance(other, Value) and isinstance(other.data, tuple):\n        return PartialTuple(\n            tuple(x.meet(Value(y)) for x, y in zip(self.data, other.data))\n        )\n    return self.bottom()\n</code></pre>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.PartialTupleMeta","title":"PartialTupleMeta","text":"<p>               Bases: <code>LatticeMeta</code></p> <p>Metaclass for PartialTuple.</p> <p>This metaclass canonicalizes PartialTuple instances with all Value elements into a single Value instance.</p>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.Pure","title":"Pure  <code>dataclass</code>","text":"<pre><code>Pure()\n</code></pre> <p>               Bases: <code>Purity</code></p> <p>The result is from a pure function.</p>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.Pure.is_subseteq","title":"is_subseteq","text":"<pre><code>is_subseteq(other: Purity) -&gt; bool\n</code></pre> <p>Subseteq operation.</p> Source code in <code>src/kirin/analysis/const/lattice.py</code> <pre><code>def is_subseteq(self, other: Purity) -&gt; bool:\n    return isinstance(other, (NotPure, Pure))\n</code></pre>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.Purity","title":"Purity  <code>dataclass</code>","text":"<pre><code>Purity()\n</code></pre> <p>               Bases: <code>SimpleJoinMixin['Purity']</code>, <code>SimpleMeetMixin['Purity']</code>, <code>BoundedLattice['Purity']</code></p> <p>Base class for purity lattice.</p>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.PurityBottom","title":"PurityBottom  <code>dataclass</code>","text":"<pre><code>PurityBottom()\n</code></pre> <p>               Bases: <code>Purity</code></p> <p>The bottom element of the purity lattice.</p>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.PurityBottom.is_subseteq","title":"is_subseteq","text":"<pre><code>is_subseteq(other: Purity) -&gt; bool\n</code></pre> <p>Subseteq operation.</p> Source code in <code>src/kirin/analysis/const/lattice.py</code> <pre><code>def is_subseteq(self, other: Purity) -&gt; bool:\n    return True\n</code></pre>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.Result","title":"Result  <code>dataclass</code>","text":"<pre><code>Result()\n</code></pre> <p>               Bases: <code>IsSubsetEqMixin['Result']</code>, <code>SimpleJoinMixin['Result']</code>, <code>SimpleMeetMixin['Result']</code>, <code>BoundedLattice['Result']</code>, <code>_ElemVisitor</code></p> <p>Base class for constant analysis results.</p>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.Unknown","title":"Unknown  <code>dataclass</code>","text":"<pre><code>Unknown()\n</code></pre> <p>               Bases: <code>Result</code></p> <p>Unknown constant value. This is the top element of the lattice.</p>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.Unknown.is_subseteq","title":"is_subseteq","text":"<pre><code>is_subseteq(other: Result) -&gt; bool\n</code></pre> <p>Subseteq operation.</p> Source code in <code>src/kirin/analysis/const/lattice.py</code> <pre><code>def is_subseteq(self, other: Result) -&gt; bool:\n    return isinstance(other, Unknown)\n</code></pre>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.Value","title":"Value  <code>dataclass</code>","text":"<pre><code>Value(data: Any)\n</code></pre> <p>               Bases: <code>Result</code></p> <p>Constant value. Wraps any Python value.</p>"},{"location":"reference/kirin/analysis/const/lattice/#kirin.analysis.const.lattice.Value.is_equal","title":"is_equal","text":"<pre><code>is_equal(other: Result) -&gt; bool\n</code></pre> <p>Check if two lattices are equal.</p> Source code in <code>src/kirin/analysis/const/lattice.py</code> <pre><code>def is_equal(self, other: Result) -&gt; bool:\n    if isinstance(other, Value):\n        return self.data == other.data\n    return False\n</code></pre>"},{"location":"reference/kirin/analysis/const/prop/","title":"Prop","text":""},{"location":"reference/kirin/analysis/const/prop/#kirin.analysis.const.prop.Propagate","title":"Propagate  <code>dataclass</code>","text":"<pre><code>Propagate(\n    dialects: DialectGroup,\n    *,\n    fuel: int | None = None,\n    debug: bool = False,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192,\n    save_all_ssa: bool = False\n)\n</code></pre> <p>               Bases: <code>ForwardExtra[JointResult, ExtraFrameInfo]</code></p> <p>Forward dataflow analysis for constant propagation.</p> <p>This analysis is a forward dataflow analysis that propagates constant values through the program. It uses the <code>JointResult</code> lattice to track the constant values and purity of the values.</p> <p>The analysis is implemented as a forward dataflow analysis, where the <code>eval_stmt</code> method is overridden to handle the different types of statements in the IR. The analysis uses the <code>interp.Interpreter</code> to evaluate the statements and propagate the constant values.</p> <p>When a statement is registered under the \"constprop\" key in the method table, the analysis will call the method to evaluate the statement instead of using the interpreter. This allows for custom handling of statements.</p>"},{"location":"reference/kirin/analysis/const/prop/#kirin.analysis.const.prop.Propagate.keys","title":"keys  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>keys = ['constprop']\n</code></pre> <p>The name of the interpreter to select from dialects by order.</p>"},{"location":"reference/kirin/analysis/const/prop/#kirin.analysis.const.prop.Propagate.lattice","title":"lattice  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lattice = JointResult\n</code></pre> <p>lattice type for the abstract interpreter.</p>"},{"location":"reference/kirin/analysis/const/prop/#kirin.analysis.const.prop.Propagate.eval_stmt","title":"eval_stmt","text":"<pre><code>eval_stmt(\n    frame: ForwardFrame[JointResult, ExtraFrameInfo],\n    stmt: ir.Statement,\n) -&gt; interp.StatementResult[JointResult]\n</code></pre> <p>Run a statement within the current frame. This is the entry point of running a statement. It will look up the statement implementation in the dialect registry, or optionally call a fallback implementation.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>FrameType</code> <p>the current frame</p> required <code>stmt</code> <code>Statement</code> <p>the statement to run</p> required <p>Returns:</p> Name Type Description <code>StatementResult</code> <code>StatementResult[ValueType]</code> <p>the result of running the statement</p> Note <p>Overload this method for the following reasons: - to change the source tracking information - to take control of how to run a statement - to change the implementation lookup behavior that cannot acheive     by overloading <code>lookup_registry</code></p> Example <ul> <li>implement an interpreter that only handles MyStmt: <pre><code>    class MyInterpreter(BaseInterpreter):\n        ...\n        def eval_stmt(self, frame: FrameType, stmt: Statement) -&gt; StatementResult[ValueType]:\n            if isinstance(stmt, MyStmt):\n                return self.run_my_stmt(frame, stmt)\n            else:\n                return ()\n</code></pre></li> </ul> Source code in <code>src/kirin/analysis/const/prop.py</code> <pre><code>def eval_stmt(\n    self, frame: ForwardFrame[JointResult, ExtraFrameInfo], stmt: ir.Statement\n) -&gt; interp.StatementResult[JointResult]:\n    if stmt.has_trait(ir.ConstantLike):\n        return self._try_eval_const_pure(frame, stmt, ())\n    elif stmt.has_trait(ir.Pure):\n        values = tuple(x.const for x in frame.get_values(stmt.args))\n        if ir.types.is_tuple_of(values, Value):\n            return self._try_eval_const_pure(frame, stmt, values)\n\n    method = self.lookup_registry(frame, stmt)\n    if method is not None:\n        ret = method(self, frame, stmt)\n        self._set_frame_not_pure(ret)\n        return ret\n    elif stmt.has_trait(ir.Pure):\n        # fallback to top for other statements\n        return (JointResult(Unknown(), Pure()),)\n    else:\n        if frame.extra is None:\n            frame.extra = ExtraFrameInfo(True)\n        return (JointResult(Unknown(), NotPure()),)\n</code></pre>"},{"location":"reference/kirin/analysis/const/prop/#kirin.analysis.const.prop.Propagate.finalize","title":"finalize","text":"<pre><code>finalize(\n    frame: ForwardFrame[JointResult, ExtraFrameInfo],\n    results: JointResult,\n) -&gt; JointResult\n</code></pre> <p>Postprocess a frame after it is popped from the stack. This is called after a method is evaluated and the frame is popped.</p> Note <p>Default implementation does nothing.</p> Source code in <code>src/kirin/analysis/const/prop.py</code> <pre><code>def finalize(\n    self,\n    frame: ForwardFrame[JointResult, ExtraFrameInfo],\n    results: JointResult,\n) -&gt; JointResult:\n    results = super().finalize(frame, results)\n    if frame.extra is not None and frame.extra.frame_is_not_pure:\n        return JointResult(results.const, NotPure())\n    return results\n</code></pre>"},{"location":"reference/kirin/analysis/const/prop/#kirin.analysis.const.prop.Propagate.initialize","title":"initialize","text":"<pre><code>initialize()\n</code></pre> <p>Initialize the interpreter global states. This method is called right upon calling <code>run</code> to initialize the interpreter global states.</p> <p>Default Implementation</p> <p>This method provides default behavior but may be overridden by subclasses to customize or extend functionality.</p> Source code in <code>src/kirin/analysis/const/prop.py</code> <pre><code>def initialize(self):\n    super().initialize()\n    self._interp.initialize()\n    return self\n</code></pre>"},{"location":"reference/kirin/analysis/const/prop/#kirin.analysis.const.prop.Propagate.run_method","title":"run_method","text":"<pre><code>run_method(\n    method: ir.Method, args: tuple[JointResult, ...]\n) -&gt; JointResult\n</code></pre> <p>How to run a method.</p> <p>This is defined by subclasses to describe what's the corresponding value of a method during the interpretation.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Method</code> <p>the method to run.</p> required <code>args</code> <code>tuple[ValueType]</code> <p>the arguments to the method, does not include self.</p> required <p>Returns:</p> Name Type Description <code>ValueType</code> <code>ValueType</code> <p>the result of the method.</p> Source code in <code>src/kirin/analysis/const/prop.py</code> <pre><code>def run_method(\n    self, method: ir.Method, args: tuple[JointResult, ...]\n) -&gt; JointResult:\n    return self.run_callable(\n        method.code, (JointResult(Value(method), NotPure()),) + args\n    )\n</code></pre>"},{"location":"reference/kirin/analysis/typeinfer/","title":"Index","text":"<p>Type inference analysis for kirin.</p>"},{"location":"reference/kirin/analysis/typeinfer/analysis/","title":"Analysis","text":""},{"location":"reference/kirin/analysis/typeinfer/analysis/#kirin.analysis.typeinfer.analysis.TypeInference","title":"TypeInference  <code>dataclass</code>","text":"<pre><code>TypeInference(\n    dialects: DialectGroup,\n    *,\n    fuel: int | None = None,\n    debug: bool = False,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192,\n    save_all_ssa: bool = False\n)\n</code></pre> <p>               Bases: <code>Forward[TypeAttribute]</code></p> <p>Type inference analysis for kirin.</p> <p>This analysis uses the forward dataflow analysis framework to infer the types of the IR. The analysis uses the type information within the IR to determine the method dispatch.</p> <p>The analysis will fallback to a type resolution algorithm if the type information is not available in the IR but the type information is available in the abstract values.</p>"},{"location":"reference/kirin/analysis/typeinfer/analysis/#kirin.analysis.typeinfer.analysis.TypeInference.keys","title":"keys  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>keys = ['typeinfer']\n</code></pre> <p>The name of the interpreter to select from dialects by order.</p>"},{"location":"reference/kirin/analysis/typeinfer/analysis/#kirin.analysis.typeinfer.analysis.TypeInference.lattice","title":"lattice  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lattice = TypeAttribute\n</code></pre> <p>lattice type for the abstract interpreter.</p>"},{"location":"reference/kirin/analysis/typeinfer/analysis/#kirin.analysis.typeinfer.analysis.TypeInference.build_signature","title":"build_signature","text":"<pre><code>build_signature(\n    frame: ForwardFrame[types.TypeAttribute, None],\n    stmt: ir.Statement,\n) -&gt; Signature\n</code></pre> <p>build signature for querying the statement implementation.</p> Source code in <code>src/kirin/analysis/typeinfer/analysis.py</code> <pre><code>def build_signature(\n    self, frame: ForwardFrame[types.TypeAttribute, None], stmt: ir.Statement\n) -&gt; Signature:\n    _args = ()\n    for x in frame.get_values(stmt.args):\n        _args += (self._unwrap(x),)\n    return Signature(stmt.__class__, _args)\n</code></pre>"},{"location":"reference/kirin/analysis/typeinfer/analysis/#kirin.analysis.typeinfer.analysis.TypeInference.eval_stmt_fallback","title":"eval_stmt_fallback","text":"<pre><code>eval_stmt_fallback(\n    frame: ForwardFrame[types.TypeAttribute, None],\n    stmt: ir.Statement,\n) -&gt; (\n    tuple[types.TypeAttribute, ...]\n    | interp.SpecialValue[types.TypeAttribute]\n)\n</code></pre> <p>The fallback implementation of statements.</p> <p>This is called when no implementation is found for the statement.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>FrameType</code> <p>the current frame</p> required <code>stmt</code> <code>Statement</code> <p>the statement to run</p> required <p>Returns:</p> Name Type Description <code>StatementResult</code> <code>StatementResult[ValueType]</code> <p>the result of running the statement</p> Note <p>Overload this method to provide a fallback implementation for statements.</p> Source code in <code>src/kirin/analysis/typeinfer/analysis.py</code> <pre><code>def eval_stmt_fallback(\n    self, frame: ForwardFrame[types.TypeAttribute, None], stmt: ir.Statement\n) -&gt; tuple[types.TypeAttribute, ...] | interp.SpecialValue[types.TypeAttribute]:\n    resolve = TypeResolution()\n    for arg, value in zip(stmt.args, frame.get_values(stmt.args)):\n        resolve.solve(arg.type, value)\n    return tuple(resolve.substitute(result.type) for result in stmt.results)\n</code></pre>"},{"location":"reference/kirin/analysis/typeinfer/analysis/#kirin.analysis.typeinfer.analysis.TypeInference.run_method","title":"run_method","text":"<pre><code>run_method(\n    method: ir.Method, args: tuple[types.TypeAttribute, ...]\n) -&gt; types.TypeAttribute\n</code></pre> <p>How to run a method.</p> <p>This is defined by subclasses to describe what's the corresponding value of a method during the interpretation.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Method</code> <p>the method to run.</p> required <code>args</code> <code>tuple[ValueType]</code> <p>the arguments to the method, does not include self.</p> required <p>Returns:</p> Name Type Description <code>ValueType</code> <code>ValueType</code> <p>the result of the method.</p> Source code in <code>src/kirin/analysis/typeinfer/analysis.py</code> <pre><code>def run_method(\n    self, method: ir.Method, args: tuple[types.TypeAttribute, ...]\n) -&gt; types.TypeAttribute:\n    return self.run_callable(\n        method.code, (types.Hinted(types.PyClass(ir.Method), method),) + args\n    )\n</code></pre>"},{"location":"reference/kirin/analysis/typeinfer/solve/","title":"Solve","text":"<p>Type resolution for type inference.</p> <p>This module contains the type resolution algorithm for type inference. A simple algorithm is used to resolve the types of the IR by comparing the input types with the output types.</p>"},{"location":"reference/kirin/analysis/typeinfer/solve/#kirin.analysis.typeinfer.solve.ResolutionError","title":"ResolutionError  <code>dataclass</code>","text":"<pre><code>ResolutionError(\n    expr: types.TypeAttribute, value: types.TypeAttribute\n)\n</code></pre> <p>               Bases: <code>TypeResolutionResult</code></p> <p>Type resolution result for failed resolution.</p>"},{"location":"reference/kirin/analysis/typeinfer/solve/#kirin.analysis.typeinfer.solve.ResolutionOk","title":"ResolutionOk  <code>dataclass</code>","text":"<pre><code>ResolutionOk()\n</code></pre> <p>               Bases: <code>TypeResolutionResult</code></p> <p>Type resolution result for successful resolution.</p>"},{"location":"reference/kirin/analysis/typeinfer/solve/#kirin.analysis.typeinfer.solve.TypeResolution","title":"TypeResolution  <code>dataclass</code>","text":"<pre><code>TypeResolution(\n    vars: dict[types.TypeVar, types.TypeAttribute] = dict()\n)\n</code></pre> <p>Type resolution algorithm for type inference.</p>"},{"location":"reference/kirin/analysis/typeinfer/solve/#kirin.analysis.typeinfer.solve.TypeResolution.solve","title":"solve","text":"<pre><code>solve(\n    annot: types.TypeAttribute, value: types.TypeAttribute\n) -&gt; TypeResolutionResult\n</code></pre> <p>Solve the type resolution problem.</p> <p>This method compares the expected type <code>annot</code> with the actual type <code>value</code> and returns a result indicating whether the types match or not.</p> <p>Parameters:</p> Name Type Description Default <code>annot</code> <code>TypeAttribute</code> <p>The expected type.</p> required <code>value</code> <code>TypeAttribute</code> <p>The actual type.</p> required <p>Returns:</p> Type Description <code>TypeResolutionResult</code> <p>A <code>TypeResolutionResult</code> object indicating the result of the</p> <code>TypeResolutionResult</code> <p>resolution.</p> Source code in <code>src/kirin/analysis/typeinfer/solve.py</code> <pre><code>def solve(\n    self, annot: types.TypeAttribute, value: types.TypeAttribute\n) -&gt; TypeResolutionResult:\n    \"\"\"Solve the type resolution problem.\n\n    This method compares the expected type `annot` with the actual\n    type `value` and returns a result indicating whether the types\n    match or not.\n\n    Args:\n        annot: The expected type.\n        value: The actual type.\n\n    Returns:\n        A `TypeResolutionResult` object indicating the result of the\n        resolution.\n    \"\"\"\n    if isinstance(annot, types.TypeVar):\n        return self.solve_TypeVar(annot, value)\n    elif isinstance(annot, types.Generic):\n        return self.solve_Generic(annot, value)\n    elif isinstance(annot, types.Union):\n        return self.solve_Union(annot, value)\n\n    if annot.is_subseteq(value):\n        return Ok\n    else:\n        return ResolutionError(annot, value)\n</code></pre>"},{"location":"reference/kirin/analysis/typeinfer/solve/#kirin.analysis.typeinfer.solve.TypeResolution.substitute","title":"substitute","text":"<pre><code>substitute(typ: types.TypeAttribute) -&gt; types.TypeAttribute\n</code></pre> <p>Substitute type variables in the type with their values.</p> <p>This method substitutes type variables in the given type with their values. If the type is a generic type, the method recursively substitutes the type variables in the type arguments.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>TypeAttribute</code> <p>The type to substitute.</p> required <p>Returns:</p> Type Description <code>TypeAttribute</code> <p>The type with the type variables substituted.</p> Source code in <code>src/kirin/analysis/typeinfer/solve.py</code> <pre><code>def substitute(self, typ: types.TypeAttribute) -&gt; types.TypeAttribute:\n    \"\"\"Substitute type variables in the type with their values.\n\n    This method substitutes type variables in the given type with their\n    values. If the type is a generic type, the method recursively\n    substitutes the type variables in the type arguments.\n\n    Args:\n        typ: The type to substitute.\n\n    Returns:\n        The type with the type variables substituted.\n    \"\"\"\n    if isinstance(typ, types.TypeVar):\n        return self.vars.get(typ, typ)\n    elif isinstance(typ, types.Generic):\n        return types.Generic(\n            typ.body, *tuple(self.substitute(var) for var in typ.vars)\n        )\n    elif isinstance(typ, types.Union):\n        return types.Union(self.substitute(t) for t in typ.types)\n    return typ\n</code></pre>"},{"location":"reference/kirin/analysis/typeinfer/solve/#kirin.analysis.typeinfer.solve.TypeResolutionResult","title":"TypeResolutionResult  <code>dataclass</code>","text":"<pre><code>TypeResolutionResult()\n</code></pre> <p>Base class for type resolution results.</p>"},{"location":"reference/kirin/decl/","title":"Index","text":""},{"location":"reference/kirin/decl/#kirin.decl.statement","title":"statement","text":"<pre><code>statement(\n    cls=None, **kwargs: Unpack[StatementOptions]\n) -&gt; Callable[[type[StmtType]], type[StmtType]]\n</code></pre> <p>Declare a new statement class.</p> <p>This decorator is used to declare a new statement class. It is used to generate the necessary boilerplate code for the class. The class should inherit from <code>kirin.ir.Statement</code>.</p> <p>Parameters:</p> Name Type Description Default <code>init(bool)</code> <p>Whether to generate an <code>__init__</code> method.</p> required <code>repr(bool)</code> <p>Whether to generate a <code>__repr__</code> method.</p> required <code>kw_only(bool)</code> <p>Whether to use keyword-only arguments in the <code>__init__</code> method.</p> required <code>dialect(Optional[Dialect])</code> <p>The dialect of the statement.</p> required <code>property(bool)</code> <p>Whether to generate property methods for attributes.</p> required Example <p>The following is an example of how to use the <code>statement</code> decorator.</p> <pre><code>@statement\nclass MyStatement(ir.Statement):\n    name = \"some_name\"\n    traits = frozenset({TraitA(), TraitB()})\n    some_input: ir.SSAValue = info.argument()\n    some_output: ir.ResultValue = info.result()\n    body: ir.Region = info.region()\n    successor: ir.Block = info.block()\n</code></pre> <p>If the <code>name</code> field is not specified, a lowercase name field will be auto generated.</p> <p>In addition, one can optionally register the statement to a dialect by providing the <code>dialect</code> argument to the decorator.</p> <p>The following example register the statement to a dialect <code>my_dialect_object</code>, and <code>name = \"myfoo\"</code> field is autogenerated</p> <pre><code>@statement(dialect=my_dialect_object)\nclass MyFoo(ir.Statement):\n    traits = frozenset({ir.FromPythonCall()})\n    value: str = info.attribute()\n</code></pre> Source code in <code>src/kirin/decl/__init__.py</code> <pre><code>@dataclass_transform(\n    field_specifiers=(\n        info.attribute,\n        info.argument,\n        info.region,\n        info.result,\n        info.block,\n    )\n)\ndef statement(\n    cls=None,\n    **kwargs: Unpack[StatementOptions],\n) -&gt; Callable[[type[StmtType]], type[StmtType]]:\n    \"\"\"Declare a new statement class.\n\n    This decorator is used to declare a new statement class. It is used to\n    generate the necessary boilerplate code for the class. The class should\n    inherit from `kirin.ir.Statement`.\n\n    Args:\n        init(bool): Whether to generate an `__init__` method.\n        repr(bool): Whether to generate a `__repr__` method.\n        kw_only(bool): Whether to use keyword-only arguments in the `__init__`\n            method.\n        dialect(Optional[Dialect]): The dialect of the statement.\n        property(bool): Whether to generate property methods for attributes.\n\n    Example:\n        The following is an example of how to use the `statement` decorator.\n\n        ```python\n        @statement\n        class MyStatement(ir.Statement):\n            name = \"some_name\"\n            traits = frozenset({TraitA(), TraitB()})\n            some_input: ir.SSAValue = info.argument()\n            some_output: ir.ResultValue = info.result()\n            body: ir.Region = info.region()\n            successor: ir.Block = info.block()\n        ```\n\n        If the `name` field is not specified, a lowercase name field will be auto generated.\n\n        In addition, one can optionally register the statement to a dialect\n        by providing the `dialect` argument to the decorator.\n\n        The following example register the statement to a dialect `my_dialect_object`, and `name = \"myfoo\"` field is autogenerated\n\n        ```python\n        @statement(dialect=my_dialect_object)\n        class MyFoo(ir.Statement):\n            traits = frozenset({ir.FromPythonCall()})\n            value: str = info.attribute()\n        ```\n    \"\"\"\n\n    def wrap(cls):\n        decl = StatementDecl(cls, **kwargs)\n        decl.scan_fields()\n        decl.verify()\n        decl.emit()\n        decl.register()\n        return cls\n\n    if cls is None:\n        return wrap\n    return wrap(cls)\n</code></pre>"},{"location":"reference/kirin/decl/base/","title":"Base","text":""},{"location":"reference/kirin/decl/camel2snake/","title":"Camel2snake","text":""},{"location":"reference/kirin/decl/info/","title":"Info","text":""},{"location":"reference/kirin/decl/info/#kirin.decl.info.ArgumentField","title":"ArgumentField  <code>dataclass</code>","text":"<pre><code>ArgumentField(\n    kw_only: bool,\n    alias: Optional[str],\n    type: types.TypeAttribute,\n    print: bool = True,\n    group: bool = False,\n)\n</code></pre> <p>               Bases: <code>Field</code></p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.ArgumentField.group","title":"group  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>group: bool = False\n</code></pre> <p>if <code>True</code>, this argument is annotated with Tuple[SSAValue, ...]</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.ArgumentField.print","title":"print  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>print: bool = True\n</code></pre> <p>if <code>True</code>, this argument name is printed in the signature.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.ArgumentField.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: TypeAttribute\n</code></pre> <p>type of the argument, will be used in validation.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.AttributeField","title":"AttributeField  <code>dataclass</code>","text":"<pre><code>AttributeField(\n    kw_only: bool,\n    alias: Optional[str],\n    default: Any,\n    init: bool,\n    repr: bool,\n    default_factory: Optional[Callable[[], Attribute]],\n    type: types.TypeAttribute,\n    property: bool,\n    pytype: bool = False,\n)\n</code></pre> <p>               Bases: <code>Field</code></p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.AttributeField.pytype","title":"pytype  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pytype: bool = False\n</code></pre> <p>if <code>True</code>, annotation is a python type hint instead of <code>TypeAttribute</code></p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields","title":"StatementFields  <code>dataclass</code>","text":"<pre><code>StatementFields(\n    std_args: dict[str, ArgumentField] = dict(),\n    kw_args: dict[str, ArgumentField] = dict(),\n    results: dict[str, ResultField] = dict(),\n    regions: dict[str, RegionField] = dict(),\n    blocks: dict[str, BlockField] = dict(),\n    attributes: dict[str, AttributeField] = dict(),\n    properties: dict[str, AttributeField] = dict(),\n)\n</code></pre>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.args","title":"args  <code>property</code>","text":"<pre><code>args\n</code></pre> <p>iterable of all argument fields.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.attributes","title":"attributes  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>attributes: dict[str, AttributeField] = field(\n    default_factory=dict\n)\n</code></pre> <p>attributes of the statement.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.blocks","title":"blocks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>blocks: dict[str, BlockField] = field(default_factory=dict)\n</code></pre> <p>blocks of the statement.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.kw_args","title":"kw_args  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>kw_args: dict[str, ArgumentField] = field(\n    default_factory=dict\n)\n</code></pre> <p>keyword-only arguments of the statement.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.properties","title":"properties  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>properties: dict[str, AttributeField] = field(\n    default_factory=dict\n)\n</code></pre> <p>properties of the statement.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.regions","title":"regions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>regions: dict[str, RegionField] = field(\n    default_factory=dict\n)\n</code></pre> <p>regions of the statement.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.required_names","title":"required_names  <code>cached</code> <code>property</code>","text":"<pre><code>required_names\n</code></pre> <p>set of all fields that do not have a default value.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.results","title":"results  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>results: dict[str, ResultField] = field(\n    default_factory=dict\n)\n</code></pre> <p>results of the statement.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.StatementFields.std_args","title":"std_args  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>std_args: dict[str, ArgumentField] = field(\n    default_factory=dict\n)\n</code></pre> <p>standard arguments of the statement.</p>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.argument","title":"argument","text":"<pre><code>argument(\n    type: types.TypeAttribute = types.Any,\n    *,\n    print: bool = True,\n    kw_only: bool = False,\n    alias: Optional[str] = None\n) -&gt; Any\n</code></pre> <p>Field specifier for arguments.</p> <p>Parameters:</p> Name Type Description Default <code>type(TypeAttribute)</code> <p>type of the argument, will be used in validation.</p> required <code>print(bool)</code> <p>if <code>True</code>, this argument name is printed in the signature.</p> required <code>kw_only(bool)</code> <p>if <code>True</code>, this argument is keyword-only.</p> required <code>alias(Optional[str])</code> <p>an alias for the argument name in the <code>__init__</code> method.</p> required Source code in <code>src/kirin/decl/info.py</code> <pre><code>def argument(\n    type: types.TypeAttribute = types.Any,\n    *,\n    print: bool = True,\n    kw_only: bool = False,\n    alias: Optional[str] = None,\n) -&gt; Any:\n    \"\"\"Field specifier for arguments.\n\n    Args:\n        type(TypeAttribute): type of the argument, will be used in validation.\n        print(bool): if `True`, this argument name is printed in the signature.\n        kw_only(bool): if `True`, this argument is keyword-only.\n        alias(Optional[str]): an alias for the argument name in the `__init__` method.\n    \"\"\"\n    return ArgumentField(\n        type=type,\n        print=print,\n        kw_only=kw_only,\n        alias=alias,\n    )\n</code></pre>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.block","title":"block","text":"<pre><code>block(\n    *,\n    init: bool = True,\n    repr: bool = True,\n    kw_only: bool = True,\n    alias: Optional[str] = None,\n    default_factory: Callable[[], Block] = Block\n) -&gt; Any\n</code></pre> <p>Field specifier for blocks.</p> <p>Parameters:</p> Name Type Description Default <code>init(bool)</code> <p>if <code>True</code>, this block field is included in the <code>__init__</code> method.</p> required <code>repr(bool)</code> <p>if <code>True</code>, this block field is included in the <code>__repr__</code> and pretty printing.</p> required <code>kw_only(bool)</code> <p>if <code>True</code>, this block field is keyword-only.</p> required <code>alias(Optional[str])</code> <p>an alias for the block field name in the <code>__init__</code> method.</p> required <code>default_factory(Callable[[],</code> <code>Block]</code> <p>a factory function to create a default block.</p> required Source code in <code>src/kirin/decl/info.py</code> <pre><code>def block(\n    *,\n    init: bool = True,\n    repr: bool = True,\n    kw_only: bool = True,\n    alias: Optional[str] = None,\n    default_factory: Callable[[], Block] = Block,\n) -&gt; Any:\n    \"\"\"Field specifier for blocks.\n\n    Args:\n        init(bool): if `True`, this block field is included in the `__init__` method.\n        repr(bool): if `True`, this block field is included in the `__repr__` and pretty printing.\n        kw_only(bool): if `True`, this block field is keyword-only.\n        alias(Optional[str]): an alias for the block field name in the `__init__` method.\n        default_factory(Callable[[], Block]): a factory function to create a default block.\n    \"\"\"\n    if kw_only is False:\n        raise TypeError(\"block fields must be keyword-only\")\n\n    return BlockField(\n        init=init,\n        repr=repr,\n        kw_only=kw_only,\n        alias=alias,\n        default_factory=default_factory,\n    )\n</code></pre>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.region","title":"region","text":"<pre><code>region(\n    *,\n    init: bool = True,\n    repr: bool = True,\n    kw_only: bool = True,\n    alias: Optional[str] = None,\n    multi: bool = False,\n    default_factory: Callable[[], Region] = Region\n) -&gt; Any\n</code></pre> <p>Field specifier for regions.</p> <p>Parameters:</p> Name Type Description Default <code>init(bool)</code> <p>if <code>True</code>, this region field is included in the <code>__init__</code> method.</p> required <code>repr(bool)</code> <p>if <code>True</code>, this region field is included in the <code>__repr__</code> and pretty printing.</p> required <code>kw_only(bool)</code> <p>if <code>True</code>, this region field is keyword-only.</p> required <code>alias(Optional[str])</code> <p>an alias for the region field name in the <code>__init__</code> method.</p> required <code>multi(bool)</code> <p>if <code>True</code>, this region can contain multiple blocks.</p> required <code>default_factory(Callable[[],</code> <code>Region]</code> <p>a factory function to create a default region.</p> required Source code in <code>src/kirin/decl/info.py</code> <pre><code>def region(\n    *,\n    init: bool = True,  # so we can use the default_factory\n    repr: bool = True,\n    kw_only: bool = True,\n    alias: Optional[str] = None,\n    multi: bool = False,\n    default_factory: Callable[[], Region] = Region,\n) -&gt; Any:\n    \"\"\"Field specifier for regions.\n\n    Args:\n        init(bool): if `True`, this region field is included in the `__init__` method.\n        repr(bool): if `True`, this region field is included in the `__repr__` and pretty printing.\n        kw_only(bool): if `True`, this region field is keyword-only.\n        alias(Optional[str]): an alias for the region field name in the `__init__` method.\n        multi(bool): if `True`, this region can contain multiple blocks.\n        default_factory(Callable[[], Region]): a factory function to create a default region.\n    \"\"\"\n    if kw_only is False:\n        raise TypeError(\"region fields must be keyword-only\")\n\n    return RegionField(\n        init=init,\n        repr=repr,\n        kw_only=kw_only,\n        alias=alias,\n        multi=multi,\n        default_factory=default_factory,\n    )\n</code></pre>"},{"location":"reference/kirin/decl/info/#kirin.decl.info.result","title":"result","text":"<pre><code>result(\n    type: types.TypeAttribute = types.Any,\n    *,\n    init: bool = False,\n    repr: bool = True,\n    kw_only: bool = True,\n    alias: Optional[str] = None\n) -&gt; Any\n</code></pre> <p>Field specifier for results.</p> <p>Parameters:</p> Name Type Description Default <code>type(TypeAttribute)</code> <p>type of the result.</p> required <code>init(bool)</code> <p>if <code>True</code>, this result field is included in the <code>__init__</code> method.</p> required <code>repr(bool)</code> <p>if <code>True</code>, this result field is included in the <code>__repr__</code> and pretty printing.</p> required <code>kw_only(bool)</code> <p>if <code>True</code>, this result field is keyword-only.</p> required <code>alias(Optional[str])</code> <p>an alias for the result field name in the <code>__init__</code> method.</p> required Source code in <code>src/kirin/decl/info.py</code> <pre><code>def result(\n    type: types.TypeAttribute = types.Any,\n    *,\n    # NOTE: init is false, use other hooks to set custom results\n    # or just mutate the statement after creation\n    init: bool = False,\n    repr: bool = True,\n    kw_only: bool = True,\n    alias: Optional[str] = None,\n) -&gt; Any:\n    \"\"\"Field specifier for results.\n\n    Args:\n        type(TypeAttribute): type of the result.\n        init(bool): if `True`, this result field is included in the `__init__` method.\n        repr(bool): if `True`, this result field is included in the `__repr__` and pretty printing.\n        kw_only(bool): if `True`, this result field is keyword-only.\n        alias(Optional[str]): an alias for the result field name in the `__init__` method.\n    \"\"\"\n    if kw_only is False:  # for linting\n        raise TypeError(\"result fields must be keyword-only\")\n\n    if init is True:\n        raise TypeError(\"result fields cannot appear in __init__\")\n\n    return ResultField(\n        type=type,\n        init=init,\n        repr=repr,\n        kw_only=kw_only,\n        alias=alias,\n    )\n</code></pre>"},{"location":"reference/kirin/decl/scan_fields/","title":"Scan fields","text":""},{"location":"reference/kirin/decl/scan_fields/#kirin.decl.scan_fields.ScanFields","title":"ScanFields","text":"<pre><code>ScanFields(cls: type, **kwargs: Unpack[StatementOptions])\n</code></pre> <p>               Bases: <code>BaseModifier</code></p> Source code in <code>src/kirin/decl/base.py</code> <pre><code>def __init__(self, cls: type, **kwargs: Unpack[StatementOptions]) -&gt; None:\n    self.cls = cls\n    self.cls_module = sys.modules.get(cls.__module__)\n\n    if \"dialect\" in kwargs:\n        self.dialect = kwargs[\"dialect\"]\n    else:\n        self.dialect = None\n    self.params = kwargs\n    setattr(cls, self._PARAMS, self.params)\n\n    if cls.__module__ in sys.modules:\n        self.globals = sys.modules[cls.__module__].__dict__\n    else:\n        # Theoretically this can happen if someone writes\n        # a custom string to cls.__module__.  In which case\n        # such dataclass won't be fully introspectable\n        # (w.r.t. typing.get_type_hints) but will still function\n        # correctly.\n        self.globals: dict[str, Any] = {}\n\n    # analysis state, used by scan_field, etc.\n    self.fields = StatementFields()\n    self.has_statement_bases = False\n    self.kw_only = self.params.get(\"kw_only\", False)\n    self.KW_ONLY_seen = False\n</code></pre>"},{"location":"reference/kirin/decl/verify/","title":"Verify","text":""},{"location":"reference/kirin/decl/emit/","title":"Index","text":""},{"location":"reference/kirin/decl/emit/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/decl/emit/init/","title":"Init","text":""},{"location":"reference/kirin/decl/emit/name/","title":"Name","text":""},{"location":"reference/kirin/decl/emit/property/","title":"Property","text":""},{"location":"reference/kirin/decl/emit/repr/","title":"Repr","text":""},{"location":"reference/kirin/decl/emit/traits/","title":"Traits","text":""},{"location":"reference/kirin/decl/emit/typecheck/","title":"Typecheck","text":""},{"location":"reference/kirin/decl/emit/verify/","title":"Verify","text":""},{"location":"reference/kirin/dialects/","title":"Index","text":"<p>Built-in dialects for Kirin.</p> <p>This module contains the built-in dialects for Kirin. Each dialect is an instance of the <code>Dialect</code> class. Each submodule contains a <code>dialect</code> variable that is an instance of the corresponding <code>Dialect</code> class.</p> <p>The modules can be directly used as dialects. For example, you can write</p> <pre><code>from kirin.dialects import py, func\n</code></pre> <p>to import the Python and function dialects.</p>"},{"location":"reference/kirin/dialects/eltype/","title":"Eltype","text":"<p>This dialect offers a statement <code>eltype</code> for other dialects' type inference to query/implement the element type of a value. For example, the <code>ilist</code> dialect implements the <code>eltype</code> statement on the <code>ilist.IList</code> type to return the element type.</p>"},{"location":"reference/kirin/dialects/eltype/#kirin.dialects.eltype.ElType","title":"ElType  <code>krin-statement</code>","text":"<pre><code>ElType(container: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>Returns the element type of a value.</p> <p>This statement is used by other dialects to query the element type of a value.</p>"},{"location":"reference/kirin/dialects/eltype/#kirin.dialects.eltype.ElType.container","title":"container  <code>kirin-argument</code>","text":"<pre><code>container: SSAValue = argument(PyClass(TypeAttribute))\n</code></pre> <p>The value to query the element type of.</p>"},{"location":"reference/kirin/dialects/eltype/#kirin.dialects.eltype.ElType.elem","title":"elem  <code>kirin-result</code>","text":"<pre><code>elem: ResultValue = result(PyClass(TypeAttribute))\n</code></pre> <p>The element type of the value.</p>"},{"location":"reference/kirin/dialects/module/","title":"Module","text":"<p>Module dialect provides a simple module that is roughly a list of function statements.</p> <p>This dialect provides the dialect necessary for compiling a function into lower-level IR with all its callee functions.</p>"},{"location":"reference/kirin/dialects/module/#kirin.dialects.module.Invoke","title":"Invoke  <code>krin-statement</code>","text":"<pre><code>Invoke(\n    inputs: tuple[ir.SSAValue, ...],\n    *,\n    callee: str,\n    kwargs: tuple[str, ...]\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>A special statement that represents a function calling functions by symbol name.</p> Note <p>This statement is here for completeness, for interpretation, it is recommended to rewrite this statement into a <code>func.Invoke</code> after looking up the symbol table.</p>"},{"location":"reference/kirin/dialects/module/#kirin.dialects.module.Invoke.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>run mandatory validation checks. This is not same as typecheck, which may be optional.</p> Source code in <code>src/kirin/dialects/module.py</code> <pre><code>def verify(self) -&gt; None:\n    if self.kwargs:\n        for name in self.kwargs:\n            if name not in self.callee:\n                raise VerificationError(\n                    self,\n                    f\"method {self.callee} does not have argument {name}\",\n                )\n    elif len(self.callee) - 1 != len(self.args):\n        raise VerificationError(\n            self,\n            f\"expected {len(self.callee)} arguments, got {len(self.args)}\",\n        )\n</code></pre>"},{"location":"reference/kirin/dialects/cf/","title":"Index","text":"<p>Control flow dialect.</p> <p>This dialect provides a low-level control flow representation.</p> <p>This dialect does not provide any lowering strategies, to lowering a Python AST to this dialect, use the <code>kirin.dialects.lowering.cf</code> dialect with this dialect.</p>"},{"location":"reference/kirin/dialects/cf/constprop/","title":"Constprop","text":""},{"location":"reference/kirin/dialects/cf/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/dialects/cf/emit/","title":"Emit","text":""},{"location":"reference/kirin/dialects/cf/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/cf/stmts/","title":"Stmts","text":""},{"location":"reference/kirin/dialects/cf/stmts/#kirin.dialects.cf.stmts.Branch","title":"Branch  <code>krin-statement</code>","text":"<pre><code>Branch(*, successor: Block)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"reference/kirin/dialects/cf/stmts/#kirin.dialects.cf.stmts.Branch.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>run mandatory validation checks. This is not same as typecheck, which may be optional.</p> Source code in <code>src/kirin/dialects/cf/stmts.py</code> <pre><code>def verify(self) -&gt; None:\n    return\n</code></pre>"},{"location":"reference/kirin/dialects/cf/stmts/#kirin.dialects.cf.stmts.ConditionalBranch","title":"ConditionalBranch  <code>krin-statement</code>","text":"<pre><code>ConditionalBranch(\n    cond: SSAValue,\n    *,\n    then_successor: Block,\n    else_successor: Block\n)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"reference/kirin/dialects/cf/stmts/#kirin.dialects.cf.stmts.ConditionalBranch.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>run mandatory validation checks. This is not same as typecheck, which may be optional.</p> Source code in <code>src/kirin/dialects/cf/stmts.py</code> <pre><code>def verify(self) -&gt; None:\n    return\n</code></pre>"},{"location":"reference/kirin/dialects/cf/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/dialects/func/","title":"Index","text":"<p>A function dialect that is compatible with python semantics.</p>"},{"location":"reference/kirin/dialects/func/attrs/","title":"Attrs","text":""},{"location":"reference/kirin/dialects/func/attrs/#kirin.dialects.func.attrs.Signature","title":"Signature  <code>dataclass</code>","text":"<pre><code>Signature(\n    inputs: tuple[TypeLatticeElem, ...],\n    output: TypeLatticeElem,\n)\n</code></pre> <p>               Bases: <code>Generic[TypeLatticeElem]</code>, <code>Attribute</code></p> <p>function body signature.</p> <p>This is not a type attribute because it just stores the signature of a function at its definition site. We don't perform type inference on this directly.</p> <p>The type of a function is the type of <code>inputs[0]</code>, which typically is a <code>MethodType</code>.</p>"},{"location":"reference/kirin/dialects/func/attrs/#kirin.dialects.func.attrs.Signature.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'Signature'\n</code></pre> <p>Name of the attribute in printing and other text format.</p>"},{"location":"reference/kirin/dialects/func/constprop/","title":"Constprop","text":""},{"location":"reference/kirin/dialects/func/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/dialects/func/emit/","title":"Emit","text":""},{"location":"reference/kirin/dialects/func/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/func/stmts/","title":"Stmts","text":""},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.ConstantNone","title":"ConstantNone  <code>krin-statement</code>","text":"<pre><code>ConstantNone()\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>A constant None value.</p> <p>This is mainly used to represent the None return value of a function to match Python semantics.</p>"},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.FuncOpCallableInterface","title":"FuncOpCallableInterface  <code>dataclass</code>","text":"<pre><code>FuncOpCallableInterface()\n</code></pre> <p>               Bases: <code>CallableStmtInterface['Function']</code></p>"},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.FuncOpCallableInterface.get_callable_region","title":"get_callable_region  <code>classmethod</code>","text":"<pre><code>get_callable_region(stmt: Function) -&gt; Region\n</code></pre> <p>Returns the body of the callable region</p> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>@classmethod\ndef get_callable_region(cls, stmt: \"Function\") -&gt; Region:\n    return stmt.body\n</code></pre>"},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.Function","title":"Function  <code>krin-statement</code>","text":"<pre><code>Function(\n    *, sym_name: str, signature: Signature, body: Region\n)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.Function.sym_name","title":"sym_name  <code>kirin-property</code> <code>kw-only</code>","text":"<pre><code>sym_name: str = attribute(property=True)\n</code></pre> <p>The symbol name of the function.</p>"},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.Invoke","title":"Invoke  <code>krin-statement</code>","text":"<pre><code>Invoke(\n    inputs: tuple[SSAValue, ...],\n    *,\n    callee: Method,\n    kwargs: tuple[str, ...]\n)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.Invoke.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>run mandatory validation checks. This is not same as typecheck, which may be optional.</p> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>def verify(self) -&gt; None:\n    if self.kwargs:\n        for name in self.kwargs:\n            if name not in self.callee.arg_names:\n                raise VerificationError(\n                    self,\n                    f\"method {self.callee.sym_name} does not have argument {name}\",\n                )\n    elif len(self.callee.arg_names) - 1 != len(self.args):\n        raise VerificationError(\n            self,\n            f\"expected {len(self.callee.arg_names)} arguments, got {len(self.args)}\",\n        )\n</code></pre>"},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.Lambda","title":"Lambda  <code>krin-statement</code>","text":"<pre><code>Lambda(\n    captured: tuple[SSAValue, ...],\n    *,\n    sym_name: str,\n    signature: Signature,\n    body: Region\n)\n</code></pre> <p>               Bases: <code>Statement</code></p>"},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.Lambda.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>run mandatory validation checks. This is not same as typecheck, which may be optional.</p> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>def verify(self) -&gt; None:\n    if self.body.blocks.isempty():\n        raise VerificationError(self, \"lambda body must not be empty\")\n</code></pre>"},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.Return","title":"Return  <code>krin-statement</code>","text":"<pre><code>Return(value_or_stmt: SSAValue | Statement | None = None)\n</code></pre> <p>               Bases: <code>Statement</code></p> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>def __init__(self, value_or_stmt: SSAValue | Statement | None = None) -&gt; None:\n    if isinstance(value_or_stmt, SSAValue):\n        args = [value_or_stmt]\n    elif isinstance(value_or_stmt, Statement):\n        if len(value_or_stmt._results) == 1:\n            args = [value_or_stmt._results[0]]\n        else:\n            raise ValueError(\n                f\"expected a single result, got {len(value_or_stmt._results)} results from {value_or_stmt.name}\"\n            )\n    elif value_or_stmt is None:\n        args = []\n    else:\n        raise ValueError(f\"expected SSAValue or Statement, got {value_or_stmt}\")\n\n    super().__init__(args=args, args_slice={\"value\": 0})\n</code></pre>"},{"location":"reference/kirin/dialects/func/stmts/#kirin.dialects.func.stmts.Return.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>run mandatory validation checks. This is not same as typecheck, which may be optional.</p> Source code in <code>src/kirin/dialects/func/stmts.py</code> <pre><code>def verify(self) -&gt; None:\n    if not self.args:\n        raise VerificationError(\n            self, \"return statement must have at least one value\"\n        )\n\n    if len(self.args) &gt; 1:\n        raise VerificationError(\n            self,\n            \"return statement must have at most one value\"\n            \", wrap multiple values in a tuple\",\n        )\n</code></pre>"},{"location":"reference/kirin/dialects/func/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/dialects/ilist/","title":"Index","text":"<p>Immutable list dialect for Python.</p> <p>This dialect provides a simple, immutable list dialect similar to Python's built-in list type.</p>"},{"location":"reference/kirin/dialects/ilist/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/ilist/lowering/","title":"Lowering","text":""},{"location":"reference/kirin/dialects/ilist/passes/","title":"Passes","text":""},{"location":"reference/kirin/dialects/ilist/passes/#kirin.dialects.ilist.passes.IListDesugar","title":"IListDesugar  <code>dataclass</code>","text":"<pre><code>IListDesugar(dialects: DialectGroup)\n</code></pre> <p>               Bases: <code>Pass</code></p> <p>This pass desugars the Python list dialect to the immutable list dialect by rewriting all constant <code>list</code> type into <code>IList</code> type.</p>"},{"location":"reference/kirin/dialects/ilist/runtime/","title":"Runtime","text":""},{"location":"reference/kirin/dialects/ilist/runtime/#kirin.dialects.ilist.runtime.IList","title":"IList  <code>dataclass</code>","text":"<pre><code>IList(data: Sequence[T])\n</code></pre> <p>               Bases: <code>Generic[T, L]</code></p> <p>A simple immutable list.</p>"},{"location":"reference/kirin/dialects/ilist/stmts/","title":"Stmts","text":""},{"location":"reference/kirin/dialects/ilist/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/dialects/ilist/rewrite/","title":"Index","text":""},{"location":"reference/kirin/dialects/ilist/rewrite/const/","title":"Const","text":""},{"location":"reference/kirin/dialects/ilist/rewrite/const/#kirin.dialects.ilist.rewrite.const.RewriteHinted","title":"RewriteHinted  <code>dataclass</code>","text":"<pre><code>RewriteHinted()\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <p>Rewrite type annotation for SSAValue with constant <code>IList</code> in <code>Hinted</code> type. This should be run after constant folding and <code>WrapConst</code> rule.</p>"},{"location":"reference/kirin/dialects/ilist/rewrite/list/","title":"List","text":""},{"location":"reference/kirin/dialects/ilist/rewrite/unroll/","title":"Unroll","text":""},{"location":"reference/kirin/dialects/lowering/","title":"Index","text":"<p>This module contains the dialects for choosing different lowering strategies.</p> <p>The dialects defined inside this module do not provide any new statements, it only provide different lowering strategies for existing statements.</p>"},{"location":"reference/kirin/dialects/lowering/call/","title":"Call","text":""},{"location":"reference/kirin/dialects/lowering/cf/","title":"Cf","text":"<p>Lowering Python AST to cf dialect.</p>"},{"location":"reference/kirin/dialects/lowering/cf/#kirin.dialects.lowering.cf.CfLowering","title":"CfLowering","text":"<p>               Bases: <code>FromPythonAST</code></p>"},{"location":"reference/kirin/dialects/lowering/cf/#kirin.dialects.lowering.cf.CfLowering.branch_next_if_not_terminated","title":"branch_next_if_not_terminated","text":"<pre><code>branch_next_if_not_terminated(frame: Frame)\n</code></pre> <p>Branch to the next block if the current block is not terminated.</p> <p>This must be used after exhausting the current frame and before popping the frame.</p> Source code in <code>src/kirin/dialects/lowering/cf.py</code> <pre><code>def branch_next_if_not_terminated(self, frame: Frame):\n    \"\"\"Branch to the next block if the current block is not terminated.\n\n    This must be used after exhausting the current frame and before popping the frame.\n    \"\"\"\n    if not frame.curr_block.last_stmt or not frame.curr_block.last_stmt.has_trait(\n        ir.IsTerminator\n    ):\n        frame.curr_block.stmts.append(\n            cf.Branch(arguments=(), successor=frame.next_block)\n        )\n</code></pre>"},{"location":"reference/kirin/dialects/lowering/func/","title":"Func","text":""},{"location":"reference/kirin/dialects/math/","title":"Index","text":"<p>math dialect, modeling functions in python's <code>math</code> stdlib</p>"},{"location":"reference/kirin/dialects/math/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/dialects/math/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/math/stmts/","title":"Stmts","text":""},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.acos","title":"acos  <code>krin-statement</code>","text":"<pre><code>acos(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>acos statement, wrapping the math.acos function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.asin","title":"asin  <code>krin-statement</code>","text":"<pre><code>asin(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>asin statement, wrapping the math.asin function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.asinh","title":"asinh  <code>krin-statement</code>","text":"<pre><code>asinh(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>asinh statement, wrapping the math.asinh function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.atan","title":"atan  <code>krin-statement</code>","text":"<pre><code>atan(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>atan statement, wrapping the math.atan function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.atan2","title":"atan2  <code>krin-statement</code>","text":"<pre><code>atan2(y: ir.SSAValue, x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>atan2 statement, wrapping the math.atan2 function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.atanh","title":"atanh  <code>krin-statement</code>","text":"<pre><code>atanh(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>atanh statement, wrapping the math.atanh function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.ceil","title":"ceil  <code>krin-statement</code>","text":"<pre><code>ceil(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>ceil statement, wrapping the math.ceil function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.copysign","title":"copysign  <code>krin-statement</code>","text":"<pre><code>copysign(x: ir.SSAValue, y: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>copysign statement, wrapping the math.copysign function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.cos","title":"cos  <code>krin-statement</code>","text":"<pre><code>cos(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>cos statement, wrapping the math.cos function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.cosh","title":"cosh  <code>krin-statement</code>","text":"<pre><code>cosh(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>cosh statement, wrapping the math.cosh function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.degrees","title":"degrees  <code>krin-statement</code>","text":"<pre><code>degrees(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>degrees statement, wrapping the math.degrees function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.erf","title":"erf  <code>krin-statement</code>","text":"<pre><code>erf(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>erf statement, wrapping the math.erf function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.erfc","title":"erfc  <code>krin-statement</code>","text":"<pre><code>erfc(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>erfc statement, wrapping the math.erfc function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.exp","title":"exp  <code>krin-statement</code>","text":"<pre><code>exp(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>exp statement, wrapping the math.exp function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.expm1","title":"expm1  <code>krin-statement</code>","text":"<pre><code>expm1(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>expm1 statement, wrapping the math.expm1 function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.fabs","title":"fabs  <code>krin-statement</code>","text":"<pre><code>fabs(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>fabs statement, wrapping the math.fabs function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.floor","title":"floor  <code>krin-statement</code>","text":"<pre><code>floor(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>floor statement, wrapping the math.floor function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.fmod","title":"fmod  <code>krin-statement</code>","text":"<pre><code>fmod(x: ir.SSAValue, y: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>fmod statement, wrapping the math.fmod function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.gamma","title":"gamma  <code>krin-statement</code>","text":"<pre><code>gamma(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>gamma statement, wrapping the math.gamma function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.isfinite","title":"isfinite  <code>krin-statement</code>","text":"<pre><code>isfinite(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>isfinite statement, wrapping the math.isfinite function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.isinf","title":"isinf  <code>krin-statement</code>","text":"<pre><code>isinf(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>isinf statement, wrapping the math.isinf function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.isnan","title":"isnan  <code>krin-statement</code>","text":"<pre><code>isnan(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>isnan statement, wrapping the math.isnan function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.lgamma","title":"lgamma  <code>krin-statement</code>","text":"<pre><code>lgamma(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>lgamma statement, wrapping the math.lgamma function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.log10","title":"log10  <code>krin-statement</code>","text":"<pre><code>log10(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>log10 statement, wrapping the math.log10 function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.log1p","title":"log1p  <code>krin-statement</code>","text":"<pre><code>log1p(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>log1p statement, wrapping the math.log1p function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.log2","title":"log2  <code>krin-statement</code>","text":"<pre><code>log2(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>log2 statement, wrapping the math.log2 function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.pow","title":"pow  <code>krin-statement</code>","text":"<pre><code>pow(x: ir.SSAValue, y: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>pow statement, wrapping the math.pow function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.radians","title":"radians  <code>krin-statement</code>","text":"<pre><code>radians(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>radians statement, wrapping the math.radians function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.remainder","title":"remainder  <code>krin-statement</code>","text":"<pre><code>remainder(x: ir.SSAValue, y: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>remainder statement, wrapping the math.remainder function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.sin","title":"sin  <code>krin-statement</code>","text":"<pre><code>sin(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>sin statement, wrapping the math.sin function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.sinh","title":"sinh  <code>krin-statement</code>","text":"<pre><code>sinh(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>sinh statement, wrapping the math.sinh function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.sqrt","title":"sqrt  <code>krin-statement</code>","text":"<pre><code>sqrt(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>sqrt statement, wrapping the math.sqrt function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.tan","title":"tan  <code>krin-statement</code>","text":"<pre><code>tan(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>tan statement, wrapping the math.tan function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.tanh","title":"tanh  <code>krin-statement</code>","text":"<pre><code>tanh(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>tanh statement, wrapping the math.tanh function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.trunc","title":"trunc  <code>krin-statement</code>","text":"<pre><code>trunc(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>trunc statement, wrapping the math.trunc function</p>"},{"location":"reference/kirin/dialects/math/stmts/#kirin.dialects.math.stmts.ulp","title":"ulp  <code>krin-statement</code>","text":"<pre><code>ulp(x: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>ulp statement, wrapping the math.ulp function</p>"},{"location":"reference/kirin/dialects/py/","title":"Index","text":"<p>Python dialects module.</p> <p>This module contains a set of dialects that represent different fractions of the Python language. The dialects are designed to be used in a union to represent the entire Python language.</p>"},{"location":"reference/kirin/dialects/py/#kirin.dialects.py.statement","title":"statement","text":"<pre><code>statement(\n    cls=None, **kwargs: Unpack[StatementOptions]\n) -&gt; Callable[[type[StmtType]], type[StmtType]]\n</code></pre> <p>Declare a new statement class.</p> <p>This decorator is used to declare a new statement class. It is used to generate the necessary boilerplate code for the class. The class should inherit from <code>kirin.ir.Statement</code>.</p> <p>Parameters:</p> Name Type Description Default <code>init(bool)</code> <p>Whether to generate an <code>__init__</code> method.</p> required <code>repr(bool)</code> <p>Whether to generate a <code>__repr__</code> method.</p> required <code>kw_only(bool)</code> <p>Whether to use keyword-only arguments in the <code>__init__</code> method.</p> required <code>dialect(Optional[Dialect])</code> <p>The dialect of the statement.</p> required <code>property(bool)</code> <p>Whether to generate property methods for attributes.</p> required Example <p>The following is an example of how to use the <code>statement</code> decorator.</p> <pre><code>@statement\nclass MyStatement(ir.Statement):\n    name = \"some_name\"\n    traits = frozenset({TraitA(), TraitB()})\n    some_input: ir.SSAValue = info.argument()\n    some_output: ir.ResultValue = info.result()\n    body: ir.Region = info.region()\n    successor: ir.Block = info.block()\n</code></pre> <p>If the <code>name</code> field is not specified, a lowercase name field will be auto generated.</p> <p>In addition, one can optionally register the statement to a dialect by providing the <code>dialect</code> argument to the decorator.</p> <p>The following example register the statement to a dialect <code>my_dialect_object</code>, and <code>name = \"myfoo\"</code> field is autogenerated</p> <pre><code>@statement(dialect=my_dialect_object)\nclass MyFoo(ir.Statement):\n    traits = frozenset({ir.FromPythonCall()})\n    value: str = info.attribute()\n</code></pre> Source code in <code>src/kirin/decl/__init__.py</code> <pre><code>@dataclass_transform(\n    field_specifiers=(\n        info.attribute,\n        info.argument,\n        info.region,\n        info.result,\n        info.block,\n    )\n)\ndef statement(\n    cls=None,\n    **kwargs: Unpack[StatementOptions],\n) -&gt; Callable[[type[StmtType]], type[StmtType]]:\n    \"\"\"Declare a new statement class.\n\n    This decorator is used to declare a new statement class. It is used to\n    generate the necessary boilerplate code for the class. The class should\n    inherit from `kirin.ir.Statement`.\n\n    Args:\n        init(bool): Whether to generate an `__init__` method.\n        repr(bool): Whether to generate a `__repr__` method.\n        kw_only(bool): Whether to use keyword-only arguments in the `__init__`\n            method.\n        dialect(Optional[Dialect]): The dialect of the statement.\n        property(bool): Whether to generate property methods for attributes.\n\n    Example:\n        The following is an example of how to use the `statement` decorator.\n\n        ```python\n        @statement\n        class MyStatement(ir.Statement):\n            name = \"some_name\"\n            traits = frozenset({TraitA(), TraitB()})\n            some_input: ir.SSAValue = info.argument()\n            some_output: ir.ResultValue = info.result()\n            body: ir.Region = info.region()\n            successor: ir.Block = info.block()\n        ```\n\n        If the `name` field is not specified, a lowercase name field will be auto generated.\n\n        In addition, one can optionally register the statement to a dialect\n        by providing the `dialect` argument to the decorator.\n\n        The following example register the statement to a dialect `my_dialect_object`, and `name = \"myfoo\"` field is autogenerated\n\n        ```python\n        @statement(dialect=my_dialect_object)\n        class MyFoo(ir.Statement):\n            traits = frozenset({ir.FromPythonCall()})\n            value: str = info.attribute()\n        ```\n    \"\"\"\n\n    def wrap(cls):\n        decl = StatementDecl(cls, **kwargs)\n        decl.scan_fields()\n        decl.verify()\n        decl.emit()\n        decl.register()\n        return cls\n\n    if cls is None:\n        return wrap\n    return wrap(cls)\n</code></pre>"},{"location":"reference/kirin/dialects/py/assertion/","title":"Assertion","text":"<p>Assertion dialect for Python.</p> <p>This module contains the dialect for the Python <code>assert</code> statement, including:</p> <ul> <li>The <code>Assert</code> statement class.</li> <li>The lowering pass for the <code>assert</code> statement.</li> <li>The concrete implementation of the <code>assert</code> statement.</li> <li>The type inference implementation of the <code>assert</code> statement.</li> <li>The Julia emitter for the <code>assert</code> statement.</li> </ul> <p>This dialect maps <code>ast.Assert</code> nodes to the <code>Assert</code> statement.</p>"},{"location":"reference/kirin/dialects/py/assign/","title":"Assign","text":"<p>Assignment dialect for Python.</p> <p>This module contains the dialect for the Python assignment statement, including:</p> <ul> <li>Statements: <code>Alias</code>, <code>SetItem</code>.</li> <li>The lowering pass for the assignments.</li> <li>The concrete implementation of the assignment statements.</li> </ul> <p>This dialects maps Python assignment syntax.</p>"},{"location":"reference/kirin/dialects/py/attr/","title":"Attr","text":"<p>Attribute access dialect for Python.</p> <p>This module contains the dialect for the Python attribute access statement, including:</p> <ul> <li>The <code>GetAttr</code> statement class.</li> <li>The lowering pass for the attribute access statement.</li> <li>The concrete implementation of the attribute access statement.</li> </ul> <p>This dialect maps <code>ast.Attribute</code> nodes to the <code>GetAttr</code> statement.</p>"},{"location":"reference/kirin/dialects/py/base/","title":"Base","text":"<p>Base dialect for Python.</p> <p>This dialect does not contain statements. It only contains lowering rules for <code>ast.Name</code> and <code>ast.Expr</code>.</p>"},{"location":"reference/kirin/dialects/py/boolop/","title":"Boolop","text":"<p>Boolean operators for Python dialect.</p> <p>This module contains the dialect for the Python boolean operators, including:</p> <ul> <li>The <code>And</code> and <code>Or</code> statement classes.</li> <li>The lowering pass for the boolean operators.</li> <li>The concrete implementation of the boolean operators.</li> <li>The Julia emitter for the boolean operators.</li> </ul> <p>This dialect maps <code>ast.BoolOp</code> nodes to the <code>And</code> and <code>Or</code> statements.</p>"},{"location":"reference/kirin/dialects/py/builtin/","title":"Builtin","text":"<p>builtin dialect for python builtins</p> <p>This dialect provides implementations for builtin functions like abs and sum.</p> <ul> <li>Statements: <code>Abs</code>, <code>Sum</code>.</li> <li>The lowering pass for the builtin functions.</li> <li>The concrete implementation of the builtin functions.</li> <li>The type inference implementation of the builtin functions.</li> </ul> <p>This dialect maps <code>ast.Call</code> nodes of builtin functions to the <code>Abs</code> and <code>Sum</code> statements.</p>"},{"location":"reference/kirin/dialects/py/constant/","title":"Constant","text":"<p>Constant statement for Python dialect.</p> <p>This module contains the dialect for the Python <code>constant</code> statement, including:</p> <ul> <li>The <code>Constant</code> statement class.</li> <li>The lowering pass for the <code>constant</code> statement.</li> <li>The concrete implementation of the <code>constant</code> statement.</li> <li>The Julia emitter for the <code>constant</code> statement.</li> </ul> <p>This dialect maps <code>ast.Constant</code> nodes to the <code>Constant</code> statement.</p>"},{"location":"reference/kirin/dialects/py/constant/#kirin.dialects.py.constant.Constant","title":"Constant  <code>krin-statement</code>","text":"<pre><code>Constant(value: T | ir.PyAttr[T])\n</code></pre> <p>               Bases: <code>Statement</code>, <code>Generic[T]</code></p> Source code in <code>src/kirin/dialects/py/constant.py</code> <pre><code>def __init__(self, value: T | ir.PyAttr[T]) -&gt; None:\n    if not isinstance(value, ir.PyAttr):\n        value = ir.PyAttr(value)\n    super().__init__(\n        properties={\"value\": value},\n        result_types=(value.type,),\n    )\n</code></pre>"},{"location":"reference/kirin/dialects/py/constant/#kirin.dialects.py.constant.Constant.typecheck","title":"typecheck","text":"<pre><code>typecheck() -&gt; None\n</code></pre> <p>check the type of the statement.</p> Note <ol> <li>Statement should implement typecheck. this is done automatically via @statement, but in the case manualy implementation is needed, it should be implemented here.</li> <li>This API should be called after all the types are figured out (by typeinfer)</li> </ol> Source code in <code>src/kirin/dialects/py/constant.py</code> <pre><code>def typecheck(self) -&gt; None:\n    if not isinstance(self.result.type, ir.types.TypeAttribute):\n        raise exceptions.VerificationError(\n            self, f\"Expected result type to be PyType, got {self.result.type}\"\n        )\n</code></pre>"},{"location":"reference/kirin/dialects/py/indexing/","title":"Indexing","text":"<p>The indexing dialect for Python.</p> <p>This module contains the dialect for the Python indexing syntax, including:</p> <ul> <li>The <code>GetItem</code> statement class.</li> <li>A base class <code>Subscript</code> for indexing statements.</li> <li>A trait <code>GetItemLike</code> for indexing statements.</li> <li>The lowering pass for the indexing statement.</li> <li>The concrete implementation of the indexing statement.</li> <li>The constant propagation implementation (special case) of the indexing statement.</li> <li>The type inference implementation of the indexing statement.</li> <li>A canonical rewrite rule for the rewriting of a given getitem-like     statement to another getitem-like statement.</li> </ul>"},{"location":"reference/kirin/dialects/py/iterable/","title":"Iterable","text":"<p>This module provides access to Python iterables.</p> <p>This is used to lower Python loops into <code>cf</code> dialect.</p> <p>This module contains the common methods for the Python iterable:</p> <ul> <li>The <code>Iter</code> statement class.</li> <li>The <code>Next</code> statement class.</li> <li>The lowering pass for the iterable.</li> <li>The concrete implementation of the iterable.</li> </ul> <p>This dialect maps <code>iter()</code> and <code>next()</code> calls to the <code>Iter</code> and <code>Next</code> statements.</p>"},{"location":"reference/kirin/dialects/py/iterable/#kirin.dialects.py.iterable.Iter","title":"Iter  <code>krin-statement</code>","text":"<pre><code>Iter(value: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>This is equivalent to <code>iter(value)</code> in Python.</p>"},{"location":"reference/kirin/dialects/py/iterable/#kirin.dialects.py.iterable.Next","title":"Next  <code>krin-statement</code>","text":"<pre><code>Next(iter: ir.SSAValue)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>This is equivalent to <code>next(iterable, None)</code> in Python.</p>"},{"location":"reference/kirin/dialects/py/len/","title":"Len","text":"<p>The <code>Len</code> dialect.</p> <p>This dialect maps the <code>len()</code> call to the <code>Len</code> statement:</p> <ul> <li>The <code>Len</code> statement class.</li> <li>The lowering pass for the <code>len()</code> call.</li> <li>The concrete implementation of the <code>len()</code> call.</li> </ul>"},{"location":"reference/kirin/dialects/py/range/","title":"Range","text":"<p>The range dialect for Python.</p> <p>This dialect models the builtin <code>range()</code> function in Python.</p> <p>The dialect includes: - The <code>Range</code> statement class. - The lowering pass for the <code>range()</code> function.</p> <p>This dialect does not include a concrete implementation or type inference for the <code>range()</code> function. One needs to use other dialect for the concrete implementation and type inference, e.g., <code>ilist</code> dialect.</p>"},{"location":"reference/kirin/dialects/py/slice/","title":"Slice","text":"<p>The slice dialect for Python.</p> <p>This dialect provides a <code>Slice</code> statement that represents a slice object in Python:</p> <ul> <li>The <code>Slice</code> statement class.</li> <li>The lowering pass for the <code>slice</code> call.</li> <li>The concrete implementation of the <code>slice</code> call.</li> <li>The type inference implementation of the <code>slice</code> call.</li> </ul>"},{"location":"reference/kirin/dialects/py/tuple/","title":"Tuple","text":"<p>The tuple dialect for Python.</p> <p>This dialect provides a way to work with Python tuples in the IR, including:</p> <ul> <li>The <code>New</code> statement class.</li> <li>The lowering pass for the tuple statement.</li> <li>The concrete implementation of the tuple statement.</li> <li>The type inference implementation of the tuple addition with <code>py.binop.Add</code>.</li> <li>The constant propagation implementation of the tuple statement.</li> <li>The Julia emitter for the tuple statement.</li> </ul> <p>This dialect maps <code>ast.Tuple</code> nodes to the <code>New</code> statement.</p>"},{"location":"reference/kirin/dialects/py/unpack/","title":"Unpack","text":"<p>The unpack dialect for Python.</p> <p>This module contains the dialect for the Python unpack semantics, including:</p> <ul> <li>The <code>Unpack</code> statement class.</li> <li>The lowering pass for the unpack statement.</li> <li>The concrete implementation of the unpack statement.</li> <li>The type inference implementation of the unpack statement.</li> <li>A helper function <code>unpacking</code> for unpacking Python AST nodes during lowering.</li> </ul>"},{"location":"reference/kirin/dialects/py/binop/","title":"Index","text":"<p>The binop dialect for Python.</p> <p>This module contains the dialect for binary operation semantics in Python, including:</p> <ul> <li>The <code>Add</code>, <code>Sub</code>, <code>Mult</code>, <code>Div</code>, <code>FloorDiv</code>, <code>Mod</code>, <code>Pow</code>,     <code>LShift</code>, <code>RShift</code>, <code>BitOr</code>, <code>BitXor</code>, and <code>BitAnd</code> statement classes.</li> <li>The lowering pass for binary operations.</li> <li>The concrete implementation of binary operations.</li> <li>The type inference implementation of binary operations.</li> <li>The Julia emitter for binary operations.</li> </ul> <p>This dialect maps <code>ast.BinOp</code> nodes to the <code>Add</code>, <code>Sub</code>, <code>Mult</code>, <code>Div</code>, <code>FloorDiv</code>, <code>Mod</code>, <code>Pow</code>, <code>LShift</code>, <code>RShift</code>, <code>BitOr</code>, <code>BitXor</code>, and <code>BitAnd</code> statements.</p>"},{"location":"reference/kirin/dialects/py/binop/#kirin.dialects.py.binop.statement","title":"statement","text":"<pre><code>statement(\n    cls=None, **kwargs: Unpack[StatementOptions]\n) -&gt; Callable[[type[StmtType]], type[StmtType]]\n</code></pre> <p>Declare a new statement class.</p> <p>This decorator is used to declare a new statement class. It is used to generate the necessary boilerplate code for the class. The class should inherit from <code>kirin.ir.Statement</code>.</p> <p>Parameters:</p> Name Type Description Default <code>init(bool)</code> <p>Whether to generate an <code>__init__</code> method.</p> required <code>repr(bool)</code> <p>Whether to generate a <code>__repr__</code> method.</p> required <code>kw_only(bool)</code> <p>Whether to use keyword-only arguments in the <code>__init__</code> method.</p> required <code>dialect(Optional[Dialect])</code> <p>The dialect of the statement.</p> required <code>property(bool)</code> <p>Whether to generate property methods for attributes.</p> required Example <p>The following is an example of how to use the <code>statement</code> decorator.</p> <pre><code>@statement\nclass MyStatement(ir.Statement):\n    name = \"some_name\"\n    traits = frozenset({TraitA(), TraitB()})\n    some_input: ir.SSAValue = info.argument()\n    some_output: ir.ResultValue = info.result()\n    body: ir.Region = info.region()\n    successor: ir.Block = info.block()\n</code></pre> <p>If the <code>name</code> field is not specified, a lowercase name field will be auto generated.</p> <p>In addition, one can optionally register the statement to a dialect by providing the <code>dialect</code> argument to the decorator.</p> <p>The following example register the statement to a dialect <code>my_dialect_object</code>, and <code>name = \"myfoo\"</code> field is autogenerated</p> <pre><code>@statement(dialect=my_dialect_object)\nclass MyFoo(ir.Statement):\n    traits = frozenset({ir.FromPythonCall()})\n    value: str = info.attribute()\n</code></pre> Source code in <code>src/kirin/decl/__init__.py</code> <pre><code>@dataclass_transform(\n    field_specifiers=(\n        info.attribute,\n        info.argument,\n        info.region,\n        info.result,\n        info.block,\n    )\n)\ndef statement(\n    cls=None,\n    **kwargs: Unpack[StatementOptions],\n) -&gt; Callable[[type[StmtType]], type[StmtType]]:\n    \"\"\"Declare a new statement class.\n\n    This decorator is used to declare a new statement class. It is used to\n    generate the necessary boilerplate code for the class. The class should\n    inherit from `kirin.ir.Statement`.\n\n    Args:\n        init(bool): Whether to generate an `__init__` method.\n        repr(bool): Whether to generate a `__repr__` method.\n        kw_only(bool): Whether to use keyword-only arguments in the `__init__`\n            method.\n        dialect(Optional[Dialect]): The dialect of the statement.\n        property(bool): Whether to generate property methods for attributes.\n\n    Example:\n        The following is an example of how to use the `statement` decorator.\n\n        ```python\n        @statement\n        class MyStatement(ir.Statement):\n            name = \"some_name\"\n            traits = frozenset({TraitA(), TraitB()})\n            some_input: ir.SSAValue = info.argument()\n            some_output: ir.ResultValue = info.result()\n            body: ir.Region = info.region()\n            successor: ir.Block = info.block()\n        ```\n\n        If the `name` field is not specified, a lowercase name field will be auto generated.\n\n        In addition, one can optionally register the statement to a dialect\n        by providing the `dialect` argument to the decorator.\n\n        The following example register the statement to a dialect `my_dialect_object`, and `name = \"myfoo\"` field is autogenerated\n\n        ```python\n        @statement(dialect=my_dialect_object)\n        class MyFoo(ir.Statement):\n            traits = frozenset({ir.FromPythonCall()})\n            value: str = info.attribute()\n        ```\n    \"\"\"\n\n    def wrap(cls):\n        decl = StatementDecl(cls, **kwargs)\n        decl.scan_fields()\n        decl.verify()\n        decl.emit()\n        decl.register()\n        return cls\n\n    if cls is None:\n        return wrap\n    return wrap(cls)\n</code></pre>"},{"location":"reference/kirin/dialects/py/binop/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/py/binop/julia/","title":"Julia","text":""},{"location":"reference/kirin/dialects/py/binop/lowering/","title":"Lowering","text":""},{"location":"reference/kirin/dialects/py/binop/stmts/","title":"Stmts","text":""},{"location":"reference/kirin/dialects/py/binop/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/dialects/py/cmp/","title":"Index","text":"<p>The cmp dialect for Python.</p> <p>This module contains the dialect for comparison semantics in Python, including:</p> <ul> <li>The <code>Eq</code>, <code>NotEq</code>, <code>Lt</code>, <code>LtE</code>, <code>Gt</code>, <code>GtE</code>, <code>Is</code>, and <code>IsNot</code> statement classes.</li> <li>The lowering pass for comparison operations.</li> <li>The concrete implementation of comparison operations.</li> <li>The Julia emitter for comparison operations.</li> </ul> <p>This dialect maps <code>ast.Compare</code> nodes to the <code>Eq</code>, <code>NotEq</code>, <code>Lt</code>, <code>LtE</code>, <code>Gt</code>, <code>GtE</code>, <code>Is</code>, and <code>IsNot</code> statements.</p>"},{"location":"reference/kirin/dialects/py/cmp/#kirin.dialects.py.cmp.statement","title":"statement","text":"<pre><code>statement(\n    cls=None, **kwargs: Unpack[StatementOptions]\n) -&gt; Callable[[type[StmtType]], type[StmtType]]\n</code></pre> <p>Declare a new statement class.</p> <p>This decorator is used to declare a new statement class. It is used to generate the necessary boilerplate code for the class. The class should inherit from <code>kirin.ir.Statement</code>.</p> <p>Parameters:</p> Name Type Description Default <code>init(bool)</code> <p>Whether to generate an <code>__init__</code> method.</p> required <code>repr(bool)</code> <p>Whether to generate a <code>__repr__</code> method.</p> required <code>kw_only(bool)</code> <p>Whether to use keyword-only arguments in the <code>__init__</code> method.</p> required <code>dialect(Optional[Dialect])</code> <p>The dialect of the statement.</p> required <code>property(bool)</code> <p>Whether to generate property methods for attributes.</p> required Example <p>The following is an example of how to use the <code>statement</code> decorator.</p> <pre><code>@statement\nclass MyStatement(ir.Statement):\n    name = \"some_name\"\n    traits = frozenset({TraitA(), TraitB()})\n    some_input: ir.SSAValue = info.argument()\n    some_output: ir.ResultValue = info.result()\n    body: ir.Region = info.region()\n    successor: ir.Block = info.block()\n</code></pre> <p>If the <code>name</code> field is not specified, a lowercase name field will be auto generated.</p> <p>In addition, one can optionally register the statement to a dialect by providing the <code>dialect</code> argument to the decorator.</p> <p>The following example register the statement to a dialect <code>my_dialect_object</code>, and <code>name = \"myfoo\"</code> field is autogenerated</p> <pre><code>@statement(dialect=my_dialect_object)\nclass MyFoo(ir.Statement):\n    traits = frozenset({ir.FromPythonCall()})\n    value: str = info.attribute()\n</code></pre> Source code in <code>src/kirin/decl/__init__.py</code> <pre><code>@dataclass_transform(\n    field_specifiers=(\n        info.attribute,\n        info.argument,\n        info.region,\n        info.result,\n        info.block,\n    )\n)\ndef statement(\n    cls=None,\n    **kwargs: Unpack[StatementOptions],\n) -&gt; Callable[[type[StmtType]], type[StmtType]]:\n    \"\"\"Declare a new statement class.\n\n    This decorator is used to declare a new statement class. It is used to\n    generate the necessary boilerplate code for the class. The class should\n    inherit from `kirin.ir.Statement`.\n\n    Args:\n        init(bool): Whether to generate an `__init__` method.\n        repr(bool): Whether to generate a `__repr__` method.\n        kw_only(bool): Whether to use keyword-only arguments in the `__init__`\n            method.\n        dialect(Optional[Dialect]): The dialect of the statement.\n        property(bool): Whether to generate property methods for attributes.\n\n    Example:\n        The following is an example of how to use the `statement` decorator.\n\n        ```python\n        @statement\n        class MyStatement(ir.Statement):\n            name = \"some_name\"\n            traits = frozenset({TraitA(), TraitB()})\n            some_input: ir.SSAValue = info.argument()\n            some_output: ir.ResultValue = info.result()\n            body: ir.Region = info.region()\n            successor: ir.Block = info.block()\n        ```\n\n        If the `name` field is not specified, a lowercase name field will be auto generated.\n\n        In addition, one can optionally register the statement to a dialect\n        by providing the `dialect` argument to the decorator.\n\n        The following example register the statement to a dialect `my_dialect_object`, and `name = \"myfoo\"` field is autogenerated\n\n        ```python\n        @statement(dialect=my_dialect_object)\n        class MyFoo(ir.Statement):\n            traits = frozenset({ir.FromPythonCall()})\n            value: str = info.attribute()\n        ```\n    \"\"\"\n\n    def wrap(cls):\n        decl = StatementDecl(cls, **kwargs)\n        decl.scan_fields()\n        decl.verify()\n        decl.emit()\n        decl.register()\n        return cls\n\n    if cls is None:\n        return wrap\n    return wrap(cls)\n</code></pre>"},{"location":"reference/kirin/dialects/py/cmp/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/py/cmp/julia/","title":"Julia","text":""},{"location":"reference/kirin/dialects/py/cmp/lowering/","title":"Lowering","text":""},{"location":"reference/kirin/dialects/py/cmp/stmts/","title":"Stmts","text":""},{"location":"reference/kirin/dialects/py/list/","title":"Index","text":"<p>The list dialect for Python.</p> <p>This module contains the dialect for list semantics in Python, including:</p> <ul> <li>The <code>New</code> and <code>Append</code> statement classes.</li> <li>The lowering pass for list operations.</li> <li>The concrete implementation of list operations.</li> <li>The type inference implementation of list operations.</li> </ul> <p>This dialect maps <code>list()</code>, <code>ast.List</code> and <code>append()</code> calls to the <code>New</code> and <code>Append</code> statements.</p>"},{"location":"reference/kirin/dialects/py/list/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/py/list/lowering/","title":"Lowering","text":""},{"location":"reference/kirin/dialects/py/list/stmts/","title":"Stmts","text":""},{"location":"reference/kirin/dialects/py/list/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/dialects/py/unary/","title":"Index","text":"<p>The unary dialect for Python.</p> <p>This module contains the dialect for unary semantics in Python, including:</p> <ul> <li>The <code>UnaryOp</code> base class for unary operations.</li> <li>The <code>UAdd</code>, <code>USub</code>, <code>Not</code>, and <code>Invert</code> statement classes.</li> <li>The lowering pass for unary operations.</li> <li>The concrete implementation of unary operations.</li> <li>The type inference implementation of unary operations.</li> <li>The constant propagation implementation of unary operations.</li> <li>The Julia emitter for unary operations.</li> </ul> <p>This dialect maps <code>ast.UnaryOp</code> nodes to the <code>UAdd</code>, <code>USub</code>, <code>Not</code>, and <code>Invert</code> statements.</p>"},{"location":"reference/kirin/dialects/py/unary/#kirin.dialects.py.unary.statement","title":"statement","text":"<pre><code>statement(\n    cls=None, **kwargs: Unpack[StatementOptions]\n) -&gt; Callable[[type[StmtType]], type[StmtType]]\n</code></pre> <p>Declare a new statement class.</p> <p>This decorator is used to declare a new statement class. It is used to generate the necessary boilerplate code for the class. The class should inherit from <code>kirin.ir.Statement</code>.</p> <p>Parameters:</p> Name Type Description Default <code>init(bool)</code> <p>Whether to generate an <code>__init__</code> method.</p> required <code>repr(bool)</code> <p>Whether to generate a <code>__repr__</code> method.</p> required <code>kw_only(bool)</code> <p>Whether to use keyword-only arguments in the <code>__init__</code> method.</p> required <code>dialect(Optional[Dialect])</code> <p>The dialect of the statement.</p> required <code>property(bool)</code> <p>Whether to generate property methods for attributes.</p> required Example <p>The following is an example of how to use the <code>statement</code> decorator.</p> <pre><code>@statement\nclass MyStatement(ir.Statement):\n    name = \"some_name\"\n    traits = frozenset({TraitA(), TraitB()})\n    some_input: ir.SSAValue = info.argument()\n    some_output: ir.ResultValue = info.result()\n    body: ir.Region = info.region()\n    successor: ir.Block = info.block()\n</code></pre> <p>If the <code>name</code> field is not specified, a lowercase name field will be auto generated.</p> <p>In addition, one can optionally register the statement to a dialect by providing the <code>dialect</code> argument to the decorator.</p> <p>The following example register the statement to a dialect <code>my_dialect_object</code>, and <code>name = \"myfoo\"</code> field is autogenerated</p> <pre><code>@statement(dialect=my_dialect_object)\nclass MyFoo(ir.Statement):\n    traits = frozenset({ir.FromPythonCall()})\n    value: str = info.attribute()\n</code></pre> Source code in <code>src/kirin/decl/__init__.py</code> <pre><code>@dataclass_transform(\n    field_specifiers=(\n        info.attribute,\n        info.argument,\n        info.region,\n        info.result,\n        info.block,\n    )\n)\ndef statement(\n    cls=None,\n    **kwargs: Unpack[StatementOptions],\n) -&gt; Callable[[type[StmtType]], type[StmtType]]:\n    \"\"\"Declare a new statement class.\n\n    This decorator is used to declare a new statement class. It is used to\n    generate the necessary boilerplate code for the class. The class should\n    inherit from `kirin.ir.Statement`.\n\n    Args:\n        init(bool): Whether to generate an `__init__` method.\n        repr(bool): Whether to generate a `__repr__` method.\n        kw_only(bool): Whether to use keyword-only arguments in the `__init__`\n            method.\n        dialect(Optional[Dialect]): The dialect of the statement.\n        property(bool): Whether to generate property methods for attributes.\n\n    Example:\n        The following is an example of how to use the `statement` decorator.\n\n        ```python\n        @statement\n        class MyStatement(ir.Statement):\n            name = \"some_name\"\n            traits = frozenset({TraitA(), TraitB()})\n            some_input: ir.SSAValue = info.argument()\n            some_output: ir.ResultValue = info.result()\n            body: ir.Region = info.region()\n            successor: ir.Block = info.block()\n        ```\n\n        If the `name` field is not specified, a lowercase name field will be auto generated.\n\n        In addition, one can optionally register the statement to a dialect\n        by providing the `dialect` argument to the decorator.\n\n        The following example register the statement to a dialect `my_dialect_object`, and `name = \"myfoo\"` field is autogenerated\n\n        ```python\n        @statement(dialect=my_dialect_object)\n        class MyFoo(ir.Statement):\n            traits = frozenset({ir.FromPythonCall()})\n            value: str = info.attribute()\n        ```\n    \"\"\"\n\n    def wrap(cls):\n        decl = StatementDecl(cls, **kwargs)\n        decl.scan_fields()\n        decl.verify()\n        decl.emit()\n        decl.register()\n        return cls\n\n    if cls is None:\n        return wrap\n    return wrap(cls)\n</code></pre>"},{"location":"reference/kirin/dialects/py/unary/constprop/","title":"Constprop","text":""},{"location":"reference/kirin/dialects/py/unary/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/py/unary/julia/","title":"Julia","text":""},{"location":"reference/kirin/dialects/py/unary/lowering/","title":"Lowering","text":""},{"location":"reference/kirin/dialects/py/unary/stmts/","title":"Stmts","text":""},{"location":"reference/kirin/dialects/py/unary/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/dialects/scf/","title":"Index","text":"<p>A Python-like structural Control Flow dialect.</p> <p>This dialect provides constructs for expressing control flow in a structured manner. The dialect provides constructs for expressing loops and conditionals. Unlike MLIR SCF dialect, this dialect does not restrict the control flow to statically analyzable forms. This dialect is designed to be compatible with Python native control flow constructs.</p> <p>This dialect depends on the following dialects: - <code>eltype</code>: for obtaining the element type of a value.</p>"},{"location":"reference/kirin/dialects/scf/constprop/","title":"Constprop","text":""},{"location":"reference/kirin/dialects/scf/interp/","title":"Interp","text":""},{"location":"reference/kirin/dialects/scf/lowering/","title":"Lowering","text":""},{"location":"reference/kirin/dialects/scf/stmts/","title":"Stmts","text":""},{"location":"reference/kirin/dialects/scf/stmts/#kirin.dialects.scf.stmts.For","title":"For  <code>krin-statement</code>","text":"<pre><code>For(\n    iterable: ir.SSAValue,\n    body: ir.Region,\n    *initializers: ir.SSAValue\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> Source code in <code>src/kirin/dialects/scf/stmts.py</code> <pre><code>def __init__(\n    self,\n    iterable: ir.SSAValue,\n    body: ir.Region,\n    *initializers: ir.SSAValue,\n):\n    stmt = body.blocks[0].last_stmt\n    if stmt is None or not isinstance(stmt, Yield):\n        raise DialectLoweringError(\"for loop body must terminate with a yield\")\n\n    if len(body.blocks) != 1:\n        raise DialectLoweringError(\"for loop body must have a single block\")\n\n    if len(body.blocks[0].args) != len(initializers) + 1:\n        raise DialectLoweringError(\n            \"for loop body must have arguments for all initializers and the loop variable\"\n        )\n\n    super().__init__(\n        args=(iterable, *initializers),\n        regions=(body,),\n        result_types=tuple(value.type for value in stmt.values),\n        args_slice={\"iterable\": 0, \"initializers\": slice(1, None)},\n    )\n</code></pre>"},{"location":"reference/kirin/dialects/scf/stmts/#kirin.dialects.scf.stmts.For.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>run mandatory validation checks. This is not same as typecheck, which may be optional.</p> Source code in <code>src/kirin/dialects/scf/stmts.py</code> <pre><code>def verify(self) -&gt; None:\n    stmt = self.body.blocks[0].last_stmt\n    if stmt is None or not isinstance(stmt, Yield):\n        raise VerificationError(self, \"for loop body must terminate with a yield\")\n    if len(stmt.values) != len(self.initializers):\n        raise VerificationError(\n            self,\n            \"for loop body must have the same number of results as initializers\",\n        )\n    if len(self.results) != len(stmt.values):\n        raise VerificationError(\n            self,\n            \"for loop must have the same number of results as the yield in the body\",\n        )\n</code></pre>"},{"location":"reference/kirin/dialects/scf/stmts/#kirin.dialects.scf.stmts.IfElse","title":"IfElse  <code>krin-statement</code>","text":"<pre><code>IfElse(\n    cond: ir.SSAValue,\n    then_body: ir.Region | ir.Block,\n    else_body: ir.Region | ir.Block | None = None,\n)\n</code></pre> <p>               Bases: <code>Statement</code></p> <p>Python-like if-else statement.</p> <p>This statement has a condition, then body, and else body.</p> <p>Then body either terminates with a yield statement or <code>scf.return</code>.</p> Source code in <code>src/kirin/dialects/scf/stmts.py</code> <pre><code>def __init__(\n    self,\n    cond: ir.SSAValue,\n    then_body: ir.Region | ir.Block,\n    else_body: ir.Region | ir.Block | None = None,\n):\n    if isinstance(then_body, ir.Region):\n        if len(then_body.blocks) != 1:\n            raise DialectLoweringError(\n                \"if-else statement must have a single block in the then region\"\n            )\n        then_body_region = then_body\n        then_body = then_body_region.blocks[0]\n    elif isinstance(then_body, ir.Block):\n        then_body_region = ir.Region(then_body)\n\n    if isinstance(else_body, ir.Region):\n        if not else_body.blocks:  # empty region\n            else_body_region = else_body\n            else_body = None\n        elif len(else_body.blocks) != 1:\n            raise DialectLoweringError(\n                \"if-else statement must have a single block in the else region\"\n            )\n        else:\n            else_body_region = else_body\n            else_body = else_body_region.blocks[0]\n    elif isinstance(else_body, ir.Block):\n        else_body_region = ir.Region(else_body)\n    else:\n        else_body_region = ir.Region()\n\n    # if either then or else body has yield, we generate results\n    # we assume if both have yields, they have the same number of results\n    then_yield = then_body.last_stmt\n    else_yield = else_body.last_stmt if else_body is not None else None\n    if then_yield is not None and isinstance(then_yield, Yield):\n        results = then_yield.values\n    elif else_yield is not None and isinstance(else_yield, Yield):\n        results = else_yield.values\n    else:\n        results = ()\n\n    result_types = tuple(value.type for value in results)\n    super().__init__(\n        args=(cond,),\n        regions=(then_body_region, else_body_region),\n        result_types=result_types,\n        args_slice={\"cond\": 0},\n    )\n</code></pre>"},{"location":"reference/kirin/dialects/scf/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/emit/","title":"Index","text":""},{"location":"reference/kirin/emit/abc/","title":"Abc","text":""},{"location":"reference/kirin/emit/abc/#kirin.emit.abc.EmitABC","title":"EmitABC  <code>dataclass</code>","text":"<pre><code>EmitABC(\n    dialects: DialectGroup,\n    *,\n    fuel: int | None = None,\n    debug: bool = False,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192\n)\n</code></pre> <p>               Bases: <code>BaseInterpreter[FrameType, ValueType]</code>, <code>ABC</code></p>"},{"location":"reference/kirin/emit/abc/#kirin.emit.abc.EmitABC.run_callable_region","title":"run_callable_region","text":"<pre><code>run_callable_region(\n    frame: FrameType, code: ir.Statement, region: ir.Region\n) -&gt; ValueType\n</code></pre> <p>A hook defines how to run the callable region given the interpreter context. Frame should be pushed before calling this method and popped after calling this method.</p> <p>A callable region is a region that can be called as a function. Unlike a general region (or the MLIR convention), it always return a value to be compatible with the Python convention.</p> Source code in <code>src/kirin/emit/abc.py</code> <pre><code>def run_callable_region(\n    self, frame: FrameType, code: ir.Statement, region: ir.Region\n) -&gt; ValueType:\n    results = self.eval_stmt(frame, code)\n    if isinstance(results, tuple):\n        if len(results) == 0:\n            return self.void\n        elif len(results) == 1:\n            return results[0]\n    raise interp.InterpreterError(f\"Unexpected results {results}\")\n</code></pre>"},{"location":"reference/kirin/emit/abc/#kirin.emit.abc.EmitABC.run_ssacfg_region","title":"run_ssacfg_region","text":"<pre><code>run_ssacfg_region(\n    frame: FrameType, region: ir.Region\n) -&gt; tuple[ValueType, ...]\n</code></pre> <p>This implements how to run a region with MLIR SSA CFG convention.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>FrameType</code> <p>the current frame.</p> required <code>region</code> <code>Region</code> <p>the region to run.</p> required <p>Returns:</p> Type Description <code>tuple[ValueType, ...] | None | ReturnValue[ValueType]</code> <p>tuple[ValueType, ...] | SpecialValue[ValueType]: the result of running the region.</p> <p>when region returns <code>tuple[ValueType, ...]</code>, it means the region terminates normally with <code>YieldValue</code>. When region returns <code>ReturnValue</code>, it means the region terminates and needs to pop the frame. Region cannot return <code>Successor</code> because reference to external region is not allowed.</p> Source code in <code>src/kirin/emit/abc.py</code> <pre><code>def run_ssacfg_region(\n    self, frame: FrameType, region: ir.Region\n) -&gt; tuple[ValueType, ...]:\n    frame.worklist.append(\n        interp.Successor(region.blocks[0], frame.get_values(region.blocks[0].args))\n    )\n    while (succ := frame.worklist.pop()) is not None:\n        block_header = self.emit_block(frame, succ.block)\n        frame.block_ref[succ.block] = block_header\n    return ()\n</code></pre>"},{"location":"reference/kirin/emit/exceptions/","title":"Exceptions","text":""},{"location":"reference/kirin/emit/julia/","title":"Julia","text":""},{"location":"reference/kirin/emit/julia/#kirin.emit.julia.EmitJulia","title":"EmitJulia  <code>dataclass</code>","text":"<pre><code>EmitJulia(\n    dialects: DialectGroup,\n    file: IO_t,\n    *,\n    fuel: int | None = None,\n    debug: bool = False,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192,\n    prefix: str = \"\",\n    prefix_if_none: str = \"var_\"\n)\n</code></pre> <p>               Bases: <code>EmitStr[IO_t]</code></p>"},{"location":"reference/kirin/emit/julia/#kirin.emit.julia.EmitJulia.keys","title":"keys  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>keys = ['emit.julia']\n</code></pre> <p>The name of the interpreter to select from dialects by order.</p>"},{"location":"reference/kirin/emit/str/","title":"Str","text":""},{"location":"reference/kirin/emit/str/#kirin.emit.str.EmitStr","title":"EmitStr  <code>dataclass</code>","text":"<pre><code>EmitStr(\n    dialects: DialectGroup,\n    file: IO_t,\n    *,\n    fuel: int | None = None,\n    debug: bool = False,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192,\n    prefix: str = \"\",\n    prefix_if_none: str = \"var_\"\n)\n</code></pre> <p>               Bases: <code>EmitABC[EmitStrFrame, str]</code>, <code>ABC</code>, <code>Generic[IO_t]</code></p>"},{"location":"reference/kirin/emit/str/#kirin.emit.str.EmitStr.void","title":"void  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>void = ''\n</code></pre> <p>What to return when the interpreter evaluates nothing.</p>"},{"location":"reference/kirin/emit/str/#kirin.emit.str.EmitStr.initialize","title":"initialize","text":"<pre><code>initialize()\n</code></pre> <p>Initialize the interpreter global states. This method is called right upon calling <code>run</code> to initialize the interpreter global states.</p> <p>Default Implementation</p> <p>This method provides default behavior but may be overridden by subclasses to customize or extend functionality.</p> Source code in <code>src/kirin/emit/str.py</code> <pre><code>def initialize(self):\n    super().initialize()\n    self.ssa_id = idtable.IdTable[ir.SSAValue](\n        prefix=self.prefix, prefix_if_none=self.prefix_if_none\n    )\n    self.block_id = idtable.IdTable[ir.Block](prefix=self.prefix + \"block_\")\n</code></pre>"},{"location":"reference/kirin/emit/str/#kirin.emit.str.EmitStr.new_frame","title":"new_frame","text":"<pre><code>new_frame(code: ir.Statement) -&gt; EmitStrFrame\n</code></pre> <p>Create a new frame for the given method.</p> Source code in <code>src/kirin/emit/str.py</code> <pre><code>def new_frame(self, code: ir.Statement) -&gt; EmitStrFrame:\n    return EmitStrFrame.from_func_like(code)\n</code></pre>"},{"location":"reference/kirin/emit/str/#kirin.emit.str.EmitStr.run_method","title":"run_method","text":"<pre><code>run_method(method: ir.Method, args: tuple[str, ...]) -&gt; str\n</code></pre> <p>How to run a method.</p> <p>This is defined by subclasses to describe what's the corresponding value of a method during the interpretation.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Method</code> <p>the method to run.</p> required <code>args</code> <code>tuple[ValueType]</code> <p>the arguments to the method, does not include self.</p> required <p>Returns:</p> Name Type Description <code>ValueType</code> <code>ValueType</code> <p>the result of the method.</p> Source code in <code>src/kirin/emit/str.py</code> <pre><code>def run_method(self, method: ir.Method, args: tuple[str, ...]) -&gt; str:\n    if len(self.state.frames) &gt;= self.max_depth:\n        raise interp.InterpreterError(\"maximum recursion depth exceeded\")\n    return self.run_callable(method.code, (method.sym_name,) + args)\n</code></pre>"},{"location":"reference/kirin/interp/","title":"Index","text":"<p>Interpreter module for Kirin.</p> <p>This module contains the interpreter framework for Kirin. The interpreter framework is used to implement concrete and abstract interpreters for the IR. The interpreter framework provides a set of classes and interfaces to implement interpreters for the IR.</p> <p>The interpreter framework is designed to be extensible and customizable. It provides a set of base classes and interfaces for implementing concrete and abstract interpreters:</p> <ul> <li><code>BaseInterpreter</code>: Base class for implementing concrete interpreters.</li> <li><code>AbstractInterpreter</code>: Base class for implementing abstract interpreters.</li> <li><code>Frame</code>: Base class for interpreter frame.</li> <li><code>MethodTable</code>: Method table for registering implementations of statements.</li> </ul>"},{"location":"reference/kirin/interp/abstract/","title":"Abstract","text":""},{"location":"reference/kirin/interp/abstract/#kirin.interp.abstract.AbstractFrame","title":"AbstractFrame  <code>dataclass</code>","text":"<pre><code>AbstractFrame(\n    code: Statement,\n    lino: int = 0,\n    stmt: Statement | None = None,\n    globals: dict[str, Any] = dict(),\n    entries: dict[SSAValue, ValueType] = dict(),\n    worklist: WorkList[Successor[ResultType]] = WorkList(),\n    visited: dict[\n        Block, set[Successor[ResultType]]\n    ] = dict(),\n)\n</code></pre> <p>               Bases: <code>Frame[ResultType]</code></p> <p>Interpreter frame for abstract interpreter.</p> <p>This frame is used to store the state of the abstract interpreter. It contains the worklist of successors to be processed.</p>"},{"location":"reference/kirin/interp/abstract/#kirin.interp.abstract.AbstractInterpreter","title":"AbstractInterpreter  <code>dataclass</code>","text":"<pre><code>AbstractInterpreter(\n    dialects: DialectGroup,\n    *,\n    fuel: int | None = None,\n    debug: bool = False,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192\n)\n</code></pre> <p>               Bases: <code>BaseInterpreter[AbstractFrameType, ResultType]</code>, <code>ABC</code></p> <p>Abstract interpreter for the IR.</p> <p>This is a base class for implementing abstract interpreters for the IR. It provides a framework for implementing abstract interpreters given a bounded lattice type.</p> <p>The abstract interpreter is a forward dataflow analysis that computes the abstract values for each SSA value in the IR. The abstract values are computed by evaluating the statements in the IR using the abstract lattice operations.</p> <p>The abstract interpreter is implemented as a worklist algorithm. The worklist contains the successors of the current block to be processed. The abstract interpreter processes each successor by evaluating the statements in the block and updating the abstract values in the frame.</p> <p>The abstract interpreter provides hooks for customizing the behavior of the interpreter. The <code>prehook_succ</code> and <code>posthook_succ</code> methods can be used to perform custom actions before and after processing a successor.</p>"},{"location":"reference/kirin/interp/abstract/#kirin.interp.abstract.AbstractInterpreter.lattice","title":"lattice  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lattice: type[BoundedLattice[ResultType]] = field(\n    init=False\n)\n</code></pre> <p>lattice type for the abstract interpreter.</p>"},{"location":"reference/kirin/interp/abstract/#kirin.interp.abstract.AbstractInterpreter.eval_recursion_limit","title":"eval_recursion_limit","text":"<pre><code>eval_recursion_limit(\n    frame: AbstractFrameType,\n) -&gt; ResultType\n</code></pre> <p>Return the value of recursion exception, e.g in concrete interpreter, it will raise an exception if the limit is reached; in type inference, it will return a special value.</p> Source code in <code>src/kirin/interp/abstract.py</code> <pre><code>def eval_recursion_limit(self, frame: AbstractFrameType) -&gt; ResultType:\n    return self.lattice.bottom()\n</code></pre>"},{"location":"reference/kirin/interp/abstract/#kirin.interp.abstract.AbstractInterpreter.posthook_succ","title":"posthook_succ","text":"<pre><code>posthook_succ(frame: AbstractFrameType, succ: Successor)\n</code></pre> <p>Hook called after processing a successor.</p> <p>This method can be used to perform custom actions after processing a successor. It is called after evaluating the statements in the block.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>AbstractFrameType</code> <p>The current frame of the interpreter.</p> required <code>succ</code> <code>Successor</code> <p>The successor that was processed.</p> required Source code in <code>src/kirin/interp/abstract.py</code> <pre><code>def posthook_succ(self, frame: AbstractFrameType, succ: Successor):\n    \"\"\"Hook called after processing a successor.\n\n    This method can be used to perform custom actions after processing\n    a successor. It is called after evaluating the statements in the block.\n\n    Args:\n        frame: The current frame of the interpreter.\n        succ: The successor that was processed.\n    \"\"\"\n    return\n</code></pre>"},{"location":"reference/kirin/interp/abstract/#kirin.interp.abstract.AbstractInterpreter.prehook_succ","title":"prehook_succ","text":"<pre><code>prehook_succ(frame: AbstractFrameType, succ: Successor)\n</code></pre> <p>Hook called before processing a successor.</p> <p>This method can be used to perform custom actions before processing a successor. It is called before evaluating the statements in the block.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>AbstractFrameType</code> <p>The current frame of the interpreter.</p> required <code>succ</code> <code>Successor</code> <p>The successor to be processed.</p> required Source code in <code>src/kirin/interp/abstract.py</code> <pre><code>def prehook_succ(self, frame: AbstractFrameType, succ: Successor):\n    \"\"\"Hook called before processing a successor.\n\n    This method can be used to perform custom actions before processing\n    a successor. It is called before evaluating the statements in the block.\n\n    Args:\n        frame: The current frame of the interpreter.\n        succ: The successor to be processed.\n    \"\"\"\n    return\n</code></pre>"},{"location":"reference/kirin/interp/abstract/#kirin.interp.abstract.AbstractInterpreter.run_block","title":"run_block","text":"<pre><code>run_block(\n    frame: AbstractFrameType, succ: Successor\n) -&gt; SpecialValue[ResultType]\n</code></pre> <p>Run a block within the current frame.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>FrameType</code> <p>the current frame.</p> required <code>block</code> <code>Block</code> <p>the block to run.</p> required <p>Returns:</p> Name Type Description <code>SpecialValue</code> <code>SpecialValue[ValueType]</code> <p>the result of running the block terminator.</p> Source code in <code>src/kirin/interp/abstract.py</code> <pre><code>def run_block(\n    self, frame: AbstractFrameType, succ: Successor\n) -&gt; SpecialValue[ResultType]:\n    self.set_values(frame, succ.block.args, succ.block_args)\n    for stmt in succ.block.stmts:\n        if self.should_exec_stmt(stmt) is False:\n            continue\n\n        frame.stmt = stmt\n        frame.lino = stmt.source.lineno if stmt.source else 0\n        stmt_results = self.eval_stmt(frame, stmt)\n        if isinstance(stmt_results, tuple):\n            self.set_values(frame, stmt._results, stmt_results)\n        else:  # terminate\n            return stmt_results\n    return None\n</code></pre>"},{"location":"reference/kirin/interp/abstract/#kirin.interp.abstract.AbstractInterpreter.run_ssacfg_region","title":"run_ssacfg_region","text":"<pre><code>run_ssacfg_region(\n    frame: AbstractFrameType, region: Region\n) -&gt; (\n    tuple[ResultType, ...] | None | ReturnValue[ResultType]\n)\n</code></pre> <p>This implements how to run a region with MLIR SSA CFG convention.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>FrameType</code> <p>the current frame.</p> required <code>region</code> <code>Region</code> <p>the region to run.</p> required <p>Returns:</p> Type Description <code>tuple[ValueType, ...] | None | ReturnValue[ValueType]</code> <p>tuple[ValueType, ...] | SpecialValue[ValueType]: the result of running the region.</p> <p>when region returns <code>tuple[ValueType, ...]</code>, it means the region terminates normally with <code>YieldValue</code>. When region returns <code>ReturnValue</code>, it means the region terminates and needs to pop the frame. Region cannot return <code>Successor</code> because reference to external region is not allowed.</p> Source code in <code>src/kirin/interp/abstract.py</code> <pre><code>def run_ssacfg_region(\n    self, frame: AbstractFrameType, region: Region\n) -&gt; tuple[ResultType, ...] | None | ReturnValue[ResultType]:\n    result = None\n    frame.worklist.append(\n        Successor(region.blocks[0], *frame.get_values(region.blocks[0].args))\n    )\n    while (succ := frame.worklist.pop()) is not None:\n        if succ.block in frame.visited:\n            if succ in frame.visited[succ.block]:\n                continue\n        else:\n            frame.visited[succ.block] = set()\n        self.prehook_succ(frame, succ)\n        block_result = self.run_block(frame, succ)\n        if len(frame.visited[succ.block]) &lt; 128:\n            frame.visited[succ.block].add(succ)\n        else:\n            continue\n\n        if isinstance(block_result, Successor):\n            raise InterpreterError(\n                \"unexpected successor, successors should be in worklist\"\n            )\n\n        result = self.join_results(result, block_result)\n        self.posthook_succ(frame, succ)\n\n    if isinstance(result, YieldValue):\n        return result.values\n    return result\n</code></pre>"},{"location":"reference/kirin/interp/abstract/#kirin.interp.abstract.AbstractInterpreter.set_values","title":"set_values","text":"<pre><code>set_values(\n    frame: AbstractFrameType,\n    ssa: Iterable[SSAValue],\n    results: Iterable[ResultType],\n)\n</code></pre> <p>Set the abstract values for the given SSA values in the frame.</p> <p>This method is used to customize how the abstract values are set in the frame. By default, the abstract values are set directly in the frame.</p> Source code in <code>src/kirin/interp/abstract.py</code> <pre><code>def set_values(\n    self,\n    frame: AbstractFrameType,\n    ssa: Iterable[SSAValue],\n    results: Iterable[ResultType],\n):\n    \"\"\"Set the abstract values for the given SSA values in the frame.\n\n    This method is used to customize how the abstract values are set in\n    the frame. By default, the abstract values are set directly in the\n    frame.\n    \"\"\"\n    frame.set_values(ssa, results)\n</code></pre>"},{"location":"reference/kirin/interp/abstract/#kirin.interp.abstract.AbstractInterpreter.should_exec_stmt","title":"should_exec_stmt","text":"<pre><code>should_exec_stmt(stmt: Statement) -&gt; bool\n</code></pre> <p>This method can be used to control which statements are executed during the abstract interpretation. By default, all statements are executed.</p> <p>This method is useful when one wants to skip certain statements during the abstract interpretation and is certain that the skipped statements do not affect the final result. This would allow saving computation time and memory by not evaluating the skipped statements and their results.</p> <p>Parameters:</p> Name Type Description Default <code>stmt</code> <code>Statement</code> <p>The statement to be executed.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the statement should be executed, False otherwise.</p> Source code in <code>src/kirin/interp/abstract.py</code> <pre><code>def should_exec_stmt(self, stmt: Statement) -&gt; bool:\n    \"\"\"This method can be used to control which statements are executed\n    during the abstract interpretation. By default, all statements are\n    executed.\n\n    This method is useful when one wants to skip certain statements\n    during the abstract interpretation and is certain that the skipped\n    statements do not affect the final result. This would allow saving\n    computation time and memory by not evaluating the skipped statements\n    and their results.\n\n    Args:\n        stmt: The statement to be executed.\n\n    Returns:\n        True if the statement should be executed, False otherwise.\n    \"\"\"\n    return True\n</code></pre>"},{"location":"reference/kirin/interp/base/","title":"Base","text":""},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter","title":"BaseInterpreter  <code>dataclass</code>","text":"<pre><code>BaseInterpreter(\n    dialects: DialectGroup,\n    *,\n    fuel: int | None = None,\n    debug: bool = False,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192\n)\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[FrameType, ValueType]</code></p> <p>A base class for interpreters.</p> <p>This class defines the basic structure of an interpreter. It is designed to be subclassed to provide the actual implementation of the interpreter.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter--required-overrides","title":"Required Overrides","text":"<p>When subclassing, if the subclass does not contain <code>ABC</code>, the subclass must define the following attributes:</p> <ul> <li><code>keys</code>: a list of strings that defines the order of dialects to select from.</li> <li><code>void</code>: the value to return when the interpreter evaluates nothing.</li> </ul>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.debug","title":"debug  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>debug: bool = field(default=False, kw_only=True)\n</code></pre> <p>Whether to enable debug mode.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.dialects","title":"dialects  <code>instance-attribute</code>","text":"<pre><code>dialects: DialectGroup\n</code></pre> <p>The dialects to interpret.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.fuel","title":"fuel  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fuel: int | None = field(default=None, kw_only=True)\n</code></pre> <p>The fuel limit for the interpreter.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.keys","title":"keys  <code>class-attribute</code>","text":"<pre><code>keys: list[str]\n</code></pre> <p>The name of the interpreter to select from dialects by order.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.max_depth","title":"max_depth  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_depth: int = field(default=128, kw_only=True)\n</code></pre> <p>The maximum depth of the interpreter stack.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.max_python_recursion_depth","title":"max_python_recursion_depth  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_python_recursion_depth: int = field(\n    default=8192, kw_only=True\n)\n</code></pre> <p>The maximum recursion depth of the Python interpreter.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.registry","title":"registry  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>registry: InterpreterRegistry = field(\n    init=False, compare=False\n)\n</code></pre> <p>The interpreter registry.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.state","title":"state  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>state: InterpreterState[FrameType] = field(\n    init=False, compare=False\n)\n</code></pre> <p>The interpreter state.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.symbol_table","title":"symbol_table  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>symbol_table: dict[str, Statement] = field(\n    init=False, compare=False\n)\n</code></pre> <p>The symbol table.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.void","title":"void  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>void: ValueType = field(init=False)\n</code></pre> <p>What to return when the interpreter evaluates nothing.</p>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.build_signature","title":"build_signature","text":"<pre><code>build_signature(\n    frame: FrameType, stmt: Statement\n) -&gt; Signature\n</code></pre> <p>build signature for querying the statement implementation.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def build_signature(self, frame: FrameType, stmt: Statement) -&gt; \"Signature\":\n    \"\"\"build signature for querying the statement implementation.\"\"\"\n    return Signature(stmt.__class__, tuple(arg.type for arg in stmt.args))\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.eval_recursion_limit","title":"eval_recursion_limit","text":"<pre><code>eval_recursion_limit(frame: FrameType) -&gt; ValueType\n</code></pre> <p>Return the value of recursion exception, e.g in concrete interpreter, it will raise an exception if the limit is reached; in type inference, it will return a special value.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def eval_recursion_limit(self, frame: FrameType) -&gt; ValueType:\n    \"\"\"Return the value of recursion exception, e.g in concrete\n    interpreter, it will raise an exception if the limit is reached;\n    in type inference, it will return a special value.\n    \"\"\"\n    raise InterpreterError(\"maximum recursion depth exceeded\")\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.eval_stmt","title":"eval_stmt","text":"<pre><code>eval_stmt(\n    frame: FrameType, stmt: Statement\n) -&gt; StatementResult[ValueType]\n</code></pre> <p>Run a statement within the current frame. This is the entry point of running a statement. It will look up the statement implementation in the dialect registry, or optionally call a fallback implementation.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>FrameType</code> <p>the current frame</p> required <code>stmt</code> <code>Statement</code> <p>the statement to run</p> required <p>Returns:</p> Name Type Description <code>StatementResult</code> <code>StatementResult[ValueType]</code> <p>the result of running the statement</p> Note <p>Overload this method for the following reasons: - to change the source tracking information - to take control of how to run a statement - to change the implementation lookup behavior that cannot acheive     by overloading <code>lookup_registry</code></p> Example <ul> <li>implement an interpreter that only handles MyStmt: <pre><code>    class MyInterpreter(BaseInterpreter):\n        ...\n        def eval_stmt(self, frame: FrameType, stmt: Statement) -&gt; StatementResult[ValueType]:\n            if isinstance(stmt, MyStmt):\n                return self.run_my_stmt(frame, stmt)\n            else:\n                return ()\n</code></pre></li> </ul> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def eval_stmt(\n    self, frame: FrameType, stmt: Statement\n) -&gt; StatementResult[ValueType]:\n    \"\"\"Run a statement within the current frame. This is the entry\n    point of running a statement. It will look up the statement implementation\n    in the dialect registry, or optionally call a fallback implementation.\n\n    Args:\n        frame: the current frame\n        stmt: the statement to run\n\n    Returns:\n        StatementResult: the result of running the statement\n\n    Note:\n        Overload this method for the following reasons:\n        - to change the source tracking information\n        - to take control of how to run a statement\n        - to change the implementation lookup behavior that cannot acheive\n            by overloading [`lookup_registry`][kirin.interp.base.BaseInterpreter.lookup_registry]\n\n    Example:\n        * implement an interpreter that only handles MyStmt:\n        ```python\n            class MyInterpreter(BaseInterpreter):\n                ...\n                def eval_stmt(self, frame: FrameType, stmt: Statement) -&gt; StatementResult[ValueType]:\n                    if isinstance(stmt, MyStmt):\n                        return self.run_my_stmt(frame, stmt)\n                    else:\n                        return ()\n        ```\n\n    \"\"\"\n    # TODO: update tracking information\n    method = self.lookup_registry(frame, stmt)\n    if method is not None:\n        results = method(self, frame, stmt)\n        if self.debug and not isinstance(results, (tuple, SpecialValue)):\n            raise InterpreterError(\n                f\"method must return tuple or SpecialResult, got {results}\"\n            )\n        return results\n\n    return self.eval_stmt_fallback(frame, stmt)\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.eval_stmt_fallback","title":"eval_stmt_fallback","text":"<pre><code>eval_stmt_fallback(\n    frame: FrameType, stmt: Statement\n) -&gt; StatementResult[ValueType]\n</code></pre> <p>The fallback implementation of statements.</p> <p>This is called when no implementation is found for the statement.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>FrameType</code> <p>the current frame</p> required <code>stmt</code> <code>Statement</code> <p>the statement to run</p> required <p>Returns:</p> Name Type Description <code>StatementResult</code> <code>StatementResult[ValueType]</code> <p>the result of running the statement</p> Note <p>Overload this method to provide a fallback implementation for statements.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def eval_stmt_fallback(\n    self, frame: FrameType, stmt: Statement\n) -&gt; StatementResult[ValueType]:\n    \"\"\"The fallback implementation of statements.\n\n    This is called when no implementation is found for the statement.\n\n    Args:\n        frame: the current frame\n        stmt: the statement to run\n\n    Returns:\n        StatementResult: the result of running the statement\n\n    Note:\n        Overload this method to provide a fallback implementation for statements.\n    \"\"\"\n    # NOTE: not using f-string here because 3.10 and 3.11 have\n    #  parser bug that doesn't allow f-string in raise statement\n    raise InterpreterError(\n        \"no implementation for stmt \"\n        + stmt.print_str(end=\"\")\n        + \" from \"\n        + str(type(self))\n    )\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.finalize","title":"finalize","text":"<pre><code>finalize(frame: FrameType, results: ValueType) -&gt; ValueType\n</code></pre> <p>Postprocess a frame after it is popped from the stack. This is called after a method is evaluated and the frame is popped.</p> Note <p>Default implementation does nothing.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def finalize(self, frame: FrameType, results: ValueType) -&gt; ValueType:\n    \"\"\"Postprocess a frame after it is popped from the stack. This is\n    called after a method is evaluated and the frame is popped.\n\n    Note:\n        Default implementation does nothing.\n    \"\"\"\n    return results\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.initialize","title":"initialize","text":"<pre><code>initialize() -&gt; Self\n</code></pre> <p>Initialize the interpreter global states. This method is called right upon calling <code>run</code> to initialize the interpreter global states.</p> <p>Default Implementation</p> <p>This method provides default behavior but may be overridden by subclasses to customize or extend functionality.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def initialize(self) -&gt; Self:\n    \"\"\"Initialize the interpreter global states. This method is called right upon\n    calling [`run`][kirin.interp.base.BaseInterpreter.run] to initialize the\n    interpreter global states.\n\n    !!! note \"Default Implementation\"\n        This method provides default behavior but may be overridden by subclasses\n        to customize or extend functionality.\n    \"\"\"\n    self.symbol_table: dict[str, Statement] = {}\n    self.state: InterpreterState[FrameType] = InterpreterState()\n    return self\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.lookup_registry","title":"lookup_registry","text":"<pre><code>lookup_registry(\n    frame: FrameType, stmt: Statement\n) -&gt; Optional[StatementImpl[Self, FrameType]]\n</code></pre> <p>Lookup the statement implementation in the registry.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>FrameType</code> <p>the current frame</p> required <code>stmt</code> <code>Statement</code> <p>the statement to run</p> required <p>Returns:</p> Type Description <code>Optional[StatementImpl[Self, FrameType]]</code> <p>Optional[StatementImpl]: the statement implementation if found, None otherwise.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def lookup_registry(\n    self, frame: FrameType, stmt: Statement\n) -&gt; Optional[\"StatementImpl[Self, FrameType]\"]:\n    \"\"\"Lookup the statement implementation in the registry.\n\n    Args:\n        frame: the current frame\n        stmt: the statement to run\n\n    Returns:\n        Optional[StatementImpl]: the statement implementation if found, None otherwise.\n    \"\"\"\n    sig = self.build_signature(frame, stmt)\n    if sig in self.registry.statements:\n        return self.registry.statements[sig]\n    elif (class_sig := Signature(stmt.__class__)) in self.registry.statements:\n        return self.registry.statements[class_sig]\n    return\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.new_frame","title":"new_frame  <code>abstractmethod</code>","text":"<pre><code>new_frame(code: Statement) -&gt; FrameType\n</code></pre> <p>Create a new frame for the given method.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>@abstractmethod\ndef new_frame(self, code: Statement) -&gt; FrameType:\n    \"\"\"Create a new frame for the given method.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.permute_values","title":"permute_values  <code>staticmethod</code>","text":"<pre><code>permute_values(\n    arg_names: Sequence[str],\n    values: tuple[ValueType, ...],\n    kwarg_names: tuple[str, ...],\n) -&gt; tuple[ValueType, ...]\n</code></pre> <p>Permute the arguments according to the method signature and the given keyword arguments, where the keyword argument names refer to the last n arguments in the values tuple.</p> <p>Parameters:</p> Name Type Description Default <code>arg_names</code> <code>Sequence[str]</code> <p>the argument names</p> required <code>values</code> <code>tuple[ValueType, ...]</code> <p>the values tuple (should not contain method itself)</p> required <code>kwarg_names</code> <code>tuple[str, ...]</code> <p>the keyword argument names</p> required Source code in <code>src/kirin/interp/base.py</code> <pre><code>@staticmethod\ndef permute_values(\n    arg_names: Sequence[str],\n    values: tuple[ValueType, ...],\n    kwarg_names: tuple[str, ...],\n) -&gt; tuple[ValueType, ...]:\n    \"\"\"Permute the arguments according to the method signature and\n    the given keyword arguments, where the keyword argument names\n    refer to the last n arguments in the values tuple.\n\n    Args:\n        arg_names: the argument names\n        values: the values tuple (should not contain method itself)\n        kwarg_names: the keyword argument names\n    \"\"\"\n    n_total = len(values)\n    if kwarg_names:\n        kwargs = dict(zip(kwarg_names, values[n_total - len(kwarg_names) :]))\n    else:\n        kwargs = None\n\n    positionals = values[: n_total - len(kwarg_names)]\n    args = BaseInterpreter.get_args(\n        arg_names[len(positionals) + 1 :], positionals, kwargs\n    )\n    return args\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.run","title":"run","text":"<pre><code>run(\n    mt: Method,\n    args: tuple[ValueType, ...],\n    kwargs: dict[str, ValueType] | None = None,\n) -&gt; Result[ValueType]\n</code></pre> <p>Run a method. This is the main entry point of the interpreter.</p> <p>Parameters:</p> Name Type Description Default <code>mt</code> <code>Method</code> <p>the method to run.</p> required <code>args</code> <code>tuple[ValueType]</code> <p>the arguments to the method, does not include self.</p> required <code>kwargs</code> <code>dict[str, ValueType]</code> <p>the keyword arguments to the method.</p> <code>None</code> <p>Returns:</p> Type Description <code>Result[ValueType]</code> <p>Result[ValueType]: the result of the method.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def run(\n    self,\n    mt: Method,\n    args: tuple[ValueType, ...],\n    kwargs: dict[str, ValueType] | None = None,\n) -&gt; Result[ValueType]:\n    \"\"\"Run a method. This is the main entry point of the interpreter.\n\n    Args:\n        mt (Method): the method to run.\n        args (tuple[ValueType]): the arguments to the method, does not include self.\n        kwargs (dict[str, ValueType], optional): the keyword arguments to the method.\n\n    Returns:\n        Result[ValueType]: the result of the method.\n    \"\"\"\n    if self._eval_lock:\n        raise InterpreterError(\n            \"recursive eval is not allowed, use run_method instead\"\n        )\n\n    self._eval_lock = True\n    self.initialize()\n    current_recursion_limit = sys.getrecursionlimit()\n    sys.setrecursionlimit(self.max_python_recursion_depth)\n    args = self.get_args(mt.arg_names[len(args) + 1 :], args, kwargs)\n    try:\n        results = self.run_method(mt, args)\n    except InterpreterError as e:\n        # NOTE: initialize will create new State\n        # so we don't need to copy the frames.\n        return Err(e, self.state.frames)\n    finally:\n        self._eval_lock = False\n        sys.setrecursionlimit(current_recursion_limit)\n    return Ok(results)\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.run_block","title":"run_block","text":"<pre><code>run_block(\n    frame: FrameType, block: Block\n) -&gt; SpecialValue[ValueType]\n</code></pre> <p>Run a block within the current frame.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>FrameType</code> <p>the current frame.</p> required <code>block</code> <code>Block</code> <p>the block to run.</p> required <p>Returns:</p> Name Type Description <code>SpecialValue</code> <code>SpecialValue[ValueType]</code> <p>the result of running the block terminator.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def run_block(self, frame: FrameType, block: Block) -&gt; SpecialValue[ValueType]:\n    \"\"\"Run a block within the current frame.\n\n    Args:\n        frame: the current frame.\n        block: the block to run.\n\n    Returns:\n        SpecialValue: the result of running the block terminator.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.run_callable","title":"run_callable","text":"<pre><code>run_callable(\n    code: Statement, args: tuple[ValueType, ...]\n) -&gt; ValueType\n</code></pre> <p>Run a callable statement.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>Statement</code> <p>the statement to run.</p> required <code>args</code> <code>tuple[ValueType]</code> <p>the arguments to the statement, includes self if the corresponding callable region contains a self argument.</p> required <p>Returns:</p> Name Type Description <code>ValueType</code> <code>ValueType</code> <p>the result of the statement.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def run_callable(self, code: Statement, args: tuple[ValueType, ...]) -&gt; ValueType:\n    \"\"\"Run a callable statement.\n\n    Args:\n        code (Statement): the statement to run.\n        args (tuple[ValueType]): the arguments to the statement,\n            includes self if the corresponding callable region contains a self argument.\n\n    Returns:\n        ValueType: the result of the statement.\n    \"\"\"\n    if len(self.state.frames) &gt;= self.max_depth:\n        return self.eval_recursion_limit(self.state.current_frame())\n\n    interface = code.get_trait(traits.CallableStmtInterface)\n    if interface is None:\n        raise InterpreterError(f\"statement {code.name} is not callable\")\n\n    frame = self.new_frame(code)\n    self.state.push_frame(frame)\n    body = interface.get_callable_region(code)\n    if not body.blocks:\n        return self.finalize(self.state.pop_frame(), self.void)\n    frame.set_values(body.blocks[0].args, args)\n    results = self.run_callable_region(frame, code, body)\n    return self.finalize(self.state.pop_frame(), results)\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.run_callable_region","title":"run_callable_region","text":"<pre><code>run_callable_region(\n    frame: FrameType, code: Statement, region: Region\n) -&gt; ValueType\n</code></pre> <p>A hook defines how to run the callable region given the interpreter context. Frame should be pushed before calling this method and popped after calling this method.</p> <p>A callable region is a region that can be called as a function. Unlike a general region (or the MLIR convention), it always return a value to be compatible with the Python convention.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def run_callable_region(\n    self, frame: FrameType, code: Statement, region: Region\n) -&gt; ValueType:\n    \"\"\"A hook defines how to run the callable region given\n    the interpreter context. Frame should be pushed before calling\n    this method and popped after calling this method.\n\n    A callable region is a region that can be called as a function.\n    Unlike a general region (or the MLIR convention), it always return a value\n    to be compatible with the Python convention.\n    \"\"\"\n    results = self.run_ssacfg_region(frame, region)\n    if isinstance(results, ReturnValue):\n        return results.value\n    elif not results:  # empty result or None\n        return self.void\n    raise InterpreterError(\n        f\"callable region {code.name} does not return `ReturnValue`, got {results}\"\n    )\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.run_method","title":"run_method  <code>abstractmethod</code>","text":"<pre><code>run_method(\n    method: Method, args: tuple[ValueType, ...]\n) -&gt; ValueType\n</code></pre> <p>How to run a method.</p> <p>This is defined by subclasses to describe what's the corresponding value of a method during the interpretation.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Method</code> <p>the method to run.</p> required <code>args</code> <code>tuple[ValueType]</code> <p>the arguments to the method, does not include self.</p> required <p>Returns:</p> Name Type Description <code>ValueType</code> <code>ValueType</code> <p>the result of the method.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>@abstractmethod\ndef run_method(self, method: Method, args: tuple[ValueType, ...]) -&gt; ValueType:\n    \"\"\"How to run a method.\n\n    This is defined by subclasses to describe what's the corresponding\n    value of a method during the interpretation.\n\n    Args:\n        method (Method): the method to run.\n        args (tuple[ValueType]): the arguments to the method, does not include self.\n\n    Returns:\n        ValueType: the result of the method.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.run_ssacfg_region","title":"run_ssacfg_region  <code>abstractmethod</code>","text":"<pre><code>run_ssacfg_region(\n    frame: FrameType, region: Region\n) -&gt; tuple[ValueType, ...] | None | ReturnValue[ValueType]\n</code></pre> <p>This implements how to run a region with MLIR SSA CFG convention.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>FrameType</code> <p>the current frame.</p> required <code>region</code> <code>Region</code> <p>the region to run.</p> required <p>Returns:</p> Type Description <code>tuple[ValueType, ...] | None | ReturnValue[ValueType]</code> <p>tuple[ValueType, ...] | SpecialValue[ValueType]: the result of running the region.</p> <p>when region returns <code>tuple[ValueType, ...]</code>, it means the region terminates normally with <code>YieldValue</code>. When region returns <code>ReturnValue</code>, it means the region terminates and needs to pop the frame. Region cannot return <code>Successor</code> because reference to external region is not allowed.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>@abstractmethod\ndef run_ssacfg_region(\n    self, frame: FrameType, region: Region\n) -&gt; tuple[ValueType, ...] | None | ReturnValue[ValueType]:\n    \"\"\"This implements how to run a region with MLIR SSA CFG convention.\n\n    Args:\n        frame: the current frame.\n        region: the region to run.\n\n    Returns:\n        tuple[ValueType, ...] | SpecialValue[ValueType]: the result of running the region.\n\n    when region returns `tuple[ValueType, ...]`, it means the region terminates normally\n    with `YieldValue`. When region returns `ReturnValue`, it means the region terminates\n    and needs to pop the frame. Region cannot return `Successor` because reference to\n    external region is not allowed.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.BaseInterpreter.run_stmt","title":"run_stmt","text":"<pre><code>run_stmt(\n    stmt: Statement, args: tuple[ValueType, ...]\n) -&gt; StatementResult[ValueType]\n</code></pre> <p>execute a statement with arguments in a new frame.</p> <p>Parameters:</p> Name Type Description Default <code>stmt</code> <code>Statement</code> <p>the statement to run.</p> required <code>args</code> <code>tuple[ValueType]</code> <p>the arguments to the statement.</p> required <p>Returns:</p> Type Description <code>StatementResult[ValueType]</code> <p>StatementResult[ValueType]: the result of the statement.</p> Source code in <code>src/kirin/interp/base.py</code> <pre><code>def run_stmt(\n    self, stmt: Statement, args: tuple[ValueType, ...]\n) -&gt; StatementResult[ValueType]:\n    \"\"\"execute a statement with arguments in a new frame.\n\n    Args:\n        stmt (Statement): the statement to run.\n        args (tuple[ValueType]): the arguments to the statement.\n\n    Returns:\n        StatementResult[ValueType]: the result of the statement.\n    \"\"\"\n    frame = self.new_frame(stmt)\n    self.state.push_frame(frame)\n    frame.set_values(stmt.args, args)\n    results = self.eval_stmt(frame, stmt)\n    return results\n</code></pre>"},{"location":"reference/kirin/interp/base/#kirin.interp.base.InterpreterMeta","title":"InterpreterMeta","text":"<p>               Bases: <code>ABCMeta</code></p> <p>A metaclass for interpreters.</p>"},{"location":"reference/kirin/interp/concrete/","title":"Concrete","text":""},{"location":"reference/kirin/interp/concrete/#kirin.interp.concrete.Interpreter","title":"Interpreter  <code>dataclass</code>","text":"<pre><code>Interpreter(\n    dialects: DialectGroup,\n    *,\n    fuel: int | None = None,\n    debug: bool = False,\n    max_depth: int = 128,\n    max_python_recursion_depth: int = 8192\n)\n</code></pre> <p>               Bases: <code>BaseInterpreter[Frame[Any], Any]</code></p> <p>Concrete interpreter for the IR.</p> <p>This is a concrete interpreter for the IR. It evaluates the IR by executing the statements in the IR using a simple stack-based interpreter.</p>"},{"location":"reference/kirin/interp/concrete/#kirin.interp.concrete.Interpreter.keys","title":"keys  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>keys = ['main']\n</code></pre> <p>The name of the interpreter to select from dialects by order.</p>"},{"location":"reference/kirin/interp/concrete/#kirin.interp.concrete.Interpreter.void","title":"void  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>void = None\n</code></pre> <p>What to return when the interpreter evaluates nothing.</p>"},{"location":"reference/kirin/interp/concrete/#kirin.interp.concrete.Interpreter.new_frame","title":"new_frame","text":"<pre><code>new_frame(code: Statement) -&gt; Frame[Any]\n</code></pre> <p>Create a new frame for the given method.</p> Source code in <code>src/kirin/interp/concrete.py</code> <pre><code>def new_frame(self, code: Statement) -&gt; Frame[Any]:\n    return Frame.from_func_like(code)\n</code></pre>"},{"location":"reference/kirin/interp/concrete/#kirin.interp.concrete.Interpreter.run_block","title":"run_block","text":"<pre><code>run_block(\n    frame: Frame[Any], block: Block\n) -&gt; SpecialValue[Any]\n</code></pre> <p>Run a block within the current frame.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>FrameType</code> <p>the current frame.</p> required <code>block</code> <code>Block</code> <p>the block to run.</p> required <p>Returns:</p> Name Type Description <code>SpecialValue</code> <code>SpecialValue[ValueType]</code> <p>the result of running the block terminator.</p> Source code in <code>src/kirin/interp/concrete.py</code> <pre><code>def run_block(self, frame: Frame[Any], block: Block) -&gt; SpecialValue[Any]:\n    for stmt in block.stmts:\n        if self.consume_fuel() == self.FuelResult.Stop:\n            raise FuelExhaustedError(\"fuel exhausted\")\n        frame.stmt = stmt\n        frame.lino = stmt.source.lineno if stmt.source else 0\n        stmt_results = self.eval_stmt(frame, stmt)\n        if isinstance(stmt_results, tuple):\n            frame.set_values(stmt._results, stmt_results)\n        else:  # terminator\n            return stmt_results\n    return None\n</code></pre>"},{"location":"reference/kirin/interp/concrete/#kirin.interp.concrete.Interpreter.run_method","title":"run_method","text":"<pre><code>run_method(method: Method, args: tuple[Any, ...]) -&gt; Any\n</code></pre> <p>How to run a method.</p> <p>This is defined by subclasses to describe what's the corresponding value of a method during the interpretation.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Method</code> <p>the method to run.</p> required <code>args</code> <code>tuple[ValueType]</code> <p>the arguments to the method, does not include self.</p> required <p>Returns:</p> Name Type Description <code>ValueType</code> <code>ValueType</code> <p>the result of the method.</p> Source code in <code>src/kirin/interp/concrete.py</code> <pre><code>def run_method(self, method: Method, args: tuple[Any, ...]) -&gt; Any:\n    return self.run_callable(method.code, (method,) + args)\n</code></pre>"},{"location":"reference/kirin/interp/concrete/#kirin.interp.concrete.Interpreter.run_ssacfg_region","title":"run_ssacfg_region","text":"<pre><code>run_ssacfg_region(\n    frame: Frame[Any], region: Region\n) -&gt; tuple[Any, ...] | None | ReturnValue[Any]\n</code></pre> <p>This implements how to run a region with MLIR SSA CFG convention.</p> <p>Parameters:</p> Name Type Description Default <code>frame</code> <code>FrameType</code> <p>the current frame.</p> required <code>region</code> <code>Region</code> <p>the region to run.</p> required <p>Returns:</p> Type Description <code>tuple[ValueType, ...] | None | ReturnValue[ValueType]</code> <p>tuple[ValueType, ...] | SpecialValue[ValueType]: the result of running the region.</p> <p>when region returns <code>tuple[ValueType, ...]</code>, it means the region terminates normally with <code>YieldValue</code>. When region returns <code>ReturnValue</code>, it means the region terminates and needs to pop the frame. Region cannot return <code>Successor</code> because reference to external region is not allowed.</p> Source code in <code>src/kirin/interp/concrete.py</code> <pre><code>def run_ssacfg_region(\n    self, frame: Frame[Any], region: Region\n) -&gt; tuple[Any, ...] | None | ReturnValue[Any]:\n    block = region.blocks[0]\n    while block is not None:\n        results = self.run_block(frame, block)\n        if isinstance(results, Successor):\n            block = results.block\n            frame.set_values(block.args, results.block_args)\n        elif isinstance(results, ReturnValue):\n            return results\n        elif isinstance(results, YieldValue):\n            return results.values\n        else:\n            return results\n    return None  # region without terminator returns empty tuple\n</code></pre>"},{"location":"reference/kirin/interp/exceptions/","title":"Exceptions","text":""},{"location":"reference/kirin/interp/exceptions/#kirin.interp.exceptions.FuelExhaustedError","title":"FuelExhaustedError","text":"<p>               Bases: <code>InterpreterError</code></p> <p>An error raised when the interpreter runs out of fuel.</p>"},{"location":"reference/kirin/interp/exceptions/#kirin.interp.exceptions.InterpreterError","title":"InterpreterError","text":"<p>               Bases: <code>Exception</code></p> <p>Generic interpreter error.</p> <p>This is the base class for all interpreter errors. Interpreter errors will be catched by the interpreter and handled appropriately as an error with stack trace (of Kirin, not Python) from the interpreter.</p>"},{"location":"reference/kirin/interp/exceptions/#kirin.interp.exceptions.WrapException","title":"WrapException  <code>dataclass</code>","text":"<pre><code>WrapException(exception: Exception)\n</code></pre> <p>               Bases: <code>InterpreterError</code></p> <p>A special interpreter error that wraps a Python exception.</p>"},{"location":"reference/kirin/interp/frame/","title":"Frame","text":""},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame","title":"Frame  <code>dataclass</code>","text":"<pre><code>Frame(\n    code: Statement,\n    lino: int = 0,\n    stmt: Statement | None = None,\n    globals: dict[str, Any] = dict(),\n    entries: dict[SSAValue, ValueType] = dict(),\n)\n</code></pre> <p>               Bases: <code>FrameABC[ValueType]</code></p> <p>Interpreter frame.</p>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame.entries","title":"entries  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>entries: dict[SSAValue, ValueType] = field(\n    default_factory=dict\n)\n</code></pre> <p>SSA values and their corresponding values.</p>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame.globals","title":"globals  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>globals: dict[str, Any] = field(default_factory=dict)\n</code></pre> <p>Global variables this frame has access to.</p>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame.stmt","title":"stmt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stmt: Statement | None = None\n</code></pre> <p>statement being interpreted.</p>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame.from_func_like","title":"from_func_like  <code>classmethod</code>","text":"<pre><code>from_func_like(code: Statement) -&gt; Self\n</code></pre> <p>Create a new frame for the given statement.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>@classmethod\ndef from_func_like(cls, code: Statement) -&gt; Self:\n    \"\"\"Create a new frame for the given statement.\"\"\"\n    return cls(code=code)\n</code></pre>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame.get","title":"get","text":"<pre><code>get(key: SSAValue) -&gt; ValueType\n</code></pre> <p>Get the value for the given <code>SSAValue</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key(SSAValue)</code> <p>The key to get the value for.</p> required <p>Returns:</p> Name Type Description <code>ValueType</code> <code>ValueType</code> <p>The value.</p> <p>Raises:</p> Type Description <code>InterpreterError</code> <p>If the value is not found. This will be catched by the interpreter.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>def get(self, key: SSAValue) -&gt; ValueType:\n    \"\"\"Get the value for the given [`SSAValue`][kirin.ir.SSAValue].\n\n    Args:\n        key(SSAValue): The key to get the value for.\n\n    Returns:\n        ValueType: The value.\n\n    Raises:\n        InterpreterError: If the value is not found. This will be catched by the interpreter.\n    \"\"\"\n    err = InterpreterError(f\"SSAValue {key} not found\")\n    value = self.entries.get(key, err)\n    if isinstance(value, InterpreterError):\n        raise err\n    else:\n        return value\n</code></pre>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame.get_typed","title":"get_typed","text":"<pre><code>get_typed(\n    key: SSAValue, type_: type[ExpectedType]\n) -&gt; ExpectedType\n</code></pre> <p>Similar to <code>get</code> but also checks the type.</p> <p>Parameters:</p> Name Type Description Default <code>key(SSAValue)</code> <p>The key to get the value for.</p> required <code>type_(type)</code> <p>The expected type.</p> required <p>Returns:</p> Name Type Description <code>ExpectedType</code> <code>ExpectedType</code> <p>The value.</p> <p>Raises:</p> Type Description <code>InterpreterError</code> <p>If the value is not of the expected type.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>def get_typed(self, key: SSAValue, type_: type[ExpectedType]) -&gt; ExpectedType:\n    \"\"\"Similar to [`get`][kirin.interp.frame.Frame.get] but also checks the type.\n\n    Args:\n        key(SSAValue): The key to get the value for.\n        type_(type): The expected type.\n\n    Returns:\n        ExpectedType: The value.\n\n    Raises:\n        InterpreterError: If the value is not of the expected type.\n    \"\"\"\n    value = self.get(key)\n    if not isinstance(value, type_):\n        raise InterpreterError(f\"expected {type_}, got {type(value)}\")\n    return value\n</code></pre>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame.set","title":"set","text":"<pre><code>set(key: SSAValue, value: ValueType) -&gt; None\n</code></pre> <p>Set the value for the given <code>SSAValue</code> key. See also <code>set_values</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key(SSAValue)</code> <p>The key to set the value for.</p> required <code>value(ValueType)</code> <p>The value.</p> required Source code in <code>src/kirin/interp/frame.py</code> <pre><code>def set(self, key: SSAValue, value: ValueType) -&gt; None:\n    self.entries[key] = value\n</code></pre>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.Frame.set_stmt","title":"set_stmt","text":"<pre><code>set_stmt(stmt: Statement) -&gt; Self\n</code></pre> <p>Set the current statement.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>def set_stmt(self, stmt: Statement) -&gt; Self:\n    self.stmt = stmt\n    return self\n</code></pre>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.FrameABC","title":"FrameABC  <code>dataclass</code>","text":"<pre><code>FrameABC(code: Statement)\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Generic[ValueType]</code></p> <p>Abstract base class for interpreter frame.</p>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.FrameABC.code","title":"code  <code>instance-attribute</code>","text":"<pre><code>code: Statement\n</code></pre> <p>func statement being interpreted.</p>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.FrameABC.from_func_like","title":"from_func_like  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>from_func_like(code: Statement) -&gt; Self\n</code></pre> <p>Create a new frame for the given method.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>@classmethod\n@abstractmethod\ndef from_func_like(cls, code: Statement) -&gt; Self:\n    \"\"\"Create a new frame for the given method.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.FrameABC.get","title":"get  <code>abstractmethod</code>","text":"<pre><code>get(key: SSAValue) -&gt; ValueType\n</code></pre> <p>Get the value for the given <code>SSAValue</code> key. See also <code>get_values</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key(SSAValue)</code> <p>The key to get the value for.</p> required <p>Returns:</p> Name Type Description <code>ValueType</code> <code>ValueType</code> <p>The value.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>@abstractmethod\ndef get(self, key: SSAValue) -&gt; ValueType:\n    \"\"\"Get the value for the given [`SSAValue`][kirin.ir.SSAValue] key.\n    See also [`get_values`][kirin.interp.frame.Frame.get_values].\n\n    Args:\n        key(SSAValue): The key to get the value for.\n\n    Returns:\n        ValueType: The value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.FrameABC.get_values","title":"get_values","text":"<pre><code>get_values(\n    keys: Iterable[SSAValue],\n) -&gt; tuple[ValueType, ...]\n</code></pre> <p>Get the values of the given <code>SSAValue</code> keys. See also <code>get</code>.</p> <p>Parameters:</p> Name Type Description Default <code>keys(Iterable[SSAValue])</code> <p>The keys to get the values for.</p> required <p>Returns:</p> Type Description <code>tuple[ValueType, ...]</code> <p>tuple[ValueType, ...]: The values.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>def get_values(self, keys: Iterable[SSAValue]) -&gt; tuple[ValueType, ...]:\n    \"\"\"Get the values of the given [`SSAValue`][kirin.ir.SSAValue] keys.\n    See also [`get`][kirin.interp.frame.Frame.get].\n\n    Args:\n        keys(Iterable[SSAValue]): The keys to get the values for.\n\n    Returns:\n        tuple[ValueType, ...]: The values.\n    \"\"\"\n    return tuple(self.get(key) for key in keys)\n</code></pre>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.FrameABC.set","title":"set  <code>abstractmethod</code>","text":"<pre><code>set(key: SSAValue, value: ValueType) -&gt; None\n</code></pre> <p>Set the value for the given <code>SSAValue</code> key. See also <code>set_values</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key(SSAValue)</code> <p>The key to set the value for.</p> required <code>value(ValueType)</code> <p>The value.</p> required Source code in <code>src/kirin/interp/frame.py</code> <pre><code>@abstractmethod\ndef set(self, key: SSAValue, value: ValueType) -&gt; None:\n    \"\"\"Set the value for the given [`SSAValue`][kirin.ir.SSAValue] key.\n    See also [`set_values`][kirin.interp.frame.Frame.set_values].\n\n    Args:\n        key(SSAValue): The key to set the value for.\n        value(ValueType): The value.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.FrameABC.set_stmt","title":"set_stmt  <code>abstractmethod</code>","text":"<pre><code>set_stmt(stmt: Statement) -&gt; Self\n</code></pre> <p>Set the current statement.</p> Source code in <code>src/kirin/interp/frame.py</code> <pre><code>@abstractmethod\ndef set_stmt(self, stmt: Statement) -&gt; Self:\n    \"\"\"Set the current statement.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/interp/frame/#kirin.interp.frame.FrameABC.set_values","title":"set_values","text":"<pre><code>set_values(\n    keys: Iterable[SSAValue], values: Iterable[ValueType]\n) -&gt; None\n</code></pre> <p>Set the values of the given <code>SSAValue</code> keys. This is a convenience method to set multiple values at once.</p> <p>Parameters:</p> Name Type Description Default <code>keys(Iterable[SSAValue])</code> <p>The keys to set the values for.</p> required <code>values(Iterable[ValueType])</code> <p>The values.</p> required Source code in <code>src/kirin/interp/frame.py</code> <pre><code>def set_values(self, keys: Iterable[SSAValue], values: Iterable[ValueType]) -&gt; None:\n    \"\"\"Set the values of the given [`SSAValue`][kirin.ir.SSAValue] keys.\n    This is a convenience method to set multiple values at once.\n\n    Args:\n        keys(Iterable[SSAValue]): The keys to set the values for.\n        values(Iterable[ValueType]): The values.\n    \"\"\"\n    for key, value in zip(keys, values):\n        self.set(key, value)\n</code></pre>"},{"location":"reference/kirin/interp/impl/","title":"Impl","text":""},{"location":"reference/kirin/interp/impl/#kirin.interp.impl.AttributeImplDef","title":"AttributeImplDef  <code>dataclass</code>","text":"<pre><code>AttributeImplDef(signature: SigType, impl: ImplType)\n</code></pre> <p>               Bases: <code>Def[type[Attribute], 'AttributeFunction']</code></p> <p>Definition of an interpreter implementation for an attribute.</p>"},{"location":"reference/kirin/interp/impl/#kirin.interp.impl.Def","title":"Def  <code>dataclass</code>","text":"<pre><code>Def(signature: SigType, impl: ImplType)\n</code></pre> <p>               Bases: <code>Generic[SigType, ImplType]</code></p> <p>Base class of an interpreter implementation definition.</p>"},{"location":"reference/kirin/interp/impl/#kirin.interp.impl.ImplDef","title":"ImplDef  <code>dataclass</code>","text":"<pre><code>ImplDef(\n    signature: SigType,\n    impl: ImplType,\n    parent: Type[Statement],\n)\n</code></pre> <p>               Bases: <code>Def[tuple[Signature, ...], 'MethodFunction']</code></p> <p>Definition of an interpreter implementation for a statement.</p>"},{"location":"reference/kirin/interp/impl/#kirin.interp.impl.Signature","title":"Signature  <code>dataclass</code>","text":"<pre><code>Signature(\n    stmt: Type[Statement],\n    args: tuple[types.TypeAttribute, ...] | None = None,\n)\n</code></pre> <p>Signature of a statement.</p>"},{"location":"reference/kirin/interp/impl/#kirin.interp.impl.impl","title":"impl","text":"<pre><code>impl(\n    stmt_or_attribute: Type[HeadType],\n    *args: types.TypeAttribute\n)\n</code></pre> <p>               Bases: <code>Generic[HeadType]</code></p> <p>Decorator to define an interpreter implementation for a statement or attribute.</p> <p>Note</p> <p>While the <code>impl</code> decorator accepts both statements and attributes, and optionally statements with its type signature, unlike a programming language, the actual dispatch behavior given an instance of a statement or attribute is defined by the implementation of the interpreter (via <code>lookup_registry</code>).</p>"},{"location":"reference/kirin/interp/impl/#kirin.interp.impl.impl--example","title":"Example","text":"<pre><code>@dialect.register\nclass MyMethods(interp.MethodTable):\n    @impl(Add)\n    def interp_add(\n        self,\n        interp: Interpreter,\n        frame: Frame,\n        stmt: Add,\n    ) -&gt; StatementResult:\n        ...\n</code></pre> Source code in <code>src/kirin/interp/impl.py</code> <pre><code>def __init__(\n    self, stmt_or_attribute: Type[HeadType], *args: types.TypeAttribute\n) -&gt; None:\n    if args and issubclass(stmt_or_attribute, Attribute):\n        raise ValueError(\"Attributes do not take arguments\")\n    self.stmt_or_attribute: type[HeadType] = stmt_or_attribute\n    self.args = args\n</code></pre>"},{"location":"reference/kirin/interp/result/","title":"Result","text":""},{"location":"reference/kirin/interp/result/#kirin.interp.result.Err","title":"Err  <code>dataclass</code>","text":"<pre><code>Err(exception: Exception, frames: list[FrameType])\n</code></pre> <p>               Bases: <code>Result[ValueType]</code>, <code>Generic[FrameType, ValueType]</code></p> Source code in <code>src/kirin/interp/result.py</code> <pre><code>def __init__(self, exception: Exception, frames: list[FrameType]):\n    super().__init__()\n    self.exception = exception\n    self.frames = frames\n</code></pre>"},{"location":"reference/kirin/interp/result/#kirin.interp.result.Err.print_stack","title":"print_stack","text":"<pre><code>print_stack()\n</code></pre> <p>Print the stack trace of the error.</p> Source code in <code>src/kirin/interp/result.py</code> <pre><code>def print_stack(self):\n    \"\"\"Print the stack trace of the error.\"\"\"\n    top_method_code = self.frames[0].code\n    if (call_trait := top_method_code.get_trait(CallableStmtInterface)) is None:\n        raise ValueError(f\"Method code {top_method_code} is not callable\")\n\n    region = call_trait.get_callable_region(top_method_code)\n    name = (\n        top_method_code.get_trait(SymbolOpInterface)\n        .get_sym_name(top_method_code)  # type: ignore\n        .data\n    )\n    args = \",\".join(\n        [\n            (\n                f\"{arg.name}\"\n                if arg.type is arg.type.top()\n                else f\"{arg.name}:{arg.type}\"\n            )\n            for arg in region.blocks[0].args[1:]\n        ]\n    )\n    print(\"Traceback (most recent call last):\")\n    print(f\"  {name}({args})\")\n    for frame in reversed(self.frames):\n        if frame.code:\n            frame.code.print()\n    print(f\"{self.exception.__class__.__name__}: {self.exception}\")\n    print(\n        \"================================ Python Stacktrace ================================\"\n    )\n</code></pre>"},{"location":"reference/kirin/interp/result/#kirin.interp.result.Result","title":"Result  <code>dataclass</code>","text":"<pre><code>Result()\n</code></pre> <p>               Bases: <code>Generic[ValueType]</code></p> <p>Result type for the interpreter.</p> <p>This is a generic result type that represents the result of interpretation. The result can be either an <code>Ok</code> value or an <code>Err</code> value. The <code>Ok</code> value represents a successful interpretation result, while the <code>Err</code> value represents an error during interpretation with a stack trace. One can use the <code>expect</code> method to extract the value from the result, which will raise an exception and print the stack trace if the result is an <code>Err</code>.</p>"},{"location":"reference/kirin/interp/state/","title":"State","text":""},{"location":"reference/kirin/interp/state/#kirin.interp.state.InterpreterState","title":"InterpreterState  <code>dataclass</code>","text":"<pre><code>InterpreterState(frames: list[FrameType] = list())\n</code></pre> <p>               Bases: <code>Generic[FrameType]</code></p> <p>Interpreter state.</p> <p>This class represents the state of the interpreter. It contains the stack of frames for the interpreter. The stack of frames is used to store the current state of the interpreter during interpretation.</p>"},{"location":"reference/kirin/interp/state/#kirin.interp.state.InterpreterState.current_frame","title":"current_frame","text":"<pre><code>current_frame() -&gt; FrameType\n</code></pre> <p>Get the current frame.</p> <p>Returns:</p> Name Type Description <code>FrameType</code> <code>FrameType</code> <p>The current frame.</p> Source code in <code>src/kirin/interp/state.py</code> <pre><code>def current_frame(self) -&gt; FrameType:\n    \"\"\"Get the current frame.\n\n    Returns:\n        FrameType: The current frame.\n    \"\"\"\n    if not self.frames:\n        raise ValueError(\n            \"unable to retrieve the current frame because no frames were pushed\"\n        )\n    return self.frames[-1]\n</code></pre>"},{"location":"reference/kirin/interp/state/#kirin.interp.state.InterpreterState.pop_frame","title":"pop_frame","text":"<pre><code>pop_frame() -&gt; FrameType\n</code></pre> <p>Pop a frame from the stack.</p> <p>Returns:</p> Name Type Description <code>FrameType</code> <code>FrameType</code> <p>The frame that was popped.</p> Source code in <code>src/kirin/interp/state.py</code> <pre><code>def pop_frame(self) -&gt; FrameType:\n    \"\"\"Pop a frame from the stack.\n\n    Returns:\n        FrameType: The frame that was popped.\n    \"\"\"\n    return self.frames.pop()\n</code></pre>"},{"location":"reference/kirin/interp/state/#kirin.interp.state.InterpreterState.push_frame","title":"push_frame","text":"<pre><code>push_frame(frame: FrameType)\n</code></pre> <p>Push a frame onto the stack.</p> <p>Parameters:</p> Name Type Description Default <code>frame(FrameType)</code> <p>The frame to push onto the stack.</p> required <p>Returns:</p> Name Type Description <code>FrameType</code> <p>The frame that was pushed.</p> Source code in <code>src/kirin/interp/state.py</code> <pre><code>def push_frame(self, frame: FrameType):\n    \"\"\"Push a frame onto the stack.\n\n    Args:\n        frame(FrameType): The frame to push onto the stack.\n\n    Returns:\n        FrameType: The frame that was pushed.\n    \"\"\"\n    self.frames.append(frame)\n    return frame\n</code></pre>"},{"location":"reference/kirin/interp/table/","title":"Table","text":""},{"location":"reference/kirin/interp/table/#kirin.interp.table.MethodTable","title":"MethodTable  <code>dataclass</code>","text":"<pre><code>MethodTable()\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Base class to define lookup tables for interpreting code for IR nodes in a dialect.</p>"},{"location":"reference/kirin/interp/table/#kirin.interp.table.MethodTable.attribute","title":"attribute  <code>class-attribute</code>","text":"<pre><code>attribute: dict[type[Attribute], AttributeFunction]\n</code></pre> <p>Lookup table for interpreting code for IR attributes in a dialect.</p>"},{"location":"reference/kirin/interp/table/#kirin.interp.table.MethodTable.table","title":"table  <code>class-attribute</code>","text":"<pre><code>table: dict[Signature, MethodFunction]\n</code></pre> <p>Lookup table for interpreting code for IR nodes in a dialect.</p>"},{"location":"reference/kirin/interp/value/","title":"Value","text":""},{"location":"reference/kirin/interp/value/#kirin.interp.value.SpecialValue","title":"SpecialValue  <code>module-attribute</code>","text":"<pre><code>SpecialValue: TypeAlias = (\n    None\n    | ReturnValue[ValueType]\n    | YieldValue[ValueType]\n    | Successor[ValueType]\n)\n</code></pre> <p>Special value for statement evaluation.</p>"},{"location":"reference/kirin/interp/value/#kirin.interp.value.StatementResult","title":"StatementResult  <code>module-attribute</code>","text":"<pre><code>StatementResult: TypeAlias = (\n    tuple[ValueType, ...] | SpecialValue[ValueType]\n)\n</code></pre> <p>Type alias for the result of a statement evaluation.</p>"},{"location":"reference/kirin/interp/value/#kirin.interp.value.ReturnValue","title":"ReturnValue  <code>dataclass</code>","text":"<pre><code>ReturnValue(value: ValueType)\n</code></pre> <p>               Bases: <code>Generic[ValueType]</code></p> <p>Return value from a statement evaluation.</p> <p>This class represents a return value from a statement evaluation. It is used to indicate that the statement evaluation should later pop the frame and return the value. Kirin does not allow multiple return values to follow Python semantics. If you want to return multiple values, you should return a tuple.</p>"},{"location":"reference/kirin/interp/value/#kirin.interp.value.Successor","title":"Successor  <code>dataclass</code>","text":"<pre><code>Successor(block: Block, *block_args: ValueType)\n</code></pre> <p>               Bases: <code>Generic[ValueType]</code></p> <p>Successor block from a statement evaluation.</p> Source code in <code>src/kirin/interp/value.py</code> <pre><code>def __init__(self, block: Block, *block_args: ValueType):\n    super().__init__()\n    self.block = block\n    self.block_args = block_args\n</code></pre>"},{"location":"reference/kirin/interp/value/#kirin.interp.value.YieldValue","title":"YieldValue  <code>dataclass</code>","text":"<pre><code>YieldValue(values: tuple[ValueType, ...])\n</code></pre> <p>               Bases: <code>Generic[ValueType]</code></p> <p>Yield value from a statement evaluation.</p> <p>This class represents values returned from a statement that terminates current region execution and returns the values to the caller. Unlike <code>ReturnValue</code>, this class won't pop the frame and return the value to the caller.</p>"},{"location":"reference/kirin/ir/","title":"Index","text":"<p>IR module for kirin.</p> <p>This module contains the data structure definition of the intermediate representation (IR) for kirin.</p>"},{"location":"reference/kirin/ir/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/ir/dialect/#kirin.ir.dialect.Dialect","title":"Dialect  <code>dataclass</code>","text":"<pre><code>Dialect(\n    name: str,\n    stmts: list[type[Statement]] = list(),\n    attrs: list[type[Attribute]] = list(),\n    interps: dict[str, MethodTable] = dict(),\n    lowering: dict[str, FromPythonAST] = dict(),\n)\n</code></pre> <p>Dialect is a collection of statements, attributes, interpreters, lowerings, and codegen.</p> Example <pre><code>    from kirin import ir\n\n    my_dialect = ir.Dialect(name=\"my_dialect\")\n</code></pre>"},{"location":"reference/kirin/ir/dialect/#kirin.ir.dialect.Dialect.attrs","title":"attrs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>attrs: list[type[Attribute]] = field(\n    default_factory=list, init=True\n)\n</code></pre> <p>A list of attributes in the dialect.</p>"},{"location":"reference/kirin/ir/dialect/#kirin.ir.dialect.Dialect.interps","title":"interps  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>interps: dict[str, MethodTable] = field(\n    default_factory=dict, init=True\n)\n</code></pre> <p>A dictionary of registered method table in the dialect.</p>"},{"location":"reference/kirin/ir/dialect/#kirin.ir.dialect.Dialect.lowering","title":"lowering  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lowering: dict[str, FromPythonAST] = field(\n    default_factory=dict, init=True\n)\n</code></pre> <p>A dictionary of registered python lowering implmentations in the dialect.</p>"},{"location":"reference/kirin/ir/dialect/#kirin.ir.dialect.Dialect.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>The name of the dialect.</p>"},{"location":"reference/kirin/ir/dialect/#kirin.ir.dialect.Dialect.stmts","title":"stmts  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stmts: list[type[Statement]] = field(\n    default_factory=list, init=True\n)\n</code></pre> <p>A list of statements in the dialect.</p>"},{"location":"reference/kirin/ir/dialect/#kirin.ir.dialect.Dialect.register","title":"register","text":"<pre><code>register(node: type | None = None, key: str | None = None)\n</code></pre> <p>register is a decorator to register a node to the dialect.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>type | None</code> <p>The node to register. Defaults to None.</p> <code>None</code> <code>key</code> <code>str | None</code> <p>The key to register the node to. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the node is not a subclass of Statement, Attribute, DialectInterpreter, FromPythonAST, or DialectEmit.</p> Example <ul> <li> <p>Register a method table for concrete interpreter (by default key=\"main\") to the dialect: <pre><code>    from kirin import ir\n\n    my_dialect = ir.Dialect(name=\"my_dialect\")\n\n    @my_dialect.register\n    class MyMethodTable(ir.MethodTable):\n        ...\n</code></pre></p> </li> <li> <p>Register a method table for the interpreter specified by <code>key</code> to the dialect: <pre><code>    from kirin import ir\n\n    my_dialect = ir.Dialect(name=\"my_dialect\")\n\n    @my_dialect.register(key=\"my_interp\")\n    class MyMethodTable(ir.MethodTable):\n        ...\n</code></pre></p> </li> </ul> Source code in <code>src/kirin/ir/dialect.py</code> <pre><code>@dataclass_transform()\ndef register(self, node: type | None = None, key: str | None = None):\n    \"\"\"register is a decorator to register a node to the dialect.\n\n    Args:\n        node (type | None): The node to register. Defaults to None.\n        key (str | None): The key to register the node to. Defaults to None.\n\n    Raises:\n        ValueError: If the node is not a subclass of Statement, Attribute, DialectInterpreter, FromPythonAST, or DialectEmit.\n\n    Example:\n        * Register a method table for concrete interpreter (by default key=\"main\") to the dialect:\n        ```python\n            from kirin import ir\n\n            my_dialect = ir.Dialect(name=\"my_dialect\")\n\n            @my_dialect.register\n            class MyMethodTable(ir.MethodTable):\n                ...\n        ```\n\n        * Register a method table for the interpreter specified by `key` to the dialect:\n        ```python\n            from kirin import ir\n\n            my_dialect = ir.Dialect(name=\"my_dialect\")\n\n            @my_dialect.register(key=\"my_interp\")\n            class MyMethodTable(ir.MethodTable):\n                ...\n        ```\n\n\n    \"\"\"\n    from kirin.interp.table import MethodTable\n    from kirin.lowering.dialect import FromPythonAST\n\n    if key is None:\n        key = \"main\"\n\n    def wrapper(node: type[T]) -&gt; type[T]:\n        if issubclass(node, Statement):\n            self.stmts.append(node)\n        elif issubclass(node, Attribute):\n            assert (\n                Attribute in node.__mro__\n            ), f\"{node} is not a subclass of Attribute\"\n            setattr(node, \"dialect\", self)\n            assert hasattr(node, \"name\"), f\"{node} does not have a name attribute\"\n            self.attrs.append(node)\n        elif issubclass(node, MethodTable):\n            if key in self.interps:\n                raise ValueError(\n                    f\"Cannot register {node} to Dialect, key {key} exists\"\n                )\n            self.interps[key] = node()\n        elif issubclass(node, FromPythonAST):\n            if key in self.lowering:\n                raise ValueError(\n                    f\"Cannot register {node} to Dialect, key {key} exists\"\n                )\n            self.lowering[key] = node()\n        else:\n            raise ValueError(f\"Cannot register {node} to Dialect\")\n        return node\n\n    if node is None:\n        return wrapper\n\n    return wrapper(node)\n</code></pre>"},{"location":"reference/kirin/ir/group/","title":"Dialect Group","text":""},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup","title":"DialectGroup  <code>dataclass</code>","text":"<pre><code>DialectGroup(\n    dialects: Iterable[Union[Dialect, ModuleType]],\n    run_pass: RunPassGen[PassParams] | None = None,\n)\n</code></pre> <p>               Bases: <code>Generic[PassParams]</code></p> Source code in <code>src/kirin/ir/group.py</code> <pre><code>def __init__(\n    self,\n    dialects: Iterable[Union[\"Dialect\", ModuleType]],\n    run_pass: RunPassGen[PassParams] | None = None,\n):\n    def identity(code: Method):\n        pass\n\n    self.data = frozenset(self.map_module(dialect) for dialect in dialects)\n    if run_pass is None:\n        self.run_pass_gen = None\n        self.run_pass = None\n    else:\n        self.run_pass_gen = run_pass\n        self.run_pass = run_pass(self)\n</code></pre>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data: frozenset[Dialect] = frozenset(\n    map_module(dialect) for dialect in dialects\n)\n</code></pre> <p>The set of dialects in the group.</p>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup.registry","title":"registry  <code>property</code>","text":"<pre><code>registry: Registry\n</code></pre> <p>return the registry for the dialect group. This returns a proxy object that can be used to select the lowering interpreters, interpreters, and codegen for the dialects in the group.</p> <p>Returns:</p> Name Type Description <code>Registry</code> <code>Registry</code> <p>the registry object.</p>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup.run_pass","title":"run_pass  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>run_pass: RunPass[PassParams] | None = None\n</code></pre> <p>the function that runs the passes on the method.</p>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup.run_pass_gen","title":"run_pass_gen  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>run_pass_gen: RunPassGen[PassParams] | None = None\n</code></pre> <p>the function that generates the <code>run_pass</code> function.</p> <p>This is used to create new dialect groups from existing ones, while keeping the same <code>run_pass</code> function.</p>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup.__call__","title":"__call__","text":"<pre><code>__call__(\n    py_func: Callable[Param, RetType],\n    *args: PassParams.args,\n    **options: PassParams.kwargs\n) -&gt; Method[Param, RetType]\n</code></pre><pre><code>__call__(\n    py_func: None = None,\n    *args: PassParams.args,\n    **options: PassParams.kwargs\n) -&gt; MethodTransform[Param, RetType]\n</code></pre> <pre><code>__call__(\n    py_func: Callable[Param, RetType] | None = None,\n    *args: PassParams.args,\n    **options: PassParams.kwargs\n) -&gt; (\n    Method[Param, RetType] | MethodTransform[Param, RetType]\n)\n</code></pre> <p>create a method from the python function.</p> <p>Parameters:</p> Name Type Description Default <code>py_func</code> <code>Callable</code> <p>the python function to create the method from.</p> <code>None</code> <code>args</code> <code>args</code> <p>the arguments to pass to the run_pass function.</p> <code>()</code> <code>options</code> <code>kwargs</code> <p>the keyword arguments to pass to the run_pass function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Method</code> <code>Method[Param, RetType] | MethodTransform[Param, RetType]</code> <p>the method created from the python function.</p> Source code in <code>src/kirin/ir/group.py</code> <pre><code>def __call__(\n    self,\n    py_func: Callable[Param, RetType] | None = None,\n    *args: PassParams.args,\n    **options: PassParams.kwargs,\n) -&gt; Method[Param, RetType] | MethodTransform[Param, RetType]:\n    \"\"\"create a method from the python function.\n\n    Args:\n        py_func (Callable): the python function to create the method from.\n        args (PassParams.args): the arguments to pass to the run_pass function.\n        options (PassParams.kwargs): the keyword arguments to pass to the run_pass function.\n\n    Returns:\n        Method: the method created from the python function.\n    \"\"\"\n    from kirin.lowering import Lowering\n\n    emit_ir = Lowering(self)\n\n    def wrapper(py_func: Callable) -&gt; Method:\n        if py_func.__name__ == \"&lt;lambda&gt;\":\n            raise ValueError(\"Cannot compile lambda functions\")\n\n        lineno_offset, file = 0, \"\"\n        frame = inspect.currentframe()\n        if frame and frame.f_back is not None and frame.f_back.f_back is not None:\n            call_site_frame = frame.f_back.f_back\n            if py_func.__name__ in call_site_frame.f_locals:\n                raise CompilerError(\n                    f\"overwriting function definition of `{py_func.__name__}`\"\n                )\n\n            lineno_offset = call_site_frame.f_lineno - 1\n            file = call_site_frame.f_code.co_filename\n\n        code = emit_ir.run(py_func, lineno_offset=lineno_offset)\n        mt = Method(\n            mod=inspect.getmodule(py_func),\n            py_func=py_func,\n            sym_name=py_func.__name__,\n            arg_names=[\"#self#\"] + inspect.getfullargspec(py_func).args,\n            dialects=self,\n            code=code,\n            file=file,\n        )\n        if doc := inspect.getdoc(py_func):\n            mt.__doc__ = doc\n\n        if self.run_pass is not None:\n            self.run_pass(mt, *args, **options)\n        return mt\n\n    if py_func is not None:\n        return wrapper(py_func)\n    return wrapper\n</code></pre>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup.add","title":"add","text":"<pre><code>add(dialect: Union[Dialect, ModuleType]) -&gt; DialectGroup\n</code></pre> <p>add a dialect to the group.</p> <p>Parameters:</p> Name Type Description Default <code>dialect</code> <code>Union[Dialect, ModuleType]</code> <p>the dialect to add</p> required <p>Returns:</p> Name Type Description <code>DialectGroup</code> <code>DialectGroup</code> <p>the new dialect group with the added</p> Source code in <code>src/kirin/ir/group.py</code> <pre><code>def add(self, dialect: Union[\"Dialect\", ModuleType]) -&gt; \"DialectGroup\":\n    \"\"\"add a dialect to the group.\n\n    Args:\n        dialect (Union[Dialect, ModuleType]): the dialect to add\n\n    Returns:\n        DialectGroup: the new dialect group with the added\n    \"\"\"\n    return self.union([dialect])\n</code></pre>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup.discard","title":"discard","text":"<pre><code>discard(\n    dialect: Union[Dialect, ModuleType]\n) -&gt; DialectGroup\n</code></pre> <p>discard a dialect from the group.</p> <p>Note</p> <p>This does not raise an error if the dialect is not in the group.</p> <p>Parameters:</p> Name Type Description Default <code>dialect</code> <code>Union[Dialect, ModuleType]</code> <p>the dialect to discard</p> required <p>Returns:</p> Name Type Description <code>DialectGroup</code> <code>DialectGroup</code> <p>the new dialect group with the discarded dialect.</p> Source code in <code>src/kirin/ir/group.py</code> <pre><code>def discard(self, dialect: Union[\"Dialect\", ModuleType]) -&gt; \"DialectGroup\":\n    \"\"\"discard a dialect from the group.\n\n    !!! note\n        This does not raise an error if the dialect is not in the group.\n\n    Args:\n        dialect (Union[Dialect, ModuleType]): the dialect to discard\n\n    Returns:\n        DialectGroup: the new dialect group with the discarded dialect.\n    \"\"\"\n    dialect_ = self.map_module(dialect)\n    return DialectGroup(\n        dialects=frozenset(\n            each for each in self.data if each.name != dialect_.name\n        ),\n        run_pass=self.run_pass_gen,  # pass the run_pass_gen function\n    )\n</code></pre>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup.map_module","title":"map_module  <code>staticmethod</code>","text":"<pre><code>map_module(dialect: Union[Dialect, ModuleType]) -&gt; Dialect\n</code></pre> <p>map the module to the dialect if it is a module. It assumes that the module has a <code>dialect</code> attribute that is an instance of <code>Dialect</code>.</p> Source code in <code>src/kirin/ir/group.py</code> <pre><code>@staticmethod\ndef map_module(dialect: Union[\"Dialect\", ModuleType]) -&gt; \"Dialect\":\n    \"\"\"map the module to the dialect if it is a module.\n    It assumes that the module has a `dialect` attribute\n    that is an instance of [`Dialect`][kirin.ir.Dialect].\n    \"\"\"\n    if isinstance(dialect, ModuleType):\n        return getattr(dialect, \"dialect\")\n    return dialect\n</code></pre>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.DialectGroup.union","title":"union","text":"<pre><code>union(\n    dialect: Iterable[Union[Dialect, ModuleType]]\n) -&gt; DialectGroup\n</code></pre> <p>union a set of dialects to the group.</p> <p>Parameters:</p> Name Type Description Default <code>dialect</code> <code>Iterable[Union[Dialect, ModuleType]]</code> <p>the dialects to union</p> required <p>Returns:</p> Name Type Description <code>DialectGroup</code> <code>DialectGroup</code> <p>the new dialect group with the union.</p> Source code in <code>src/kirin/ir/group.py</code> <pre><code>def union(self, dialect: Iterable[Union[\"Dialect\", ModuleType]]) -&gt; \"DialectGroup\":\n    \"\"\"union a set of dialects to the group.\n\n    Args:\n        dialect (Iterable[Union[Dialect, ModuleType]]): the dialects to union\n\n    Returns:\n        DialectGroup: the new dialect group with the union.\n    \"\"\"\n    return DialectGroup(\n        dialects=self.data.union(frozenset(self.map_module(d) for d in dialect)),\n        run_pass=self.run_pass_gen,  # pass the run_pass_gen function\n    )\n</code></pre>"},{"location":"reference/kirin/ir/group/#kirin.ir.group.dialect_group","title":"dialect_group","text":"<pre><code>dialect_group(\n    dialects: Iterable[Union[Dialect, ModuleType]]\n) -&gt; Callable[\n    [RunPassGen[PassParams]], DialectGroup[PassParams]\n]\n</code></pre> <p>Create a dialect group from the given dialects based on the definition of <code>run_pass</code> function.</p> <p>Parameters:</p> Name Type Description Default <code>dialects</code> <code>Iterable[Union[Dialect, ModuleType]]</code> <p>the dialects to include in the group.</p> required <p>Returns:</p> Type Description <code>Callable[[RunPassGen[PassParams]], DialectGroup[PassParams]]</code> <p>Callable[[RunPassGen[PassParams]], DialectGroup[PassParams]]: the dialect group.</p> Example <pre><code>from kirin.dialects import cf, fcf, func, math\n\n@dialect_group([cf, fcf, func, math])\ndef basic_no_opt(self):\n    # initializations\n    def run_pass(mt: Method) -&gt; None:\n        # how passes are applied to the method\n        pass\n\n    return run_pass\n</code></pre> Source code in <code>src/kirin/ir/group.py</code> <pre><code>def dialect_group(\n    dialects: Iterable[Union[\"Dialect\", ModuleType]]\n) -&gt; Callable[[RunPassGen[PassParams]], DialectGroup[PassParams]]:\n    \"\"\"Create a dialect group from the given dialects based on the\n    definition of `run_pass` function.\n\n    Args:\n        dialects (Iterable[Union[Dialect, ModuleType]]): the dialects to include in the group.\n\n    Returns:\n        Callable[[RunPassGen[PassParams]], DialectGroup[PassParams]]: the dialect group.\n\n    Example:\n        ```python\n        from kirin.dialects import cf, fcf, func, math\n\n        @dialect_group([cf, fcf, func, math])\n        def basic_no_opt(self):\n            # initializations\n            def run_pass(mt: Method) -&gt; None:\n                # how passes are applied to the method\n                pass\n\n            return run_pass\n        ```\n    \"\"\"\n\n    # NOTE: do not alias the annotation below\n    def wrapper(\n        transform: RunPassGen[PassParams],\n    ) -&gt; DialectGroup[PassParams]:\n        ret = DialectGroup(dialects, run_pass=transform)\n        update_wrapper(ret, transform)\n        return ret\n\n    return wrapper\n</code></pre>"},{"location":"reference/kirin/ir/method/","title":"Method","text":""},{"location":"reference/kirin/ir/method/#kirin.ir.method.Method","title":"Method  <code>dataclass</code>","text":"<pre><code>Method(\n    mod: ModuleType | None,\n    py_func: Callable[Param, RetType] | None,\n    sym_name: str,\n    arg_names: list[str],\n    dialects: DialectGroup,\n    code: Statement,\n    fields: tuple = tuple(),\n    file: str = \"\",\n    inferred: bool = False,\n    verified: bool = False,\n)\n</code></pre> <p>               Bases: <code>Printable</code>, <code>Generic[Param, RetType]</code></p>"},{"location":"reference/kirin/ir/method/#kirin.ir.method.Method.inferred","title":"inferred  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inferred: bool = False\n</code></pre> <p>if typeinfer has been run on this method</p>"},{"location":"reference/kirin/ir/method/#kirin.ir.method.Method.verified","title":"verified  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>verified: bool = False\n</code></pre> <p>if <code>code.verify</code> has been run on this method</p>"},{"location":"reference/kirin/ir/method/#kirin.ir.method.Method.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>verify the method body.</p> Source code in <code>src/kirin/ir/method.py</code> <pre><code>def verify(self) -&gt; None:\n    \"\"\"verify the method body.\"\"\"\n    try:\n        self.code.verify()\n    except VerificationError as e:\n        msg = f'File \"{self.file}\"'\n        if isinstance(e.node, Statement):\n            if e.node.source:\n                msg += f\", line {e.node.source.lineno}\"\n            msg += f\", in {e.node.name}\"\n\n        msg += f\":\\n    Verification failed for {self.sym_name}: {e.args[0]}\"\n        raise Exception(msg) from e\n    self.verified = True\n    return\n</code></pre>"},{"location":"reference/kirin/ir/ssa/","title":"SSA values","text":""},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.BlockArgument","title":"BlockArgument  <code>dataclass</code>","text":"<pre><code>BlockArgument(\n    block: Block,\n    index: int,\n    type: TypeAttribute = AnyType(),\n)\n</code></pre> <p>               Bases: <code>SSAValue</code></p> <p>SSAValue that is an argument to a <code>Block</code>.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def __init__(\n    self, block: Block, index: int, type: TypeAttribute = AnyType()\n) -&gt; None:\n    super().__init__()\n    self.type = type\n    self.block = block\n    self.index = index\n</code></pre>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.BlockArgument.block","title":"block  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>block: Block = block\n</code></pre> <p>The block that this argument belongs to.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.BlockArgument.index","title":"index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>index: int = index\n</code></pre> <p>The index of this argument in the block's argument list.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.BlockArgument.owner","title":"owner  <code>property</code>","text":"<pre><code>owner: Block\n</code></pre> <p>The object that owns this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.BlockArgument.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type = type\n</code></pre> <p>The type of this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.DeletedSSAValue","title":"DeletedSSAValue  <code>dataclass</code>","text":"<pre><code>DeletedSSAValue(value: SSAValue)\n</code></pre> <p>               Bases: <code>SSAValue</code></p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def __init__(self, value: SSAValue) -&gt; None:\n    super().__init__()\n    self.value = value\n    self.type = value.type\n</code></pre>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.DeletedSSAValue.owner","title":"owner  <code>property</code>","text":"<pre><code>owner: Statement | Block\n</code></pre> <p>The object that owns this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.DeletedSSAValue.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type = type\n</code></pre> <p>The type of this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.ResultValue","title":"ResultValue  <code>dataclass</code>","text":"<pre><code>ResultValue(\n    stmt: Statement,\n    index: int,\n    type: TypeAttribute | None = None,\n)\n</code></pre> <p>               Bases: <code>SSAValue</code></p> <p>SSAValue that is a result of a <code>Statement</code>.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def __init__(\n    self, stmt: Statement, index: int, type: TypeAttribute | None = None\n) -&gt; None:\n    super().__init__()\n    self.type = type or AnyType()\n    self.stmt = stmt\n    self.index = index\n</code></pre>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.ResultValue.index","title":"index  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>index: int = index\n</code></pre> <p>The index of this value in the statement's result list.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.ResultValue.owner","title":"owner  <code>property</code>","text":"<pre><code>owner: Statement\n</code></pre> <p>The object that owns this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.ResultValue.stmt","title":"stmt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stmt: Statement = stmt\n</code></pre> <p>The statement that this value is a result of.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.ResultValue.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type = type or AnyType()\n</code></pre> <p>The type of this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue","title":"SSAValue  <code>dataclass</code>","text":"<pre><code>SSAValue()\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Printable</code></p> <p>Base class for all SSA values in the IR.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue.name","title":"name  <code>property</code> <code>writable</code>","text":"<pre><code>name: str | None\n</code></pre> <p>The name of this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue.name_pattern","title":"name_pattern  <code>class-attribute</code>","text":"<pre><code>name_pattern: Pattern[str] = compile(\n    \"([A-Za-z_$.-][\\\\w$.-]*)\"\n)\n</code></pre> <p>The pattern that the name of this SSA value must match.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue.owner","title":"owner  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>owner: Statement | Block\n</code></pre> <p>The object that owns this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type: TypeAttribute = field(\n    default_factory=AnyType, init=False, repr=True\n)\n</code></pre> <p>The type of this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue.uses","title":"uses  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>uses: set[Use] = field(\n    init=False, default_factory=set, repr=False\n)\n</code></pre> <p>The uses of this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue.add_use","title":"add_use","text":"<pre><code>add_use(use: Use) -&gt; Self\n</code></pre> <p>Add a use to this SSA value.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def add_use(self, use: Use) -&gt; Self:\n    \"\"\"Add a use to this SSA value.\"\"\"\n    self.uses.add(use)\n    return self\n</code></pre>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue.delete","title":"delete","text":"<pre><code>delete(safe: bool = True) -&gt; None\n</code></pre> <p>Delete this SSA value. If <code>safe</code> is <code>True</code>, raise an error if there are uses.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def delete(self, safe: bool = True) -&gt; None:\n    \"\"\"Delete this SSA value. If `safe` is `True`, raise an error if there are uses.\"\"\"\n    if safe and len(self.uses) &gt; 0:\n        raise ValueError(\"Cannot delete SSA value with uses\")\n    self.replace_by(DeletedSSAValue(self))\n</code></pre>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue.remove_use","title":"remove_use","text":"<pre><code>remove_use(use: Use) -&gt; Self\n</code></pre> <p>Remove a use from this SSA value.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def remove_use(self, use: Use) -&gt; Self:\n    \"\"\"Remove a use from this SSA value.\"\"\"\n    # print(use)\n    # assert use in self.uses, \"Use not found\"\n    if use in self.uses:\n        self.uses.remove(use)\n    return self\n</code></pre>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.SSAValue.replace_by","title":"replace_by","text":"<pre><code>replace_by(other: SSAValue) -&gt; None\n</code></pre> <p>Replace this SSA value with another SSA value. Update all uses.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def replace_by(self, other: SSAValue) -&gt; None:\n    \"\"\"Replace this SSA value with another SSA value. Update all uses.\"\"\"\n    for use in self.uses.copy():\n        use.stmt.args[use.index] = other\n\n    if other.name is None and self.name is not None:\n        other.name = self.name\n\n    assert len(self.uses) == 0, \"Uses not empty\"\n</code></pre>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.TestValue","title":"TestValue  <code>dataclass</code>","text":"<pre><code>TestValue(type: TypeAttribute = AnyType())\n</code></pre> <p>               Bases: <code>SSAValue</code></p> <p>Test SSAValue for testing IR construction.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def __init__(self, type: TypeAttribute = AnyType()) -&gt; None:\n    super().__init__()\n    self.type = type\n</code></pre>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.TestValue.owner","title":"owner  <code>property</code>","text":"<pre><code>owner: Statement | Block\n</code></pre> <p>The object that owns this SSA value.</p>"},{"location":"reference/kirin/ir/ssa/#kirin.ir.ssa.TestValue.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type = type\n</code></pre> <p>The type of this SSA value.</p>"},{"location":"reference/kirin/ir/use/","title":"Use","text":""},{"location":"reference/kirin/ir/use/#kirin.ir.use.Use","title":"Use  <code>dataclass</code>","text":"<pre><code>Use(stmt: Statement, index: int)\n</code></pre> <p>A use of an SSA value in a statement.</p>"},{"location":"reference/kirin/ir/use/#kirin.ir.use.Use.index","title":"index  <code>instance-attribute</code>","text":"<pre><code>index: int\n</code></pre> <p>The index of the use in the statement.</p>"},{"location":"reference/kirin/ir/use/#kirin.ir.use.Use.stmt","title":"stmt  <code>instance-attribute</code>","text":"<pre><code>stmt: Statement\n</code></pre> <p>The statement that uses the SSA value.</p>"},{"location":"reference/kirin/ir/attrs/","title":"Index","text":"<p>Compile-time values in Kirin IR.</p> <p>This module contains the following:</p>"},{"location":"reference/kirin/ir/attrs/#kirin.ir.attrs--abc-module","title":"<code>abc</code> module","text":"<p><code>abc.AttributeMeta</code>: The metaclass for all attributes. <code>abc.Attribute</code>: The base class for all attributes.</p>"},{"location":"reference/kirin/ir/attrs/#kirin.ir.attrs--types-module","title":"<code>types</code> module","text":"<p><code>types.TypeAttribute</code>: The base class for all type attributes. <code>types.PyClass</code>: A type attribute representing a Python class. <code>types.TypeVar</code>: A type attribute representing a type variable. <code>types.Literal</code>: A type attribute representing a literal type. <code>types.Generic</code>: A type attribute representing a generic type. <code>types.Hinted</code>: A type attribute representing a hinted type. <code>types.Union</code>: A type attribute representing a union type.</p>"},{"location":"reference/kirin/ir/attrs/#kirin.ir.attrs--py-module","title":"<code>py</code> module","text":"<p><code>py.PyAttr</code>: An attribute representing a Python value.</p>"},{"location":"reference/kirin/ir/attrs/abc/","title":"Abc","text":""},{"location":"reference/kirin/ir/attrs/abc/#kirin.ir.attrs.abc.Attribute","title":"Attribute  <code>dataclass</code>","text":"<pre><code>Attribute()\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Printable</code></p> <p>ABC for compile-time values. All attributes are hashable and thus need to implement the <code>__hash__</code> method.</p> <p>Pretty Printing</p> <p>This object is pretty printable via <code>.print()</code> method.</p>"},{"location":"reference/kirin/ir/attrs/abc/#kirin.ir.attrs.abc.Attribute.dialect","title":"dialect  <code>class-attribute</code>","text":"<pre><code>dialect: Optional[Dialect] = field(\n    default=None, init=False, repr=False\n)\n</code></pre> <p>Dialect of the attribute. (default: None)</p>"},{"location":"reference/kirin/ir/attrs/abc/#kirin.ir.attrs.abc.Attribute.name","title":"name  <code>class-attribute</code>","text":"<pre><code>name: str = field(init=False, repr=False)\n</code></pre> <p>Name of the attribute in printing and other text format.</p>"},{"location":"reference/kirin/ir/attrs/abc/#kirin.ir.attrs.abc.AttributeMeta","title":"AttributeMeta","text":"<p>               Bases: <code>ABCMeta</code></p> <p>Metaclass for attributes.</p>"},{"location":"reference/kirin/ir/attrs/py/","title":"Py","text":""},{"location":"reference/kirin/ir/attrs/py/#kirin.ir.attrs.py.PyAttr","title":"PyAttr  <code>dataclass</code>","text":"<pre><code>PyAttr(data: T, pytype: TypeAttribute | None = None)\n</code></pre> <p>               Bases: <code>Generic[T]</code>, <code>Attribute</code></p> <p>Python attribute for compile-time values. This is a generic attribute that holds a Python value.</p> <p>The constructor takes a Python value and an optional type attribute. If the type attribute is not provided, the type of the value is inferred as <code>PyClass(type(value))</code>.</p> <p>Pretty Printing</p> <p>This object is pretty printable via <code>.print()</code> method.</p> Source code in <code>src/kirin/ir/attrs/py.py</code> <pre><code>def __init__(self, data: T, pytype: TypeAttribute | None = None):\n    self.data = data\n\n    if pytype is None:\n        self.type = PyClass(type(data))\n    else:\n        self.type = pytype\n</code></pre>"},{"location":"reference/kirin/ir/attrs/py/#kirin.ir.attrs.py.PyAttr.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'PyAttr'\n</code></pre> <p>Name of the attribute in printing and other text format.</p>"},{"location":"reference/kirin/ir/attrs/types/","title":"Types","text":""},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.AnyType","title":"AnyType  <code>dataclass</code>","text":"<pre><code>AnyType()\n</code></pre> <p>               Bases: <code>TypeAttribute</code></p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.AnyType.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'Any'\n</code></pre> <p>Name of the attribute in printing and other text format.</p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.BottomType","title":"BottomType  <code>dataclass</code>","text":"<pre><code>BottomType()\n</code></pre> <p>               Bases: <code>TypeAttribute</code></p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.BottomType.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'Bottom'\n</code></pre> <p>Name of the attribute in printing and other text format.</p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.BottomType.is_subseteq","title":"is_subseteq","text":"<pre><code>is_subseteq(other: TypeAttribute) -&gt; bool\n</code></pre> <p>Subseteq operation.</p> Source code in <code>src/kirin/ir/attrs/types.py</code> <pre><code>def is_subseteq(self, other: TypeAttribute) -&gt; bool:\n    if isinstance(other, TypeVar):\n        return self.is_subseteq(other.bound)\n    return True\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Generic","title":"Generic  <code>dataclass</code>","text":"<pre><code>Generic(\n    body: type[PyClassType] | PyClass[PyClassType],\n    *vars: TypeAttribute | list | Vararg\n)\n</code></pre> <p>               Bases: <code>TypeAttribute</code>, <code>Generic[PyClassType]</code></p> Source code in <code>src/kirin/ir/attrs/types.py</code> <pre><code>def __init__(\n    self,\n    body: type[PyClassType] | PyClass[PyClassType],\n    *vars: TypeAttribute | list | Vararg,\n):\n    if isinstance(body, PyClass):\n        self.body = body\n    else:\n        self.body = PyClass(body)\n    self.vars, self.vararg = _split_type_args(vars)\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Generic.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'Generic'\n</code></pre> <p>Name of the attribute in printing and other text format.</p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Hinted","title":"Hinted  <code>dataclass</code>","text":"<pre><code>Hinted(type: TypeAttribute, data: HintedData)\n</code></pre> <p>               Bases: <code>TypeAttribute</code>, <code>Generic[HintedData]</code></p> <p>Type wrapped with a hint.</p> <p><code>Hinted</code> is used to represent a type with additional data that can be used as a hint for type inference. The additional data is only used for specific type inference purposes, or improve certain type inference precision, it does not affect the order of types in the lattice.</p> Source code in <code>src/kirin/ir/attrs/types.py</code> <pre><code>def __init__(self, type: TypeAttribute, data: HintedData):\n    self.data = data\n    if isinstance(type, Hinted):\n        type = type.type\n    self.type = type\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Hinted.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'Hinted'\n</code></pre> <p>Name of the attribute in printing and other text format.</p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Literal","title":"Literal  <code>dataclass</code>","text":"<pre><code>Literal(data: LiteralType)\n</code></pre> <p>               Bases: <code>TypeAttribute</code>, <code>Generic[LiteralType]</code></p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Literal.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'Literal'\n</code></pre> <p>Name of the attribute in printing and other text format.</p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Literal.is_equal","title":"is_equal","text":"<pre><code>is_equal(other: TypeAttribute) -&gt; bool\n</code></pre> <p>Check if two lattices are equal.</p> Source code in <code>src/kirin/ir/attrs/types.py</code> <pre><code>def is_equal(self, other: TypeAttribute) -&gt; bool:\n    return self is other\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.PyClass","title":"PyClass  <code>dataclass</code>","text":"<pre><code>PyClass(typ: type[PyClassType])\n</code></pre> <p>               Bases: <code>TypeAttribute</code>, <code>Generic[PyClassType]</code></p> Source code in <code>src/kirin/ir/attrs/types.py</code> <pre><code>def __init__(self, typ: type[PyClassType]) -&gt; None:\n    self.typ = typ\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.PyClass.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'PyClass'\n</code></pre> <p>Name of the attribute in printing and other text format.</p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.SingletonTypeMeta","title":"SingletonTypeMeta","text":"<pre><code>SingletonTypeMeta(name, bases, attrs)\n</code></pre> <p>               Bases: <code>TypeAttributeMeta</code>, <code>SingletonMeta</code></p> <p>Metaclass for singleton type attributes.</p> <p>Singleton type attributes are attributes that have only one instance.</p> <p>Examples: - <code>AnyType</code> - <code>BottomType</code></p> Source code in <code>src/kirin/lattice/abc.py</code> <pre><code>def __init__(cls, name, bases, attrs):\n    super().__init__(name, bases, attrs)\n    cls._instance = None\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.TypeAttribute","title":"TypeAttribute  <code>dataclass</code>","text":"<pre><code>TypeAttribute()\n</code></pre> <p>               Bases: <code>_TypeAttribute</code>, <code>SimpleMeetMixin['TypeAttribute']</code>, <code>IsSubsetEqMixin['TypeAttribute']</code>, <code>BoundedLattice['TypeAttribute']</code></p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.TypeAttribute.join","title":"join","text":"<pre><code>join(other: TypeAttribute) -&gt; TypeAttribute\n</code></pre> <p>Join operation.</p> Source code in <code>src/kirin/ir/attrs/types.py</code> <pre><code>def join(self, other: \"TypeAttribute\") -&gt; \"TypeAttribute\":\n    if self.is_subseteq(other):\n        return other\n    elif other.is_subseteq(self):\n        return self\n    elif isinstance(other, TypeAttribute):\n        return Union(self, other)\n    return AnyType()  # don't know how to join\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.TypeAttributeMeta","title":"TypeAttributeMeta","text":"<p>               Bases: <code>AttributeMeta</code>, <code>LatticeMeta</code></p> <p>Metaclass for type attributes.</p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.TypeVar","title":"TypeVar  <code>dataclass</code>","text":"<pre><code>TypeVar(name: str, bound: TypeAttribute | None = None)\n</code></pre> <p>               Bases: <code>TypeAttribute</code></p> Source code in <code>src/kirin/ir/attrs/types.py</code> <pre><code>def __init__(self, name: str, bound: TypeAttribute | None = None):\n    self.varname = name\n    self.bound = bound or AnyType()\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.TypeVar.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'TypeVar'\n</code></pre> <p>Name of the attribute in printing and other text format.</p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.TypeVar.is_equal","title":"is_equal","text":"<pre><code>is_equal(other: TypeAttribute) -&gt; bool\n</code></pre> <p>Check if two lattices are equal.</p> Source code in <code>src/kirin/ir/attrs/types.py</code> <pre><code>def is_equal(self, other: TypeAttribute) -&gt; bool:\n    return (\n        isinstance(other, TypeVar)\n        and self.varname == other.varname\n        and self.bound.is_equal(other.bound)\n    )\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Union","title":"Union  <code>dataclass</code>","text":"<pre><code>Union(\n    typ_or_set: (\n        TypeAttribute | typing.Iterable[TypeAttribute]\n    ),\n    *typs: TypeAttribute\n)\n</code></pre> <p>               Bases: <code>TypeAttribute</code></p> Source code in <code>src/kirin/ir/attrs/types.py</code> <pre><code>def __init__(\n    self,\n    typ_or_set: TypeAttribute | typing.Iterable[TypeAttribute],\n    *typs: TypeAttribute,\n):\n    if isinstance(typ_or_set, TypeAttribute):\n        params: typing.Iterable[TypeAttribute] = (typ_or_set, *typs)\n    else:\n        params = typ_or_set\n        assert not typs, \"Cannot pass multiple arguments when passing a set\"\n\n    types: frozenset[TypeAttribute] = frozenset()\n    for typ in params:\n        if isinstance(typ, Union):\n            types = types.union(typ.types)\n        else:\n            types = types.union({typ})\n    self.types = types\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Union.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'Union'\n</code></pre> <p>Name of the attribute in printing and other text format.</p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Union.is_equal","title":"is_equal","text":"<pre><code>is_equal(other: TypeAttribute) -&gt; bool\n</code></pre> <p>Check if two lattices are equal.</p> Source code in <code>src/kirin/ir/attrs/types.py</code> <pre><code>def is_equal(self, other: TypeAttribute) -&gt; bool:\n    return isinstance(other, Union) and self.types == other.types\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Union.join","title":"join","text":"<pre><code>join(other: TypeAttribute) -&gt; TypeAttribute\n</code></pre> <p>Join operation.</p> Source code in <code>src/kirin/ir/attrs/types.py</code> <pre><code>def join(self, other: TypeAttribute) -&gt; TypeAttribute:\n    if self.is_subseteq(other):\n        return other\n    elif other.is_subseteq(self):\n        return self\n    elif isinstance(other, Union):\n        return Union(self.types | other.types)\n    elif isinstance(other, TypeAttribute):\n        return Union(self.types | {other})\n    return BottomType()\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Union.meet","title":"meet","text":"<pre><code>meet(other: TypeAttribute) -&gt; TypeAttribute\n</code></pre> <p>Meet operation.</p> Source code in <code>src/kirin/ir/attrs/types.py</code> <pre><code>def meet(self, other: TypeAttribute) -&gt; TypeAttribute:\n    if self.is_subseteq(other):\n        return self\n    elif other.is_subseteq(self):\n        return other\n    elif isinstance(other, Union):\n        return Union(self.types &amp; other.types)\n    elif isinstance(other, TypeAttribute):\n        return Union(self.types &amp; {other})\n    return BottomType()\n</code></pre>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Vararg","title":"Vararg  <code>dataclass</code>","text":"<pre><code>Vararg(typ: TypeAttribute)\n</code></pre> <p>               Bases: <code>Attribute</code></p>"},{"location":"reference/kirin/ir/attrs/types/#kirin.ir.attrs.types.Vararg.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'Vararg'\n</code></pre> <p>Name of the attribute in printing and other text format.</p>"},{"location":"reference/kirin/ir/nodes/","title":"Index","text":"<p>Definition of Kirin's Intermediate Representation (IR) nodes.</p>"},{"location":"reference/kirin/ir/nodes/base/","title":"Base","text":""},{"location":"reference/kirin/ir/nodes/base/#kirin.ir.nodes.base.IRNode","title":"IRNode  <code>dataclass</code>","text":"<pre><code>IRNode()\n</code></pre> <p>               Bases: <code>Generic[ParentType]</code>, <code>ABC</code>, <code>Printable</code></p> <p>Base class for all IR nodes. All IR nodes are hashable and can be compared for equality. The hash of an IR node is the same as the id of the object.</p> <p>Pretty Printing</p> <p>This object is pretty printable via <code>.print()</code> method.</p>"},{"location":"reference/kirin/ir/nodes/base/#kirin.ir.nodes.base.IRNode.parent_node","title":"parent_node  <code>abstractmethod</code> <code>property</code> <code>writable</code>","text":"<pre><code>parent_node: ParentType | None\n</code></pre> <p>Parent node of the current node.</p>"},{"location":"reference/kirin/ir/nodes/base/#kirin.ir.nodes.base.IRNode.attach","title":"attach","text":"<pre><code>attach(parent: ParentType) -&gt; None\n</code></pre> <p>Attach the current node to the parent node.</p> Source code in <code>src/kirin/ir/nodes/base.py</code> <pre><code>def attach(self, parent: ParentType) -&gt; None:\n    \"\"\"Attach the current node to the parent node.\"\"\"\n    assert isinstance(parent, IRNode), f\"Expected IRNode, got {type(parent)}\"\n\n    if self.parent_node:\n        raise ValueError(\"Node already has a parent\")\n    if self.is_ancestor(parent):\n        raise ValueError(\"Node is an ancestor of the parent\")\n    self.parent_node = parent\n</code></pre>"},{"location":"reference/kirin/ir/nodes/base/#kirin.ir.nodes.base.IRNode.delete","title":"delete  <code>abstractmethod</code>","text":"<pre><code>delete(safe: bool = True) -&gt; None\n</code></pre> <p>Delete the current node.</p> <p>Parameters:</p> Name Type Description Default <code>safe</code> <code>bool</code> <p>If True, check if the node has any references before deleting.</p> <code>True</code> Source code in <code>src/kirin/ir/nodes/base.py</code> <pre><code>@abstractmethod\ndef delete(self, safe: bool = True) -&gt; None:\n    \"\"\"Delete the current node.\n\n    Args:\n        safe: If True, check if the node has any references before deleting.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/ir/nodes/base/#kirin.ir.nodes.base.IRNode.detach","title":"detach  <code>abstractmethod</code>","text":"<pre><code>detach() -&gt; None\n</code></pre> <p>Detach the current node from the parent node.</p> Source code in <code>src/kirin/ir/nodes/base.py</code> <pre><code>@abstractmethod\ndef detach(self) -&gt; None:\n    \"\"\"Detach the current node from the parent node.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/ir/nodes/base/#kirin.ir.nodes.base.IRNode.drop_all_references","title":"drop_all_references  <code>abstractmethod</code>","text":"<pre><code>drop_all_references() -&gt; None\n</code></pre> <p>Drop all references to other nodes.</p> Source code in <code>src/kirin/ir/nodes/base.py</code> <pre><code>@abstractmethod\ndef drop_all_references(self) -&gt; None:\n    \"\"\"Drop all references to other nodes.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/ir/nodes/base/#kirin.ir.nodes.base.IRNode.get_root","title":"get_root","text":"<pre><code>get_root() -&gt; IRNode\n</code></pre> <p>Get the root node of the current node.</p> Source code in <code>src/kirin/ir/nodes/base.py</code> <pre><code>def get_root(self) -&gt; IRNode:\n    \"\"\"Get the root node of the current node.\"\"\"\n    if (parent := self.parent_node) is None:\n        return self\n    return parent.get_root()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/base/#kirin.ir.nodes.base.IRNode.is_ancestor","title":"is_ancestor","text":"<pre><code>is_ancestor(op: IRNode) -&gt; bool\n</code></pre> <p>Check if the given node is an ancestor of the current node.</p> Source code in <code>src/kirin/ir/nodes/base.py</code> <pre><code>def is_ancestor(self, op: IRNode) -&gt; bool:\n    \"\"\"Check if the given node is an ancestor of the current node.\"\"\"\n    if op is self:\n        return True\n    if (parent := op.parent_node) is None:\n        return False\n    return self.is_ancestor(parent)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/base/#kirin.ir.nodes.base.IRNode.is_equal","title":"is_equal","text":"<pre><code>is_equal(other: IRNode, context: dict = {}) -&gt; bool\n</code></pre> <p>Check if the current node is equal to the other node.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>IRNode</code> <p>The other node to compare.</p> required <code>context</code> <code>dict</code> <p>The context to store the visited nodes. Defaults to {}.</p> <code>{}</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the nodes are equal, False otherwise.</p> <p>Note</p> <p>This method is not the same as the <code>==</code> operator. It checks for structural equality rather than identity. To change the behavior of structural equality, override the <code>is_structurally_equal</code> method.</p> Source code in <code>src/kirin/ir/nodes/base.py</code> <pre><code>def is_equal(self, other: IRNode, context: dict = {}) -&gt; bool:\n    \"\"\"Check if the current node is equal to the other node.\n\n    Args:\n        other: The other node to compare.\n        context: The context to store the visited nodes. Defaults to {}.\n\n    Returns:\n        True if the nodes are equal, False otherwise.\n\n    !!! note\n        This method is not the same as the `==` operator. It checks for\n        structural equality rather than identity. To change the behavior\n        of structural equality, override the `is_structurally_equal` method.\n    \"\"\"\n    if not isinstance(other, type(self)):\n        return False\n    return self.is_structurally_equal(other, context)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/base/#kirin.ir.nodes.base.IRNode.is_structurally_equal","title":"is_structurally_equal  <code>abstractmethod</code>","text":"<pre><code>is_structurally_equal(\n    other: Self,\n    context: (\n        dict[IRNode | SSAValue, IRNode | SSAValue] | None\n    ) = None,\n) -&gt; bool\n</code></pre> <p>Check if the current node is structurally equal to the other node.</p> <p>Note</p> <p>This method is for tweaking the behavior of structural equality. To check if two nodes are structurally equal, use the <code>is_equal</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>The other node to compare.</p> required <code>context</code> <code>dict[IRNode | SSAValue, IRNode | SSAValue] | None</code> <p>The context to store the visited nodes.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the nodes are structurally equal, False otherwise.</p> Source code in <code>src/kirin/ir/nodes/base.py</code> <pre><code>@abstractmethod\ndef is_structurally_equal(\n    self,\n    other: Self,\n    context: dict[IRNode | SSAValue, IRNode | SSAValue] | None = None,\n) -&gt; bool:\n    \"\"\"Check if the current node is structurally equal to the other node.\n\n    !!! note\n        This method is for tweaking the behavior of structural equality.\n        To check if two nodes are structurally equal, use the `is_equal` method.\n\n    Args:\n        other: The other node to compare.\n        context: The context to store the visited nodes.\n\n    Returns:\n        True if the nodes are structurally equal, False otherwise.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/ir/nodes/base/#kirin.ir.nodes.base.IRNode.typecheck","title":"typecheck  <code>abstractmethod</code>","text":"<pre><code>typecheck() -&gt; None\n</code></pre> <p>check if types are correct.</p> Source code in <code>src/kirin/ir/nodes/base.py</code> <pre><code>@abstractmethod\ndef typecheck(self) -&gt; None:\n    \"\"\"check if types are correct.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/ir/nodes/base/#kirin.ir.nodes.base.IRNode.verify","title":"verify  <code>abstractmethod</code>","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>run mandatory validation checks. This is not same as typecheck, which may be optional.</p> Source code in <code>src/kirin/ir/nodes/base.py</code> <pre><code>@abstractmethod\ndef verify(self) -&gt; None:\n    \"\"\"run mandatory validation checks. This is not same as typecheck, which may be optional.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/","title":"Block","text":""},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block","title":"Block  <code>dataclass</code>","text":"<pre><code>Block(\n    stmts: Sequence[Statement] = (),\n    argtypes: Iterable[TypeAttribute] = (),\n)\n</code></pre> <p>               Bases: <code>IRNode['Region']</code></p> <p>Block consist of a list of Statements and optionally input arguments.</p> <p>Pretty Printing</p> <p>This object is pretty printable via <code>.print()</code> method.</p> <pre><code>argtypes (Iterable[TypeAttribute], optional): The type of the block arguments. Defaults to ().\n</code></pre> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def __init__(\n    self,\n    stmts: Sequence[Statement] = (),\n    argtypes: Iterable[TypeAttribute] = (),\n):\n    \"\"\"\n    Args:\n        stmts (Sequence[Statement], optional): A list of statements. Defaults to ().\n        argtypes (Iterable[TypeAttribute], optional): The type of the block arguments. Defaults to ().\n    \"\"\"\n    super().__init__()\n    self._args = tuple(\n        BlockArgument(self, i, argtype) for i, argtype in enumerate(argtypes)\n    )\n\n    self._first_stmt = None\n    self._last_stmt = None\n    self._first_branch = None\n    self._last_branch = None\n    self._stmt_len = 0\n    self.stmts.extend(stmts)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.args","title":"args  <code>property</code>","text":"<pre><code>args: BlockArguments\n</code></pre> <p>Get the  arguments of the Block.</p> <p>Returns:</p> Name Type Description <code>BlockArguments</code> <code>BlockArguments</code> <p>The arguments view of the Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.first_stmt","title":"first_stmt  <code>property</code>","text":"<pre><code>first_stmt: Statement | None\n</code></pre> <p>Get the first Statement of the Block.</p> <p>Returns:</p> Type Description <code>Statement | None</code> <p>Statement | None: The first Statement of the Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.last_stmt","title":"last_stmt  <code>property</code>","text":"<pre><code>last_stmt: Statement | None\n</code></pre> <p>Get the last Statement of the Block.</p> <p>Returns:</p> Type Description <code>Statement | None</code> <p>Statement | None: The last Statement of the Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.parent","title":"parent  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parent: Region | None = field(default=None, repr=False)\n</code></pre> <p>Parent Region of the Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.parent_node","title":"parent_node  <code>property</code> <code>writable</code>","text":"<pre><code>parent_node: Region | None\n</code></pre> <p>Get parent Region of the Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.parent_stmt","title":"parent_stmt  <code>property</code>","text":"<pre><code>parent_stmt: Statement | None\n</code></pre> <p>parent statement of the Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.stmts","title":"stmts  <code>property</code>","text":"<pre><code>stmts: BlockStmts\n</code></pre> <p>Get the list of Statements of the Block.</p> <p>Returns:</p> Name Type Description <code>BlockStmts</code> <code>BlockStmts</code> <p>The Statements of the Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.delete","title":"delete","text":"<pre><code>delete(safe: bool = True) -&gt; None\n</code></pre> <p>Delete the Block completely from the IR.</p> Note <p>This method will detach + remove references of the block.</p> <p>Parameters:</p> Name Type Description Default <code>safe</code> <code>bool</code> <p>If True, raise error if there is anything that still reference components in the block. Defaults to True.</p> <code>True</code> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def delete(self, safe: bool = True) -&gt; None:\n    \"\"\"Delete the Block completely from the IR.\n\n    Note:\n        This method will detach + remove references of the block.\n\n    Args:\n        safe (bool, optional): If True, raise error if there is anything that still reference components in the block. Defaults to True.\n    \"\"\"\n    self.detach()\n    self.drop_all_references()\n    for stmt in self.stmts:\n        stmt.delete(safe=safe)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.detach","title":"detach","text":"<pre><code>detach() -&gt; None\n</code></pre> <p>Detach this Block from the IR.</p> Note <p>Detach only detach the Block from the IR graph. It does not remove uses that reference the Block.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def detach(self) -&gt; None:\n    \"\"\"Detach this Block from the IR.\n\n    Note:\n        Detach only detach the Block from the IR graph. It does not remove uses that reference the Block.\n    \"\"\"\n    if self.parent is None:\n        return\n\n    idx = self.parent[self]\n    del self.parent._blocks[idx]\n    del self.parent._block_idx[self]\n    for block in self.parent._blocks[idx:]:\n        self.parent._block_idx[block] -= 1\n    self.parent = None\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.drop_all_references","title":"drop_all_references","text":"<pre><code>drop_all_references() -&gt; None\n</code></pre> <p>Remove all the dependency that reference/uses this Block.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def drop_all_references(self) -&gt; None:\n    \"\"\"Remove all the dependency that reference/uses this Block.\"\"\"\n    self.parent = None\n    for stmt in self.stmts:\n        stmt.drop_all_references()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.is_structurally_equal","title":"is_structurally_equal","text":"<pre><code>is_structurally_equal(\n    other: Self,\n    context: (\n        dict[IRNode | SSAValue, IRNode | SSAValue] | None\n    ) = None,\n) -&gt; bool\n</code></pre> <p>Check if the Block is structurally equal to another Block.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>The other Block to compare with.</p> required <code>context</code> <code>dict[IRNode | SSAValue, IRNode | SSAValue] | None</code> <p>A map of IRNode/SSAValue to hint that they are equivalent so the check will treat them as equivalent. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the Block is structurally equal to the other Block.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def is_structurally_equal(\n    self,\n    other: Self,\n    context: dict[IRNode | SSAValue, IRNode | SSAValue] | None = None,\n) -&gt; bool:\n    \"\"\"Check if the Block is structurally equal to another Block.\n\n    Args:\n        other (Self): The other Block to compare with.\n        context (dict[IRNode  |  SSAValue, IRNode  |  SSAValue] | None, optional): A map of IRNode/SSAValue to hint that they are equivalent so the check will treat them as equivalent. Defaults to None.\n\n    Returns:\n        bool: True if the Block is structurally equal to the other Block.\n    \"\"\"\n    if context is None:\n        context = {}\n\n    if len(self._args) != len(other._args) or len(self.stmts) != len(other.stmts):\n        return False\n\n    for arg, other_arg in zip(self._args, other._args):\n        if arg.type != other_arg.type:\n            return False\n        context[arg] = other_arg\n\n    context[self] = other\n    if not all(\n        stmt.is_structurally_equal(other_stmt, context)\n        for stmt, other_stmt in zip(self.stmts, other.stmts)\n    ):\n        return False\n\n    return True\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.typecheck","title":"typecheck","text":"<pre><code>typecheck() -&gt; None\n</code></pre> <p>Checking the types of the Statments in the Block.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def typecheck(self) -&gt; None:\n    \"\"\"Checking the types of the Statments in the Block.\"\"\"\n    for stmt in self.stmts:\n        stmt.typecheck()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>Verify the correctness of the Block.</p> <p>Raises:</p> Type Description <code>VerificationError</code> <p>If the Block is not correct.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def verify(self) -&gt; None:\n    \"\"\"Verify the correctness of the Block.\n\n    Raises:\n        VerificationError: If the Block is not correct.\n    \"\"\"\n    from kirin.ir.nodes.stmt import Region\n\n    if not isinstance(self.parent, Region):\n        raise VerificationError(self, \"Parent is not a region\")\n\n    for stmt in self.stmts:\n        stmt.verify()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.Block.walk","title":"walk","text":"<pre><code>walk(\n    *, reverse: bool = False, region_first: bool = False\n) -&gt; Iterator[Statement]\n</code></pre> <p>Traversal the Statements in a Block.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>If walk in the reversed manner. Defaults to False.</p> <code>False</code> <code>region_first</code> <code>bool</code> <p>If the walk should go through the Statement first or the Region of a Statement first. Defaults to False.</p> <code>False</code> <p>Yields:</p> Type Description <code>Statement</code> <p>Iterator[Statement]: An iterator that yield Statements in the Block in the specified order.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def walk(\n    self, *, reverse: bool = False, region_first: bool = False\n) -&gt; Iterator[Statement]:\n    \"\"\"Traversal the Statements in a Block.\n\n    Args:\n        reverse (bool, optional): If walk in the reversed manner. Defaults to False.\n        region_first (bool, optional): If the walk should go through the Statement first or the Region of a Statement first. Defaults to False.\n\n    Yields:\n        Iterator[Statement]: An iterator that yield Statements in the Block in the specified order.\n    \"\"\"\n    for stmt in reversed(self.stmts) if reverse else self.stmts:\n        yield from stmt.walk(reverse=reverse, region_first=region_first)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockArguments","title":"BlockArguments  <code>dataclass</code>","text":"<pre><code>BlockArguments(node: NodeType, field: FieldType)\n</code></pre> <p>               Bases: <code>MutableSequenceView[tuple, 'Block', BlockArgument]</code></p> <p>A View object that contains a list of BlockArgument.</p> Description <p>This is a proxy object that provide safe API to manipulate the arguments of a Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockArguments.append_from","title":"append_from","text":"<pre><code>append_from(\n    typ: TypeAttribute, name: str | None = None\n) -&gt; BlockArgument\n</code></pre> <p>Append a new argument to the Block that this View reference to.</p> Description <p>This method will create a new <code>BlockArgument</code> and append it to the argument list of the reference <code>Block</code>.</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>TypeAttribute</code> <p>The type of the argument.</p> required <code>name</code> <code>str | None</code> <p>name of the argument. Defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>BlockArgument</code> <code>BlockArgument</code> <p>The newly created <code>BlockArgument</code>.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def append_from(self, typ: TypeAttribute, name: str | None = None) -&gt; BlockArgument:\n    \"\"\"Append a new argument to the Block that this View reference to.\n\n    Description:\n        This method will create a new [`BlockArgument`][kirin.ir.BlockArgument] and append it to the argument list\n        of the reference `Block`.\n\n    Args:\n        typ (TypeAttribute): The type of the argument.\n        name (str | None, optional): name of the argument. Defaults to `None`.\n\n    Returns:\n        BlockArgument: The newly created [`BlockArgument`][kirin.ir.BlockArgument].\n\n    \"\"\"\n    new_arg = BlockArgument(self.node, len(self.node._args), typ)\n    if name:\n        new_arg.name = name\n\n    self.node._args += (new_arg,)\n    return new_arg\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockArguments.delete","title":"delete","text":"<pre><code>delete(arg: BlockArgument, safe: bool = True) -&gt; None\n</code></pre> <p>Delete a BlockArgument from the Block that this View reference to.</p> <p>Parameters:</p> Name Type Description Default <code>arg</code> <code>BlockArgument</code> <p>description</p> required <code>safe</code> <code>bool</code> <p>If True, error will be raised if the BlockArgument has any Use by others.  Defaults to True.</p> <code>True</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the argument does not belong to the reference block.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def delete(self, arg: BlockArgument, safe: bool = True) -&gt; None:\n    \"\"\"Delete a BlockArgument from the Block that this View reference to.\n\n\n    Args:\n        arg (BlockArgument): _description_\n        safe (bool, optional): If True, error will be raised if the BlockArgument has any Use by others.  Defaults to True.\n\n    Raises:\n        ValueError: If the argument does not belong to the reference block.\n    \"\"\"\n    if arg.block is not self.node:\n        raise ValueError(\"Attempt to delete an argument that is not in the block\")\n\n    for block_arg in self.field[arg.index + 1 :]:\n        block_arg.index -= 1\n    self.node._args = (*self.field[: arg.index], *self.field[arg.index + 1 :])\n    arg.delete(safe=safe)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockArguments.insert_from","title":"insert_from","text":"<pre><code>insert_from(\n    idx: int, typ: TypeAttribute, name: str | None = None\n) -&gt; BlockArgument\n</code></pre> <p>Insert a new argument to the Block that this View reference to.</p> Description <p>This method will create a new <code>BlockArgument</code> and insert it to the argument list of the reference Block at the specified index</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>Insert location index.</p> required <code>typ</code> <code>TypeAttribute</code> <p>The type of the argument.</p> required <code>name</code> <code>str | None</code> <p>Name of the argument. Defaults to <code>None</code>.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>BlockArgument</code> <code>BlockArgument</code> <p>The newly created BlockArgument.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def insert_from(\n    self, idx: int, typ: TypeAttribute, name: str | None = None\n) -&gt; BlockArgument:\n    \"\"\"Insert a new argument to the Block that this View reference to.\n\n    Description:\n        This method will create a new `BlockArgument` and insert it to the argument list\n        of the reference Block at the specified index\n\n    Args:\n        idx (int): Insert location index.\n        typ (TypeAttribute): The type of the argument.\n        name (str | None, optional): Name of the argument. Defaults to `None`.\n\n    Returns:\n        BlockArgument: The newly created BlockArgument.\n    \"\"\"\n    if idx &lt; 0 or idx &gt; len(self.node._args):\n        raise ValueError(\"Invalid index\")\n\n    new_arg = BlockArgument(self.node, idx, typ)\n    if name:\n        new_arg.name = name\n\n    for arg in self.node._args[idx:]:\n        arg.index += 1\n    self.node._args = self.node._args[:idx] + (new_arg,) + self.node._args[idx:]\n    return new_arg\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockStmtIterator","title":"BlockStmtIterator  <code>dataclass</code>","text":"<pre><code>BlockStmtIterator(next_stmt: Statement | None)\n</code></pre> <p>Proxy object to iterate over the Statements in a Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockStmts","title":"BlockStmts  <code>dataclass</code>","text":"<pre><code>BlockStmts(node: NodeType)\n</code></pre> <p>               Bases: <code>View['Block', 'Statement']</code></p> <p>A View object that contains a list of Statements.</p> Description <p>This is a proxy object that provide safe API to manipulate the statements of a Block.</p>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockStmts.append","title":"append","text":"<pre><code>append(value: Statement) -&gt; None\n</code></pre> <p>Append a Statement to the reference Block.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Statement</code> <p>A Statement to be appended.</p> required Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def append(self, value: Statement) -&gt; None:\n    \"\"\"Append a Statement to the reference Block.\n\n    Args:\n        value (Statement): A Statement to be appended.\n    \"\"\"\n    from kirin.ir.nodes.stmt import Statement\n\n    if not isinstance(value, Statement):\n        raise ValueError(f\"Expected Statement, got {type(value).__name__}\")\n\n    if self.node._stmt_len == 0:  # empty block\n        value.attach(self.node)\n        self.node._first_stmt = value\n        self.node._last_stmt = value\n        self.node._stmt_len += 1\n    elif self.node._last_stmt:\n        value.insert_after(self.node._last_stmt)\n    else:\n        raise ValueError(\"Invalid block, last_stmt is None\")\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockStmts.at","title":"at","text":"<pre><code>at(index: int) -&gt; Statement\n</code></pre> <p>This is similar to getitem but due to the nature of the linked list, it is less efficient than getitem.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the Statement.</p> required <p>Returns:</p> Name Type Description <code>Statement</code> <code>Statement</code> <p>The Statement at the specified index.</p> Source code in <code>src/kirin/ir/nodes/block.py</code> <pre><code>def at(self, index: int) -&gt; Statement:\n    \"\"\"This is similar to __getitem__ but due to the nature of the linked list,\n    it is less efficient than __getitem__.\n\n    Args:\n        index (int): Index of the Statement.\n\n    Returns:\n        Statement: The Statement at the specified index.\n    \"\"\"\n    if index &gt;= len(self):\n        raise IndexError(\"Index out of range\")\n\n    if index &lt; 0:\n        return self._at_reverse(-index - 1)\n\n    return self._at_forward(index)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/block/#kirin.ir.nodes.block.BlockStmtsReverseIterator","title":"BlockStmtsReverseIterator  <code>dataclass</code>","text":"<pre><code>BlockStmtsReverseIterator(next_stmt: Statement | None)\n</code></pre> <p>Proxy object to iterate over the Statements in a Block in reverse order.</p>"},{"location":"reference/kirin/ir/nodes/region/","title":"Region","text":""},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region","title":"Region  <code>dataclass</code>","text":"<pre><code>Region(\n    blocks: Block | Iterable[Block] = (),\n    parent: Statement | None = None,\n)\n</code></pre> <p>               Bases: <code>IRNode['Statement']</code></p> <p>Region consist of a list of Blocks</p> <p>Pretty Printing</p> <p>This object is pretty printable via <code>.print()</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>blocks</code> <code>Block | Iterable[Block]</code> <p>A single <code>Block</code> object or an iterable of Block objects. Defaults to ().</p> <code>()</code> <code>parent</code> <code>Statement | None</code> <p>The parent <code>Statement</code> object. Defaults to None.</p> <code>None</code> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def __init__(\n    self,\n    blocks: Block | Iterable[Block] = (),\n    parent: Statement | None = None,\n):\n    \"\"\"Initialize a Region object.\n\n    Args:\n        blocks (Block | Iterable[Block], optional): A single [`Block`][kirin.ir.Block] object or an iterable of Block objects. Defaults to ().\n        parent (Statement | None, optional): The parent [`Statement`][kirin.ir.Statement] object. Defaults to None.\n    \"\"\"\n    self._blocks = []\n    self._block_idx = {}\n    self.parent_node = parent\n    if isinstance(blocks, Block):\n        blocks = (blocks,)\n    for block in blocks:\n        self.blocks.append(block)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.blocks","title":"blocks  <code>property</code>","text":"<pre><code>blocks: RegionBlocks\n</code></pre> <p>Get the Blocks in the region.</p> <p>Returns:</p> Name Type Description <code>RegionBlocks</code> <code>RegionBlocks</code> <p>The blocks View object of the region.</p>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.parent_node","title":"parent_node  <code>property</code> <code>writable</code>","text":"<pre><code>parent_node: Statement | None\n</code></pre> <p>Get the parent statement of the region.</p>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.region_index","title":"region_index  <code>property</code>","text":"<pre><code>region_index: int\n</code></pre> <p>Get the index of the region within the parent scope.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The index of the region within the parent scope.</p>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(block: Block) -&gt; int\n</code></pre> <p>Get the index of a block within the region.</p> <p>Parameters:</p> Name Type Description Default <code>block</code> <code>Block</code> <p>The block to get the index of.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the block does not belong to the region.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The index of the block within the region.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def __getitem__(self, block: Block) -&gt; int:\n    \"\"\"Get the index of a block within the region.\n\n    Args:\n        block (Block): The block to get the index of.\n\n    Raises:\n        ValueError: If the block does not belong to the region.\n\n    Returns:\n        int: The index of the block within the region.\n    \"\"\"\n    if block.parent is not self:\n        raise ValueError(\"Block does not belong to the region\")\n    return self._block_idx[block]\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.clone","title":"clone","text":"<pre><code>clone(\n    ssamap: dict[SSAValue, SSAValue] | None = None\n) -&gt; Region\n</code></pre> <p>Clone a region. This will clone all blocks and statements in the region. <code>SSAValue</code> defined outside the region will not be cloned unless provided in <code>ssamap</code>.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def clone(self, ssamap: dict[SSAValue, SSAValue] | None = None) -&gt; Region:\n    \"\"\"Clone a region. This will clone all blocks and statements in the region.\n    `SSAValue` defined outside the region will not be cloned unless provided in `ssamap`.\n    \"\"\"\n    ret = Region()\n    successor_map: dict[Block, Block] = {}\n    _ssamap = ssamap or {}\n    for block in self.blocks:\n        new_block = Block()\n        ret.blocks.append(new_block)\n        successor_map[block] = new_block\n        for arg in block.args:\n            new_arg = new_block.args.append_from(arg.type, arg.name)\n            _ssamap[arg] = new_arg\n\n    # update statements\n    for block in self.blocks:\n        for stmt in block.stmts:\n            new_stmt = stmt.from_stmt(\n                stmt,\n                args=[_ssamap[arg] for arg in stmt.args],\n                regions=[region.clone(_ssamap) for region in stmt.regions],\n                successors=[\n                    successor_map[successor] for successor in stmt.successors\n                ],\n            )\n            successor_map[block].stmts.append(new_stmt)\n            for result, new_result in zip(stmt.results, new_stmt.results):\n                _ssamap[result] = new_result\n\n    return ret\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.delete","title":"delete","text":"<pre><code>delete(safe: bool = True) -&gt; None\n</code></pre> <p>Delete the Region completely from the IR graph.</p> Note <p>This method will detach + remove references of the Region.</p> <p>Parameters:</p> Name Type Description Default <code>safe</code> <code>bool</code> <p>If True, raise error if there is anything that still reference components in the Region. Defaults to True.</p> <code>True</code> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def delete(self, safe: bool = True) -&gt; None:\n    \"\"\"Delete the Region completely from the IR graph.\n\n    Note:\n        This method will detach + remove references of the Region.\n\n    Args:\n        safe (bool, optional): If True, raise error if there is anything that still reference components in the Region. Defaults to True.\n    \"\"\"\n    self.detach()\n    self.drop_all_references()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.detach","title":"detach","text":"<pre><code>detach(index: int | None = None) -&gt; None\n</code></pre> <p>Detach this Region from the IR tree graph.</p> Note <p>Detach only detach the Region from the IR graph. It does not remove uses that reference the Region.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def detach(self, index: int | None = None) -&gt; None:\n    \"\"\"Detach this Region from the IR tree graph.\n\n    Note:\n        Detach only detach the Region from the IR graph. It does not remove uses that reference the Region.\n    \"\"\"\n    # already detached\n    if self.parent_node is None:\n        return\n\n    if index is not None:\n        region_idx = index\n    else:\n        region_idx = self.region_index\n\n    del self.parent_node._regions[region_idx]\n    self.parent_node = None\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.drop_all_references","title":"drop_all_references","text":"<pre><code>drop_all_references() -&gt; None\n</code></pre> <p>Remove all the dependency that reference/uses this Region.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def drop_all_references(self) -&gt; None:\n    \"\"\"Remove all the dependency that reference/uses this Region.\"\"\"\n    self.parent_node = None\n    for block in self._blocks:\n        block.drop_all_references()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.is_structurally_equal","title":"is_structurally_equal","text":"<pre><code>is_structurally_equal(\n    other: Self,\n    context: (\n        dict[IRNode | SSAValue, IRNode | SSAValue] | None\n    ) = None,\n) -&gt; bool\n</code></pre> <p>Check if the Region is structurally equal to another Region.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>The other Region to compare with.</p> required <code>context</code> <code>dict[IRNode | SSAValue, IRNode | SSAValue] | None</code> <p>A map of IRNode/SSAValue to hint that they are equivalent so the check will treat them as equivalent. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the Region is structurally equal to the other Region.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def is_structurally_equal(\n    self,\n    other: Self,\n    context: dict[IRNode | SSAValue, IRNode | SSAValue] | None = None,\n) -&gt; bool:\n    \"\"\"Check if the Region is structurally equal to another Region.\n\n    Args:\n        other (Self): The other Region to compare with.\n        context (dict[IRNode  |  SSAValue, IRNode  |  SSAValue] | None, optional): A map of IRNode/SSAValue to hint that they are equivalent so the check will treat them as equivalent. Defaults to None.\n\n    Returns:\n        bool: True if the Region is structurally equal to the other Region.\n    \"\"\"\n    if context is None:\n        context = {}\n\n    if len(self.blocks) != len(other.blocks):\n        return False\n\n    for block, other_block in zip(self.blocks, other.blocks):\n        context[block] = other_block\n\n    if not all(\n        block.is_structurally_equal(other_block, context)\n        for block, other_block in zip(self.blocks, other.blocks)\n    ):\n        return False\n\n    return True\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.stmts","title":"stmts","text":"<pre><code>stmts() -&gt; Iterator[Statement]\n</code></pre> <p>Iterate over all the Statements in the Region. This does not walk into nested Regions.</p> <p>Yields:</p> Type Description <code>Statement</code> <p>Iterator[Statement]: An iterator that yield Statements of Blocks in the Region.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def stmts(self) -&gt; Iterator[Statement]:\n    \"\"\"Iterate over all the Statements in the Region. This does not walk into nested Regions.\n\n    Yields:\n        Iterator[Statement]: An iterator that yield Statements of Blocks in the Region.\n    \"\"\"\n    for block in self.blocks:\n        yield from block.stmts\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.typecheck","title":"typecheck","text":"<pre><code>typecheck() -&gt; None\n</code></pre> <p>Checking the types of the Statments of Blocks in the Region.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def typecheck(self) -&gt; None:\n    \"\"\"Checking the types of the Statments of Blocks in the Region.\"\"\"\n    for block in self.blocks:\n        block.typecheck()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>Verify the correctness of the Region.</p> <p>Raises:</p> Type Description <code>VerificationError</code> <p>If the Region is not correct.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def verify(self) -&gt; None:\n    \"\"\"Verify the correctness of the Region.\n\n    Raises:\n        VerificationError: If the Region is not correct.\n    \"\"\"\n    from kirin.ir.nodes.stmt import Statement\n\n    if not isinstance(self.parent_node, Statement):\n        raise VerificationError(\n            self, \"expect Region to have a parent of type Statement\"\n        )\n\n    for block in self.blocks:\n        block.verify()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.Region.walk","title":"walk","text":"<pre><code>walk(\n    *, reverse: bool = False, region_first: bool = False\n) -&gt; Iterator[Statement]\n</code></pre> <p>Traversal the Statements of Blocks in the Region.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>If walk in the reversed manner. Defaults to False.</p> <code>False</code> <code>region_first</code> <code>bool</code> <p>If the walk should go through the Statement first or the Region of a Statement first. Defaults to False.</p> <code>False</code> <p>Yields:</p> Type Description <code>Statement</code> <p>Iterator[Statement]: An iterator that yield Statements of Blocks in the Region, in the specified order.</p> Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def walk(\n    self, *, reverse: bool = False, region_first: bool = False\n) -&gt; Iterator[Statement]:\n    \"\"\"Traversal the Statements of Blocks in the Region.\n\n    Args:\n        reverse (bool, optional): If walk in the reversed manner. Defaults to False.\n        region_first (bool, optional): If the walk should go through the Statement first or the Region of a Statement first. Defaults to False.\n\n    Yields:\n        Iterator[Statement]: An iterator that yield Statements of Blocks in the Region, in the specified order.\n    \"\"\"\n    for block in reversed(self.blocks) if reverse else self.blocks:\n        yield from block.walk(reverse=reverse, region_first=region_first)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.RegionBlocks","title":"RegionBlocks  <code>dataclass</code>","text":"<pre><code>RegionBlocks(node: NodeType, field: FieldType)\n</code></pre> <p>               Bases: <code>MutableSequenceView[list[Block], 'Region', Block]</code></p> <p>A View object that contains a list of Blocks of a Region.</p> Description <p>This is a proxy object that provide safe API to manipulate the Blocks of a Region.</p>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.RegionBlocks.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(\n    idx: int | slice,\n    block_or_blocks: Block | Iterable[Block],\n) -&gt; None\n</code></pre> <p>Replace/Set the Blocks of the Region.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int | slice</code> <p>The index or slice to replace the <code>Blocks</code>.</p> required <code>block_or_blocks</code> <code>Block | Iterable[Block]</code> <p>The Block or Blocks to replace the Blocks.</p> required Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def __setitem__(\n    self, idx: int | slice, block_or_blocks: Block | Iterable[Block]\n) -&gt; None:\n    \"\"\"Replace/Set the Blocks of the Region.\n\n    Args:\n        idx (int | slice): The index or slice to replace the [`Blocks`][kirin.ir.Block].\n        block_or_blocks (Block | Iterable[Block]): The Block or Blocks to replace the Blocks.\n\n    \"\"\"\n    if isinstance(idx, int) and isinstance(block_or_blocks, Block):\n        self.field[idx].detach()\n        block_or_blocks.attach(self.node)\n        self.field[idx] = block_or_blocks\n        self.node._block_idx[block_or_blocks] = idx\n    elif isinstance(idx, slice) and isinstance(block_or_blocks, Iterable):\n        for block in block_or_blocks:\n            block.attach(self.node)\n        self.field[idx] = block_or_blocks\n        self.node._block_idx = {\n            block: i for i, block in enumerate(self.field)\n        }  # reindex\n    else:\n        raise ValueError(\"Invalid assignment\")\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.RegionBlocks.append","title":"append","text":"<pre><code>append(value: Block) -&gt; None\n</code></pre> <p>Append a Block to the Region.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Block</code> <p>The block to be appended.</p> required Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def append(self, value: Block) -&gt; None:\n    \"\"\"Append a Block to the Region.\n\n    Args:\n        value (Block): The block to be appended.\n    \"\"\"\n    value.attach(self.node)\n    self.node._block_idx[value] = len(self.field)\n    self.field.append(value)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/region/#kirin.ir.nodes.region.RegionBlocks.insert","title":"insert","text":"<pre><code>insert(idx: int, value: Block) -&gt; None\n</code></pre> <p>Inserts a Block at the specified index.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>The index at which to insert the block.</p> required <code>value</code> <code>Block</code> <p>The block to be inserted.</p> required Source code in <code>src/kirin/ir/nodes/region.py</code> <pre><code>def insert(self, idx: int, value: Block) -&gt; None:\n    \"\"\"Inserts a Block at the specified index.\n\n    Args:\n        idx (int): The index at which to insert the block.\n        value (Block): The block to be inserted.\n    \"\"\"\n    value.attach(self.node)\n    self.field.insert(idx, value)\n    for i, value in enumerate(self.field[idx:], idx):\n        self.node._block_idx[value] = i\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/","title":"Stmt","text":""},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.ArgumentList","title":"ArgumentList  <code>dataclass</code>","text":"<pre><code>ArgumentList(node: NodeType, field: FieldType)\n</code></pre> <p>               Bases: <code>MutableSequenceView[tuple, 'Statement', SSAValue]</code>, <code>Printable</code></p> <p>A View object that contains a list of Arguemnts of a Statement.</p> Description <p>This is a proxy object that provide safe API to manipulate the arguemnts of a statement.</p> <p>Pretty Printing</p> <p>This object is pretty printable via <code>.print()</code> method.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.ArgumentList.get_slice","title":"get_slice","text":"<pre><code>get_slice(name: str) -&gt; slice\n</code></pre> <p>Get the slice of the arguments.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the slice.</p> required <p>Returns:</p> Name Type Description <code>slice</code> <code>slice</code> <p>The slice of the arguments.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def get_slice(self, name: str) -&gt; slice:\n    \"\"\"Get the slice of the arguments.\n\n    Args:\n        name (str): The name of the slice.\n\n    Returns:\n        slice: The slice of the arguments.\n    \"\"\"\n    index = self.node._name_args_slice[name]\n    if isinstance(index, int):\n        return slice(index, index + 1)\n    return index\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.ArgumentList.insert","title":"insert","text":"<pre><code>insert(idx: int, value: SSAValue) -&gt; None\n</code></pre> <p>Insert the argument SSAValue at the specified index.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>The index to insert the value.</p> required <code>value</code> <code>SSAValue</code> <p>The value to insert.</p> required Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def insert(self, idx: int, value: SSAValue) -&gt; None:\n    \"\"\"Insert the argument SSAValue at the specified index.\n\n    Args:\n        idx (int): The index to insert the value.\n        value (SSAValue): The value to insert.\n    \"\"\"\n    args = self.field\n    value.add_use(Use(self.node, idx))\n    new_args = (*args[:idx], value, *args[idx:])\n    self.node._args = new_args\n    self.field = new_args\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.ArgumentList.set_item","title":"set_item","text":"<pre><code>set_item(idx: int, value: SSAValue) -&gt; None\n</code></pre> <p>Set the argument SSAVAlue at the specified index.</p> <p>Parameters:</p> Name Type Description Default <code>idx</code> <code>int</code> <p>The index of the item to set.</p> required <code>value</code> <code>SSAValue</code> <p>The value to set.</p> required Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def set_item(self, idx: int, value: SSAValue) -&gt; None:\n    \"\"\"Set the argument SSAVAlue at the specified index.\n\n    Args:\n        idx (int): The index of the item to set.\n        value (SSAValue): The value to set.\n    \"\"\"\n    args = self.field\n    args[idx].remove_use(Use(self.node, idx))\n    value.add_use(Use(self.node, idx))\n    new_args = (*args[:idx], value, *args[idx + 1 :])\n    self.node._args = new_args\n    self.field = new_args\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.ResultList","title":"ResultList  <code>dataclass</code>","text":"<pre><code>ResultList(node: NodeType, field: FieldType)\n</code></pre> <p>               Bases: <code>MutableSequenceView[list, 'Statement', ResultValue]</code></p> <p>A View object that contains a list of ResultValue of a Statement.</p> Description <p>This is a proxy object that provide safe API to manipulate the result values of a statement</p> <p>Pretty Printing</p> <p>This object is pretty printable via <code>.print()</code> method.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.ResultList.types","title":"types  <code>property</code>","text":"<pre><code>types: Sequence[TypeAttribute]\n</code></pre> <p>Get the result types of the Statement.</p> <p>Returns:</p> Type Description <code>Sequence[TypeAttribute]</code> <p>Sequence[TypeAttribute]: type of each result value.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement","title":"Statement  <code>dataclass</code>","text":"<pre><code>Statement(\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None\n)\n</code></pre> <p>               Bases: <code>IRNode['Block']</code></p> <p>The Statment is an instruction in the IR</p> <p>Pretty Printing</p> <p>This object is pretty printable via <code>.print()</code> method.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def __init__(\n    self,\n    *,\n    args: Sequence[SSAValue] = (),\n    regions: Sequence[Region] = (),\n    successors: Sequence[Block] = (),\n    attributes: Mapping[str, Attribute] = {},\n    properties: Mapping[str, Attribute] = {},\n    results: Sequence[ResultValue] = (),\n    result_types: Sequence[TypeAttribute] = (),\n    args_slice: Mapping[str, int | slice] = {},\n    source: SourceInfo | None = None,\n) -&gt; None:\n    super().__init__()\n    \"\"\"Initialize the Statement.\n\n    Args:\n        arsg (Sequence[SSAValue], optional): The arguments of the Statement. Defaults to ().\n        regions (Sequence[Region], optional): The regions where the Statement belong to. Defaults to ().\n        successors (Sequence[Block], optional): The successors of the Statement. Defaults to ().\n        attributes (Mapping[str, Attribute], optional): The attributes of the Statement. Defaults to {}.\n        results (Sequence[ResultValue], optional): The result values of the Statement. Defaults to ().\n        result_types (Sequence[TypeAttribute], optional): The result types of the Statement. Defaults to ().\n        args_slice (Mapping[str, int | slice], optional): The arguments slice of the Statement. Defaults to {}.\n        source (SourceInfo | None, optional): The source information of the Statement for debugging/stacktracing. Defaults to None.\n\n    \"\"\"\n    self._args = ()\n    self._regions = []\n    self._name_args_slice = dict(args_slice)\n    self.source = source\n    self.args = args\n\n    if results:\n        self._results = list(results)\n        assert (\n            len(result_types) == 0\n        ), \"expect either results or result_types specified, got both\"\n\n    if result_types:\n        self._results = [\n            ResultValue(self, idx, type=type)\n            for idx, type in enumerate(result_types)\n        ]\n\n    if not results and not result_types:\n        self._results = list(results)\n\n    self.successors = list(successors)\n    self.properties = dict(properties)\n    self.attributes = dict(attributes)\n    self.regions = list(regions)\n\n    self.parent = None\n    self._next_stmt = None\n    self._prev_stmt = None\n    self.__post_init__()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.args","title":"args  <code>instance-attribute</code> <code>property</code> <code>writable</code>","text":"<pre><code>args: ArgumentList = args\n</code></pre> <p>Get the arguments of the Statement.</p> <p>Returns:</p> Name Type Description <code>ArgumentList</code> <code>ArgumentList</code> <p>The arguments View of the Statement.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.next_stmt","title":"next_stmt  <code>property</code> <code>writable</code>","text":"<pre><code>next_stmt: Statement | None\n</code></pre> <p>Get the next statement.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.parent_block","title":"parent_block  <code>property</code>","text":"<pre><code>parent_block: Block | None\n</code></pre> <p>Get the parent Block.</p> <p>Returns:</p> Type Description <code>Block | None</code> <p>Block | None: The parent Block.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.parent_node","title":"parent_node  <code>property</code> <code>writable</code>","text":"<pre><code>parent_node: Block | None\n</code></pre> <p>Get the parent node.</p> <p>Returns:</p> Type Description <code>Block | None</code> <p>Block | None: The parent node.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.parent_region","title":"parent_region  <code>property</code>","text":"<pre><code>parent_region: Region | None\n</code></pre> <p>Get the parent Region. Returns:     Region | None: The parent Region.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.parent_stmt","title":"parent_stmt  <code>property</code>","text":"<pre><code>parent_stmt: Statement | None\n</code></pre> <p>Get the parent statement.</p> <p>Returns:</p> Type Description <code>Statement | None</code> <p>Statement | None: The parent statement.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.prev_stmt","title":"prev_stmt  <code>property</code> <code>writable</code>","text":"<pre><code>prev_stmt: Statement | None\n</code></pre> <p>Get the previous statement.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.regions","title":"regions  <code>instance-attribute</code> <code>property</code> <code>writable</code>","text":"<pre><code>regions: list[Region] = list(regions)\n</code></pre> <p>Get a list of regions of the Statement.</p> <p>Returns:</p> Type Description <code>list[Region]</code> <p>list[Region]: The list of regions of the Statement.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.results","title":"results  <code>property</code>","text":"<pre><code>results: ResultList\n</code></pre> <p>Get the result values of the Statement.</p> <p>Returns:</p> Name Type Description <code>ResultList</code> <code>ResultList</code> <p>The result values View of the Statement.</p>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.delete","title":"delete","text":"<pre><code>delete(safe: bool = True) -&gt; None\n</code></pre> <p>Delete the Statement completely from the IR graph.</p> Note <p>This method will detach + remove references of the Statement.</p> <p>Parameters:</p> Name Type Description Default <code>safe</code> <code>bool</code> <p>If True, raise error if there is anything that still reference components in the Statement. Defaults to True.</p> <code>True</code> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def delete(self, safe: bool = True) -&gt; None:\n    \"\"\"Delete the Statement completely from the IR graph.\n\n    Note:\n        This method will detach + remove references of the Statement.\n\n    Args:\n        safe (bool, optional): If True, raise error if there is anything that still reference components in the Statement. Defaults to True.\n    \"\"\"\n    self.detach()\n    self.drop_all_references()\n    for result in self._results:\n        result.delete(safe=safe)\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.detach","title":"detach","text":"<pre><code>detach() -&gt; None\n</code></pre> <p>detach the statement from its parent block.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def detach(self) -&gt; None:\n    \"\"\"detach the statement from its parent block.\"\"\"\n    if self.parent is None:\n        return\n\n    parent: Block = self.parent\n    prev_stmt = self.prev_stmt\n    next_stmt = self.next_stmt\n\n    if prev_stmt is not None:\n        prev_stmt._next_stmt = next_stmt\n        self._prev_stmt = None\n    else:\n        assert (\n            parent._first_stmt is self\n        ), \"Invalid statement, has no prev_stmt but not first_stmt\"\n        parent._first_stmt = next_stmt\n\n    if next_stmt is not None:\n        next_stmt._prev_stmt = prev_stmt\n        self._next_stmt = None\n    else:\n        assert (\n            parent._last_stmt is self\n        ), \"Invalid statement, has no next_stmt but not last_stmt\"\n        parent._last_stmt = prev_stmt\n\n    self.parent = None\n    parent._stmt_len -= 1\n    return\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.drop_all_references","title":"drop_all_references","text":"<pre><code>drop_all_references() -&gt; None\n</code></pre> <p>Remove all the dependency that reference/uses this Statement.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def drop_all_references(self) -&gt; None:\n    \"\"\"Remove all the dependency that reference/uses this Statement.\"\"\"\n    self.parent = None\n    for idx, arg in enumerate(self._args):\n        arg.remove_use(Use(self, idx))\n    for region in self._regions:\n        region.drop_all_references()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.expect_one_result","title":"expect_one_result","text":"<pre><code>expect_one_result() -&gt; ResultValue\n</code></pre> <p>Check if the statement contain only one result, and return it</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def expect_one_result(self) -&gt; ResultValue:\n    \"\"\"Check if the statement contain only one result, and return it\"\"\"\n    if len(self._results) != 1:\n        raise ValueError(f\"expected one result, got {len(self._results)}\")\n    return self._results[0]\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.from_stmt","title":"from_stmt  <code>classmethod</code>","text":"<pre><code>from_stmt(\n    other: Statement,\n    args: Sequence[SSAValue] | None = None,\n    regions: list[Region] | None = None,\n    successors: list[Block] | None = None,\n    attributes: dict[str, Attribute] | None = None,\n) -&gt; Self\n</code></pre> <p>Create a similar Statement with new <code>ResultValue</code> and without attaching to any parent block. This still references to the old successor and regions.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>@classmethod\ndef from_stmt(\n    cls,\n    other: Statement,\n    args: Sequence[SSAValue] | None = None,\n    regions: list[Region] | None = None,\n    successors: list[Block] | None = None,\n    attributes: dict[str, Attribute] | None = None,\n) -&gt; Self:\n    \"\"\"Create a similar Statement with new `ResultValue` and without\n    attaching to any parent block. This still references to the old successor\n    and regions.\n    \"\"\"\n    obj = cls.__new__(cls)\n    Statement.__init__(\n        obj,\n        args=args or other._args,\n        regions=regions or other._regions,\n        successors=successors or other.successors,\n        attributes=attributes or other.attributes,\n        properties=other.properties,  # properties are immutable, thus no need to copy\n        result_types=[result.type for result in other._results],\n        args_slice=other._name_args_slice,\n    )\n    return obj\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.get_attr_or_prop","title":"get_attr_or_prop","text":"<pre><code>get_attr_or_prop(key: str) -&gt; Attribute | None\n</code></pre> <p>Get the attribute or property of the Statement.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the attribute or property.</p> required <p>Returns:</p> Type Description <code>Attribute | None</code> <p>Attribute | None: The attribute or property of the Statement.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def get_attr_or_prop(self, key: str) -&gt; Attribute | None:\n    \"\"\"Get the attribute or property of the Statement.\n\n    Args:\n        key (str): The key of the attribute or property.\n\n    Returns:\n        Attribute | None: The attribute or property of the Statement.\n    \"\"\"\n    return self.attributes.get(key, self.properties.get(key))\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.get_trait","title":"get_trait  <code>classmethod</code>","text":"<pre><code>get_trait(trait: type[TraitType]) -&gt; TraitType | None\n</code></pre> <p>Get the trait of the Statement.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>@classmethod\ndef get_trait(cls, trait: type[TraitType]) -&gt; TraitType | None:\n    \"\"\"Get the trait of the Statement.\"\"\"\n    for t in cls.traits:\n        if isinstance(t, trait):\n            return t\n    return None\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.has_trait","title":"has_trait  <code>classmethod</code>","text":"<pre><code>has_trait(trait_type: type[StmtTrait]) -&gt; bool\n</code></pre> <p>Check if the Statement has a specific trait.</p> <p>Parameters:</p> Name Type Description Default <code>trait_type</code> <code>type[StmtTrait]</code> <p>The type of trait to check for.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the class has the specified trait, False otherwise.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>@classmethod\ndef has_trait(cls, trait_type: type[StmtTrait]) -&gt; bool:\n    \"\"\"Check if the Statement has a specific trait.\n\n    Args:\n        trait_type (type[StmtTrait]): The type of trait to check for.\n\n    Returns:\n        bool: True if the class has the specified trait, False otherwise.\n    \"\"\"\n    for trait in cls.traits:\n        if isinstance(trait, trait_type):\n            return True\n    return False\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.insert_after","title":"insert_after","text":"<pre><code>insert_after(stmt: Statement) -&gt; None\n</code></pre> <p>Insert the current Statement after the input Statement.</p> <p>Parameters:</p> Name Type Description Default <code>stmt</code> <code>Statement</code> <p>Input Statement.</p> required Example <p>The following example demonstrates how to insert a Statement after another Statement. After <code>insert_after</code> is called, <code>stmt1</code> will be inserted after <code>stmt2</code>, which appears in IR in the order (stmt2 -&gt; stmt1) <pre><code>stmt1 = Statement()\nstmt2 = Statement()\nstmt1.insert_after(stmt2)\n</code></pre></p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def insert_after(self, stmt: Statement) -&gt; None:\n    \"\"\"Insert the current Statement after the input Statement.\n\n    Args:\n        stmt (Statement): Input Statement.\n\n    Example:\n        The following example demonstrates how to insert a Statement after another Statement.\n        After `insert_after` is called, `stmt1` will be inserted after `stmt2`, which appears in IR in the order (stmt2 -&gt; stmt1)\n        ```python\n        stmt1 = Statement()\n        stmt2 = Statement()\n        stmt1.insert_after(stmt2)\n        ```\n    \"\"\"\n    if self._next_stmt is not None and self._prev_stmt is not None:\n        raise ValueError(\n            f\"Cannot insert before a statement that is already in a block: {self.name}\"\n        )\n\n    if stmt._next_stmt is not None:\n        stmt._next_stmt._prev_stmt = self\n\n    self._prev_stmt = stmt\n    self._next_stmt = stmt._next_stmt\n\n    self.parent = stmt.parent\n    stmt._next_stmt = self\n\n    if self.parent:\n        self.parent._stmt_len += 1\n\n        if self._next_stmt is None:\n            self.parent._last_stmt = self\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.insert_before","title":"insert_before","text":"<pre><code>insert_before(stmt: Statement) -&gt; None\n</code></pre> <p>Insert the current Statement before the input Statement.</p> <p>Parameters:</p> Name Type Description Default <code>stmt</code> <code>Statement</code> <p>Input Statement.</p> required Example <p>The following example demonstrates how to insert a Statement before another Statement. After <code>insert_before</code> is called, <code>stmt1</code> will be inserted before <code>stmt2</code>, which appears in IR in the order (stmt1 -&gt; stmt2) <pre><code>stmt1 = Statement()\nstmt2 = Statement()\nstmt1.insert_before(stmt2)\n</code></pre></p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def insert_before(self, stmt: Statement) -&gt; None:\n    \"\"\"Insert the current Statement before the input Statement.\n\n    Args:\n        stmt (Statement): Input Statement.\n\n    Example:\n        The following example demonstrates how to insert a Statement before another Statement.\n        After `insert_before` is called, `stmt1` will be inserted before `stmt2`, which appears in IR in the order (stmt1 -&gt; stmt2)\n        ```python\n        stmt1 = Statement()\n        stmt2 = Statement()\n        stmt1.insert_before(stmt2)\n        ```\n    \"\"\"\n    if self._next_stmt is not None and self._prev_stmt is not None:\n        raise ValueError(\n            f\"Cannot insert before a statement that is already in a block: {self.name}\"\n        )\n\n    if stmt._prev_stmt is not None:\n        stmt._prev_stmt._next_stmt = self\n\n    self._next_stmt = stmt\n    self._prev_stmt = stmt._prev_stmt\n\n    self.parent = stmt.parent\n    stmt._prev_stmt = self\n\n    if self.parent:\n        self.parent._stmt_len += 1\n\n        if self._prev_stmt is None:\n            self.parent._first_stmt = self\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.is_structurally_equal","title":"is_structurally_equal","text":"<pre><code>is_structurally_equal(\n    other: Self,\n    context: (\n        dict[IRNode | SSAValue, IRNode | SSAValue] | None\n    ) = None,\n) -&gt; bool\n</code></pre> <p>Check if the Statement is structurally equal to another Statement.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>The other Statelemt to compare with.</p> required <code>context</code> <code>dict[IRNode | SSAValue, IRNode | SSAValue] | None</code> <p>A map of IRNode/SSAValue to hint that they are equivalent so the check will treat them as equivalent. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the IRNode is structurally equal to the other.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def is_structurally_equal(\n    self,\n    other: Self,\n    context: dict[IRNode | SSAValue, IRNode | SSAValue] | None = None,\n) -&gt; bool:\n    \"\"\"Check if the Statement is structurally equal to another Statement.\n\n    Args:\n        other (Self): The other Statelemt to compare with.\n        context (dict[IRNode  |  SSAValue, IRNode  |  SSAValue] | None, optional): A map of IRNode/SSAValue to hint that they are equivalent so the check will treat them as equivalent. Defaults to None.\n\n    Returns:\n        bool: True if the IRNode is structurally equal to the other.\n    \"\"\"\n    if context is None:\n        context = {}\n\n    if self.name != other.name:\n        return False\n\n    if (\n        len(self.args) != len(other.args)\n        or len(self.regions) != len(other.regions)\n        or len(self.successors) != len(other.successors)\n        or self.attributes != other.attributes\n        or self.properties != other.properties\n    ):\n        return False\n\n    if (\n        self.parent is not None\n        and other.parent is not None\n        and context.get(self.parent) != other.parent\n    ):\n        return False\n\n    if not all(\n        context.get(arg, arg) == other_arg\n        for arg, other_arg in zip(self.args, other.args)\n    ):\n        return False\n\n    if not all(\n        context.get(successor, successor) == other_successor\n        for successor, other_successor in zip(self.successors, other.successors)\n    ):\n        return False\n\n    if not all(\n        region.is_structurally_equal(other_region, context)\n        for region, other_region in zip(self.regions, other.regions)\n    ):\n        return False\n\n    for result, other_result in zip(self._results, other._results):\n        context[result] = other_result\n\n    return True\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.replace_by","title":"replace_by","text":"<pre><code>replace_by(stmt: Statement) -&gt; None\n</code></pre> <p>Replace the current Statement by the input Statement.</p> <p>Parameters:</p> Name Type Description Default <code>stmt</code> <code>Statement</code> <p>Input Statement.</p> required Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def replace_by(self, stmt: Statement) -&gt; None:\n    \"\"\"Replace the current Statement by the input Statement.\n\n    Args:\n        stmt (Statement): Input Statement.\n    \"\"\"\n    stmt.insert_before(self)\n    for result, old_result in zip(stmt._results, self._results):\n        old_result.replace_by(result)\n        if old_result.name:\n            result.name = old_result.name\n    self.delete()\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.typecheck","title":"typecheck","text":"<pre><code>typecheck() -&gt; None\n</code></pre> <p>check the type of the statement.</p> Note <ol> <li>Statement should implement typecheck. this is done automatically via @statement, but in the case manualy implementation is needed, it should be implemented here.</li> <li>This API should be called after all the types are figured out (by typeinfer)</li> </ol> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def typecheck(self) -&gt; None:\n    \"\"\"check the type of the statement.\n\n    Note:\n        1. Statement should implement typecheck.\n        this is done automatically via @statement, but\n        in the case manualy implementation is needed,\n        it should be implemented here.\n        2. This API should be called after all the types are figured out (by typeinfer)\n\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>run mandatory validation checks. This is not same as typecheck, which may be optional.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def verify(self) -&gt; None:\n    return\n</code></pre>"},{"location":"reference/kirin/ir/nodes/stmt/#kirin.ir.nodes.stmt.Statement.walk","title":"walk","text":"<pre><code>walk(\n    *,\n    reverse: bool = False,\n    region_first: bool = False,\n    include_self: bool = True\n) -&gt; Iterator[Statement]\n</code></pre> <p>Traversal the Statements of Regions.</p> <p>Parameters:</p> Name Type Description Default <code>reverse</code> <code>bool</code> <p>If walk in the reversed manner. Defaults to False.</p> <code>False</code> <code>region_first</code> <code>bool</code> <p>If the walk should go through the Statement first or the Region of a Statement first. Defaults to False.</p> <code>False</code> <code>include_self</code> <code>bool</code> <p>If the walk should include the Statement itself. Defaults to True.</p> <code>True</code> <p>Yields:</p> Type Description <code>Statement</code> <p>Iterator[Statement]: An iterator that yield Statements of Blocks in the Region, in the specified order.</p> Source code in <code>src/kirin/ir/nodes/stmt.py</code> <pre><code>def walk(\n    self,\n    *,\n    reverse: bool = False,\n    region_first: bool = False,\n    include_self: bool = True,\n) -&gt; Iterator[Statement]:\n    \"\"\"Traversal the Statements of Regions.\n\n    Args:\n        reverse (bool, optional): If walk in the reversed manner. Defaults to False.\n        region_first (bool, optional): If the walk should go through the Statement first or the Region of a Statement first. Defaults to False.\n        include_self (bool, optional): If the walk should include the Statement itself. Defaults to True.\n\n    Yields:\n        Iterator[Statement]: An iterator that yield Statements of Blocks in the Region, in the specified order.\n    \"\"\"\n    if include_self and not region_first:\n        yield self\n\n    for region in reversed(self.regions) if reverse else self.regions:\n        yield from region.walk(reverse=reverse, region_first=region_first)\n\n    if include_self and region_first:\n        yield self\n</code></pre>"},{"location":"reference/kirin/ir/nodes/view/","title":"View","text":""},{"location":"reference/kirin/ir/nodes/view/#kirin.ir.nodes.view.MutableSequenceView","title":"MutableSequenceView  <code>dataclass</code>","text":"<pre><code>MutableSequenceView(node: NodeType, field: FieldType)\n</code></pre> <p>               Bases: <code>SequenceView[FieldType, NodeType, ElemType]</code></p>"},{"location":"reference/kirin/ir/nodes/view/#kirin.ir.nodes.view.MutableSequenceView.popfirst","title":"popfirst","text":"<pre><code>popfirst() -&gt; ElemType | None\n</code></pre> <p>Pop the first element from the view.</p> <p>Returns:</p> Type Description <code>ElemType | None</code> <p>The first element in the view.</p> Source code in <code>src/kirin/ir/nodes/view.py</code> <pre><code>def popfirst(self) -&gt; ElemType | None:\n    \"\"\"Pop the first element from the view.\n\n    Returns:\n        The first element in the view.\n    \"\"\"\n    if self:\n        return self.pop(0)\n    return None\n</code></pre>"},{"location":"reference/kirin/ir/nodes/view/#kirin.ir.nodes.view.MutableSequenceView.poplast","title":"poplast","text":"<pre><code>poplast() -&gt; ElemType | None\n</code></pre> <p>Pop the last element from the view.</p> <p>Returns:</p> Type Description <code>ElemType | None</code> <p>The last element in the view.</p> Source code in <code>src/kirin/ir/nodes/view.py</code> <pre><code>def poplast(self) -&gt; ElemType | None:\n    \"\"\"Pop the last element from the view.\n\n    Returns:\n        The last element in the view.\n    \"\"\"\n    if self:\n        return self.pop(-1)\n    return None\n</code></pre>"},{"location":"reference/kirin/ir/traits/","title":"Index","text":"<p>Kirin IR Traits.</p> <p>This module defines the traits that can be used to define the behavior of Kirin IR nodes. The base trait is <code>StmtTrait</code>, which is a <code>dataclass</code> that implements the <code>__hash__</code> and <code>__eq__</code> methods.</p> <p>There are also some basic traits that are provided for convenience, such as <code>Pure</code>, <code>HasParent</code>, <code>ConstantLike</code>, <code>IsTerminator</code>, <code>NoTerminator</code>, and <code>IsolatedFromAbove</code>.</p>"},{"location":"reference/kirin/ir/traits/abc/","title":"Abc","text":""},{"location":"reference/kirin/ir/traits/abc/#kirin.ir.traits.abc.PythonLoweringTrait","title":"PythonLoweringTrait  <code>dataclass</code>","text":"<pre><code>PythonLoweringTrait()\n</code></pre> <p>               Bases: <code>StmtTrait</code>, <code>Generic[StatementType, ASTNode]</code></p> <p>A trait that indicates that a statement can be lowered from Python AST.</p>"},{"location":"reference/kirin/ir/traits/abc/#kirin.ir.traits.abc.RegionTrait","title":"RegionTrait  <code>dataclass</code>","text":"<pre><code>RegionTrait()\n</code></pre> <p>               Bases: <code>StmtTrait</code>, <code>Generic[GraphType]</code></p> <p>A trait that indicates the properties of the statement's region.</p>"},{"location":"reference/kirin/ir/traits/abc/#kirin.ir.traits.abc.StmtTrait","title":"StmtTrait  <code>dataclass</code>","text":"<pre><code>StmtTrait()\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Base class for all statement traits.</p>"},{"location":"reference/kirin/ir/traits/basic/","title":"Basic","text":""},{"location":"reference/kirin/ir/traits/basic/#kirin.ir.traits.basic.ConstantLike","title":"ConstantLike  <code>dataclass</code>","text":"<pre><code>ConstantLike()\n</code></pre> <p>               Bases: <code>StmtTrait</code></p> <p>A trait that indicates that a statement is constant-like, i.e., it represents a constant value.</p>"},{"location":"reference/kirin/ir/traits/basic/#kirin.ir.traits.basic.HasParent","title":"HasParent  <code>dataclass</code>","text":"<pre><code>HasParent(parents: tuple[type[Statement]])\n</code></pre> <p>               Bases: <code>StmtTrait</code></p> <p>A trait that indicates that a statement has a parent statement.</p>"},{"location":"reference/kirin/ir/traits/basic/#kirin.ir.traits.basic.IsTerminator","title":"IsTerminator  <code>dataclass</code>","text":"<pre><code>IsTerminator()\n</code></pre> <p>               Bases: <code>StmtTrait</code></p> <p>A trait that indicates that a statement is a terminator, i.e., it terminates a block.</p>"},{"location":"reference/kirin/ir/traits/basic/#kirin.ir.traits.basic.NoTerminator","title":"NoTerminator  <code>dataclass</code>","text":"<pre><code>NoTerminator()\n</code></pre> <p>               Bases: <code>StmtTrait</code></p> <p>A trait that indicates that the region of a statement has no terminator.</p>"},{"location":"reference/kirin/ir/traits/basic/#kirin.ir.traits.basic.Pure","title":"Pure  <code>dataclass</code>","text":"<pre><code>Pure()\n</code></pre> <p>               Bases: <code>StmtTrait</code></p> <p>A trait that indicates that a statement is pure, i.e., it has no side effects.</p>"},{"location":"reference/kirin/ir/traits/callable/","title":"Callable","text":""},{"location":"reference/kirin/ir/traits/callable/#kirin.ir.traits.callable.CallableStmtInterface","title":"CallableStmtInterface  <code>dataclass</code>","text":"<pre><code>CallableStmtInterface()\n</code></pre> <p>               Bases: <code>StmtTrait</code>, <code>Generic[StmtType]</code></p> <p>A trait that indicates that a statement is a callable statement.</p> <p>A callable statement is a statement that can be called as a function.</p>"},{"location":"reference/kirin/ir/traits/callable/#kirin.ir.traits.callable.CallableStmtInterface.get_callable_region","title":"get_callable_region  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>get_callable_region(stmt: StmtType) -&gt; Region\n</code></pre> <p>Returns the body of the callable region</p> Source code in <code>src/kirin/ir/traits/callable.py</code> <pre><code>@classmethod\n@abstractmethod\ndef get_callable_region(cls, stmt: \"StmtType\") -&gt; \"Region\":\n    \"\"\"Returns the body of the callable region\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/ir/traits/callable/#kirin.ir.traits.callable.HasSignature","title":"HasSignature  <code>dataclass</code>","text":"<pre><code>HasSignature()\n</code></pre> <p>               Bases: <code>StmtTrait</code>, <code>ABC</code></p> <p>A trait that indicates that a statement has a function signature attribute.</p>"},{"location":"reference/kirin/ir/traits/symbol/","title":"Symbol","text":""},{"location":"reference/kirin/ir/traits/symbol/#kirin.ir.traits.symbol.SymbolOpInterface","title":"SymbolOpInterface  <code>dataclass</code>","text":"<pre><code>SymbolOpInterface()\n</code></pre> <p>               Bases: <code>StmtTrait</code></p> <p>A trait that indicates that a statement is a symbol operation.</p> <p>A symbol operation is a statement that has a symbol name attribute.</p>"},{"location":"reference/kirin/ir/traits/symbol/#kirin.ir.traits.symbol.SymbolTable","title":"SymbolTable  <code>dataclass</code>","text":"<pre><code>SymbolTable()\n</code></pre> <p>               Bases: <code>StmtTrait</code></p> <p>Statement with SymbolTable trait can only have one region with one block.</p>"},{"location":"reference/kirin/ir/traits/lowering/","title":"Index","text":"<p>Lowering traits for the IR.</p>"},{"location":"reference/kirin/ir/traits/lowering/call/","title":"Call","text":""},{"location":"reference/kirin/ir/traits/lowering/call/#kirin.ir.traits.lowering.call.FromPythonCall","title":"FromPythonCall  <code>dataclass</code>","text":"<pre><code>FromPythonCall()\n</code></pre> <p>               Bases: <code>PythonLoweringTrait[StatementType, Call]</code></p> <p>Trait for customizing lowering of Python calls to a statement.</p> <p>Declared in a statement definition to indicate that the statement can be constructed from a Python call (i.e., a function call <code>ast.Call</code> in the Python AST).</p> <p>Subclassing this trait allows for customizing the lowering of Python calls to the statement. The <code>lower</code> method should be implemented to parse the arguments from the Python call and construct the statement instance.</p>"},{"location":"reference/kirin/ir/traits/lowering/context/","title":"Context","text":"<p>Traits for customizing lowering of Python <code>with</code> syntax to a statement.</p>"},{"location":"reference/kirin/ir/traits/lowering/context/#kirin.ir.traits.lowering.context.FromPythonWith","title":"FromPythonWith  <code>dataclass</code>","text":"<pre><code>FromPythonWith()\n</code></pre> <p>               Bases: <code>PythonLoweringTrait[StatementType, With]</code></p> <p>Trait for customizing lowering of Python with statements to a statement.</p> <p>Subclassing this trait allows for customizing the lowering of Python with statements to the statement. The <code>lower</code> method should be implemented to parse the arguments from the Python with statement and construct the statement instance.</p>"},{"location":"reference/kirin/ir/traits/lowering/context/#kirin.ir.traits.lowering.context.FromPythonWithSingleItem","title":"FromPythonWithSingleItem  <code>dataclass</code>","text":"<pre><code>FromPythonWithSingleItem()\n</code></pre> <p>               Bases: <code>FromPythonWith[StatementType]</code></p> <p>Trait for customizing lowering of the following Python with syntax to a statement:</p> <pre><code>with &lt;stmt&gt;[ as &lt;name&gt;]:\n    &lt;body&gt;\n</code></pre> <p>where <code>&lt;stmt&gt;</code> is the statement being lowered, <code>&lt;name&gt;</code> is an optional name for the result of the statement, and <code>&lt;body&gt;</code> is the body of the with statement. The optional <code>as &lt;name&gt;</code> is not valid when the statement has no results.</p> <p>This syntax is slightly different from the standard Python <code>with</code> statement in that <code>&lt;name&gt;</code> refers to the result of the statement, not the context manager. Thus typically one sould access <code>&lt;name&gt;</code> in <code>&lt;body&gt;</code> to use the result of the statement.</p> <p>In some cases, however, <code>&lt;name&gt;</code> may be used as a reference of a special value <code>self</code> that is passed to the <code>&lt;body&gt;</code> of the statement. This is useful for statements that have a similar behavior to a closure.</p>"},{"location":"reference/kirin/ir/traits/region/","title":"Index","text":"<p>Builtin region traits.</p>"},{"location":"reference/kirin/ir/traits/region/ssacfg/","title":"Ssacfg","text":"<p>SSACFG region trait.</p> <p>This module defines the SSACFGRegion trait, which is used to indicate that a region has an SSACFG graph.</p>"},{"location":"reference/kirin/lattice/","title":"Index","text":""},{"location":"reference/kirin/lattice/abc/","title":"Lattice","text":""},{"location":"reference/kirin/lattice/abc/#kirin.lattice.abc.Lattice","title":"Lattice","text":"<p>               Bases: <code>ABC</code>, <code>Generic[LatticeType]</code></p> <p>ABC for lattices as Python class.</p> <p>While <code>Lattice</code> is only an interface, <code>LatticeABC</code> is an abstract class that can be inherited from. This provides a few default implementations for the lattice operations.</p>"},{"location":"reference/kirin/lattice/abc/#kirin.lattice.abc.Lattice.is_equal","title":"is_equal","text":"<pre><code>is_equal(other: LatticeType) -&gt; bool\n</code></pre> <p>Check if two lattices are equal.</p> Source code in <code>src/kirin/lattice/abc.py</code> <pre><code>def is_equal(self, other: LatticeType) -&gt; bool:\n    \"\"\"Check if two lattices are equal.\"\"\"\n    if self is other:\n        return True\n    else:\n        return self.is_subseteq(other) and other.is_subseteq(self)\n</code></pre>"},{"location":"reference/kirin/lattice/abc/#kirin.lattice.abc.Lattice.is_subseteq","title":"is_subseteq  <code>abstractmethod</code>","text":"<pre><code>is_subseteq(other: LatticeType) -&gt; bool\n</code></pre> <p>Subseteq operation.</p> Source code in <code>src/kirin/lattice/abc.py</code> <pre><code>@abstractmethod\ndef is_subseteq(self, other: LatticeType) -&gt; bool:\n    \"\"\"Subseteq operation.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/lattice/abc/#kirin.lattice.abc.Lattice.join","title":"join  <code>abstractmethod</code>","text":"<pre><code>join(other: LatticeType) -&gt; LatticeType\n</code></pre> <p>Join operation.</p> Source code in <code>src/kirin/lattice/abc.py</code> <pre><code>@abstractmethod\ndef join(self, other: LatticeType) -&gt; LatticeType:\n    \"\"\"Join operation.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/lattice/abc/#kirin.lattice.abc.Lattice.meet","title":"meet  <code>abstractmethod</code>","text":"<pre><code>meet(other: LatticeType) -&gt; LatticeType\n</code></pre> <p>Meet operation.</p> Source code in <code>src/kirin/lattice/abc.py</code> <pre><code>@abstractmethod\ndef meet(self, other: LatticeType) -&gt; LatticeType:\n    \"\"\"Meet operation.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/kirin/lattice/abc/#kirin.lattice.abc.SingletonMeta","title":"SingletonMeta","text":"<pre><code>SingletonMeta(name, bases, attrs)\n</code></pre> <p>               Bases: <code>LatticeMeta</code></p> <p>Singleton metaclass for lattices. It ensures that only one instance of a lattice is created.</p> <p>See https://stackoverflow.com/questions/674304/why-is-init-always-called-after-new/8665179#8665179</p> Source code in <code>src/kirin/lattice/abc.py</code> <pre><code>def __init__(cls, name, bases, attrs):\n    super().__init__(name, bases, attrs)\n    cls._instance = None\n</code></pre>"},{"location":"reference/kirin/lattice/abc/#kirin.lattice.abc.UnionMeta","title":"UnionMeta","text":"<p>               Bases: <code>LatticeMeta</code></p> <p>Meta class for union types. It simplifies the union if possible.</p>"},{"location":"reference/kirin/lattice/empty/","title":"Empty","text":""},{"location":"reference/kirin/lattice/empty/#kirin.lattice.empty.EmptyLattice","title":"EmptyLattice","text":"<p>               Bases: <code>BoundedLattice['EmptyLattice']</code></p> <p>Empty lattice.</p>"},{"location":"reference/kirin/lattice/empty/#kirin.lattice.empty.EmptyLattice.is_subseteq","title":"is_subseteq","text":"<pre><code>is_subseteq(other: EmptyLattice) -&gt; bool\n</code></pre> <p>Subseteq operation.</p> Source code in <code>src/kirin/lattice/empty.py</code> <pre><code>def is_subseteq(self, other: \"EmptyLattice\") -&gt; bool:\n    return True\n</code></pre>"},{"location":"reference/kirin/lattice/empty/#kirin.lattice.empty.EmptyLattice.join","title":"join","text":"<pre><code>join(other: EmptyLattice) -&gt; EmptyLattice\n</code></pre> <p>Join operation.</p> Source code in <code>src/kirin/lattice/empty.py</code> <pre><code>def join(self, other: \"EmptyLattice\") -&gt; \"EmptyLattice\":\n    return self\n</code></pre>"},{"location":"reference/kirin/lattice/empty/#kirin.lattice.empty.EmptyLattice.meet","title":"meet","text":"<pre><code>meet(other: EmptyLattice) -&gt; EmptyLattice\n</code></pre> <p>Meet operation.</p> Source code in <code>src/kirin/lattice/empty.py</code> <pre><code>def meet(self, other: \"EmptyLattice\") -&gt; \"EmptyLattice\":\n    return self\n</code></pre>"},{"location":"reference/kirin/lattice/mixin/","title":"Mixin","text":""},{"location":"reference/kirin/lattice/mixin/#kirin.lattice.mixin.IsSubsetEqMixin","title":"IsSubsetEqMixin","text":"<p>               Bases: <code>BoundedLattice[BoundedLatticeType]</code></p> <p>A special mixin for lattices that provides a default implementation for <code>is_subseteq</code> by using the visitor pattern. This is useful if the lattice has a lot of different subclasses that need to be compared.</p> <p>Must be used before <code>BoundedLattice</code> in the inheritance chain.</p>"},{"location":"reference/kirin/lattice/mixin/#kirin.lattice.mixin.IsSubsetEqMixin.is_subseteq","title":"is_subseteq","text":"<pre><code>is_subseteq(other: BoundedLatticeType) -&gt; bool\n</code></pre> <p>Subseteq operation.</p> Source code in <code>src/kirin/lattice/mixin.py</code> <pre><code>def is_subseteq(self, other: BoundedLatticeType) -&gt; bool:\n    if other is self.top():\n        return True\n    elif other is self.bottom():\n        return False\n\n    method = getattr(\n        self,\n        \"is_subseteq_\" + other.__class__.__name__,\n        getattr(self, \"is_subseteq_fallback\", None),\n    )\n    if method is not None:\n        return method(other)\n    return False\n</code></pre>"},{"location":"reference/kirin/lattice/mixin/#kirin.lattice.mixin.SimpleJoinMixin","title":"SimpleJoinMixin","text":"<p>               Bases: <code>BoundedLattice[BoundedLatticeType]</code></p> <p>A mixin that provides a simple implementation for the join operation.</p>"},{"location":"reference/kirin/lattice/mixin/#kirin.lattice.mixin.SimpleJoinMixin.join","title":"join","text":"<pre><code>join(other: BoundedLatticeType) -&gt; BoundedLatticeType\n</code></pre> <p>Join operation.</p> Source code in <code>src/kirin/lattice/mixin.py</code> <pre><code>def join(self, other: BoundedLatticeType) -&gt; BoundedLatticeType:\n    if self.is_subseteq(other):\n        return other\n    elif other.is_subseteq(self):\n        return self  # type: ignore\n    return self.top()\n</code></pre>"},{"location":"reference/kirin/lattice/mixin/#kirin.lattice.mixin.SimpleMeetMixin","title":"SimpleMeetMixin","text":"<p>               Bases: <code>BoundedLattice[BoundedLatticeType]</code></p> <p>A mixin that provides a simple implementation for the meet operation.</p>"},{"location":"reference/kirin/lattice/mixin/#kirin.lattice.mixin.SimpleMeetMixin.meet","title":"meet","text":"<pre><code>meet(other: BoundedLatticeType) -&gt; BoundedLatticeType\n</code></pre> <p>Meet operation.</p> Source code in <code>src/kirin/lattice/mixin.py</code> <pre><code>def meet(self, other: BoundedLatticeType) -&gt; BoundedLatticeType:\n    if self.is_subseteq(other):\n        return self  # type: ignore\n    elif other.is_subseteq(self):\n        return other\n    return self.bottom()\n</code></pre>"},{"location":"reference/kirin/lowering/","title":"Index","text":""},{"location":"reference/kirin/lowering/binding/","title":"Binding","text":""},{"location":"reference/kirin/lowering/binding/#kirin.lowering.binding.wraps","title":"wraps","text":"<pre><code>wraps(parent: type[Statement])\n</code></pre> <p>Wraps a <code>Statement</code> to a <code>Binding</code> object which will be special cased in the lowering process.</p> <p>This is useful for providing type hints by faking the call signature of a <code>Statement</code>.</p>"},{"location":"reference/kirin/lowering/binding/#kirin.lowering.binding.wraps--example","title":"Example","text":"<p>Directly writing a function with the statement will let Python linter think you intend to call the constructor of the statement class. However, given the context of a kernel, our intention is to actually \"call\" the statement, e.g the following will produce type errors with pyright or mypy:</p> <pre><code>from kirin.dialects import math\nfrom kirin.prelude import basic_no_opt\n\n@basic_no_opt\ndef main(x: float):\n    return math.sin(x) # this is a statement, not a function\n</code></pre> <p>the <code>@lowering.wraps</code> decorator allows us to provide a type hint for the statement, e.g:</p> <pre><code>from kirin import lowering\n\n@lowering.wraps(math.sin)\ndef sin(value: float) -&gt; float: ...\n\n@basic_no_opt\ndef main(x: float):\n    return sin(x) # linter now thinks this is a function\n\nsin(1.0) # this will raise a NotImplementedError(\"Binding of sin can only be called from a kernel\")\n</code></pre> Source code in <code>src/kirin/lowering/binding.py</code> <pre><code>def wraps(parent: type[\"Statement\"]):\n    \"\"\"Wraps a [`Statement`][kirin.ir.nodes.stmt.Statement] to a `Binding` object\n    which will be special cased in the lowering process.\n\n    This is useful for providing type hints by faking the call signature of a\n    [`Statement`][kirin.ir.nodes.stmt.Statement].\n\n    ## Example\n\n    Directly writing a function with the statement will let Python linter think\n    you intend to call the constructor of the statement class. However, given the\n    context of a kernel, our intention is to actually \"call\" the statement, e.g\n    the following will produce type errors with pyright or mypy:\n\n    ```python\n    from kirin.dialects import math\n    from kirin.prelude import basic_no_opt\n\n    @basic_no_opt\n    def main(x: float):\n        return math.sin(x) # this is a statement, not a function\n    ```\n\n    the `@lowering.wraps` decorator allows us to provide a type hint for the\n    statement, e.g:\n\n    ```python\n    from kirin import lowering\n\n    @lowering.wraps(math.sin)\n    def sin(value: float) -&gt; float: ...\n\n    @basic_no_opt\n    def main(x: float):\n        return sin(x) # linter now thinks this is a function\n\n    sin(1.0) # this will raise a NotImplementedError(\"Binding of sin can only be called from a kernel\")\n    ```\n    \"\"\"\n\n    def wrapper(func: Callable[Params, RetType]) -&gt; Binding[Params, RetType]:\n        return Binding(parent)\n\n    return wrapper\n</code></pre>"},{"location":"reference/kirin/lowering/core/","title":"Core","text":""},{"location":"reference/kirin/lowering/dialect/","title":"Dialect","text":""},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.FromPythonAST","title":"FromPythonAST","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.FromPythonAST.lower","title":"lower","text":"<pre><code>lower(state: LoweringState, node: ast.AST) -&gt; Result\n</code></pre> <p>Entry point of dialect specific lowering.</p> Source code in <code>src/kirin/lowering/dialect.py</code> <pre><code>def lower(self, state: LoweringState, node: ast.AST) -&gt; Result:\n    \"\"\"Entry point of dialect specific lowering.\"\"\"\n    return getattr(self, f\"lower_{node.__class__.__name__}\", self.unreachable)(\n        state, node\n    )\n</code></pre>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.Method","title":"Method  <code>dataclass</code>","text":"<pre><code>Method(\n    mod: ModuleType | None,\n    py_func: Callable[Param, RetType] | None,\n    sym_name: str,\n    arg_names: list[str],\n    dialects: DialectGroup,\n    code: Statement,\n    fields: tuple = tuple(),\n    file: str = \"\",\n    inferred: bool = False,\n    verified: bool = False,\n)\n</code></pre> <p>               Bases: <code>Printable</code>, <code>Generic[Param, RetType]</code></p>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.Method.inferred","title":"inferred  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inferred: bool = False\n</code></pre> <p>if typeinfer has been run on this method</p>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.Method.verified","title":"verified  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>verified: bool = False\n</code></pre> <p>if <code>code.verify</code> has been run on this method</p>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.Method.verify","title":"verify","text":"<pre><code>verify() -&gt; None\n</code></pre> <p>verify the method body.</p> Source code in <code>src/kirin/ir/method.py</code> <pre><code>def verify(self) -&gt; None:\n    \"\"\"verify the method body.\"\"\"\n    try:\n        self.code.verify()\n    except VerificationError as e:\n        msg = f'File \"{self.file}\"'\n        if isinstance(e.node, Statement):\n            if e.node.source:\n                msg += f\", line {e.node.source.lineno}\"\n            msg += f\", in {e.node.name}\"\n\n        msg += f\":\\n    Verification failed for {self.sym_name}: {e.args[0]}\"\n        raise Exception(msg) from e\n    self.verified = True\n    return\n</code></pre>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.SSAValue","title":"SSAValue  <code>dataclass</code>","text":"<pre><code>SSAValue()\n</code></pre> <p>               Bases: <code>ABC</code>, <code>Printable</code></p> <p>Base class for all SSA values in the IR.</p>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.SSAValue.name","title":"name  <code>property</code> <code>writable</code>","text":"<pre><code>name: str | None\n</code></pre> <p>The name of this SSA value.</p>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.SSAValue.name_pattern","title":"name_pattern  <code>class-attribute</code>","text":"<pre><code>name_pattern: Pattern[str] = compile(\n    \"([A-Za-z_$.-][\\\\w$.-]*)\"\n)\n</code></pre> <p>The pattern that the name of this SSA value must match.</p>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.SSAValue.owner","title":"owner  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>owner: Statement | Block\n</code></pre> <p>The object that owns this SSA value.</p>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.SSAValue.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type: TypeAttribute = field(\n    default_factory=AnyType, init=False, repr=True\n)\n</code></pre> <p>The type of this SSA value.</p>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.SSAValue.uses","title":"uses  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>uses: set[Use] = field(\n    init=False, default_factory=set, repr=False\n)\n</code></pre> <p>The uses of this SSA value.</p>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.SSAValue.add_use","title":"add_use","text":"<pre><code>add_use(use: Use) -&gt; Self\n</code></pre> <p>Add a use to this SSA value.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def add_use(self, use: Use) -&gt; Self:\n    \"\"\"Add a use to this SSA value.\"\"\"\n    self.uses.add(use)\n    return self\n</code></pre>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.SSAValue.delete","title":"delete","text":"<pre><code>delete(safe: bool = True) -&gt; None\n</code></pre> <p>Delete this SSA value. If <code>safe</code> is <code>True</code>, raise an error if there are uses.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def delete(self, safe: bool = True) -&gt; None:\n    \"\"\"Delete this SSA value. If `safe` is `True`, raise an error if there are uses.\"\"\"\n    if safe and len(self.uses) &gt; 0:\n        raise ValueError(\"Cannot delete SSA value with uses\")\n    self.replace_by(DeletedSSAValue(self))\n</code></pre>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.SSAValue.remove_use","title":"remove_use","text":"<pre><code>remove_use(use: Use) -&gt; Self\n</code></pre> <p>Remove a use from this SSA value.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def remove_use(self, use: Use) -&gt; Self:\n    \"\"\"Remove a use from this SSA value.\"\"\"\n    # print(use)\n    # assert use in self.uses, \"Use not found\"\n    if use in self.uses:\n        self.uses.remove(use)\n    return self\n</code></pre>"},{"location":"reference/kirin/lowering/dialect/#kirin.lowering.dialect.SSAValue.replace_by","title":"replace_by","text":"<pre><code>replace_by(other: SSAValue) -&gt; None\n</code></pre> <p>Replace this SSA value with another SSA value. Update all uses.</p> Source code in <code>src/kirin/ir/ssa.py</code> <pre><code>def replace_by(self, other: SSAValue) -&gt; None:\n    \"\"\"Replace this SSA value with another SSA value. Update all uses.\"\"\"\n    for use in self.uses.copy():\n        use.stmt.args[use.index] = other\n\n    if other.name is None and self.name is not None:\n        other.name = self.name\n\n    assert len(self.uses) == 0, \"Uses not empty\"\n</code></pre>"},{"location":"reference/kirin/lowering/frame/","title":"Frame","text":""},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame","title":"Frame  <code>dataclass</code>","text":"<pre><code>Frame(\n    state: LoweringState,\n    parent: Optional[Frame],\n    stream: StmtStream[ast.stmt],\n    curr_region: Region,\n    entr_block: Block,\n    curr_block: Block,\n    next_block: Block,\n    defs: dict[str, SSAValue] = dict(),\n    globals: dict[str, Any] = dict(),\n    captures: dict[str, SSAValue] = dict(),\n    capture_callback: Optional[CallbackFn] = None,\n)\n</code></pre>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.capture_callback","title":"capture_callback  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>capture_callback: Optional[CallbackFn] = None\n</code></pre> <p>callback function that creates a local SSAValue value when an captured value was used.</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.captures","title":"captures  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>captures: dict[str, SSAValue] = field(default_factory=dict)\n</code></pre> <p>values accessed from the parent frame</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.curr_block","title":"curr_block  <code>instance-attribute</code>","text":"<pre><code>curr_block: Block\n</code></pre> <p>current block being lowered</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.curr_region","title":"curr_region  <code>instance-attribute</code>","text":"<pre><code>curr_region: Region\n</code></pre> <p>current region being lowered</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.defs","title":"defs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>defs: dict[str, SSAValue] = field(default_factory=dict)\n</code></pre> <p>values defined in the current frame</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.entr_block","title":"entr_block  <code>instance-attribute</code>","text":"<pre><code>entr_block: Block\n</code></pre> <p>entry block of the frame region</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.globals","title":"globals  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>globals: dict[str, Any] = field(default_factory=dict)\n</code></pre> <p>global values known to the current frame</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.next_block","title":"next_block  <code>instance-attribute</code>","text":"<pre><code>next_block: Block\n</code></pre> <p>next block to be lowered, but not yet inserted in the region</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.parent","title":"parent  <code>instance-attribute</code>","text":"<pre><code>parent: Optional[Frame]\n</code></pre> <p>parent frame, if any</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.state","title":"state  <code>instance-attribute</code>","text":"<pre><code>state: LoweringState\n</code></pre> <p>lowering state</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.stream","title":"stream  <code>instance-attribute</code>","text":"<pre><code>stream: StmtStream[stmt]\n</code></pre> <p>stream of statements to be lowered</p>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.append_block","title":"append_block","text":"<pre><code>append_block(block: Block | None = None)\n</code></pre> <p>Append a block to the current region.</p> <p>Parameters:</p> Name Type Description Default <code>block(Block)</code> <p>block to append, default <code>None</code> to create a new block.</p> required Source code in <code>src/kirin/lowering/frame.py</code> <pre><code>def append_block(self, block: Block | None = None):\n    \"\"\"Append a block to the current region.\n\n    Args:\n        block(Block): block to append, default `None` to create a new block.\n    \"\"\"\n    block = block or Block()\n    self.curr_region.blocks.append(block)\n    self.curr_block = block\n    return block\n</code></pre>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.from_stmts","title":"from_stmts  <code>classmethod</code>","text":"<pre><code>from_stmts(\n    stmts: Sequence[ast.stmt] | StmtStream[ast.stmt],\n    state: LoweringState,\n    parent: Optional[Frame] = None,\n    region: Optional[Region] = None,\n    entr_block: Optional[Block] = None,\n    next_block: Optional[Block] = None,\n    globals: dict[str, Any] | None = None,\n    capture_callback: Optional[CallbackFn] = None,\n)\n</code></pre> <p>Create a new frame from a list of statements or a new <code>StmtStream</code>.</p> <ul> <li><code>stmts</code>: list of statements or a <code>StmtStream</code> to be lowered.</li> <li><code>region</code>: <code>Region</code> to append the new block to, <code>None</code> to create a new one, default <code>None</code>.</li> <li><code>entr_block</code>: <code>Block</code> to append the new statements to,     <code>None</code> to create a new one and attached to the region, default <code>None</code>.</li> <li><code>next_block</code>: <code>Block</code> to use if branching to a new block, if <code>None</code> to create     a new one without attaching to the region. (note: this should not attach to     the region at frame construction)</li> <li><code>globals</code>: global variables, default <code>None</code>.</li> </ul> Source code in <code>src/kirin/lowering/frame.py</code> <pre><code>@classmethod\ndef from_stmts(\n    cls,\n    stmts: Sequence[ast.stmt] | StmtStream[ast.stmt],\n    state: \"LoweringState\",\n    parent: Optional[\"Frame\"] = None,\n    region: Optional[Region] = None,\n    entr_block: Optional[Block] = None,\n    next_block: Optional[Block] = None,\n    globals: dict[str, Any] | None = None,\n    capture_callback: Optional[CallbackFn] = None,\n):\n    \"\"\"Create a new frame from a list of statements or a new `StmtStream`.\n\n    - `stmts`: list of statements or a `StmtStream` to be lowered.\n    - `region`: `Region` to append the new block to, `None` to create a new one, default `None`.\n    - `entr_block`: `Block` to append the new statements to,\n        `None` to create a new one and attached to the region, default `None`.\n    - `next_block`: `Block` to use if branching to a new block, if `None` to create\n        a new one without attaching to the region. (note: this should not attach to\n        the region at frame construction)\n    - `globals`: global variables, default `None`.\n    \"\"\"\n    if not isinstance(stmts, StmtStream):\n        stmts = StmtStream(stmts)\n\n    region = region or Region()\n\n    entr_block = entr_block or Block()\n    region.blocks.append(entr_block)\n\n    return cls(\n        state=state,\n        parent=parent,\n        stream=stmts,\n        curr_region=region or Region(entr_block),\n        entr_block=entr_block,\n        curr_block=entr_block,\n        next_block=next_block or Block(),\n        globals=globals or {},\n        capture_callback=capture_callback,\n    )\n</code></pre>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.get_scope","title":"get_scope","text":"<pre><code>get_scope(name: str)\n</code></pre> <p>Get a variable from current scope.</p> <p>Parameters:</p> Name Type Description Default <code>name(str)</code> <p>variable name</p> required <p>Returns:</p> Name Type Description <code>SSAValue</code> <p>the value of the variable</p> <p>Raises:</p> Type Description <code>DialectLoweringError</code> <p>if the variable is not found in the scope, or if the variable has multiple possible values.</p> Source code in <code>src/kirin/lowering/frame.py</code> <pre><code>def get_scope(self, name: str):\n    \"\"\"Get a variable from current scope.\n\n    Args:\n        name(str): variable name\n\n    Returns:\n        SSAValue: the value of the variable\n\n    Raises:\n        DialectLoweringError: if the variable is not found in the scope,\n            or if the variable has multiple possible values.\n    \"\"\"\n    value = self.defs.get(name)\n    if isinstance(value, SSAValue):\n        return value\n    else:\n        raise DialectLoweringError(f\"Variable {name} not found in scope\")\n</code></pre>"},{"location":"reference/kirin/lowering/frame/#kirin.lowering.frame.Frame.jump_next","title":"jump_next","text":"<pre><code>jump_next()\n</code></pre> <p>Jump to the next block and return it. This appends the current <code>Frame.next_block</code> to the current region and creates a new Block for <code>next_block</code>.</p> <p>Returns:</p> Name Type Description <code>Block</code> <p>the next block</p> Source code in <code>src/kirin/lowering/frame.py</code> <pre><code>def jump_next(self):\n    \"\"\"Jump to the next block and return it.\n    This appends the current `Frame.next_block` to the current region\n    and creates a new Block for `next_block`.\n\n    Returns:\n        Block: the next block\n    \"\"\"\n    block = self.append_block(self.next_block)\n    self.next_block = Block()\n    return block\n</code></pre>"},{"location":"reference/kirin/lowering/result/","title":"Result","text":""},{"location":"reference/kirin/lowering/state/","title":"State","text":""},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.LoweringState","title":"LoweringState  <code>dataclass</code>","text":"<pre><code>LoweringState(\n    dialects: DialectGroup,\n    registry: dict[str, FromPythonAST],\n    lines: list[str],\n    lineno_offset: int,\n    col_offset: int,\n    source: SourceInfo,\n    max_lines: int = 3,\n    _current_frame: Frame | None = None,\n)\n</code></pre> <p>               Bases: <code>NodeVisitor</code></p>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.LoweringState.col_offset","title":"col_offset  <code>instance-attribute</code>","text":"<pre><code>col_offset: int\n</code></pre> <p>column offset at the beginning of the source</p>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.LoweringState.lineno_offset","title":"lineno_offset  <code>instance-attribute</code>","text":"<pre><code>lineno_offset: int\n</code></pre> <p>lineno offset at the beginning of the source</p>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.LoweringState.source","title":"source  <code>instance-attribute</code>","text":"<pre><code>source: SourceInfo\n</code></pre> <p>source info of the current node</p>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.LoweringState.append_stmt","title":"append_stmt","text":"<pre><code>append_stmt(stmt: StmtType) -&gt; StmtType\n</code></pre> <p>Shorthand for appending a statement to the current block of current frame.</p> Source code in <code>src/kirin/lowering/state.py</code> <pre><code>def append_stmt(self, stmt: StmtType) -&gt; StmtType:\n    \"\"\"Shorthand for appending a statement to the current block of current frame.\"\"\"\n    return self.current_frame.append_stmt(stmt)\n</code></pre>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.LoweringState.default_Call_lower","title":"default_Call_lower","text":"<pre><code>default_Call_lower(\n    stmt: type[Statement], node: ast.Call\n) -&gt; Result\n</code></pre> <p>Default lowering for Python call to statement.</p> <p>This method is intended to be used by traits like <code>FromPythonCall</code> to provide a default lowering for Python calls to statements.</p> <p>Parameters:</p> Name Type Description Default <code>stmt(type[Statement])</code> <p>Statement class to construct.</p> required <code>node(ast.Call)</code> <p>Python call node to lower.</p> required <p>Returns:</p> Name Type Description <code>Result</code> <code>Result</code> <p>Result of lowering the Python call to statement.</p> Source code in <code>src/kirin/lowering/state.py</code> <pre><code>def default_Call_lower(self, stmt: type[Statement], node: ast.Call) -&gt; Result:\n    \"\"\"Default lowering for Python call to statement.\n\n    This method is intended to be used by traits like `FromPythonCall` to\n    provide a default lowering for Python calls to statements.\n\n    Args:\n        stmt(type[Statement]): Statement class to construct.\n        node(ast.Call): Python call node to lower.\n\n    Returns:\n        Result: Result of lowering the Python call to statement.\n    \"\"\"\n    args, kwargs = self.default_Call_inputs(stmt, node)\n    return Result(self.append_stmt(stmt(*args.values(), **kwargs)))\n</code></pre>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.LoweringState.exhaust","title":"exhaust","text":"<pre><code>exhaust(frame: Frame | None = None) -&gt; Frame\n</code></pre> <p>Exhaust given frame's stream. If not given, exhaust current frame's stream.</p> Source code in <code>src/kirin/lowering/state.py</code> <pre><code>def exhaust(self, frame: Frame | None = None) -&gt; Frame:\n    \"\"\"Exhaust given frame's stream. If not given, exhaust current frame's stream.\"\"\"\n    if not frame:\n        current_frame = self.current_frame\n    else:\n        current_frame = frame\n\n    stream = current_frame.stream\n    while stream.has_next():\n        stmt = stream.pop()\n        self.visit(stmt)\n    return current_frame\n</code></pre>"},{"location":"reference/kirin/lowering/state/#kirin.lowering.state.LoweringState.pop_frame","title":"pop_frame","text":"<pre><code>pop_frame(finalize_next: bool = True)\n</code></pre> <p>Pop the current frame and return it.</p> <p>Parameters:</p> Name Type Description Default <code>finalize_next(bool)</code> <p>If True, append the next block of the current frame.</p> required <p>Returns:</p> Name Type Description <code>Frame</code> <p>The popped frame.</p> Source code in <code>src/kirin/lowering/state.py</code> <pre><code>def pop_frame(self, finalize_next: bool = True):\n    \"\"\"Pop the current frame and return it.\n\n    Args:\n        finalize_next(bool): If True, append the next block of the current frame.\n\n    Returns:\n        Frame: The popped frame.\n    \"\"\"\n    if self._current_frame is None:\n        raise ValueError(\"No frame to pop\")\n    frame = self._current_frame\n\n    if finalize_next and frame.next_block.parent is None:\n        frame.append_block(frame.next_block)\n    self._current_frame = frame.parent\n    return frame\n</code></pre>"},{"location":"reference/kirin/lowering/stream/","title":"Stream","text":""},{"location":"reference/kirin/passes/","title":"Index","text":""},{"location":"reference/kirin/passes/abc/","title":"Abc","text":""},{"location":"reference/kirin/passes/abc/#kirin.passes.abc.Pass","title":"Pass  <code>dataclass</code>","text":"<pre><code>Pass(dialects: DialectGroup)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>A pass is a transformation that is applied to a method. It wraps the analysis and rewrites needed to transform the method as an independent unit.</p> <p>Unlike LLVM/MLIR passes, a pass in Kirin does not apply to a module, this is because we focus on individual methods defined within python modules. This is a design choice to allow seamless integration within the Python interpreter.</p> <p>A Kirin compile unit is a <code>ir.Method</code> object, which is always equivalent to a LLVM/MLIR module if it were lowered to LLVM/MLIR just like other JIT compilers.</p>"},{"location":"reference/kirin/passes/fold/","title":"Fold","text":""},{"location":"reference/kirin/passes/inline/","title":"Inline","text":""},{"location":"reference/kirin/passes/typeinfer/","title":"Typeinfer","text":""},{"location":"reference/kirin/passes/aggressive/","title":"Index","text":""},{"location":"reference/kirin/passes/aggressive/fold/","title":"Fold","text":""},{"location":"reference/kirin/print/","title":"Index","text":"<p>Pretty printing utilities.</p> <p>This module provides a pretty printing utility for the IR nodes and other objects in the compiler.</p> <p>The pretty printing utility is implemented using the visitor pattern. The <code>Printable</code> class is the base class for all objects that can be pretty printed.</p> <p>The <code>Printer</code> class is the visitor that traverses the object and prints the object to a string. The <code>Printer</code> class provides methods for printing different types of objects.</p>"},{"location":"reference/kirin/print/printable/","title":"Printable","text":""},{"location":"reference/kirin/print/printable/#kirin.print.printable.Printable","title":"Printable","text":"<p>Base class for all objects that can be pretty printed.</p> <p>This class provides an interface for pretty printing objects. The <code>print</code> method is the entry point for the printing process. The <code>print_impl</code> method is the implementation of the printing process and should be implemented by the derived classes.</p>"},{"location":"reference/kirin/print/printable/#kirin.print.printable.Printable.pager","title":"pager","text":"<pre><code>pager(\n    printer: Printer | None = None,\n    **options: Unpack[\"_PrintOptions\"]\n) -&gt; None\n</code></pre> <p>Pretty print the object with a pager.</p> <p>Parameters:</p> Name Type Description Default <code>printer</code> <code>Printer</code> <p><code>Printer</code> object to use for printing. If None, a new <code>Printer</code> object will be created.</p> <code>None</code> <p>Other Parameters:</p> Name Type Description <code>console</code> <code>Console</code> <p>The console to use for printing. If not provided, a new console will be created.</p> <code>analysis</code> <code>dict[SSAValue, Printable]</code> <p>Analysis results to use for printing. If <code>None</code>, no analysis results</p> <code>show_indent_mark</code> <code>bool</code> <p>Whether to show the indentation mark.</p> <code>theme</code> <code>Theme | dict | str</code> <p>The theme to use for printing, defaults to \"dark\".</p> <p>Note</p> <p>This function also accepts all other <code>rich.console.Console</code> options.</p> Source code in <code>src/kirin/print/printable.py</code> <pre><code>def pager(\n    self,\n    printer: Printer | None = None,\n    **options: Unpack[\"_PrintOptions\"],\n) -&gt; None:\n    \"\"\"Pretty print the object with a pager.\n\n    Args:\n        printer (Printer):\n            `Printer` object to use for printing.\n            If None, a new `Printer` object will be created.\n\n    Keyword Args:\n        console (rich.Console):\n            The console to use for printing. If not provided, a new console\n            will be created.\n        analysis (dict[ir.SSAValue, Printable]):\n            Analysis results to use for printing. If `None`, no analysis results\n        show_indent_mark (bool):\n            Whether to show the indentation mark.\n        theme (Theme | dict | str):\n            The theme to use for printing, defaults to \"dark\".\n\n    !!! note\n        This function also accepts all other `rich.console.Console` options.\n    \"\"\"\n    printer = self.__get_printer(printer, **options)\n    with printer.console.pager(styles=True, links=True):\n        self.print(printer)\n</code></pre>"},{"location":"reference/kirin/print/printable/#kirin.print.printable.Printable.print","title":"print","text":"<pre><code>print(\n    printer: Printer | None = None,\n    end: str = \"\\n\",\n    **options: Unpack[\"_PrintOptions\"]\n) -&gt; None\n</code></pre> <p>Entry point of the printing process.</p> <p>Parameters:</p> Name Type Description Default <code>printer</code> <code>Printer</code> <p><code>Printer</code> object to use for printing. If None, a new <code>Printer</code> object will be created.</p> <code>None</code> <p>Other Parameters:</p> Name Type Description <code>console</code> <code>Console</code> <p>The console to use for printing. If not provided, a new console will be created.</p> <code>analysis</code> <code>dict[SSAValue, Printable]</code> <p>Analysis results to use for printing. If <code>None</code>, no analysis results</p> <code>show_indent_mark</code> <code>bool</code> <p>Whether to show the indentation mark.</p> <code>theme</code> <code>Theme | dict | str</code> <p>The theme to use for printing, defaults to \"dark\".</p> <p>Note</p> <p>This function also accepts all other <code>rich.console.Console</code> options.</p> Source code in <code>src/kirin/print/printable.py</code> <pre><code>def print(\n    self,\n    printer: Printer | None = None,\n    end: str = \"\\n\",\n    **options: Unpack[\"_PrintOptions\"],\n) -&gt; None:\n    \"\"\"\n    Entry point of the printing process.\n\n    Args:\n        printer (Printer):\n            `Printer` object to use for printing.\n            If None, a new `Printer` object will be created.\n\n    Keyword Args:\n        console (rich.Console):\n            The console to use for printing. If not provided, a new console\n            will be created.\n        analysis (dict[ir.SSAValue, Printable]):\n            Analysis results to use for printing. If `None`, no analysis results\n        show_indent_mark (bool):\n            Whether to show the indentation mark.\n        theme (Theme | dict | str):\n            The theme to use for printing, defaults to \"dark\".\n\n    !!! note\n        This function also accepts all other `rich.console.Console` options.\n    \"\"\"\n    printer = self.__get_printer(printer, **options)\n    self.print_impl(printer)\n    printer.plain_print(end)\n</code></pre>"},{"location":"reference/kirin/print/printable/#kirin.print.printable.Printable.print_str","title":"print_str","text":"<pre><code>print_str(\n    printer: Printer | None = None,\n    end: str = \"\\n\",\n    **options: Unpack[\"_PrintOptions\"]\n) -&gt; str\n</code></pre> <p>Print the object to a string.</p> <p>Parameters:</p> Name Type Description Default <code>printer</code> <code>Printer</code> <p><code>Printer</code> object to use for printing. If None, a new <code>Printer</code> object will be created.</p> <code>None</code> <p>Other Parameters:</p> Name Type Description <code>console</code> <code>Console</code> <p>The console to use for printing. If not provided, a new console will be created.</p> <code>analysis</code> <code>dict[SSAValue, Printable]</code> <p>Analysis results to use for printing. If <code>None</code>, no analysis results</p> <code>show_indent_mark</code> <code>bool</code> <p>Whether to show the indentation mark.</p> <code>theme</code> <code>Theme | dict | str</code> <p>The theme to use for printing, defaults to \"dark\".</p> <p>Note</p> <p>This function also accepts all other <code>rich.console.Console</code> options.</p> Source code in <code>src/kirin/print/printable.py</code> <pre><code>def print_str(\n    self,\n    printer: Printer | None = None,\n    end: str = \"\\n\",\n    **options: Unpack[\"_PrintOptions\"],\n) -&gt; str:\n    \"\"\"Print the object to a string.\n\n    Args:\n        printer (Printer):\n            `Printer` object to use for printing.\n            If None, a new `Printer` object will be created.\n\n    Keyword Args:\n        console (rich.Console):\n            The console to use for printing. If not provided, a new console\n            will be created.\n        analysis (dict[ir.SSAValue, Printable]):\n            Analysis results to use for printing. If `None`, no analysis results\n        show_indent_mark (bool):\n            Whether to show the indentation mark.\n        theme (Theme | dict | str):\n            The theme to use for printing, defaults to \"dark\".\n\n    !!! note\n        This function also accepts all other `rich.console.Console` options.\n    \"\"\"\n    printer = self.__get_printer(printer, **options)\n    with printer.string_io() as stream:\n        self.print(printer, end=end, **options)\n        return stream.getvalue()\n</code></pre>"},{"location":"reference/kirin/print/printer/","title":"Printer","text":""},{"location":"reference/kirin/print/printer/#kirin.print.printer.PrintState","title":"PrintState  <code>dataclass</code>","text":"<pre><code>PrintState(\n    ssa_id: IdTable[ir.SSAValue] = IdTable[\"ir.SSAValue\"](),\n    block_id: IdTable[ir.Block] = lambda: IdTable[\n        \"ir.Block\"\n    ](prefix=\"^\")(),\n    indent: int = 0,\n    result_width: int = 0,\n    indent_marks: list[int] = list(),\n    rich_style: str | None = None,\n    rich_highlight: bool | None = False,\n    messages: list[str] = list(),\n)\n</code></pre>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.PrintState.result_width","title":"result_width  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result_width: int = 0\n</code></pre> <p>SSA-value column width in printing</p>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer","title":"Printer  <code>dataclass</code>","text":"<pre><code>Printer(\n    console: Console = _default_console(),\n    analysis: dict[ir.SSAValue, Any] | None = None,\n    state: PrintState = PrintState(),\n    *,\n    show_indent_mark: bool = True,\n    theme: Theme | dict | Literal[\"dark\", \"light\"] = \"dark\"\n)\n</code></pre> <p>A IR pretty printer build on top of Rich console.</p>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.analysis","title":"analysis  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>analysis: dict[SSAValue, Any] | None = None\n</code></pre> <p>Analysis results</p>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.console","title":"console  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>console: Console = field(default_factory=_default_console)\n</code></pre> <p>Rich console</p>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.show_indent_mark","title":"show_indent_mark  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>show_indent_mark: bool = field(default=True, kw_only=True)\n</code></pre> <p>Whether to show indent marks, e.g \u2502</p>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.state","title":"state  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>state: PrintState = field(default_factory=PrintState)\n</code></pre> <p>Printing state</p>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.theme","title":"theme  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>theme: Theme | dict | Literal[\"dark\", \"light\"] = field(\n    default=\"dark\", kw_only=True\n)\n</code></pre> <p>Theme to use for printing</p>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.align","title":"align","text":"<pre><code>align(width: int) -&gt; Generator[PrintState, Any, None]\n</code></pre> <p>align the result column width, and restore it after the context.</p> <p>Parameters:</p> Name Type Description Default <code>width(int)</code> <p>width of the column</p> required <p>Yields:</p> Name Type Description <code>PrintState</code> <code>PrintState</code> <p>the state with the new column width</p> Source code in <code>src/kirin/print/printer.py</code> <pre><code>@contextmanager\ndef align(self, width: int) -&gt; Generator[PrintState, Any, None]:\n    \"\"\"align the result column width, and restore it after the context.\n\n    Args:\n        width(int): width of the column\n\n    Yields:\n        PrintState: the state with the new column width\n    \"\"\"\n    old_width = self.state.result_width\n    self.state.result_width = width\n    try:\n        yield self.state\n    finally:\n        self.state.result_width = old_width\n</code></pre>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.debug","title":"debug","text":"<pre><code>debug(message: str)\n</code></pre> <p>Print a debug message.</p> Source code in <code>src/kirin/print/printer.py</code> <pre><code>def debug(self, message: str):\n    \"\"\"Print a debug message.\"\"\"\n    self.state.messages.append(f\"DEBUG: {message}\")\n</code></pre>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.indent","title":"indent","text":"<pre><code>indent(\n    increase: int = 2, mark: bool | None = None\n) -&gt; Generator[PrintState, Any, None]\n</code></pre> <p>increase the indentation level, and restore it after the context.</p> <p>Parameters:</p> Name Type Description Default <code>increase(int)</code> <p>amount to increase the indentation level, default to 2</p> required <code>mark(bool)</code> <p>whether to mark the indentation level, default to None</p> required <p>Yields:</p> Name Type Description <code>PrintState</code> <code>PrintState</code> <p>the state with the new indentation level.</p> Source code in <code>src/kirin/print/printer.py</code> <pre><code>@contextmanager\ndef indent(\n    self, increase: int = 2, mark: bool | None = None\n) -&gt; Generator[PrintState, Any, None]:\n    \"\"\"increase the indentation level, and restore it after the context.\n\n    Args:\n        increase(int): amount to increase the indentation level, default to 2\n        mark(bool): whether to mark the indentation level, default to None\n\n    Yields:\n        PrintState: the state with the new indentation level.\n    \"\"\"\n    mark = mark if mark is not None else self.show_indent_mark\n    self.state.indent += increase\n    if mark:\n        self.state.indent_marks.append(self.state.indent)\n    try:\n        yield self.state\n    finally:\n        self.state.indent -= increase\n        if mark:\n            self.state.indent_marks.pop()\n</code></pre>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.plain_print","title":"plain_print","text":"<pre><code>plain_print(\n    *objects, sep=\"\", end=\"\", style=None, highlight=None\n)\n</code></pre> <p>print objects without any formatting.</p> <p>Parameters:</p> Name Type Description Default <code>*objects</code> <p>objects to print</p> <code>()</code> <p>Other Parameters:</p> Name Type Description <code>sep(str)</code> <p>separator between objects, default to \"\"</p> <code>end(str)</code> <p>end character, default to \"\"</p> <code>style(str)</code> <p>style to use, default to None</p> <code>highlight(bool)</code> <p>whether to highlight the text, default to None</p> Source code in <code>src/kirin/print/printer.py</code> <pre><code>def plain_print(self, *objects, sep=\"\", end=\"\", style=None, highlight=None):\n    \"\"\"print objects without any formatting.\n\n    Args:\n        *objects: objects to print\n\n    Keyword Args:\n        sep(str): separator between objects, default to \"\"\n        end(str): end character, default to \"\"\n        style(str): style to use, default to None\n        highlight(bool): whether to highlight the text, default to None\n    \"\"\"\n    self.console.out(\n        *objects,\n        sep=sep,\n        end=end,\n        style=style or self.state.rich_style,\n        highlight=highlight or self.state.rich_highlight,\n    )\n</code></pre>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.print","title":"print","text":"<pre><code>print(object)\n</code></pre> <p>entry point for printing an object</p> <p>Parameters:</p> Name Type Description Default <code>object</code> <p>object to print.</p> required Source code in <code>src/kirin/print/printer.py</code> <pre><code>def print(self, object):\n    \"\"\"entry point for printing an object\n\n    Args:\n        object: object to print.\n    \"\"\"\n    if isinstance(object, Printable):\n        object.print_impl(self)\n    else:\n        fn = getattr(self, f\"print_{object.__class__.__name__}\", None)\n        if fn is None:\n            raise NotImplementedError(\n                f\"Printer for {object.__class__.__name__} not found\"\n            )\n        fn(object)\n</code></pre>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.print_dialect_path","title":"print_dialect_path","text":"<pre><code>print_dialect_path(\n    node: Union[ir.Attribute, ir.Statement],\n    prefix: str = \"\",\n) -&gt; None\n</code></pre> <p>print the dialect path of a node.</p> <p>Parameters:</p> Name Type Description Default <code>node(ir.Attribute</code> <code>| ir.Statement</code> <p>node to print</p> required <code>prefix(str)</code> <p>prefix to print before the dialect path, default to \"\"</p> required Source code in <code>src/kirin/print/printer.py</code> <pre><code>def print_dialect_path(\n    self, node: Union[\"ir.Attribute\", \"ir.Statement\"], prefix: str = \"\"\n) -&gt; None:\n    \"\"\"print the dialect path of a node.\n\n    Args:\n        node(ir.Attribute | ir.Statement): node to print\n        prefix(str): prefix to print before the dialect path, default to \"\"\n    \"\"\"\n    if node.dialect:  # not None\n        self.plain_print(prefix)\n        self.plain_print(node.dialect.name, style=\"dialect\")\n    else:\n        self.plain_print(prefix)\n</code></pre>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.print_indent","title":"print_indent","text":"<pre><code>print_indent()\n</code></pre> <p>print the current indentation level optionally with indent marks.</p> Source code in <code>src/kirin/print/printer.py</code> <pre><code>def print_indent(self):\n    \"\"\"print the current indentation level optionally with indent marks.\"\"\"\n    indent_str = \"\"\n    if self.show_indent_mark and self.state.indent_marks:\n        indent_str = \"\".join(\n            \"\u2502\" if i in self.state.indent_marks else \" \"\n            for i in range(self.state.indent)\n        )\n        with self.rich(style=\"comment\"):\n            self.plain_print(indent_str)\n    else:\n        indent_str = \" \" * self.state.indent\n        self.plain_print(indent_str)\n</code></pre>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.print_mapping","title":"print_mapping","text":"<pre><code>print_mapping(\n    elems: dict[KeyType, ValueType],\n    *,\n    emit: Callable[[ValueType], None] | None = None,\n    delim: str = \", \"\n) -&gt; None\n</code></pre> <p>print a mapping of key-value pairs.</p> <p>Parameters:</p> Name Type Description Default <code>elems(dict[KeyType,</code> <code>ValueType]</code> <p>mapping to print</p> required <p>Other Parameters:</p> Name Type Description <code>emit(Callable[[ValueType],</code> <code>None]</code> <p>function to print each value, default to None</p> <code>delim(str)</code> <p>delimiter between key-value pairs, default to \", \"</p> Source code in <code>src/kirin/print/printer.py</code> <pre><code>def print_mapping(\n    self,\n    elems: dict[KeyType, ValueType],\n    *,\n    emit: Callable[[ValueType], None] | None = None,\n    delim: str = \", \",\n) -&gt; None:\n    \"\"\"print a mapping of key-value pairs.\n\n    Args:\n        elems(dict[KeyType, ValueType]): mapping to print\n\n    Keyword Args:\n        emit(Callable[[ValueType], None]): function to print each value, default to None\n        delim(str): delimiter between key-value pairs, default to \", \"\n    \"\"\"\n    emit = emit or self.print\n    for i, (key, value) in enumerate(elems.items()):\n        if i &gt; 0:\n            self.plain_print(delim)\n        self.plain_print(f\"{key}=\")\n        emit(value)\n</code></pre>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.print_name","title":"print_name","text":"<pre><code>print_name(\n    node: Union[ir.Attribute, ir.Statement],\n    prefix: str = \"\",\n) -&gt; None\n</code></pre> <p>print the name of a node</p> <p>Parameters:</p> Name Type Description Default <code>node(ir.Attribute</code> <code>| ir.Statement</code> <p>node to print</p> required <code>prefix(str)</code> <p>prefix to print before the name, default to \"\"</p> required Source code in <code>src/kirin/print/printer.py</code> <pre><code>def print_name(\n    self, node: Union[\"ir.Attribute\", \"ir.Statement\"], prefix: str = \"\"\n) -&gt; None:\n    \"\"\"print the name of a node\n\n    Args:\n        node(ir.Attribute | ir.Statement): node to print\n        prefix(str): prefix to print before the name, default to \"\"\n    \"\"\"\n    self.print_dialect_path(node, prefix=prefix)\n    if node.dialect:\n        self.plain_print(\".\")\n    self.plain_print(node.name)\n</code></pre>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.print_newline","title":"print_newline","text":"<pre><code>print_newline()\n</code></pre> <p>print a newline character.</p> <p>This method also prints any messages in the state for debugging.</p> Source code in <code>src/kirin/print/printer.py</code> <pre><code>def print_newline(self):\n    \"\"\"print a newline character.\n\n    This method also prints any messages in the state for debugging.\n    \"\"\"\n    self.plain_print(\"\\n\")\n\n    if self.state.messages:\n        for message in self.state.messages:\n            self.plain_print(message)\n            self.plain_print(\"\\n\")\n        self.state.messages.clear()\n    self.print_indent()\n</code></pre>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.print_seq","title":"print_seq","text":"<pre><code>print_seq(\n    seq: Iterable[ElemType],\n    *,\n    emit: Callable[[ElemType], None] | None = None,\n    delim: str = \", \",\n    prefix: str = \"\",\n    suffix: str = \"\",\n    style=None,\n    highlight=None\n) -&gt; None\n</code></pre> <p>print a sequence of objects.</p> <p>Parameters:</p> Name Type Description Default <code>seq(Iterable[ElemType])</code> <p>sequence of objects to print</p> required <p>Other Parameters:</p> Name Type Description <code>emit(Callable[[ElemType],</code> <code>None]</code> <p>function to print each element, default to None</p> <code>delim(str)</code> <p>delimiter between elements, default to \", \"</p> <code>prefix(str)</code> <p>prefix to print before the sequence, default to \"\"</p> <code>suffix(str)</code> <p>suffix to print after the sequence, default to \"\"</p> <code>style(str)</code> <p>style to use, default to None</p> <code>highlight(bool)</code> <p>whether to highlight the text, default to None</p> Source code in <code>src/kirin/print/printer.py</code> <pre><code>def print_seq(\n    self,\n    seq: Iterable[ElemType],\n    *,\n    emit: Callable[[ElemType], None] | None = None,\n    delim: str = \", \",\n    prefix: str = \"\",\n    suffix: str = \"\",\n    style=None,\n    highlight=None,\n) -&gt; None:\n    \"\"\"print a sequence of objects.\n\n    Args:\n        seq(Iterable[ElemType]): sequence of objects to print\n\n    Keyword Args:\n        emit(Callable[[ElemType], None]): function to print each element, default to None\n        delim(str): delimiter between elements, default to \", \"\n        prefix(str): prefix to print before the sequence, default to \"\"\n        suffix(str): suffix to print after the sequence, default to \"\"\n        style(str): style to use, default to None\n        highlight(bool): whether to highlight the text, default to None\n    \"\"\"\n    emit = emit or self.print\n    self.plain_print(prefix, style=style, highlight=highlight)\n    for idx, item in enumerate(seq):\n        if idx &gt; 0:\n            self.plain_print(delim)\n        emit(item)\n    self.plain_print(suffix, style=style, highlight=highlight)\n</code></pre>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.result_str","title":"result_str","text":"<pre><code>result_str(results: list[ir.ResultValue]) -&gt; str\n</code></pre> <p>return the string representation of a list of result values.</p> <p>Parameters:</p> Name Type Description Default <code>results(list[ir.ResultValue])</code> <p>list of result values to print</p> required Source code in <code>src/kirin/print/printer.py</code> <pre><code>def result_str(self, results: list[\"ir.ResultValue\"]) -&gt; str:\n    \"\"\"return the string representation of a list of result values.\n\n    Args:\n        results(list[ir.ResultValue]): list of result values to print\n    \"\"\"\n    with self.string_io() as stream:\n        self.print_seq(results, delim=\", \")\n        result_str = stream.getvalue()\n    return result_str\n</code></pre>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.result_width","title":"result_width","text":"<pre><code>result_width(stmts: Iterable[ir.Statement]) -&gt; int\n</code></pre> <p>return the maximum width of the result column for a sequence of statements.</p> <p>Parameters:</p> Name Type Description Default <code>stmts(Iterable[ir.Statement])</code> <p>sequence of statements</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>maximum width of the result column</p> Source code in <code>src/kirin/print/printer.py</code> <pre><code>def result_width(self, stmts: Iterable[\"ir.Statement\"]) -&gt; int:\n    \"\"\"return the maximum width of the result column for a sequence of statements.\n\n    Args:\n        stmts(Iterable[ir.Statement]): sequence of statements\n\n    Returns:\n        int: maximum width of the result column\n    \"\"\"\n    result_width = 0\n    for stmt in stmts:\n        result_width = max(result_width, len(self.result_str(stmt._results)))\n    return result_width\n</code></pre>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.rich","title":"rich","text":"<pre><code>rich(\n    style: str | None = None, highlight: bool = False\n) -&gt; Generator[PrintState, Any, None]\n</code></pre> <p>set the rich style and highlight, and restore them after the context.</p> <p>Parameters:</p> Name Type Description Default <code>style(str</code> <code>| None</code> <p>style to use, default to None</p> required <code>highlight(bool)</code> <p>whether to highlight the text, default to False</p> required <p>Yields:</p> Name Type Description <code>PrintState</code> <code>PrintState</code> <p>the state with the new style and highlight.</p> Source code in <code>src/kirin/print/printer.py</code> <pre><code>@contextmanager\ndef rich(\n    self, style: str | None = None, highlight: bool = False\n) -&gt; Generator[PrintState, Any, None]:\n    \"\"\"set the rich style and highlight, and restore them after the context.\n\n    Args:\n        style(str | None): style to use, default to None\n        highlight(bool): whether to highlight the text, default to False\n\n    Yields:\n        PrintState: the state with the new style and highlight.\n    \"\"\"\n    old_style = self.state.rich_style\n    old_highlight = self.state.rich_highlight\n    self.state.rich_style = style\n    self.state.rich_highlight = highlight\n    try:\n        yield self.state\n    finally:\n        self.state.rich_style = old_style\n        self.state.rich_highlight = old_highlight\n</code></pre>"},{"location":"reference/kirin/print/printer/#kirin.print.printer.Printer.string_io","title":"string_io","text":"<pre><code>string_io() -&gt; Generator[io.StringIO, Any, None]\n</code></pre> <p>Temporary string IO for capturing output.</p> <p>Yields:</p> Type Description <code>StringIO</code> <p>io.StringIO: the string IO object.</p> Source code in <code>src/kirin/print/printer.py</code> <pre><code>@contextmanager\ndef string_io(self) -&gt; Generator[io.StringIO, Any, None]:\n    \"\"\"Temporary string IO for capturing output.\n\n    Yields:\n        io.StringIO: the string IO object.\n    \"\"\"\n    stream = io.StringIO()\n    old_file = self.console.file\n    self.console.file = stream\n    try:\n        yield stream\n    finally:\n        self.console.file = old_file\n        stream.close()\n</code></pre>"},{"location":"reference/kirin/rewrite/","title":"Index","text":""},{"location":"reference/kirin/rewrite/abc/","title":"Abc","text":""},{"location":"reference/kirin/rewrite/abc/#kirin.rewrite.abc.RewriteRule","title":"RewriteRule  <code>dataclass</code>","text":"<pre><code>RewriteRule()\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>A rewrite rule that matches and rewrites IR nodes.</p> <p>The rewrite rule is applied to an IR node by calling the instance with the node as an argument. The rewrite rule should mutate the node instead of returning a new node. A <code>RewriteResult</code> should be returned to indicate whether the rewrite rule has done something, whether the rewrite rule should terminate, and whether the rewrite rule has exceeded the maximum number of iterations.</p>"},{"location":"reference/kirin/rewrite/alias/","title":"Alias","text":""},{"location":"reference/kirin/rewrite/apply_type/","title":"Apply type","text":""},{"location":"reference/kirin/rewrite/call2invoke/","title":"Call2invoke","text":""},{"location":"reference/kirin/rewrite/call2invoke/#kirin.rewrite.call2invoke.Call2Invoke","title":"Call2Invoke  <code>dataclass</code>","text":"<pre><code>Call2Invoke(results: dict[ir.SSAValue, const.JointResult])\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <p>Rewrite a <code>Call</code> statement to an <code>Invoke</code> statement.</p>"},{"location":"reference/kirin/rewrite/chain/","title":"Chain","text":""},{"location":"reference/kirin/rewrite/chain/#kirin.rewrite.chain.Chain","title":"Chain  <code>dataclass</code>","text":"<pre><code>Chain(\n    rule: RewriteRule | Iterable[RewriteRule],\n    *others: RewriteRule\n)\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <p>Chain multiple rewrites together.</p> <p>The chain will apply each rewrite in order until one of the rewrites terminates.</p> Source code in <code>src/kirin/rewrite/chain.py</code> <pre><code>def __init__(self, rule: RewriteRule | Iterable[RewriteRule], *others: RewriteRule):\n    if isinstance(rule, RewriteRule):\n        self.rules = [rule, *others]\n    else:\n        assert (\n            others == ()\n        ), \"Cannot pass multiple positional arguments if the first argument is an iterable\"\n        self.rules = list(rule)\n</code></pre>"},{"location":"reference/kirin/rewrite/compactify/","title":"Compactify","text":""},{"location":"reference/kirin/rewrite/compactify/#kirin.rewrite.compactify.CFGCompactify","title":"CFGCompactify  <code>dataclass</code>","text":"<pre><code>CFGCompactify()\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <p>Compactify the CFG by removing dead blocks and merging blocks if the statement uses the SSACFG convention. Do nothing if given <code>ir.Region</code> or <code>ir.Block</code> due to no context of the region.</p> <p>To compactify hierarchical CFG, combine this rule with <code>kirin.rewrite.Walk</code> to recursively apply this rule to all statements.</p>"},{"location":"reference/kirin/rewrite/compactify/#kirin.rewrite.compactify.CFGEdge","title":"CFGEdge  <code>dataclass</code>","text":"<pre><code>CFGEdge(cfg: CFG)\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <p>Merge non-branching blocks on the edge of the CFG.</p> <p>Example:</p> <pre><code>/---&gt; [B] --&gt; [D] --&gt; [E]\n</code></pre> <p>[A]-----&gt; [C] -------------^</p> <p>[B] and [D] are non-branching blocks on the same edge. They can be merged into one block.</p> <pre><code>/---&gt; [B,D] --&gt; [E]\n</code></pre> <p>[A]-----&gt; [C] -------^</p>"},{"location":"reference/kirin/rewrite/compactify/#kirin.rewrite.compactify.CompactifyRegion","title":"CompactifyRegion  <code>dataclass</code>","text":"<pre><code>CompactifyRegion(cfg: CFG)\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <p>Wrapper to share the CFG object with same CFG region.</p> Source code in <code>src/kirin/rewrite/compactify.py</code> <pre><code>def __init__(self, cfg: CFG):\n    self.cfg = cfg\n    self.rule = Fixpoint(\n        Chain(\n            DeadBlock(cfg), Walk(DuplicatedBranch()), SkipBlock(cfg), CFGEdge(cfg)\n        )\n    )\n</code></pre>"},{"location":"reference/kirin/rewrite/compactify/#kirin.rewrite.compactify.DeadBlock","title":"DeadBlock  <code>dataclass</code>","text":"<pre><code>DeadBlock(cfg: CFG)\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <p>Compactify the CFG by removing dead blocks.</p>"},{"location":"reference/kirin/rewrite/compactify/#kirin.rewrite.compactify.DuplicatedBranch","title":"DuplicatedBranch  <code>dataclass</code>","text":"<pre><code>DuplicatedBranch()\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <p>Merge duplicated branches into a single branch.</p> <p>Example:</p> <pre><code>[A]--&gt;[B]\n  -----^\n</code></pre> <p>Merge the two branches into one without changing the CFG:</p> <pre><code>[A]--&gt;[B]\n</code></pre>"},{"location":"reference/kirin/rewrite/compactify/#kirin.rewrite.compactify.SkipBlock","title":"SkipBlock  <code>dataclass</code>","text":"<pre><code>SkipBlock(cfg: CFG)\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <p>Simplify a block that only contains a branch statement.</p>"},{"location":"reference/kirin/rewrite/cse/","title":"Cse","text":""},{"location":"reference/kirin/rewrite/dce/","title":"Dce","text":""},{"location":"reference/kirin/rewrite/fixpoint/","title":"Fixpoint","text":""},{"location":"reference/kirin/rewrite/fixpoint/#kirin.rewrite.fixpoint.Fixpoint","title":"Fixpoint  <code>dataclass</code>","text":"<pre><code>Fixpoint(rule: RewriteRule, max_iter: int = 32)\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <p>Apply a rewrite rule until a fixpoint is reached.</p> <p>The rewrite rule is applied to the node until the rewrite rule does not do anything.</p>"},{"location":"reference/kirin/rewrite/fixpoint/#kirin.rewrite.fixpoint.Fixpoint--parameters","title":"Parameters","text":"<ul> <li><code>map</code>: The rewrite rule to apply.</li> <li><code>max_iter</code>: The maximum number of iterations to apply the rewrite rule. Default is 32.</li> </ul>"},{"location":"reference/kirin/rewrite/fold/","title":"Fold","text":""},{"location":"reference/kirin/rewrite/getfield/","title":"Getfield","text":""},{"location":"reference/kirin/rewrite/getitem/","title":"Getitem","text":""},{"location":"reference/kirin/rewrite/inline/","title":"Inline","text":""},{"location":"reference/kirin/rewrite/inline/#kirin.rewrite.inline.Inline","title":"Inline  <code>dataclass</code>","text":"<pre><code>Inline(heuristic: Callable[[ir.IRNode], bool])\n</code></pre> <p>               Bases: <code>RewriteRule</code></p>"},{"location":"reference/kirin/rewrite/inline/#kirin.rewrite.inline.Inline.heuristic","title":"heuristic  <code>instance-attribute</code>","text":"<pre><code>heuristic: Callable[[IRNode], bool]\n</code></pre> <p>inline heuristic that determines whether a function should be inlined</p>"},{"location":"reference/kirin/rewrite/inline/#kirin.rewrite.inline.Inline.inline_call_like","title":"inline_call_like","text":"<pre><code>inline_call_like(\n    call_like: ir.Statement,\n    args: tuple[ir.SSAValue, ...],\n    region: ir.Region,\n)\n</code></pre> <p>Inline a function call-like statement</p> <p>Parameters:</p> Name Type Description Default <code>call_like</code> <code>Statement</code> <p>the call-like statement</p> required <code>args</code> <code>tuple[SSAValue, ...]</code> <p>the arguments of the call (first one is the callee)</p> required <code>region</code> <code>Region</code> <p>the region of the callee</p> required Source code in <code>src/kirin/rewrite/inline.py</code> <pre><code>def inline_call_like(\n    self,\n    call_like: ir.Statement,\n    args: tuple[ir.SSAValue, ...],\n    region: ir.Region,\n):\n    \"\"\"\n    Inline a function call-like statement\n\n    Args:\n        call_like (ir.Statement): the call-like statement\n        args (tuple[ir.SSAValue, ...]): the arguments of the call (first one is the callee)\n        region (ir.Region): the region of the callee\n    \"\"\"\n    # &lt;stmt&gt;\n    # &lt;stmt&gt;\n    # &lt;br (a, b, c)&gt;\n\n    # &lt;block (a, b,c)&gt;:\n    # &lt;block&gt;:\n    # &lt;block&gt;:\n    # &lt;br&gt;\n\n    # ^&lt;block&gt;:\n    # &lt;stmt&gt;\n    # &lt;stmt&gt;\n\n    # 1. we insert the entry block of the callee function\n    # 2. we insert the rest of the blocks into the parent region\n    # 3.1 if the return is in the entry block, means no control flow,\n    #     replace the call results with the return values\n    # 3.2 if the return is some of the blocks, means control flow,\n    #     split the current block into two, and replace the return with\n    #     the branch instruction\n    # 4. remove the call\n    if not call_like.parent_block:\n        return\n\n    if not call_like.parent_region:\n        return\n\n    # NOTE: we cannot change region because it may be used elsewhere\n    inline_region: ir.Region = region.clone()\n    parent_block: ir.Block = call_like.parent_block\n    parent_region: ir.Region = call_like.parent_region\n\n    # wrap what's after invoke into a block\n    after_block = ir.Block()\n    stmt = call_like.next_stmt\n    while stmt is not None:\n        stmt.detach()\n        after_block.stmts.append(stmt)\n        stmt = call_like.next_stmt\n\n    for result in call_like.results:\n        block_arg = after_block.args.append_from(result.type, result.name)\n        result.replace_by(block_arg)\n\n    parent_block_idx = parent_region._block_idx[parent_block]\n    entry_block = inline_region.blocks.popfirst()\n    idx, block = 0, entry_block\n    while block is not None:\n        idx += 1\n\n        if block.last_stmt and isinstance(block.last_stmt, func.Return):\n            block.last_stmt.replace_by(\n                cf.Branch(\n                    arguments=(block.last_stmt.value,),\n                    successor=after_block,\n                )\n            )\n\n        parent_region.blocks.insert(parent_block_idx + idx, block)\n        block = inline_region.blocks.popfirst()\n\n    parent_region.blocks.append(after_block)\n\n    # NOTE: we expect always to have an entry block\n    # but we still check for it cuz we are not gonna\n    # error for empty regions here.\n    if entry_block:\n        cf.Branch(\n            arguments=args,\n            successor=entry_block,\n        ).insert_before(call_like)\n    call_like.delete()\n    return\n</code></pre>"},{"location":"reference/kirin/rewrite/result/","title":"Result","text":""},{"location":"reference/kirin/rewrite/walk/","title":"Walk","text":""},{"location":"reference/kirin/rewrite/walk/#kirin.rewrite.walk.Walk","title":"Walk  <code>dataclass</code>","text":"<pre><code>Walk(\n    rule: RewriteRule,\n    worklist: WorkList[IRNode] = WorkList(),\n    reverse: bool = False,\n    region_first: bool = False,\n)\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <p>Walk through the IR nodes and apply a rewrite rule.</p> <p>The walk will apply the rewrite rule to each node in the IR tree in a depth-first order.</p>"},{"location":"reference/kirin/rewrite/walk/#kirin.rewrite.walk.Walk--parameters","title":"Parameters","text":"<ul> <li><code>map</code>: The rewrite rule to apply.</li> <li><code>reverse</code>: Whether to traverse the IR tree in reverse order. Default is <code>False</code>.</li> <li><code>region_first</code>: Whether to traverse the regions before the blocks. Default is <code>False</code>.</li> </ul>"},{"location":"reference/kirin/rewrite/wrap_const/","title":"Wrap const","text":""},{"location":"reference/kirin/rewrite/aggressive/","title":"Index","text":""},{"location":"reference/kirin/rewrite/aggressive/fold/","title":"Fold","text":""},{"location":"blog/archive/2024/","title":"2024","text":""}]}