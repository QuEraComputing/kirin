# This file is generated by gen.py
import math

from kirin.interp import ResultValue, DialectInterpreter, impl
from kirin.dialects.math import stmts
from kirin.dialects.math.dialect import dialect


@dialect.register
class Interpreter(DialectInterpreter):

    @impl(stmts.acos)
    def acos(self, interp, stmt: stmts.acos, values: tuple) -> ResultValue:
        return ResultValue(math.acos(values[0]))

    @impl(stmts.asin)
    def asin(self, interp, stmt: stmts.asin, values: tuple) -> ResultValue:
        return ResultValue(math.asin(values[0]))

    @impl(stmts.asinh)
    def asinh(self, interp, stmt: stmts.asinh, values: tuple) -> ResultValue:
        return ResultValue(math.asinh(values[0]))

    @impl(stmts.atan)
    def atan(self, interp, stmt: stmts.atan, values: tuple) -> ResultValue:
        return ResultValue(math.atan(values[0]))

    @impl(stmts.atan2)
    def atan2(self, interp, stmt: stmts.atan2, values: tuple) -> ResultValue:
        return ResultValue(math.atan2(values[0], values[1]))

    @impl(stmts.atanh)
    def atanh(self, interp, stmt: stmts.atanh, values: tuple) -> ResultValue:
        return ResultValue(math.atanh(values[0]))

    # NOTE: 3.10 compat
    # @impl(stmts.cbrt)
    # def cbrt(self, interp, stmt: stmts.cbrt, values: tuple) -> ResultValue:
    #     return ResultValue(math.cbrt(values[0]))

    @impl(stmts.ceil)
    def ceil(self, interp, stmt: stmts.ceil, values: tuple) -> ResultValue:
        return ResultValue(math.ceil(values[0]))

    @impl(stmts.copysign)
    def copysign(self, interp, stmt: stmts.copysign, values: tuple) -> ResultValue:
        return ResultValue(math.copysign(values[0], values[1]))

    @impl(stmts.cos)
    def cos(self, interp, stmt: stmts.cos, values: tuple) -> ResultValue:
        return ResultValue(math.cos(values[0]))

    @impl(stmts.cosh)
    def cosh(self, interp, stmt: stmts.cosh, values: tuple) -> ResultValue:
        return ResultValue(math.cosh(values[0]))

    @impl(stmts.degrees)
    def degrees(self, interp, stmt: stmts.degrees, values: tuple) -> ResultValue:
        return ResultValue(math.degrees(values[0]))

    @impl(stmts.erf)
    def erf(self, interp, stmt: stmts.erf, values: tuple) -> ResultValue:
        return ResultValue(math.erf(values[0]))

    @impl(stmts.erfc)
    def erfc(self, interp, stmt: stmts.erfc, values: tuple) -> ResultValue:
        return ResultValue(math.erfc(values[0]))

    @impl(stmts.exp)
    def exp(self, interp, stmt: stmts.exp, values: tuple) -> ResultValue:
        return ResultValue(math.exp(values[0]))

    # NOTE: 3.10 compat
    # @impl(stmts.exp2)
    # def exp2(self, interp, stmt: stmts.exp2, values: tuple) -> ResultValue:
    #     return ResultValue(math.exp2(values[0]))

    @impl(stmts.expm1)
    def expm1(self, interp, stmt: stmts.expm1, values: tuple) -> ResultValue:
        return ResultValue(math.expm1(values[0]))

    @impl(stmts.fabs)
    def fabs(self, interp, stmt: stmts.fabs, values: tuple) -> ResultValue:
        return ResultValue(math.fabs(values[0]))

    @impl(stmts.floor)
    def floor(self, interp, stmt: stmts.floor, values: tuple) -> ResultValue:
        return ResultValue(math.floor(values[0]))

    @impl(stmts.fmod)
    def fmod(self, interp, stmt: stmts.fmod, values: tuple) -> ResultValue:
        return ResultValue(math.fmod(values[0], values[1]))

    @impl(stmts.gamma)
    def gamma(self, interp, stmt: stmts.gamma, values: tuple) -> ResultValue:
        return ResultValue(math.gamma(values[0]))

    @impl(stmts.isfinite)
    def isfinite(self, interp, stmt: stmts.isfinite, values: tuple) -> ResultValue:
        return ResultValue(math.isfinite(values[0]))

    @impl(stmts.isinf)
    def isinf(self, interp, stmt: stmts.isinf, values: tuple) -> ResultValue:
        return ResultValue(math.isinf(values[0]))

    @impl(stmts.isnan)
    def isnan(self, interp, stmt: stmts.isnan, values: tuple) -> ResultValue:
        return ResultValue(math.isnan(values[0]))

    @impl(stmts.lgamma)
    def lgamma(self, interp, stmt: stmts.lgamma, values: tuple) -> ResultValue:
        return ResultValue(math.lgamma(values[0]))

    @impl(stmts.log10)
    def log10(self, interp, stmt: stmts.log10, values: tuple) -> ResultValue:
        return ResultValue(math.log10(values[0]))

    @impl(stmts.log1p)
    def log1p(self, interp, stmt: stmts.log1p, values: tuple) -> ResultValue:
        return ResultValue(math.log1p(values[0]))

    @impl(stmts.log2)
    def log2(self, interp, stmt: stmts.log2, values: tuple) -> ResultValue:
        return ResultValue(math.log2(values[0]))

    @impl(stmts.pow)
    def pow(self, interp, stmt: stmts.pow, values: tuple) -> ResultValue:
        return ResultValue(math.pow(values[0], values[1]))

    @impl(stmts.radians)
    def radians(self, interp, stmt: stmts.radians, values: tuple) -> ResultValue:
        return ResultValue(math.radians(values[0]))

    @impl(stmts.remainder)
    def remainder(self, interp, stmt: stmts.remainder, values: tuple) -> ResultValue:
        return ResultValue(math.remainder(values[0], values[1]))

    @impl(stmts.sin)
    def sin(self, interp, stmt: stmts.sin, values: tuple) -> ResultValue:
        return ResultValue(math.sin(values[0]))

    @impl(stmts.sinh)
    def sinh(self, interp, stmt: stmts.sinh, values: tuple) -> ResultValue:
        return ResultValue(math.sinh(values[0]))

    @impl(stmts.sqrt)
    def sqrt(self, interp, stmt: stmts.sqrt, values: tuple) -> ResultValue:
        return ResultValue(math.sqrt(values[0]))

    @impl(stmts.tan)
    def tan(self, interp, stmt: stmts.tan, values: tuple) -> ResultValue:
        return ResultValue(math.tan(values[0]))

    @impl(stmts.tanh)
    def tanh(self, interp, stmt: stmts.tanh, values: tuple) -> ResultValue:
        return ResultValue(math.tanh(values[0]))

    @impl(stmts.trunc)
    def trunc(self, interp, stmt: stmts.trunc, values: tuple) -> ResultValue:
        return ResultValue(math.trunc(values[0]))

    @impl(stmts.ulp)
    def ulp(self, interp, stmt: stmts.ulp, values: tuple) -> ResultValue:
        return ResultValue(math.ulp(values[0]))
